<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Plonky3 recursion book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Plonky3 recursion book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="plonky3-recursion-book"><a class="header" href="#plonky3-recursion-book">Plonky3 recursion book</a></h1>
<p>This book introduces the <strong>Plonky3 recursion</strong> stack, a <a href="https://polygon.technology/">Polygon Labs</a> project, aimed at providing sufficient modularity and flexibility for developers, while maintaining high efficiency through its fixed recursive verifier design.</p>
<p>The material is organized to help potential contributors and users understand the motivation, construction and extensions of the recursive verifier.</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/Plonky3/Plonky3">Plonky3</a> offers a comprehensive toolbox of cryptographic building blocks: hash functions, finite fields, and polynomial commitment schemes, ... to build tailored STARK proof systems. However, its adoption has been limited by the lack of native recursion, to allow arbitrary program execution replication in proof systems and to alleviate proof sizes and related on-chain verification costs.</p>
<p>This project aims at addressing this limitation, by proposing a minimal, fixed recursive verifier for Plonky3, which conceptual simplicity allows for blazing fast recursion performance. A key distinction with its predecessor <a href="https://github.com/0xPolygonZero/plonky2">plonky2</a>, is that rather than wrapping a STARK proof in a separate plonkish SNARK, the Plonky3 recursion stack itself is built using Plonky3’s STARK primitives.</p>
<p>The source code is open-source, available at <a href="https://github.com/Plonky3/Plonky3-recursion">Plonky3 recursion</a> and dual-licensed MIT/APACHE-2.</p>
<p><em><strong>NOTE</strong></em>: <em>This project is under active development, unaudited and as such not ready for production use. We welcome all external contributors who would like to support the development effort.</em></p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="recursion-approach-and-construction"><a class="header" href="#recursion-approach-and-construction">Recursion Approach and Construction</a></h1>
<h2 id="high-level-architecture"><a class="header" href="#high-level-architecture">High-level architecture</a></h2>
<p>Recursion in zero-knowledge proofs means using one proof to verify another: an (outer) prover will generate a proof
to assert validity of an (inner) STARK proof. By applying this recursively, one obtains a (possibly compact) outer proof that attests to arbitrarily deep chains of computation.</p>
<p>Our approach to recursion for Plonky3 differs from a traditional zkVM approach: there is <strong>no program counter, instruction set, or branching logic</strong>. Instead, a fixed program is chosen, and the verifier circuit is specialized to this program only.</p>
<h2 id="why-fixing-the-program-shape"><a class="header" href="#why-fixing-the-program-shape">Why fixing the program shape?</a></h2>
<ul>
<li>
<p><strong>Performance</strong>: without program counter logic, branching, or instruction decoding,
the verifier’s constraints are much lighter.</p>
</li>
<li>
<p><strong>Recursion efficiency</strong>: since the shape of the trace is predetermined,
the recursion circuit can be aggressively optimized.</p>
</li>
<li>
<p><strong>Simplicity</strong>: all inputs follow the same structural pattern, which keeps
implementation complexity low.</p>
</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>
<p><strong>Rigidity</strong>: only the supported program(s) can be proven.</p>
</li>
<li>
<p><strong>No variable-length traces</strong>: input size must fit the circuit’s predefined structure.</p>
</li>
<li>
<p><strong>Reusability</strong>: adapting to a new program requires a new circuit.</p>
</li>
</ul>
<p>The rest of this book explains how this approach is built, <a href="extensions.html#strategies">how to soften its rigidity</a>,
and why it provides a powerful foundation for recursive proof systems.</p>
<h2 id="execution-ir"><a class="header" href="#execution-ir">Execution IR</a></h2>
<p>An <strong>Execution IR</strong> (intermediate representation) is defined to describe the steps of the verifier.
This IR is <em>not proved itself</em>; it only guides trace population.
The actual soundness comes from the constraints inside the operation-specific STARK chips along with their lookups into the central witness table.</p>
<h2 id="witness-table"><a class="header" href="#witness-table">Witness Table</a></h2>
<p>The Witness table is a central bus that stores values shared across operations. It gathers the pairs <code>(index, value)</code> that will be accessed by
the different chips via lookups to enforce consistency.</p>
<ul>
<li>The index column is <em>preprocessed</em>, or <em>preprocessed</em> [[<a href="bibliography.html#rap">rap</a>]]: it is known to both prover and verifier in advance, requiring no online commitment.<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></li>
<li>The Witness table values are represented as extension field elements directly (where base field elements are padded with 0 on higher coordinates) for addressing efficiency.</li>
</ul>
<h2 id="operation-specific-stark-chips"><a class="header" href="#operation-specific-stark-chips">Operation-specific STARK Chips</a></h2>
<p>Each operation family (e.g. addition, multiplication, Merkle path verification, FRI folding) has its own chip.</p>
<p>A chip contains:</p>
<ul>
<li>Local columns for its variables.</li>
<li>Lookup ports into the witness table.</li>
<li>An AIR that enforces its semantics.</li>
</ul>
<h2 id="lookups"><a class="header" href="#lookups">Lookups</a></h2>
<p>All chips interactions are performed via a lookup argument against the central Witness table. Enforcing multiset equality between chip ports and the Witness table entries ensures correctness without proving the execution order of the entire IR itself.</p>
<p>Below is a representation of the interactions between the main Witness table and the different chips.</p>
<pre class="mermaid">%%{init: {'theme':'dark',&quot;flowchart&quot;:{&quot;htmlLabels&quot;:true}}}%%
flowchart TB
    subgraph P[PI Chip]
      P1[&quot;• Purpose: bind index=0 to the declared public input x.&quot;]
      P2[&quot;• Lookup: (0, x) must appear in Witness; also exposed as a public value.&quot;]
    end

    subgraph C[CONST Chip]
      C1[&quot;• Preprocessed rows: (1, 37), (3, 111), (4, 0)&quot;]
      C2[&quot;• Lookup: preprocessed pairs must be present in Witness (aggregated lookup).&quot;]
    end

    subgraph W[Witness Table]
      W0[&quot;0: 3 // &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public input x&quot;]
      W1[&quot;1: 37 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// constant&quot;]
      W2[&quot;2: 111 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// p = 37 * x&quot;]
      W3[&quot;3: 111 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// constant&quot;]
      W4[&quot;4: 0 // const (y = p - 111)&quot;]
    end

    subgraph M[MUL chip]
      M1[&quot;• Ports: (0, x), (1, 37) → inputs; (2, p) → output.&quot;]
      M2[&quot;• AIR: x * 37 = p.&quot;]
    end

    subgraph S [ SUB Chip ]
      S1[&quot;• Ports: (2, p), (3, 111) → inputs; (4, y) → output.&quot;]
      S2[&quot;• AIR: p - 111 = y.&quot;]
    end

    W --- P
    W --- C
    W --- M
    W --- S
</pre>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Preprocessed columns / polynomials can be reconstructed manually by the verifier, removing the need for a prover to commit to them and later perform the FRI protocol on them. However, the verifier needs <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> work when these columns are not structured, as it still needs to interpolate them. To alleviate this, the Plonky3 recursion stack performs <em>offline</em> commitment of unstructured preprocessed columns, so that we need only one instance of the FRI protocol to verify all preprocessed columns evaluations. <a href="#fr-1-1">↩</a></p>
</li>
</ol><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="handling-arbitrary-programs"><a class="header" href="#handling-arbitrary-programs">Handling arbitrary programs</a></h1>
<p>The fixed recursive verifier described in this book supports only fixed, predetermined programs.<br />
This design choice maximizes performance but raises the question: <strong>how can one prove statements of varying size or complexity?</strong></p>
<p>We highlight below two distinct approaches to alleviate this limitation and allow for arbitrary recursion</p>
<h2 id="tree-style-recursion-for-variable-length-inputs"><a class="header" href="#tree-style-recursion-for-variable-length-inputs">Tree-style recursion for variable-length inputs</a></h2>
<p>One can split a large computation into chunks and prove each piece using a fixed inner circuit in parallel.
These proofs can then be <em>recursively aggregated</em> in a tree structure, where each leaf of the tree corresponds to a prover portion of the computation. The tree root yields a single proof attesting to the validity of the entire computation.</p>
<p>A formal description of this tree-style recursion for STARKs can be seen in [[<a href="bibliography.html#zktree">zktree</a>]].</p>
<h2 id="flexible-fri-verification"><a class="header" href="#flexible-fri-verification">Flexible FRI verification</a></h2>
<p>To support proofs with different FRI shapes, one can:</p>
<ul>
<li>
<p><strong>Lift the proofs</strong> to a larger domain, as described in [[<a href="bibliography.html#fri_lift">fri_lift</a>]].<br />
Lifting allows a fixed circuit to efficiently verify proofs of varying trace sizes
by projecting smaller domains into larger ones, reusing the original LDE and commitments without recomputation.</p>
</li>
<li>
<p><strong>Verify distinct proof shapes together</strong> inside a fixed FRI verifier circuit. Instead of having a single proof
size that can be verified by a given FRI verifier circuit, one can extend it over a range of sizes instead at a minimal overhead cost. See a related implementation in <code>plonky2</code> recursion: (<a href="https://github.com/0xPolygonZero/plonky2/pull/1635">Plonky2 PR #1635</a>) for more details.</p>
</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h1>
<p>This section will present empirical performance results for the Plonky3 recursion system,
including instructions for reproducibility across target machines.</p>
<p><em>To be filled soon.</em></p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="bibliography"><a class="header" href="#bibliography">Bibliography</a></h1>
<script type="text/javascript">
function defaultCopyTextToClipboard(text) {
    var textArea = document.createElement("textarea");
    textArea.value = text;

    // Avoid scrolling to bottom
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";

    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
        var ok = document.execCommand('copy');
        var msg = ok ? 'was ok' : 'failed';
        console.log('Backing copy: Text copy was ' + msg);
    } catch (err) {
        console.error('Backing copy: Unable to copy text', err);
    }

    document.body.removeChild(textArea);
}

function copyToClipboard(text) {
    if (!navigator.clipboard) {
        defaultCopyTextToClipboard(text);
        return;
    }
    navigator.clipboard.writeText(text).then(function() {
        console.log('Text copied to clipboard');
    }, function(err) {
        console.error('Error copying text: ', err);
    });
}

</script>
<style></style>
<div class="bib_div">
<details data-key="rap" class=ref>
<summary class=citation>
<a id="rap">[rap]</a> - Ariel Gabizon - <a href="https://hackmd.io/@aztec-network/plonk-arithmetiization-air" target="_blank"><cite>From AIRs to RAPs - how PLONK-style arithmetization works</cite></a>. - 2021. -
<button onclick="copyToClipboard('\{\{ #cite rap \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract"><a class="header" href="#summaryabstract">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="zktree" class=ref>
<summary class=citation>
<a id="zktree">[zktree]</a> - Sai Deng and Bo Du - <a href="https://eprint.iacr.org/2023/208" target="_blank"><cite>{zkTree}: A Zero-Knowledge Recursion Tree with {ZKP} Membership Proofs</cite></a>. - 2023. -
<button onclick="copyToClipboard('\{\{ #cite zktree \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-1"><a class="header" href="#summaryabstract-1">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="fri_lift" class=ref>
<summary class=citation>
<a id="fri_lift">[fri_lift]</a> - Adrian Hamelink - <a href="https://hackmd.io/HkfET6x1Qh-yNvm4fKc7zA" target="_blank"><cite>Lifting plonky3</cite></a>. - 2025. -
<button onclick="copyToClipboard('\{\{ #cite fri_lift \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-2"><a class="header" href="#summaryabstract-2">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
