<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Plonky3 recursion book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Plonky3 recursion book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="plonky3-recursion-book"><a class="header" href="#plonky3-recursion-book">Plonky3 recursion book</a></h1>
<p>This book introduces the <strong>Plonky3 recursion</strong> stack, a <a href="https://polygon.technology/">Polygon Labs</a> project, aimed at providing sufficient modularity and flexibility for developers, while maintaining high efficiency through its fixed recursive verifier design.</p>
<p>The material is organized to help potential contributors and users understand the motivation, construction and extensions of the recursive verifier.</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/Plonky3/Plonky3">Plonky3</a> offers a comprehensive toolbox of cryptographic building blocks: hash functions, finite fields, and polynomial commitment schemes, ... to build tailored STARK proof systems. However, its adoption has been limited by the lack of native recursion, to allow arbitrary program execution replication in proof systems and to alleviate proof sizes and related on-chain verification costs.</p>
<p>This project aims at addressing this limitation, by proposing a minimal, fixed recursive verifier for Plonky3, which conceptual simplicity allows for blazing fast recursion performance. A key distinction with its predecessor <a href="https://github.com/0xPolygonZero/plonky2">plonky2</a>, is that rather than wrapping a STARK proof in a separate plonkish SNARK, the Plonky3 recursion stack itself is built using Plonky3’s STARK primitives.</p>
<p>The source code is open-source, available at <a href="https://github.com/Plonky3/Plonky3-recursion">Plonky3 recursion</a> and dual-licensed MIT/APACHE-2.</p>
<p><em><strong>NOTE</strong></em>: <em>This project is under active development, unaudited and as such not ready for production use. We welcome all external contributors who would like to support the development effort.</em></p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="recursion-approach-and-construction"><a class="header" href="#recursion-approach-and-construction">Recursion Approach and Construction</a></h1>
<h2 id="high-level-architecture"><a class="header" href="#high-level-architecture">High-level architecture</a></h2>
<p>Recursion in zero-knowledge proofs means using one proof to verify another: an (outer) prover will generate a proof
to assert validity of an (inner) STARK proof. By applying this recursively, one obtains a (possibly compact) outer proof that attests to arbitrarily deep chains of computation.</p>
<p>Our approach to recursion for Plonky3 differs from a traditional zkVM approach: there is <strong>no program counter, instruction set, or branching logic</strong>. Instead, a fixed program is chosen, and the verifier circuit is specialized to this program only.</p>
<h2 id="why-fixing-the-program-shape"><a class="header" href="#why-fixing-the-program-shape">Why fixing the program shape?</a></h2>
<ul>
<li>
<p><strong>Performance</strong>: without program counter logic, branching, or instruction decoding,
the verifier’s constraints are much lighter.</p>
</li>
<li>
<p><strong>Recursion efficiency</strong>: since the shape of the trace is predetermined,
the recursion circuit can be aggressively optimized.</p>
</li>
<li>
<p><strong>Simplicity</strong>: all inputs follow the same structural pattern, which keeps
implementation complexity low.</p>
</li>
</ul>
<p>By fixing the program to execute, in particular here proving the correct verification of some <em>known</em> AIR(s) program(s), prover and verifier can agree on the integral execution flow of the program.
As such, each step corresponds to an instruction <strong>known at compile-time</strong> with operands either known at compile-time in the case of constants, or defined by the prover at runtime. This removes all the
overhead of handling arbitrary control flow, and makes the resulting AIR(s) statement(s) effectively tailored for the program they represent, as opposed to regular VMs.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>
<p><strong>Rigidity</strong>: only the supported program(s) can be proven.</p>
</li>
<li>
<p><strong>No variable-length traces</strong>: input size must fit the circuit’s predefined structure.</p>
</li>
<li>
<p><strong>Reusability</strong>: adapting to a new program requires a new circuit.</p>
</li>
</ul>
<p>The rest of this book explains how this approach is built, <a href="extensions.html#strategies">how to soften its rigidity</a>,
and why it provides a powerful foundation for recursive proof systems.</p>
<h2 id="execution-ir"><a class="header" href="#execution-ir">Execution IR</a></h2>
<p>An <strong>Execution IR</strong> (intermediate representation) is defined to describe the steps of the verifier.
This IR is <em>not itself proved</em>, but will be used as source of truth between prover and verifier to guide trace population.
The actual soundness comes from the constraints inside the operation-specific STARK chips along with an aggregated lookup argument ensuring consistency of the common values they operate on.
The lookups can be seen as representing the <code>READ</code>/<code>WRITE</code> operations from/to the witness table.</p>
<p>The example below represents the (fixed) IR associated to the statement <code>37.x - 111 = 0</code>, where <code>x</code> is a public input. It can be reproduced by running</p>
<pre><code class="language-bash">cargo test --package p3-circuit --lib -- tables::tests::test_toy_example_37_times_x_minus_111 --exact --show-output
</code></pre>
<p>A given row of the represented IR contains an operation and its associated operands.</p>
<pre><code class="language-bash">=== CIRCUIT PRIMITIVE OPERATIONS ===
0: Const { out: WitnessId(0), val: 0 }
1: Const { out: WitnessId(1), val: 37 }
2: Const { out: WitnessId(2), val: 111 }
3: Public { out: WitnessId(3), public_pos: 0 }
4: Mul { a: WitnessId(1), b: WitnessId(3), out: WitnessId(4) }
5: Add { a: WitnessId(2), b: WitnessId(0), out: WitnessId(4) }
</code></pre>
<p>i.e. operation 4 performs <code>w[4] &lt;- w[1] * w[3]</code>, and operation 5 encodes the subtraction check as an addition <code>w[2] + w[0] = w[4]</code> (verifying <code>37 * x - 111 = 0</code>).</p>
<p>In order to generate the IR, the first step is to create all operations symbolically.</p>
<p>In the symbolic executor, the computation is represented as a graph where nodes are called either <code>ExprId</code> (since they represent the index of an expression) or <code>Target</code> in the code. Each <code>Target</code> can be:</p>
<ul>
<li>a constant,</li>
<li>a public input,</li>
<li>the output of an operation.</li>
</ul>
<p>The computation graph that represents all operations in the IR is called <code>Circuit</code>.</p>
<p>A <code>circuit_builder</code> provides convenient helper functions and macros for representing and defining operations within this graph. See section <a href="./circuit_building.html#building-circuits">Building Circuits</a> for more details on how to build a circuit.</p>
<h2 id="witness-table"><a class="header" href="#witness-table">Witness Table</a></h2>
<p>The <code>Witness</code> table can be seen as a central memory bus that stores values shared across all operations. It is represented as pairs <code>(index, value)</code>, where indices are  that will be accessed by
the different chips via lookups to enforce consistency.</p>
<ul>
<li>The index column is <em>preprocessed</em>, or <em>read-after-preprocess</em> (<a href="https://hackmd.io/@aztec-network/plonk-arithmetiization-air">RAP</a>): it is known to both prover and verifier in advance, requiring no online commitment.<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></li>
<li>The <code>Witness</code> table values are represented as extension field elements directly (where base field elements are padded with 0 on higher coordinates) for addressing efficiency.</li>
</ul>
<p>From the fixed IR of the example above, we can deduce an associated <code>Witness</code> table as follows:</p>
<pre><code class="language-bash">=== WITNESS TRACE ===
Row 0: WitnessId(w0) = 0
Row 1: WitnessId(w1) = 37
Row 2: WitnessId(w2) = 111
Row 3: WitnessId(w3) = 3
Row 4: WitnessId(w4) = 111
</code></pre>
<p>Note that the initial version of the recursion machine, for the sake of simplicity and ease of iteration, contains a <code>Witness</code> table. However, because the verifier effectively knows the order of
each operation and the interaction between them, the <code>Witness</code> table can be entirely removed, and global consistency can still be enforced at the cost of additional (smaller) lookups between the different chips.</p>
<h2 id="operation-specific-stark-chips"><a class="header" href="#operation-specific-stark-chips">Operation-specific STARK Chips</a></h2>
<p>Each operation family (e.g. addition, multiplication, MMCS path verification, FRI folding) has its own chip.</p>
<p>A chip contains:</p>
<ul>
<li>Local columns for its variables.</li>
<li>Lookup ports into the <code>Witness</code> table.</li>
<li>An AIR that enforces its semantics.</li>
</ul>
<p>We distinguish two kind of chips: those representing native, i.e. primitive operations, and additional non-primitive ones, defined at runtime, that serve as precompiles to optimize certain operations.
The recursion machine contains 4 primitive chips: <code>CONST</code> / <code>PUBLIC_INPUT</code> / <code>ADD</code> and <code>MUL</code>, with <code>SUB</code> and <code>DIV</code> being emulated via the <code>ADD</code> and <code>MUL</code> chips.</p>
<p>Given only the primitive operations, one should be able to carry out most operations necessary in circuit verification. Primitive operations have the following properties:</p>
<ul>
<li>They operate on elements of the <code>Witness</code> table, through their <code>WitnessId</code> (index within the <code>Witness</code> table).</li>
<li>The representation can be heavily optimized. For example, every time a constant is added to the IR, we either create a new <code>WitnessId</code> or return an already existing one. We could also carry out common subexpression elimination.</li>
<li>They are executed in topological order during the circuit evaluation, and they form a directed acyclic graph of dependencies.</li>
</ul>
<p>But relying only on primitive operations for the entire verification would lead to the introduction of many temporary values in the IR. In turn, this would lead to enlarged <code>Witness</code> and primitive tables. To reduce the overall surface area of our AIRs, we can introduce <em>non-primitive</em> specialized chips that carry out specific (non-primitive) operations. We can offload repeated computations to these non-primitive chips to optimize the overall proving flow.</p>
<p>These non-primitive operations use not only <code>Witness</code> table elements (including public inputs), but may also require the use of <em>private data</em>. For example, when verifying a Merkle path, hash outputs are not stored in the <code>Witness</code> table.</p>
<p>This library aims at providing a certain
number of non-primary chips so that projects can natively inherit from full recursive verifiers, which implies chips for FRI, MMCS path verification, etc. Specific applications can also build their own
non-primitive chips and plug them at runtime.</p>
<p>Going back to the previous example, prover and verifier can agree on the following logic for each chip:</p>
<pre><code class="language-bash">=== CONST TRACE ===
Row 0: WitnessId(w0) = 0
Row 1: WitnessId(w1) = 37
Row 2: WitnessId(w2) = 111

=== PUBLIC TRACE ===
Row 0: WitnessId(w3) = 3

=== MUL TRACE ===
Row 0: WitnessId(w1) * WitnessId(w3) -&gt; WitnessId(w4) | 37 * 3 -&gt; 111

=== ADD TRACE ===
Row 0: WitnessId(w2) + WitnessId(w0) -&gt; WitnessId(w4) | 111 + 0 -&gt; 111
</code></pre>
<p>Note that because we started from a known, fixed program that has been lowered to a deterministic IR, we can have the <code>CONST</code> chip's table entirely preprocessed
(i.e. known to the verifier), as well as all <code>index</code> columns of the other primitive chips.</p>
<h2 id="lookups"><a class="header" href="#lookups">Lookups</a></h2>
<p>All chips interactions are performed via a lookup argument. Enforcing multiset equality between all chip ports and the <code>Witness</code> table entries ensures correctness without proving the execution order of the entire IR itself. Lookups can be seen as <code>READ</code>/<code>WRITE</code> or <code>RECEIVE</code>/<code>SEND</code> interactions between tables which allow global consistency over local AIRs.</p>
<p>Cross-table lookups (CTLs) ensure that <strong>every</strong> chip interaction happens through the Witness table: producers write a <code>(index, value)</code> pair into Witness and consumers read the same pair back. No chip talks directly to any other chip; the aggregated LogUp argument enforces multiset equality between the writes and reads.</p>
<p>For the toy example the CTL relations are:<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup></p>
<pre><code class="language-bash">(index 0, value 0)   : CONST → Witness → ADD
(index 1, value 37)  : CONST → Witness → MUL
(index 2, value 111) : CONST → Witness → ADD
(index 3, value 3)   : PUBLIC → Witness → MUL
(index 4, value 111) : MUL → Witness ← ADD
</code></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Preprocessed columns / polynomials can be reconstructed manually by the verifier, removing the need for a prover to commit to them and later perform the FRI protocol on them. However, the verifier needs <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> work when these columns are not structured, as it still needs to interpolate them. To alleviate this, the Plonky3 recursion stack performs <em>offline</em> commitment of unstructured preprocessed columns, so that we need only one instance of the FRI protocol to verify all preprocessed columns evaluations. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>The <code>ADD</code> and <code>MUL</code> tables both issue CTL writes of their outputs to the same Witness row. Because the Witness table is a <em>read-only</em> / <em>write-once</em> memory bus, the aggregated lookup forces those duplicate writes <code>w4 = 111</code> to agree, which is exactly the constraint <code>37 * 3 = 111 = 0 + 111</code>. <a href="#fr-2-1">↩</a></p>
</li>
</ol><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="building-circuits"><a class="header" href="#building-circuits">Building Circuits</a></h1>
<p>This section explains how the <code>CircuitBuilder</code> allows to build a concrete <code>Circuit</code> for a given program.
We’ll use a simple Fibonacci example throughout this page to ground the ideas behind circuit building:</p>
<pre><code class="language-rust ignore">let mut builder = CircuitBuilder::&lt;F&gt;::new();

// Public input: expected F(n)
let expected_result = builder.add_public_input();

// Compute F(n) iteratively
let mut a = builder.add_const(F::ZERO); // F(0)
let mut b = builder.add_const(F::ONE);  // F(1)

for _i in 2..=n {
    let next = builder.add(a, b); // F(N) &lt;- F(N-1) + F(N-2)
    a = b;
    b = next;
}

// Assert computed F(n) equals expected result
builder.connect(b, expected_result);

let circuit = builder.build()?;
let mut runner = circuit.runner();</code></pre>
<h2 id="building-pipeline"><a class="header" href="#building-pipeline">Building Pipeline</a></h2>
<p>In what follows, we call <code>WitnessId</code> what serves as identifier for values in the global Witness storage bus, and
<code>ExprId</code> position identifiers in the <code>ExpressionGraph</code> (with the hardcoded constant <code>ZERO</code> always stored at position 0).</p>
<p>Building a circuit works in 4 successive steps:</p>
<h3 id="stage-1--lower-to-primitives"><a class="header" href="#stage-1--lower-to-primitives">Stage 1 — Lower to primitives</a></h3>
<p>This stage will go through the <code>ExpressionGraph</code> in successive passes and emit primitive operations.</p>
<ul>
<li>
<p>when going through emitted <code>Const</code> nodes, the builder ensures no identical constants appear in distinct nodes of the circuit, seen as a DAG (Directed Acyclic Graph), by performing witness aliasing, i.e. looking at node equivalence classes. This allows to prune duplicated <code>Const</code> nodes by replacing further references with the single equivalence class representative that will be part of the DAG. This allows to enforce equality constraints are <strong>structurally</strong>, without requiring extra gates.</p>
</li>
<li>
<p>public inputs and arithmetic operations may also reuse pre-allocated slots if connected to some existing node.</p>
</li>
</ul>
<h3 id="stage-2--lower-non-primitives"><a class="header" href="#stage-2--lower-non-primitives">Stage 2 — Lower non-primitives</a></h3>
<p>This stage translates the <code>ExprId</code> of logged non-primitive operations inputs (from the set of non-primitive operations allowed at runtime) to <code>WitnessId</code>s similarly to Stage 1.</p>
<h3 id="stage-3--optimize-primitives"><a class="header" href="#stage-3--optimize-primitives">Stage 3 — Optimize primitives</a></h3>
<p>This stage aims at optimizing the generated circuit by removing or optimizing redundant operations within the graph.
For instance, if the output of a primitive operation is never used elsewhere in the circuit, its associated node can
be pruned away from the graph, and the operation removed.</p>
<p>Once all the nodes have been assigned, and the circuit has been fully optimized, we output it.</p>
<h2 id="building-recursive-air-constraints"><a class="header" href="#building-recursive-air-constraints">Building recursive AIR constraints</a></h2>
<p>In order to recursively verify an AIR, its constraints need to be added to the circuit and folded together. In Plonky3, we can get an AIR's constraints in symbolic form. Since our primitive chips (see section <a href="./construction.html#execution-ir">Execution IR</a>) encompass the various entries in the symbolic representation, we can simply map each symbolic operation to its circuit counterpart. The <code>symbolic_to_circuit</code> function does exactly that for a given symbolic constraint.</p>
<p>We can consider a small example to show how operations are mapped. Given public inputs <code>a</code> and <code>b</code>, and a constant <code>c</code>, we have the following symbolic constraint: <code>Mul{ a, Sub {b, Const{ c }}}</code> (which corresponds to: <code>a * (b - c)</code>).</p>
<pre><code class="language-rust ignore">// We get the `ExprId` corresponding to Const{ c } by adding a constant to the circuit.
let x = builder.add_const(c);
// We use the previously computed `x` to compute the subtraction in the circuit.
let y = builder.sub(b, x);
// We use the previously computed `y` to compute the multiplication in the circuit.
let z = builder.mul(a, y);</code></pre>
<p><code>z</code> is then the output <code>ExprId</code> of the constraint in the circuit.</p>
<p>Using this function, we have implemented, for all AIRs, the automatic translation from their set of symbolic constraints to the circuit version of the folded constraints:</p>
<pre><code class="language-rust ignore">// Transforms an AIR's symbolic constraints into its counterpart circuit version, 
// and folds all the constraints in the circuit using the challenge `alpha`.
fn eval_folded_circuit(
        // The AIR at hand.
        &amp;self,
        builder: &amp;mut CircuitBuilder&lt;F&gt;,
        // Circuit version of Langrange selectors.
        sels: &amp;RecursiveLagrangeSelectors,
        // Folding challenge.
        alpha: &amp;ExprId,
        // All kind of columns that could be involved in constraints.
        columns: ColumnsTargets,
    ) -&gt; Target {
        // Get all the constraints in symbolic form.
        let symbolic_constraints = 
            get_symbolic_constraints(self, 0, columns.public_values.len());

        // Fold all the constraints using the folding challenge.
        let mut acc = builder.add_const(F::ZERO);
        for s_c in symbolic_constraints {
            let mul_prev = builder.mul(acc, *alpha);

            // Get the current constraint in circuit form.
            let constraints = 
                symbolic_to_circuit(sels.row_selectors, &amp;columns, &amp;s_c, builder);

            // Fold the current constraint with the previous value.
            acc = builder.add(mul_prev, constraints);
        }

        acc
    }</code></pre>
<p>This facilitates the integration of <em>any</em> AIR verification into our circuit.</p>
<h2 id="proving"><a class="header" href="#proving">Proving</a></h2>
<p>Calling <code>circuit.runner()</code> will return a instance of <code>CircuitRunner</code> allowing to execute the
represented program and generate associated execution traces needed for proving:</p>
<pre><code class="language-rust ignore">let mut runner = circuit.runner();

// Set public input
let expected_fib = compute_fibonacci_classical(n);
runner.set_public_inputs(&amp;[expected_fib])?;

// Instantiate prover instance
let config = build_standard_config_koalabear();
let multi_prover = MultiTableProver::new(config);

// Generate traces
let traces = runner.run()?;

// Prove the program
let proof = multi_prover.prove_all_tables(&amp;traces)?;</code></pre>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key takeaways</a></h2>
<ul>
<li>
<p><strong>“Free” equality constraints:</strong> by leveraging <strong>witness aliasing</strong>, we obtain essentially free equality constraints for the prover, removing the need for additional arithmetic constraints.</p>
</li>
<li>
<p><strong>Deterministic layout:</strong> The ordered primitive lowering combined with equivalence class allocation yields predictable <code>WitnessId</code>s.</p>
</li>
<li>
<p><strong>Minimal primitive set:</strong> With <code>Sub</code>/<code>Div</code> being effectively translated as equivalent <code>Add</code>/<code>Mul</code> operations, the IR stays extremely lean, consisting only of <code>Const</code>, <code>Public</code>, <code>Add</code> and <code>Mul</code>, simplifying the design and implementation details.</p>
</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="handling-arbitrary-programs"><a class="header" href="#handling-arbitrary-programs">Handling arbitrary programs</a></h1>
<p>The fixed recursive verifier described in this book supports only fixed, predetermined programs.<br />
This design choice maximizes performance but raises the question: <strong>how can one prove statements of varying size or complexity?</strong></p>
<p>We highlight below two distinct approaches to alleviate this limitation and allow for arbitrary recursion</p>
<h2 id="tree-style-recursion-for-variable-length-inputs"><a class="header" href="#tree-style-recursion-for-variable-length-inputs">Tree-style recursion for variable-length inputs</a></h2>
<p>One can split a large computation into chunks and prove each piece using a fixed inner circuit in parallel.
These proofs can then be <em>recursively aggregated</em> in a tree structure, where each leaf of the tree corresponds to a prover portion of the computation. The tree root yields a single proof attesting to the validity of the entire computation.</p>
<p>A formal description of this tree-style recursion for STARKs can be seen in <a href="https://eprint.iacr.org/2023/208">zkTree</a>.</p>
<h2 id="flexible-fri-verification"><a class="header" href="#flexible-fri-verification">Flexible FRI verification</a></h2>
<p>To support proofs with different FRI shapes, one can:</p>
<ul>
<li>
<p><strong>Lift the proofs</strong> to a larger domain, as described in <a href="https://hackmd.io/HkfET6x1Qh-yNvm4fKc7zA">Lifting plonky3</a>.<br />
Lifting allows a fixed circuit to efficiently verify proofs of varying trace sizes
by projecting smaller domains into larger ones, reusing the original LDE and commitments without recomputation.</p>
</li>
<li>
<p><strong>Verify distinct proof shapes together</strong> inside a fixed FRI verifier circuit. Instead of having a single proof
size that can be verified by a given FRI verifier circuit, one can extend it over a range of sizes instead at a minimal overhead cost. See a related implementation in <code>plonky2</code> recursion: (<a href="https://github.com/0xPolygonZero/plonky2/pull/1635">Plonky2 PR #1635</a>) for more details.</p>
</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>The <code>CircuitBuilder</code> provides built-in debugging tools to help identify wiring issues and unsatisfied constraints.</p>
<h2 id="allocation-logging"><a class="header" href="#allocation-logging">Allocation Logging</a></h2>
<p>The <code>CircuitBuilder</code> supports an allocation logger during circuit building that logs allocations being performed.
These logs can then be analyzed at runtime and leveraged to detect issues in circuit constructions.</p>
<h3 id="enabling-debug-logging"><a class="header" href="#enabling-debug-logging">Enabling Debug Logging</a></h3>
<p>Allocation logging is automatically enabled in debug builds (or moe generally if <code>debug_assertions</code> are enabled).
Logs can be dumped to <code>stdout</code> when calling <code>builder.dump_allocation_log()</code>, if logging level is set to <code>DEBUG</code> or lower.</p>
<h3 id="allocation-log-format"><a class="header" href="#allocation-log-format">Allocation Log Format</a></h3>
<p>By default, the <code>CircuitBuilder</code> automatically logs all allocations with no specific labels.
One can decide to attach a specific descriptive to ease debugging, like so:</p>
<pre><code class="language-rust ignore">let mut builder = CircuitBuilder::&lt;F&gt;::new();

// Allocating with custom labels
let input_a = builder.alloc_public_input("input_a");
let input_b = builder.alloc_public_input("input_b");
let input_c = builder.alloc_public_input("input_c");

let b_times_c = builder.alloc_mul(input_b, input_c, "b_times_c");
let a_plus_bc = builder.alloc_add(input_a, b_times_c, "a_plus_bc");
let a_minus_bc = builder.alloc_sub(input_a, b_times_c, "a_minus_bc");

// Default allocation
let x = builder.add_public_input(); // unlabelled
let y = builder.add(x, z);          // unlabelled</code></pre>
<p>The <code>CircuitBuilder</code> also allows for nested scoping of allocation logs, so that users can debug
a specific context within a larger circuit. Scoping can be defined arbitrarily by users as follows:</p>
<pre><code class="language-rust ignore">fn complex_function(builder: &amp;mut CircuitBuilder) {
    builder.push_scope("complex function");

    // Do something
    inner_function(builder); // &lt;- this will create a nested scope within the inner function

    builder.pop_scope();
}

fn inner_function(builder: &amp;mut CircuitBuilder) {
    builder.push_scope("inner function");

    // Do something else

    builder.pop_scope();
}</code></pre>
<h2 id="debugging-constraints"><a class="header" href="#debugging-constraints">Debugging constraints</a></h2>
<p>When debugging constraint satisfaction issues, the system relies on Plonky3's internal <code>check_constraints</code>
feature to evaluate AIR constraints, available in debug mode.
This ensures that all constraints are properly satisfied before proceeding to the next proving phases.</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h1>
<p>This section will present empirical performance results for the Plonky3 recursion system,
including instructions for reproducibility across target machines.</p>
<p><em>To be filled soon.</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
