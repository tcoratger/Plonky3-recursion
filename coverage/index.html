<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 72px;
}
.code-line {
  margin: 0;
  height: 1em;
  counter-increment: line;

  position: absolute;
  padding: 0 0.3em 0.3em 0.3em;
  display: inherit;
  width: 100%;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

.code-text-container {
  position: relative;
  height: 1em;
  padding: 0.3em 0;
}

.cover-indicator {
  display: flex;
  width: 100%;
  position: absolute;
  justify-content: end;
  height: 1em;
  align-items: center;
  padding: 0 0.3em 0.3em 0.3em;
}

.cover-indicator.check-cover::after {
  content: "\2713";
  font-weight: bold;
  background-color: var(--green);
  height: 1em;
}

.cover-indicator.no-cover::after {
  content: "\2716";
  font-weight: bold;
  background-color: var(--red);
  height: 1em;
}

.stat-line-hit {
  max-width: 48px;
  overflow: hidden;
  font-weight: bold;
  margin-right: 4px;
  background-color: var(--green);
  position: relative;
  top: 0.1em;
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","challenger-air","src","main.rs"],"content":"pub fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[{"line":1,"address":[389872,389904],"length":1,"stats":{"Line":1}},{"line":2,"address":[389905],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","benches","runner_traces.rs"],"content":"//! Benchmarks: circuit runner execution + trace building.\n//!\n//! Includes micro-benchmarks: execute_all (evaluation only), per-table trace\n//! building, and full run. Parameterized by instance size and shape.\n\nuse criterion::{BenchmarkId, Criterion, black_box, criterion_group, criterion_main};\nuse p3_baby_bear::BabyBear;\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::tables::{\n    AluTraceBuilder, ConstTraceBuilder, PublicTraceBuilder, WitnessTraceBuilder,\n};\nuse p3_field::PrimeCharacteristicRing;\n\ntype F = BabyBear;\n\nfn fib_circuit(n: usize) -\u003e (p3_circuit::Circuit\u003cF\u003e, F) {\n    let mut builder = CircuitBuilder::new();\n    let expected_result = builder.alloc_public_input(\"expected_result\");\n    let mut a = builder.alloc_const(F::ZERO, \"F(0)\");\n    let mut b = builder.alloc_const(F::ONE, \"F(1)\");\n    for _ in 2..=n {\n        let next = builder.add(a, b);\n        a = b;\n        b = next;\n    }\n    builder.connect(b, expected_result);\n    let circuit = builder.build().unwrap();\n    let expected_fib = fib_classical(n);\n    (circuit, expected_fib)\n}\n\nfn fib_classical(n: usize) -\u003e F {\n    if n == 0 {\n        return F::ZERO;\n    }\n    if n == 1 {\n        return F::ONE;\n    }\n    let mut a = F::ZERO;\n    let mut b = F::ONE;\n    for _ in 2..=n {\n        let next = a + b;\n        a = b;\n        b = next;\n    }\n    b\n}\n\n/// Circuit with N Const ops only (stresses set_witness / Const path).\nfn many_const_circuit(n: usize) -\u003e (p3_circuit::Circuit\u003cF\u003e, F) {\n    let mut builder = CircuitBuilder::new();\n    let pub_in = builder.alloc_public_input(\"p\");\n    let mut prev = builder.alloc_const(F::ZERO, \"c0\");\n    for i in 1..n {\n        prev = builder.alloc_const(F::from_u64(i as u64), \"c\");\n    }\n    builder.connect(prev, pub_in);\n    let circuit = builder.build().unwrap();\n    let public_val = F::from_u64((n - 1) as u64);\n    (circuit, public_val)\n}\n\n/// Mul-heavy: out = c^N (N muls). Stresses get_witness + set_witness on Mul path.\nfn mul_heavy_circuit(n: usize) -\u003e (p3_circuit::Circuit\u003cF\u003e, F) {\n    let mut builder = CircuitBuilder::new();\n    let expected_result = builder.alloc_public_input(\"expected_result\");\n    let c = builder.alloc_const(F::from_u64(3), \"c\");\n    let mut acc = builder.alloc_const(F::ONE, \"acc0\");\n    for _ in 0..n {\n        acc = builder.mul(acc, c);\n    }\n    builder.connect(acc, expected_result);\n    let circuit = builder.build().unwrap();\n    let mut expected = F::ONE;\n    for _ in 0..n {\n        expected *= F::from_u64(3);\n    }\n    (circuit, expected)\n}\n\nfn bench_runner_traces(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"runner_traces\");\n    for n in [100, 500, 2000, 10_000] {\n        group.bench_with_input(BenchmarkId::new(\"fibonacci\", n), \u0026n, |b, \u0026n| {\n            b.iter(|| {\n                let (circuit, expected_fib) = fib_circuit(n);\n                let mut runner = circuit.runner();\n                runner.set_public_inputs(\u0026[expected_fib]).unwrap();\n                black_box(runner.run().unwrap())\n            });\n        });\n    }\n    group.finish();\n}\n\nfn bench_execute_all(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"execute_all\");\n    for n in [100, 500, 2000, 10_000] {\n        group.bench_with_input(BenchmarkId::new(\"fibonacci\", n), \u0026n, |b, \u0026n| {\n            b.iter(|| {\n                let (circuit, expected_fib) = fib_circuit(n);\n                let mut runner = circuit.runner();\n                runner.set_public_inputs(\u0026[expected_fib]).unwrap();\n                runner.execute_all().unwrap();\n                black_box(());\n            });\n        });\n    }\n    for n in [1_000, 10_000, 50_000] {\n        group.bench_with_input(BenchmarkId::new(\"many_const\", n), \u0026n, |b, \u0026n| {\n            b.iter(|| {\n                let (circuit, public_val) = many_const_circuit(n);\n                let mut runner = circuit.runner();\n                runner.set_public_inputs(\u0026[public_val]).unwrap();\n                runner.execute_all().unwrap();\n                black_box(());\n            });\n        });\n    }\n    for n in [100, 500, 2000] {\n        group.bench_with_input(BenchmarkId::new(\"mul_heavy\", n), \u0026n, |b, \u0026n| {\n            b.iter(|| {\n                let (circuit, expected_val) = mul_heavy_circuit(n);\n                let mut runner = circuit.runner();\n                runner.set_public_inputs(\u0026[expected_val]).unwrap();\n                runner.execute_all().unwrap();\n                black_box(());\n            });\n        });\n    }\n    group.finish();\n}\n\nfn bench_trace_build(c: \u0026mut Criterion) {\n    const N: usize = 2000;\n    let (circuit, expected_fib) = fib_circuit(N);\n    let mut runner = circuit.runner();\n    runner.set_public_inputs(\u0026[expected_fib]).unwrap();\n    runner.execute_all().unwrap();\n    let witness = runner.witness();\n    let ops = runner.ops();\n\n    let mut group = c.benchmark_group(\"trace_build\");\n    group.bench_function(\"witness\", |b| {\n        b.iter(|| black_box(WitnessTraceBuilder::new(witness).build().unwrap()));\n    });\n    group.bench_function(\"const\", |b| {\n        b.iter(|| black_box(ConstTraceBuilder::new(ops).build().unwrap()));\n    });\n    group.bench_function(\"public\", |b| {\n        b.iter(|| black_box(PublicTraceBuilder::new(ops, witness).build().unwrap()));\n    });\n    group.bench_function(\"alu\", |b| {\n        b.iter(|| black_box(AluTraceBuilder::new(ops, witness).build().unwrap()));\n    });\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_runner_traces,\n    bench_execute_all,\n    bench_trace_build,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","examples","allocation_log.rs"],"content":"//! An example to show how the allocation log works.\n//!\n//! *NOTE*: The example must be run in debug mode or with a custom profile\n//! that enables debug_assertions, and with `RUST_LOG=DEBUG` for tracing.\n\nuse p3_baby_bear::BabyBear;\nuse p3_circuit::CircuitBuilder;\nuse p3_field::PrimeCharacteristicRing;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n/// Initializes a global logger with default parameters.\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\nfn main() {\n    init_logger();\n\n    println!(\"Building a simple circuit to demonstrate the allocation log...\\n\");\n\n    let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n    // Build a simple circuit: (a + b * c) * (a - b) / 2\n    println!(\"Creating circuit: result = (a + b * c) * (a - b) / 2\\n\");\n\n    let a = builder.alloc_public_input(\"input_a\");\n    let b = builder.alloc_public_input(\"input_b\");\n    let c = builder.alloc_public_input(\"input_c\");\n\n    let two = builder.alloc_const(BabyBear::TWO, \"2\");\n\n    let _two_bis = builder.alloc_const(BabyBear::TWO, \"2 bis\"); // should be ignored\n\n    let bc = builder.alloc_mul(b, c, \"b_times_c\");\n    let sum = builder.alloc_add(a, bc, \"a_plus_bc\");\n    let diff = builder.alloc_sub(a, bc, \"a_minus_bc\");\n    let product = builder.alloc_mul(sum, diff, \"sum_times_diff\");\n    let _result = builder.alloc_div(product, two, \"final_result\");\n\n    builder.dump_allocation_log();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","alloc_entry.rs"],"content":"//! Module defining allocation entries for debugging purposes.\n//! These complement circuit building by logging all allocations happening\n//! within the expression graph.\n\nuse alloc::format;\nuse alloc::string::{String, ToString};\nuse alloc::vec::Vec;\n\nuse hashbrown::HashSet;\n\nuse crate::ExprId;\nuse crate::op::NonPrimitiveOpType;\n\n/// Type of allocation for debugging purposes\n#[derive(Debug, Clone)]\npub enum AllocationType {\n    Public,\n    Const,\n    Add,\n    Sub,\n    Mul,\n    Div,\n    NonPrimitiveOp(NonPrimitiveOpType),\n    NonPrimitiveOutput,\n    WitnessHint,\n}\n\n/// Detailed allocation entry for debugging\n#[derive(Debug, Clone)]\npub struct AllocationEntry {\n    /// The expression ID allocated\n    pub expr_id: ExprId,\n    /// Type of allocation\n    pub alloc_type: AllocationType,\n    /// User-provided label (if any)\n    pub label: \u0026'static str,\n    /// Dependencies for this entry, i.e. the expressions that this entry depends on.\n    pub dependencies: Vec\u003cVec\u003cExprId\u003e\u003e,\n    /// Scope/sub-circuit this allocation belongs to (if any)\n    pub scope: Option\u003cString\u003e,\n}\n\n/// Look up allocation info for specific ExprIds and dump to debug log.\n///\n/// This is useful for debugging WitnessConflict errors where two ExprIds\n/// have been merged to the same WitnessId.\npub fn dump_expr_ids(allocation_log: \u0026[AllocationEntry], expr_ids: \u0026[ExprId]) {\n    tracing::debug!(\"=== Allocation Info for ExprIds {:?} ===\", expr_ids);\n    for expr_id in expr_ids {\n        if let Some(entry) = allocation_log.iter().find(|e| e.expr_id == *expr_id) {\n            tracing::debug!(\n                \"  ExprId({}) = {:?}, label='{}', scope={:?}, deps={:?}\",\n                entry.expr_id.0,\n                entry.alloc_type,\n                entry.label,\n                entry.scope,\n                entry.dependencies\n            );\n        } else {\n            tracing::debug!(\"  ExprId({}) not found in allocation log\", expr_id.0);\n        }\n    }\n    tracing::debug!(\"=== End ExprId Info ===\\n\");\n}\n\n/// Dump an allocation log (debug builds only).\n///\n/// Shows all allocations with their types, labels, and dependencies,\n/// grouped by allocation type.\npub(crate) fn dump_allocation_log(allocation_log: \u0026[AllocationEntry]) {\n    tracing::debug!(\"=== Circuit Allocation Log ===\");\n    tracing::debug!(\"Total allocations: {}\\n\", allocation_log.len());\n\n    let all_scopes = list_scopes(allocation_log);\n\n    for scope in all_scopes {\n        dump_allocation_log_scope(allocation_log, Some(\u0026scope));\n    }\n\n    // Dump also allocations that do not fall under a particular scope\n    dump_allocation_log_scope(allocation_log, None);\n\n    tracing::debug!(\"=== End Allocation Log ===\\n\");\n}\n\n/// Dump an allocation log filtered by scope (debug builds only).\n///\n/// Shows only allocations within the specified scope, grouped by allocation type.\npub(crate) fn dump_allocation_log_scope(allocation_log: \u0026[AllocationEntry], scope: Option\u003c\u0026str\u003e) {\n    let filtered: Vec\u003c_\u003e = allocation_log\n        .iter()\n        .filter(|e| e.scope == scope.map(|s| s.to_string()))\n        .cloned()\n        .collect();\n\n    let scope_name = scope.unwrap_or(\"main\");\n\n    if filtered.is_empty() {\n        tracing::debug!(\"\\nScope '{}' has no allocations\\n\", scope_name);\n        return;\n    }\n\n    tracing::debug!(\"=== Allocation Log for scope '{}' ===\", scope_name);\n    tracing::debug!(\"Total allocations in scope: {}\\n\", filtered.len());\n\n    dump_internal_log(\u0026filtered);\n\n    tracing::debug!(\"=== End Scope Log ===\\n\");\n}\n\nfn dump_internal_log(allocation_log: \u0026[AllocationEntry]) {\n    // Group by type\n    let mut publics = Vec::new();\n    let mut consts = Vec::new();\n    let mut adds = Vec::new();\n    let mut subs = Vec::new();\n    let mut muls = Vec::new();\n    let mut divs = Vec::new();\n    let mut non_primitives = Vec::new();\n    let mut witness_hints = Vec::new();\n\n    fn display_label(label: \u0026str) -\u003e String {\n        if label.is_empty() {\n            \"\".to_string()\n        } else {\n            format!(\": {label}\")\n        }\n    }\n\n    for entry in allocation_log {\n        match entry.alloc_type {\n            AllocationType::Public =\u003e publics.push(entry),\n            AllocationType::Const =\u003e consts.push(entry),\n            AllocationType::Add =\u003e adds.push(entry),\n            AllocationType::Sub =\u003e subs.push(entry),\n            AllocationType::Mul =\u003e muls.push(entry),\n            AllocationType::Div =\u003e divs.push(entry),\n            AllocationType::NonPrimitiveOp(_) | AllocationType::NonPrimitiveOutput =\u003e {\n                non_primitives.push(entry);\n            }\n            AllocationType::WitnessHint =\u003e witness_hints.push(entry),\n        }\n    }\n\n    // Dump all operations per group\n\n    if !publics.is_empty() {\n        tracing::debug!(\"--- Public Inputs ({}) ---\", publics.len());\n        for entry in publics {\n            tracing::debug!(\n                \"  expr_{} (Public){}\",\n                entry.expr_id.0,\n                display_label(entry.label)\n            );\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !consts.is_empty() {\n        tracing::debug!(\"--- Constants ({}) ---\", consts.len());\n        for entry in consts {\n            tracing::debug!(\n                \"  expr_{} (Const){}\",\n                entry.expr_id.0,\n                display_label(entry.label)\n            );\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !adds.is_empty() {\n        tracing::debug!(\"--- Additions ({}) ---\", adds.len());\n        for entry in adds {\n            if entry.dependencies.len() == 2 {\n                tracing::debug!(\n                    \"  expr_{} = expr_{} + expr_{}{}\",\n                    entry.expr_id.0,\n                    entry.dependencies[0][0].0,\n                    entry.dependencies[1][0].0,\n                    display_label(entry.label)\n                );\n            } else {\n                tracing::debug!(\n                    \"  expr_{} (Add){}\",\n                    entry.expr_id.0,\n                    display_label(entry.label)\n                );\n            }\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !subs.is_empty() {\n        tracing::debug!(\"--- Subtractions ({}) ---\", subs.len());\n        for entry in subs {\n            if entry.dependencies.len() == 2 {\n                tracing::debug!(\n                    \"  expr_{} = expr_{} - expr_{}{}\",\n                    entry.expr_id.0,\n                    entry.dependencies[0][0].0,\n                    entry.dependencies[1][0].0,\n                    display_label(entry.label)\n                );\n            } else {\n                tracing::debug!(\n                    \"  expr_{} (Sub){}\",\n                    entry.expr_id.0,\n                    display_label(entry.label)\n                );\n            }\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !muls.is_empty() {\n        tracing::debug!(\"--- Multiplications ({}) ---\", muls.len());\n        for entry in muls {\n            if entry.dependencies.len() == 2 {\n                tracing::debug!(\n                    \"  expr_{} = expr_{} * expr_{}{}\",\n                    entry.expr_id.0,\n                    entry.dependencies[0][0].0,\n                    entry.dependencies[1][0].0,\n                    display_label(entry.label)\n                );\n            } else {\n                tracing::debug!(\n                    \"  expr_{} (Mul){}\",\n                    entry.expr_id.0,\n                    display_label(entry.label)\n                );\n            }\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !divs.is_empty() {\n        tracing::debug!(\"--- Divisions ({}) ---\", divs.len());\n        for entry in divs {\n            if entry.dependencies.len() == 2 {\n                tracing::debug!(\n                    \"  expr_{} = expr_{} / expr_{}{}\",\n                    entry.expr_id.0,\n                    entry.dependencies[0][0].0,\n                    entry.dependencies[1][0].0,\n                    display_label(entry.label)\n                );\n            } else {\n                tracing::debug!(\n                    \"  expr_{} (Div){}\",\n                    entry.expr_id.0,\n                    display_label(entry.label)\n                );\n            }\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !non_primitives.is_empty() {\n        tracing::debug!(\n            \"--- Non-Primitive Operations ({}) ---\",\n            non_primitives.len()\n        );\n        for entry in non_primitives {\n            let op_name = match \u0026entry.alloc_type {\n                AllocationType::NonPrimitiveOp(op_type) =\u003e format!(\"{op_type:?}\").to_string(),\n                AllocationType::NonPrimitiveOutput =\u003e \"NonPrimitiveOutput\".to_string(),\n                _ =\u003e \"Unknown\".to_string(),\n            };\n            if !entry.dependencies.is_empty() {\n                let deps: Vec\u003c_\u003e = entry\n                    .dependencies\n                    .iter()\n                    .flatten()\n                    .map(|e| format!(\"expr_{}\", e.0))\n                    .collect();\n                tracing::debug!(\n                    \"  {} (inputs: [{}]){}\",\n                    op_name,\n                    deps.join(\", \"),\n                    display_label(entry.label)\n                );\n            } else {\n                tracing::debug!(\"  {}{}\", op_name, display_label(entry.label));\n            }\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !witness_hints.is_empty() {\n        tracing::debug!(\"--- Witness Hints ({}) ---\", witness_hints.len());\n        for entry in witness_hints {\n            tracing::debug!(\n                \"  expr_{} (WitnessHint){}\",\n                entry.expr_id.0,\n                display_label(entry.label)\n            );\n        }\n        tracing::debug!(\"\");\n    }\n}\n\n/// List all unique scopes present in the allocation log.\npub(crate) fn list_scopes(allocation_log: \u0026[AllocationEntry]) -\u003e Vec\u003cString\u003e {\n    let mut scopes = HashSet::new();\n    for entry in allocation_log {\n        if let Some(scope) = \u0026entry.scope {\n            scopes.insert(scope.clone());\n        }\n    }\n\n    let mut scope_list: Vec\u003c_\u003e = scopes.into_iter().collect();\n    scope_list.sort_unstable();\n    scope_list\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","circuit_builder.rs"],"content":"use alloc::boxed::Box;\nuse alloc::string::{String, ToString as _};\nuse alloc::sync::Arc;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::hash::Hash;\nuse core::marker::PhantomData;\n\nuse hashbrown::HashMap;\nuse itertools::zip_eq;\nuse p3_field::{ExtensionField, Field, PrimeCharacteristicRing, PrimeField64};\nuse p3_symmetric::Permutation;\n\n#[cfg(feature = \"profiling\")]\nuse super::OpCounts;\nuse super::compiler::{ExpressionLowerer, Optimizer};\nuse super::{BuilderConfig, ExpressionBuilder, PublicInputTracker};\nuse crate::circuit::Circuit;\nuse crate::op::{NonPrimitiveExecutor, NonPrimitiveOpConfig, NonPrimitiveOpType};\nuse crate::ops::{Poseidon2Params, Poseidon2PermCall, Poseidon2PermCallBase};\nuse crate::tables::TraceGeneratorFn;\nuse crate::types::{ExprId, NonPrimitiveOpId, WitnessAllocator, WitnessId};\nuse crate::{CircuitBuilderError, CircuitError, CircuitField, Poseidon2PermOps};\n\n/// Builder for constructing circuits.\npub struct CircuitBuilder\u003cF: Field\u003e {\n    /// Expression graph builder\n    expr_builder: ExpressionBuilder\u003cF\u003e,\n\n    /// Public input tracker\n    public_tracker: PublicInputTracker,\n\n    /// Witness index allocator\n    witness_alloc: WitnessAllocator,\n\n    /// Non-primitive operations (complex constraints that don't produce `ExprId`s)\n    non_primitive_ops: Vec\u003cNonPrimitiveOperationData\u003cF\u003e\u003e,\n\n    /// Builder configuration\n    config: BuilderConfig\u003cF\u003e,\n\n    /// Registered non-primitive trace generators.\n    non_primitive_trace_generators: HashMap\u003cNonPrimitiveOpType, TraceGeneratorFn\u003cF\u003e\u003e,\n\n    /// Tags for wires (ExprId) - enables probing values by name after execution.\n    tag_to_expr: HashMap\u003cString, ExprId\u003e,\n\n    /// Tags for non-primitive operations - enables setting private data by name.\n    tag_to_op: HashMap\u003cString, NonPrimitiveOpId\u003e,\n}\n\n/// Per-op extra parameters that are not encoded in the op type.\n#[derive(Debug)]\npub enum NonPrimitiveOpParams\u003cF\u003e {\n    Poseidon2Perm {\n        new_start: bool,\n        merkle_path: bool,\n    },\n    Unconstrained {\n        executor: Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e,\n    },\n}\n\nimpl\u003cF: Field\u003e Clone for NonPrimitiveOpParams\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        match self {\n            Self::Poseidon2Perm {\n                new_start,\n                merkle_path,\n            } =\u003e Self::Poseidon2Perm {\n                new_start: *new_start,\n                merkle_path: *merkle_path,\n            },\n            Self::Unconstrained { executor } =\u003e Self::Unconstrained {\n                executor: executor.boxed(),\n            },\n        }\n    }\n}\n\n/// The non-primitive operation id, type, the vectors of the expressions representing its inputs\n/// and outputs, and any per-op parameters.\n#[derive(Debug, Clone)]\npub struct NonPrimitiveOperationData\u003cF: Field\u003e {\n    pub op_id: NonPrimitiveOpId,\n    pub op_type: NonPrimitiveOpType,\n    /// Input expressions (e.g., for Poseidon2Perm: [in0, in1, in2, in3, mmcs_index_sum, mmcs_bit])\n    pub input_exprs: Vec\u003cVec\u003cExprId\u003e\u003e,\n    /// Output expressions (e.g., for Poseidon2Perm: [out0, out1])\n    pub output_exprs: Vec\u003cVec\u003cExprId\u003e\u003e,\n    pub params: Option\u003cNonPrimitiveOpParams\u003cF\u003e\u003e,\n}\n\nimpl\u003cF: Field\u003e Default for CircuitBuilder\u003cF\u003e\nwhere\n    F: Clone + PrimeCharacteristicRing + Eq + Hash,\n{\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cF: Field\u003e CircuitBuilder\u003cF\u003e\nwhere\n    F: Clone + PrimeCharacteristicRing + Eq + Hash,\n{\n    /// Creates a new circuit builder.\n    pub fn new() -\u003e Self {\n        Self {\n            expr_builder: ExpressionBuilder::new(),\n            public_tracker: PublicInputTracker::new(),\n            witness_alloc: WitnessAllocator::new(),\n            non_primitive_ops: Vec::new(),\n            config: BuilderConfig::new(),\n            non_primitive_trace_generators: HashMap::new(),\n            tag_to_expr: HashMap::new(),\n            tag_to_op: HashMap::new(),\n        }\n    }\n\n    /// Enables a non-primitive operation type on this builder.\n    pub fn enable_op(\u0026mut self, op: NonPrimitiveOpType, cfg: crate::op::NonPrimitiveOpConfig\u003cF\u003e) {\n        self.config.enable_op(op, cfg);\n    }\n\n    /// Enables Poseidon2 permutation operations (one perm per table row).\n    ///\n    /// The current implementation only supports extension degree D=4 and WIDTH=16.\n    ///\n    /// # Arguments\n    /// * `trace_generator` - Function to generate Poseidon2 trace from circuit and witness\n    /// * `perm` - The Poseidon2 permutation to use for execution\n    pub fn enable_poseidon2_perm\u003cConfig, P\u003e(\n        \u0026mut self,\n        trace_generator: TraceGeneratorFn\u003cF\u003e,\n        perm: P,\n    ) where\n        Config: Poseidon2Params,\n        F: CircuitField + ExtensionField\u003cConfig::BaseField\u003e,\n        P: Permutation\u003c[Config::BaseField; 16]\u003e + Clone + Send + Sync + 'static,\n    {\n        // Hard gate on D=4 and WIDTH=16 to avoid silently accepting incompatible configs.\n        assert!(\n            Config::D == 4,\n            \"Poseidon2 perm op only supports extension degree D=4\"\n        );\n        assert!(\n            Config::WIDTH == 16,\n            \"Poseidon2 perm op only supports WIDTH=16\"\n        );\n\n        // Build exec closure that:\n        // 1. Converts [F;4] extension limbs to [Base;16] using basis coefficients\n        // 2. Calls perm.permute([Base;16])\n        // 3. Converts output [Base;16] back to [F;4]\n        let exec: crate::op::Poseidon2PermExec\u003cF, 4\u003e = Arc::new(move |input: \u0026[F; 4]| {\n            // Convert 4 extension elements to 16 base elements\n            let mut base_input = [Config::BaseField::ZERO; 16];\n            for (i, ext_elem) in input.iter().enumerate() {\n                let coeffs = ext_elem.as_basis_coefficients_slice();\n                debug_assert_eq!(\n                    coeffs.len(),\n                    4,\n                    \"Extension field should have D=4 basis coefficients\"\n                );\n                base_input[i * 4..(i + 1) * 4].copy_from_slice(coeffs);\n            }\n\n            // Apply permutation\n            let base_output = perm.permute(base_input);\n\n            // Convert 16 base elements back to 4 extension elements\n            let mut output = [F::ZERO; 4];\n            for i in 0..4 {\n                let coeffs = \u0026base_output[i * 4..(i + 1) * 4];\n                output[i] = F::from_basis_coefficients_slice(coeffs)\n                    .expect(\"basis coefficients should be valid\");\n            }\n            output\n        });\n\n        self.config.enable_op(\n            NonPrimitiveOpType::Poseidon2Perm(Config::CONFIG),\n            NonPrimitiveOpConfig::Poseidon2Perm {\n                config: Config::CONFIG,\n                exec,\n            },\n        );\n        self.non_primitive_trace_generators.insert(\n            NonPrimitiveOpType::Poseidon2Perm(Config::CONFIG),\n            trace_generator,\n        );\n    }\n\n    /// Enables the Poseidon2 permutation operation for base field challenges (D=1).\n    ///\n    /// This variant is for tests/circuits using base field as the challenge type.\n    /// The permutation operates directly on 16 base field elements without packing.\n    ///\n    /// # Arguments\n    /// * `trace_generator` - Function to generate Poseidon2 trace from circuit and witness\n    /// * `perm` - The Poseidon2 permutation to use for execution\n    pub fn enable_poseidon2_perm_base\u003cConfig, P\u003e(\n        \u0026mut self,\n        trace_generator: TraceGeneratorFn\u003cF\u003e,\n        perm: P,\n    ) where\n        Config: Poseidon2Params,\n        F: CircuitField,\n        P: Permutation\u003c[F; 16]\u003e + Clone + Send + Sync + 'static,\n    {\n        assert!(\n            Config::D == 1,\n            \"enable_poseidon2_perm_base only supports extension degree D=1\"\n        );\n        assert!(\n            Config::WIDTH == 16,\n            \"enable_poseidon2_perm_base only supports WIDTH=16\"\n        );\n\n        // For D=1, the exec closure operates directly on 16 base field elements\n        let exec: crate::op::Poseidon2PermExecBase\u003cF\u003e =\n            Arc::new(move |input: \u0026[F; 16]| perm.permute(*input));\n\n        self.config.enable_op(\n            NonPrimitiveOpType::Poseidon2Perm(Config::CONFIG),\n            crate::op::NonPrimitiveOpConfig::Poseidon2PermBase {\n                config: Config::CONFIG,\n                exec,\n            },\n        );\n        self.non_primitive_trace_generators.insert(\n            NonPrimitiveOpType::Poseidon2Perm(Config::CONFIG),\n            trace_generator,\n        );\n    }\n\n    /// Checks whether an op type is enabled on this builder.\n    fn is_op_enabled(\u0026self, op: \u0026NonPrimitiveOpType) -\u003e bool {\n        self.config.is_op_enabled(op)\n    }\n\n    pub(crate) fn ensure_op_enabled(\n        \u0026self,\n        op: NonPrimitiveOpType,\n    ) -\u003e Result\u003c(), CircuitBuilderError\u003e {\n        // Unconstrained operations are always enable\n        if !self.is_op_enabled(\u0026op) \u0026\u0026 op != NonPrimitiveOpType::Unconstrained {\n            return Err(CircuitBuilderError::OpNotAllowed { op });\n        }\n        Ok(())\n    }\n\n    /// Adds a public input to the circuit.\n    ///\n    /// Cost: 1 row in Public table + 1 row in witness table.\n    pub fn public_input(\u0026mut self) -\u003e ExprId {\n        self.alloc_public_input(\"\")\n    }\n\n    /// Allocates a public input with a descriptive label.\n    ///\n    /// The label is logged in debug builds for easier debugging of public input ordering.\n    ///\n    /// Cost: 1 row in Public table + 1 row in witness table.\n    pub fn alloc_public_input(\u0026mut self, label: \u0026'static str) -\u003e ExprId {\n        let pos = self.public_tracker.alloc();\n        self.expr_builder.public(pos, label)\n    }\n\n    /// Allocates multiple public inputs with a descriptive label.\n    pub fn alloc_public_inputs(\u0026mut self, count: usize, label: \u0026'static str) -\u003e Vec\u003cExprId\u003e {\n        (0..count).map(|_| self.alloc_public_input(label)).collect()\n    }\n\n    /// Allocates a fixed-size array of public inputs with a descriptive label.\n    pub fn alloc_public_input_array\u003cconst N: usize\u003e(\u0026mut self, label: \u0026'static str) -\u003e [ExprId; N] {\n        core::array::from_fn(|_| self.alloc_public_input(label))\n    }\n\n    /// Returns the current public input count.\n    pub const fn public_input_count(\u0026self) -\u003e usize {\n        self.public_tracker.count()\n    }\n\n    /// Adds a constant to the circuit (deduplicated).\n    ///\n    /// If this value was previously added, returns the original ExprId.\n    /// Cost: 1 row in Const table + 1 row in witness table (only for new constants).\n    pub fn define_const(\u0026mut self, val: F) -\u003e ExprId {\n        self.alloc_const(val, \"\")\n    }\n\n    /// Allocates a constant with a descriptive label.\n    ///\n    /// Cost: 1 row in Const table + 1 row in witness table (only for new constants).\n    pub fn alloc_const(\u0026mut self, val: F, label: \u0026'static str) -\u003e ExprId {\n        self.expr_builder.define_const(val, label)\n    }\n\n    /// Adds two expressions.\n    ///\n    /// Cost: 1 row in the ALU table (add selector) + 1 row in the witness table.\n    pub fn add(\u0026mut self, lhs: ExprId, rhs: ExprId) -\u003e ExprId {\n        self.alloc_add(lhs, rhs, \"\")\n    }\n\n    /// Adds two expressions with a descriptive label.\n    ///\n    /// Cost: 1 row in the ALU table (add selector) + 1 row in the witness table.\n    pub fn alloc_add(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.expr_builder.add(lhs, rhs, label)\n    }\n\n    /// Subtracts two expressions.\n    ///\n    /// Cost: 1 row in the ALU table (add selector) + 1 row in the witness table (encoded as result + rhs = lhs).\n    pub fn sub(\u0026mut self, lhs: ExprId, rhs: ExprId) -\u003e ExprId {\n        self.alloc_sub(lhs, rhs, \"\")\n    }\n\n    /// Subtracts two expressions with a descriptive label.\n    ///\n    /// Cost: 1 row in the ALU table (add selector) + 1 row in the witness table.\n    pub fn alloc_sub(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.expr_builder.sub(lhs, rhs, label)\n    }\n\n    /// Multiplies two expressions.\n    ///\n    /// Cost: 1 row in the ALU table (mul selector) + 1 row in the witness table.\n    pub fn mul(\u0026mut self, lhs: ExprId, rhs: ExprId) -\u003e ExprId {\n        self.alloc_mul(lhs, rhs, \"\")\n    }\n\n    /// Multiplies two expressions with a descriptive label.\n    ///\n    /// Cost: 1 row in the ALU table (mul selector) + 1 row in the witness table.\n    pub fn alloc_mul(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.expr_builder.mul(lhs, rhs, label)\n    }\n\n    /// Computes and returns `a * b + c`.\n    ///\n    /// This is a common fused operation in cryptographic circuits.\n    ///\n    /// # Arguments\n    /// * `a`, `b`, `c`: The expressions to operate on.\n    ///\n    /// # Returns\n    /// A new `ExprId` representing the result of `a * b + c`.\n    ///\n    /// # Cost\n    /// 1 multiplication and 1 addition constraint.\n    pub fn mul_add(\u0026mut self, a: ExprId, b: ExprId, c: ExprId) -\u003e ExprId {\n        let product = self.mul(a, b);\n        self.add(product, c)\n    }\n\n    /// Multiplies a slice of expressions together.\n    ///\n    /// # Arguments\n    /// * `inputs`: A slice of `ExprId`s to multiply.\n    ///\n    /// # Returns\n    /// A new `ExprId` representing the product of all inputs. Returns `1` if the slice is empty.\n    ///\n    /// # Cost\n    /// `N-1` multiplication constraints, where `N` is the number of inputs.\n    pub fn mul_many(\u0026mut self, inputs: \u0026[ExprId]) -\u003e ExprId {\n        // Handle edge cases for empty or single-element slices.\n        if inputs.is_empty() {\n            return self.define_const(F::ONE);\n        }\n        if inputs.len() == 1 {\n            return inputs[0];\n        }\n\n        // Efficiently multiply all elements using a fold.\n        inputs\n            .iter()\n            .skip(1)\n            .fold(inputs[0], |acc, \u0026x| self.mul(acc, x))\n    }\n\n    /// Computes the inner product (dot product) of two slices of expressions.\n    ///\n    /// Computes `∑ (a[i] * b[i])`.\n    ///\n    /// # Arguments\n    /// * `a`: The first slice of `ExprId`s.\n    /// * `b`: The second slice of `ExprId`s.\n    ///\n    /// # Panics\n    /// Panics if the input slices `a` and `b` have different lengths.\n    ///\n    /// # Returns\n    /// A new `ExprId` representing the inner product.\n    ///\n    /// # Cost\n    /// `N` multiplications and `N-1` additions, where `N` is the length of the slices.\n    pub fn inner_product(\u0026mut self, a: \u0026[ExprId], b: \u0026[ExprId]) -\u003e ExprId {\n        let zero = self.define_const(F::ZERO);\n\n        // Calculate the sum of element-wise products.\n        zip_eq(a, b).fold(zero, |acc, (\u0026x, \u0026y)| self.mul_add(x, y, acc))\n    }\n\n    /// Divides two expressions.\n    ///\n    /// Cost: 1 row in the ALU table (mul selector) + 1 row in the witness table (encoded as rhs * out = lhs).\n    pub fn div(\u0026mut self, lhs: ExprId, rhs: ExprId) -\u003e ExprId {\n        self.alloc_div(lhs, rhs, \"\")\n    }\n\n    /// Divides two expressions with a descriptive label.\n    ///\n    /// Cost: 1 row in the ALU table (mul selector) + 1 row in the witness table.\n    pub fn alloc_div(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.expr_builder.div(lhs, rhs, label)\n    }\n\n    /// Asserts that an expression equals zero by connecting it to Const(0).\n    ///\n    /// Cost: Free in proving (implemented via connect).\n    pub fn assert_zero(\u0026mut self, expr: ExprId) {\n        self.connect(expr, ExprId::ZERO);\n    }\n\n    /// Asserts that an expression is boolean: b ∈ {0,1}.\n    ///\n    /// Encodes the constraint b · (b − 1) = 0 via `assert_zero`.\n    /// Cost: 1 mul + 1 add.\n    pub fn assert_bool(\u0026mut self, b: ExprId) {\n        let one = self.define_const(F::ONE);\n        let b_minus_one = self.sub(b, one);\n        let prod = self.mul(b, b_minus_one);\n        self.assert_zero(prod);\n    }\n\n    /// Connects two expressions, enforcing a == b (by aliasing outputs).\n    ///\n    /// Cost: Free in proving (handled by IR optimization layer via witness slot aliasing).\n    pub fn connect(\u0026mut self, a: ExprId, b: ExprId) {\n        self.expr_builder.connect(a, b);\n    }\n\n    /// Selects between two values using selector `b`:\n    /// result = s + b · (t − s).\n    ///\n    /// When `b` ∈ {0,1}, this returns `t` if b = 1, else `s` if b = 0.\n    /// Call `assert_bool(b)` beforehand if you need booleanity enforced.\n    /// Cost: 1 sub + 1 mul_add (0 if trivial).\n    pub fn select(\u0026mut self, b: ExprId, t: ExprId, s: ExprId) -\u003e ExprId {\n        // Trivial: both branches identical\n        if t == s {\n            return s;\n        }\n        // Selector is known constant\n        if self.expr_builder.is_const_zero(b) {\n            return s;\n        }\n        if self.expr_builder.is_const_one(b) {\n            return t;\n        }\n        let t_minus_s = self.sub(t, s);\n        let scaled = self.mul(b, t_minus_s);\n        self.add(s, scaled)\n    }\n\n    /// Exponentiates a base expression to a power of 2 (i.e. base^(2^power_log)), by squaring repeatedly.\n    pub fn exp_power_of_2(\u0026mut self, base: ExprId, power_log: usize) -\u003e ExprId {\n        let mut res = base;\n        for _ in 0..power_log {\n            let square = self.mul(res, res);\n            res = square;\n        }\n        res\n    }\n\n    /// Pushes a non-primitive op and creates optional output nodes tied to the call.\n    ///\n    /// `output_labels` must have length equal to the op's output arity; each `Some(label)`\n    /// creates an `Expr::NonPrimitiveOutput { call, output_idx }` node for that output index.\n    /// The returned `Vec\u003cOption\u003cExprId\u003e\u003e` is aligned with `output_labels`.\n    pub(crate) fn push_non_primitive_op_with_outputs(\n        \u0026mut self,\n        op_type: NonPrimitiveOpType,\n        input_exprs: Vec\u003cVec\u003cExprId\u003e\u003e,\n        output_labels: Vec\u003cOption\u003c\u0026'static str\u003e\u003e,\n        params: Option\u003cNonPrimitiveOpParams\u003cF\u003e\u003e,\n        label: \u0026'static str,\n    ) -\u003e (NonPrimitiveOpId, ExprId, Vec\u003cOption\u003cExprId\u003e\u003e) {\n        let op_id = NonPrimitiveOpId(self.non_primitive_ops.len() as u32);\n\n        let flattened_inputs: Vec\u003cExprId\u003e = input_exprs.iter().flatten().copied().collect();\n        let call_expr_id =\n            self.expr_builder\n                .add_non_primitive_call(op_id, op_type, flattened_inputs, label);\n\n        let mut output_exprs: Vec\u003cVec\u003cExprId\u003e\u003e = vec![Vec::new(); output_labels.len()];\n        let mut outputs: Vec\u003cOption\u003cExprId\u003e\u003e = vec![None; output_labels.len()];\n        for (i, maybe_label) in output_labels.into_iter().enumerate() {\n            if let Some(out_label) = maybe_label {\n                let out_expr_id =\n                    self.expr_builder\n                        .add_non_primitive_output(call_expr_id, i as u32, out_label);\n                output_exprs[i] = vec![out_expr_id];\n                outputs[i] = Some(out_expr_id);\n            }\n        }\n\n        self.non_primitive_ops.push(NonPrimitiveOperationData {\n            op_id,\n            op_type,\n            input_exprs,\n            output_exprs,\n            params,\n        });\n\n        (op_id, call_expr_id, outputs)\n    }\n\n    /// Pushes an unconstrained non-primitive op into the circuit and returns its output expressions.\n    ///\n    /// Each returned `ExprId` is an `Expr::NonPrimitiveOutput { call, output_idx }` node.\n    /// The `call` ID points to the newly created `NonPrimitiveOpWithExecutor` entry, so the\n    /// dependency is explicit in the computation DAG.\n    ///\n    /// This is used for creating new unconstrained wires assigned to a non-deterministic values\n    /// computed by `hint`.\n    pub(crate) fn push_unconstrained_op\u003cH: NonPrimitiveExecutor\u003cF\u003e + 'static\u003e(\n        \u0026mut self,\n        input_exprs: Vec\u003cVec\u003cExprId\u003e\u003e,\n        n_outputs: usize,\n        hint: H,\n        label: \u0026'static str,\n    ) -\u003e (NonPrimitiveOpId, ExprId, Vec\u003cOption\u003cExprId\u003e\u003e) {\n        self.push_non_primitive_op_with_outputs(\n            NonPrimitiveOpType::Unconstrained,\n            input_exprs,\n            (0..n_outputs).map(|_| Some(label)).collect(),\n            Some(NonPrimitiveOpParams::Unconstrained {\n                executor: Box::new(hint),\n            }),\n            label,\n        )\n    }\n\n    /// Pushes a new scope onto the scope stack.\n    ///\n    /// All subsequent allocations will be tagged with this scope until\n    /// `pop_scope` is called. Scopes can be nested.\n    ///\n    /// If the `debugging` feature is not enabled, this is a no-op.\n    #[allow(warnings)]\n    pub fn push_scope(\u0026mut self, scope: \u0026str) {\n        #[cfg(feature = \"debugging\")]\n        self.expr_builder.push_scope(scope);\n    }\n\n    /// Pops the current scope from the scope stack.\n    ///\n    /// If the `debugging` feature is not enabled, this is a no-op.\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn pop_scope(\u0026mut self) {\n        #[cfg(feature = \"debugging\")]\n        self.expr_builder.pop_scope();\n    }\n\n    /// Dumps the allocation log for specific `ExprId`s.\n    ///\n    /// If the `debugging` feature is not enabled, this is a no-op.\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn dump_expr_ids(\u0026self, expr_ids: \u0026[ExprId]) {\n        self.expr_builder.dump_expr_ids(expr_ids);\n    }\n\n    /// Dumps the allocation log.\n    ///\n    /// If debug_assertions are not enabled, this is a no-op.\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn dump_allocation_log(\u0026self) {\n        self.expr_builder.dump_allocation_log();\n    }\n\n    /// Lists all unique scopes in the allocation log.\n    ///\n    /// Returns an empty vector if the `debugging` feature is not enabled.\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn list_scopes(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.expr_builder.list_scopes()\n    }\n\n    /// Returns global operation counts collected during circuit construction when profiling is enabled.\n    ///\n    /// When the `profiling` feature is disabled, this method is not compiled.\n    #[cfg(feature = \"profiling\")]\n    pub const fn global_op_counts(\u0026self) -\u003e \u0026OpCounts {\n        let (global, _) = self.expr_builder.profiling_counts();\n        global\n    }\n\n    /// Returns per-scope operation counts collected during circuit construction when profiling is enabled.\n    ///\n    /// The returned map is keyed by the scope names passed to `push_scope`.\n    /// When the `profiling` feature is disabled, this method is not compiled.\n    #[cfg(feature = \"profiling\")]\n    pub const fn scope_op_counts(\u0026self) -\u003e \u0026HashMap\u003cString, OpCounts\u003e {\n        let (_, per_scope) = self.expr_builder.profiling_counts();\n        per_scope\n    }\n\n    /// Convenience method logging global, per-scope, and per-non-primitive-id profiling information.\n    ///\n    /// When the `profiling` feature is disabled, this is a no-op.\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn profile(\u0026self) {\n        #[cfg(feature = \"profiling\")]\n        {\n            let (global, per_scope) = self.expr_builder.profiling_counts();\n\n            tracing::info!(\"[PROFILING] global: {:?}\", global);\n            for (scope, counts) in per_scope.iter() {\n                tracing::info!(\"[PROFILING] scope: {:?}, counts: {:?}\", scope, counts);\n            }\n        }\n    }\n\n    /// Tags an expression for value lookup via `Traces::probe()` later on during\n    /// circuit execution.\n    ///\n    /// Tags must be unique within a circuit. Duplicate tags will return an error.\n    ///\n    /// Note that this is different from allocation labels for `ExprId`s, which are\n    /// used purely for debugging purposes.\n    ///\n    /// # Example\n    /// ```ignore\n    /// let result = builder.add(a, b);\n    /// builder.tag(result, \"my-sum\")?;\n    /// // After execution:\n    /// let value = traces.probe(\"my-sum\").unwrap();\n    /// ```\n    pub fn tag(\u0026mut self, expr: ExprId, tag: impl Into\u003cString\u003e) -\u003e Result\u003c(), CircuitBuilderError\u003e {\n        let tag = tag.into();\n        if self.tag_to_expr.contains_key(\u0026tag) || self.tag_to_op.contains_key(\u0026tag) {\n            return Err(CircuitBuilderError::DuplicateTag { tag });\n        }\n        self.tag_to_expr.insert(tag, expr);\n        Ok(())\n    }\n\n    /// Tags a non-primitive operation for private data setting via tag later on during\n    /// circuit execution.\n    ///\n    /// Tags must be unique within a circuit. Duplicate tags will return an error.\n    ///\n    /// Note that this is different from allocation labels for `ExprId`s, which are\n    /// used purely for debugging purposes.\n    ///\n    /// # Example\n    /// ```ignore\n    /// let (op_id, outputs) = builder.add_poseidon2_perm(...)?;\n    /// builder.tag_op(op_id, format!(\"fri-query-{}-depth-{}\", i, j))?;\n    /// // Before execution:\n    /// runner.set_private_data_by_tag(\"fri-query-0-depth-1\", data)?;\n    /// ```\n    pub fn tag_op(\n        \u0026mut self,\n        op_id: NonPrimitiveOpId,\n        tag: impl Into\u003cString\u003e,\n    ) -\u003e Result\u003c(), CircuitBuilderError\u003e {\n        let tag = tag.into();\n        if self.tag_to_expr.contains_key(\u0026tag) || self.tag_to_op.contains_key(\u0026tag) {\n            return Err(CircuitBuilderError::DuplicateTag { tag });\n        }\n        self.tag_to_op.insert(tag, op_id);\n        Ok(())\n    }\n}\n\nimpl\u003cF\u003e CircuitBuilder\u003cF\u003e\nwhere\n    F: Field + Clone + PartialEq + Eq + Hash,\n{\n    /// Builds the circuit into a Circuit with separate lowering and IR transformation stages.\n    /// Returns an error if lowering fails due to an internal inconsistency.\n    pub fn build(self) -\u003e Result\u003cCircuit\u003cF\u003e, CircuitBuilderError\u003e {\n        self.profile();\n\n        let (circuit, _) = self.build_with_public_mapping()?;\n        Ok(circuit)\n    }\n\n    /// Builds the circuit and returns both the circuit and the ExprId→WitnessId mapping for public inputs.\n    #[allow(clippy::type_complexity)]\n    pub fn build_with_public_mapping(\n        self,\n    ) -\u003e Result\u003c(Circuit\u003cF\u003e, HashMap\u003cExprId, WitnessId\u003e), CircuitBuilderError\u003e {\n        // Stage 1: Lower expressions and non-primitives into a single op list\n        for data in \u0026self.non_primitive_ops {\n            self.ensure_op_enabled(data.op_type)?;\n        }\n        let lowerer = ExpressionLowerer::new(\n            self.expr_builder.graph(),\n            \u0026self.non_primitive_ops,\n            self.expr_builder.pending_connects(),\n            self.public_tracker.count(),\n            self.witness_alloc,\n        );\n        let (ops, public_rows, expr_to_widx, public_mappings, witness_count) = lowerer.lower()?;\n\n        // Stage 2: IR transformations and optimizations\n        let optimizer = Optimizer::new();\n        let (ops, rewrite) = optimizer.optimize(ops);\n\n        let resolve = |id: WitnessId| Optimizer::resolve_witness(\u0026rewrite, id);\n        let expr_to_widx = expr_to_widx\n            .into_iter()\n            .map(|(e, w)| (e, resolve(w)))\n            .collect();\n        let public_rows = public_rows.into_iter().map(resolve).collect();\n\n        // Stage 3: Generate final circuit\n        let mut circuit = Circuit::new(witness_count, expr_to_widx);\n        circuit.ops = ops;\n        circuit.public_rows = public_rows;\n        if !rewrite.is_empty() {\n            circuit.witness_rewrite = Some(rewrite);\n        }\n        circuit.public_flat_len = self.public_tracker.count();\n        circuit.enabled_ops = self.config.into_enabled_ops();\n        circuit.non_primitive_trace_generators = self.non_primitive_trace_generators;\n        let mut gen_order: Vec\u003c_\u003e = circuit\n            .non_primitive_trace_generators\n            .keys()\n            .copied()\n            .collect();\n        gen_order.sort();\n        circuit.non_primitive_trace_generator_order = gen_order;\n\n        // Transfer wire tags, converting ExprId to WitnessId\n        for (tag, expr_id) in self.tag_to_expr {\n            if let Some(\u0026witness_id) = circuit.expr_to_widx.get(\u0026expr_id) {\n                circuit.tag_to_witness.insert(tag, witness_id);\n            } else {\n                return Err(CircuitBuilderError::MissingExprMapping {\n                    expr_id,\n                    context: tag,\n                });\n            }\n        }\n\n        // Transfer operation tags directly\n        circuit.tag_to_op_id = self.tag_to_op;\n\n        Ok((circuit, public_mappings))\n    }\n\n    /// Decomposes a field element into its little-endian binary representation.\n    ///\n    /// Given a target `x`, creates `n_bits` boolean witness targets representing\n    /// the binary decomposition, and constrains them to reconstruct `x`.\n    ///\n    /// # Parameters\n    /// - `x`: The field element to decompose.\n    /// - `n_bits`: Number of bits in the decomposition (must be ≤ 64).\n    ///\n    /// # Returns\n    /// A vector of `n_bits` boolean [`ExprId`]s\n    /// ```text\n    ///     [b_0, b_1, ..., b_{n-1}]\n    /// ```\n    /// such that:\n    /// ```text\n    ///     x = b_0·2^0 + b_1·2^1 + b_2·2^2 + ... + b_{n-1}·2^{n-1}.\n    /// ```\n    ///\n    /// # Errors\n    /// Returns [`CircuitError::BinaryDecompositionTooManyBits`] if `n_bits \u003e 64`.\n    ///\n    /// # Cost\n    /// `n_bits` witness hints + `n_bits` boolean constraints + reconstruction constraints.\n    pub fn decompose_to_bits\u003cBF\u003e(\n        \u0026mut self,\n        x: ExprId,\n        n_bits: usize,\n    ) -\u003e Result\u003cVec\u003cExprId\u003e, CircuitBuilderError\u003e\n    where\n        F: ExtensionField\u003cBF\u003e,\n        BF: PrimeField64,\n    {\n        self.push_scope(\"decompose_to_bits\");\n\n        // We cannot request more bits than the extension field can represent.\n        if n_bits \u003e F::bits() {\n            return Err(CircuitBuilderError::BinaryDecompositionTooManyBits {\n                expected: BF::bits(),\n                n_bits,\n            });\n        }\n\n        // Create bit witness variables\n        let binary_decomposition_hint = BinaryDecompositionHint::new();\n        let mut bits: Vec\u003cExprId\u003e = self\n            .push_unconstrained_op(\n                vec![vec![x]],\n                // We need all the bits so that we can reconstruct the F element.\n                F::bits(),\n                binary_decomposition_hint,\n                \"decompose_to_bits\",\n            )\n            .2\n            .into_iter()\n            .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n            .ok_or(CircuitBuilderError::MissingOutput)?;\n\n        // Constrain that the bits reconstruct to the original value.\n        let reconstructed = self.reconstruct_index_from_bits(\u0026bits)?;\n        self.connect(x, reconstructed);\n\n        // Return only `n_bits` bits.\n        let _ = bits.split_off(n_bits);\n        self.pop_scope();\n        Ok(bits)\n    }\n\n    /// Packs little-endian bits into an extension-field element, limb by limb.\n    ///\n    /// The input bits `[b_0, ..., b_{n-1}]` are in little-endian order. Let\n    /// `W = BF::bits()`. Bits are processed in chunks of `W` bits. For chunk index `i`,\n    /// the code computes:\n    ///\n    /// `limb_i = Σ b · 2^k`\n    ///\n    /// where the sum ranges over bits `b` in the chunk and `k` is the bit position\n    /// within the chunk.\n    ///\n    /// Each `limb_i` is embedded into `F` using the canonical basis element `E_i`.\n    /// The final value is `Σ limb_i · E_i`.\n    ///\n    /// # Parameters\n    /// - `bits`: Boolean `ExprId`s in little-endian order.\n    ///\n    /// # Returns\n    /// - `Ok(ExprId)` if `bits.len() \u003c= F::bits()`, otherwise an error.\n    ///\n    /// # Cost\n    /// `n` boolean constraints + `n` multiplications + `n` additions,\n    /// where `n = bits.len()`.\n    pub fn reconstruct_index_from_bits\u003cBF\u003e(\n        \u0026mut self,\n        bits: \u0026[ExprId],\n    ) -\u003e Result\u003cExprId, CircuitBuilderError\u003e\n    where\n        F: ExtensionField\u003cBF\u003e,\n        BF: Field,\n    {\n        self.push_scope(\"reconstruct_index_from_bits\");\n\n        if bits.len() \u003e F::bits() {\n            return Err(CircuitBuilderError::BinaryDecompositionTooManyBits {\n                expected: F::bits(),\n                n_bits: bits.len(),\n            });\n        }\n\n        // Accumulator for the running sum.\n        let mut acc = self.define_const(F::ZERO);\n\n        for (i, chunk) in bits.chunks(BF::bits()).enumerate() {\n            // The canonical basis element e_i.\n            let mut e_i = vec![BF::ZERO; F::DIMENSION];\n            e_i[i] = BF::ONE;\n            let e_i =\n                F::from_basis_coefficients_slice(\u0026e_i).expect(\"`basis` is of size `F::DIMENSION`\");\n            for (j, \u0026b) in chunk.iter().enumerate() {\n                // Add the constant `2^j * e_i`\n                let pow2 = self.define_const(e_i * BF::from_u64(1 \u003c\u003c j));\n                // Ensure each bit is boolean.\n                self.assert_bool(b);\n\n                // Add b_i · 2^j to the accumulator (at the corresponding limb).\n                let term = self.mul(b, pow2);\n                acc = self.add(acc, term);\n            }\n        }\n\n        self.pop_scope();\n        Ok(acc)\n    }\n\n    /// Recomposes D base field coefficients into an extension field element.\n    ///\n    /// Given coefficients `[c_0, c_1, ..., c_{D-1}]`, computes `x = sum(c_i * basis_i)`\n    /// where `basis_i` is the i-th canonical basis element of the extension field.\n    ///\n    /// Each input coefficient should be a base field element embedded in the extension\n    /// field (i.e., only the first basis component is non-zero).\n    ///\n    /// # Parameters\n    /// - `coeffs`: Slice of D base field coefficient targets\n    ///\n    /// # Returns\n    /// A single target representing the extension field element\n    ///\n    /// # Errors\n    /// Returns error if `coeffs.len() != F::DIMENSION`\n    ///\n    /// # Cost\n    /// D multiplications + (D-1) additions\n    pub fn recompose_base_coeffs_to_ext\u003cBF\u003e(\n        \u0026mut self,\n        coeffs: \u0026[ExprId],\n    ) -\u003e Result\u003cExprId, CircuitBuilderError\u003e\n    where\n        BF: PrimeField64,\n        F: ExtensionField\u003cBF\u003e,\n    {\n        if coeffs.len() != F::DIMENSION {\n            return Err(CircuitBuilderError::InvalidDimension {\n                expected: F::DIMENSION,\n                actual: coeffs.len(),\n            });\n        }\n\n        self.push_scope(\"recompose_base_coeffs_to_ext\");\n\n        let mut acc = self.define_const(F::ZERO);\n\n        for (i, \u0026coeff) in coeffs.iter().enumerate() {\n            // Construct the i-th canonical basis element: [0, ..., 0, 1, 0, ..., 0]\n            let mut basis_coeffs = vec![BF::ZERO; F::DIMENSION];\n            basis_coeffs[i] = BF::ONE;\n            let basis_elem = F::from_basis_coefficients_slice(\u0026basis_coeffs)\n                .expect(\"basis coefficients are valid\");\n\n            // Multiply coefficient by basis element\n            let basis_const = self.define_const(basis_elem);\n            let term = self.mul(coeff, basis_const);\n            acc = self.add(acc, term);\n        }\n\n        self.pop_scope();\n        Ok(acc)\n    }\n\n    /// Decomposes an extension field element into its D base field coefficients.\n    ///\n    /// Given `x = c_0 + c_1*w + c_2*w^2 + ... + c_{D-1}*w^{D-1}`, returns `[c_0, c_1, ..., c_{D-1}]`\n    /// as targets. Each coefficient target represents a base field element embedded in the\n    /// extension field (i.e., only the first basis component is non-zero).\n    ///\n    /// # Parameters\n    /// - `x`: The extension field element to decompose\n    ///\n    /// # Returns\n    /// Vector of D targets, each representing a base field coefficient\n    ///\n    /// # Constraints Added\n    /// - D witness allocations for coefficients (via `ExtDecompositionHint`)\n    /// - 1 recomposition constraint: `sum(c_i * basis_i) == x`\n    ///\n    /// # Cost\n    /// - D Witness rows + D Mul rows + (D-1) Add rows (for the recomposition constraint)\n    pub fn decompose_ext_to_base_coeffs\u003cBF\u003e(\n        \u0026mut self,\n        x: ExprId,\n    ) -\u003e Result\u003cVec\u003cExprId\u003e, CircuitBuilderError\u003e\n    where\n        BF: PrimeField64,\n        F: ExtensionField\u003cBF\u003e,\n    {\n        self.push_scope(\"decompose_ext_to_base_coeffs\");\n\n        // Allocate D witness slots for coefficients using hint\n        let ext_decomposition_hint = ExtDecompositionHint::\u003cBF\u003e::new();\n        let coeffs: Vec\u003cExprId\u003e = self\n            .push_unconstrained_op(\n                vec![vec![x]],\n                F::DIMENSION,\n                ext_decomposition_hint,\n                \"ext_decomposition\",\n            )\n            .2\n            .into_iter()\n            .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n            .ok_or(CircuitBuilderError::MissingOutput)?;\n\n        // Constrain: sum(coeffs[i] * basis[i]) == x\n        let reconstructed = self.recompose_base_coeffs_to_ext::\u003cBF\u003e(\u0026coeffs)?;\n        self.connect(x, reconstructed);\n\n        self.pop_scope();\n        Ok(coeffs)\n    }\n\n    /// Applies Poseidon2 permutation for the circuit challenger.\n    ///\n    /// Takes 4 extension element inputs and returns 4 extension element outputs.\n    /// This operation is **CTL-verified** against the Poseidon2 AIR table for soundness.\n    ///\n    /// # CTL Verification\n    /// - Inputs 0-3: CTL-verified against witness table\n    /// - Outputs 0-1: CTL-verified against witness table (rate elements)\n    /// - Outputs 2-3: NOT CTL-verified (capacity elements, constrained by Poseidon2 AIR)\n    ///\n    /// # Parameters\n    /// - `config`: The Poseidon2 configuration to use\n    /// - `inputs`: 4 extension element targets (the sponge state)\n    ///\n    /// # Returns\n    /// 4 extension element targets (the permuted state)\n    ///\n    /// # Errors\n    /// Returns error if the Poseidon2 operation is not enabled\n    pub fn add_poseidon2_perm_for_challenger(\n        \u0026mut self,\n        config: crate::ops::Poseidon2Config,\n        inputs: [ExprId; 4],\n    ) -\u003e Result\u003c[ExprId; 4], CircuitBuilderError\u003e {\n        self.push_scope(\"poseidon2_perm_for_challenger\");\n\n        // Use add_poseidon2_perm with CTL verification for soundness\n        // - All 4 inputs are CTL-verified\n        // - Outputs 0-1 are CTL-verified (rate elements)\n        // - Outputs 2-3 are returned but NOT CTL-verified (capacity elements)\n        let (_op_id, outputs) = self.add_poseidon2_perm(Poseidon2PermCall {\n            config,\n            new_start: true, // Each challenger permutation is independent\n            merkle_path: false,\n            mmcs_bit: None,\n            inputs: [\n                Some(inputs[0]),\n                Some(inputs[1]),\n                Some(inputs[2]),\n                Some(inputs[3]),\n            ],\n            out_ctl: [true, true],    // CTL-verify rate outputs\n            return_all_outputs: true, // Return all 4 outputs for sponge state\n            mmcs_index_sum: None,\n        })?;\n\n        let output_exprs: [ExprId; 4] = [\n            outputs[0].ok_or(CircuitBuilderError::MissingOutput)?,\n            outputs[1].ok_or(CircuitBuilderError::MissingOutput)?,\n            outputs[2].ok_or(CircuitBuilderError::MissingOutput)?,\n            outputs[3].ok_or(CircuitBuilderError::MissingOutput)?,\n        ];\n\n        self.pop_scope();\n        Ok(output_exprs)\n    }\n\n    /// Applies Poseidon2 permutation for the circuit challenger (base field, D=1).\n    ///\n    /// Takes 16 base field element inputs and returns 16 base field element outputs.\n    /// This operation is **CTL-verified** against the Poseidon2 AIR table for soundness.\n    ///\n    /// # CTL Verification\n    /// - Inputs 0-15: CTL-verified against witness table\n    /// - Outputs 0-7: CTL-verified against witness table (rate elements)\n    /// - Outputs 8-15: NOT CTL-verified (capacity elements, constrained by Poseidon2 AIR)\n    ///\n    /// # Parameters\n    /// - `config`: The Poseidon2 configuration to use (must be D=1)\n    /// - `inputs`: 16 base field element targets (the sponge state)\n    ///\n    /// # Returns\n    /// 16 base field element targets (the permuted state)\n    ///\n    /// # Errors\n    /// Returns error if the Poseidon2 operation is not enabled\n    pub fn add_poseidon2_perm_for_challenger_base(\n        \u0026mut self,\n        config: crate::ops::Poseidon2Config,\n        inputs: [ExprId; 16],\n    ) -\u003e Result\u003c[ExprId; 16], CircuitBuilderError\u003e {\n        self.push_scope(\"poseidon2_perm_for_challenger_base\");\n\n        // Use add_poseidon2_perm_base with CTL verification for soundness\n        // - All 16 inputs are CTL-verified\n        // - Outputs 0-7 are CTL-verified (rate elements)\n        // - Outputs 8-15 are returned but NOT CTL-verified (capacity elements)\n        let (_op_id, outputs) = self.add_poseidon2_perm_base(Poseidon2PermCallBase {\n            config,\n            new_start: true,          // Each challenger permutation is independent\n            inputs: inputs.map(Some), // All 16 inputs are CTL-verified\n            out_ctl: [true; 8],       // CTL-verify all 8 rate outputs\n            return_all_outputs: true, // Return all 16 outputs for sponge state\n        })?;\n\n        let output_exprs: [ExprId; 16] =\n            core::array::from_fn(|i| outputs[i].expect(\"output should exist\"));\n\n        self.pop_scope();\n        Ok(output_exprs)\n    }\n}\n\n/// Witness hint for extension field decomposition.\n///\n/// At runtime, extracts the basis coefficients from an extension field element\n/// and embeds each coefficient as an extension field element with zeroed higher coefficients.\n#[derive(Debug, Clone)]\nstruct ExtDecompositionHint\u003cBF: PrimeField64\u003e {\n    _phantom: PhantomData\u003cBF\u003e,\n}\n\nimpl\u003cBF: PrimeField64\u003e ExtDecompositionHint\u003cBF\u003e {\n    pub const fn new() -\u003e Self {\n        Self {\n            _phantom: PhantomData,\n        }\n    }\n}\n\nimpl\u003cBF: PrimeField64, EF: ExtensionField\u003cBF\u003e\u003e NonPrimitiveExecutor\u003cEF\u003e\n    for ExtDecompositionHint\u003cBF\u003e\n{\n    fn execute(\n        \u0026self,\n        inputs: \u0026[Vec\u003ccrate::WitnessId\u003e],\n        outputs: \u0026[Vec\u003ccrate::WitnessId\u003e],\n        ctx: \u0026mut crate::op::ExecutionContext\u003c'_, EF\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        if inputs.len() != 1 || inputs[0].len() != 1 {\n            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                op: NonPrimitiveOpType::Unconstrained,\n                expected: \"1 input\".to_string(),\n                got: inputs.len(),\n            });\n        }\n\n        if outputs.len() != EF::DIMENSION {\n            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                op: NonPrimitiveOpType::Unconstrained,\n                expected: format!(\"{} outputs\", EF::DIMENSION),\n                got: outputs.len(),\n            });\n        }\n\n        outputs.iter().try_for_each(|out| {\n            if out.len() != 1 {\n                Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                    op: NonPrimitiveOpType::Unconstrained,\n                    expected: \"1\".to_string(),\n                    got: out.len(),\n                })\n            } else {\n                Ok(())\n            }\n        })?;\n\n        let ext_val = ctx.get_witness(inputs[0][0])?;\n        let coeffs = ext_val.as_basis_coefficients_slice();\n\n        for (i, coeff) in coeffs.iter().enumerate() {\n            // Embed base field coefficient into extension field (zeroed higher coeffs)\n            let mut embedded = vec![BF::ZERO; EF::DIMENSION];\n            embedded[0] = *coeff;\n            let embedded_ef = EF::from_basis_coefficients_slice(\u0026embedded)\n                .expect(\"embedded coefficients are valid\");\n            ctx.set_witness(outputs[i][0], embedded_ef)?;\n        }\n\n        Ok(())\n    }\n\n    fn op_type(\u0026self) -\u003e \u0026NonPrimitiveOpType {\n        \u0026NonPrimitiveOpType::Unconstrained\n    }\n\n    fn as_any(\u0026self) -\u003e \u0026dyn core::any::Any {\n        self\n    }\n\n    fn boxed(\u0026self) -\u003e alloc::boxed::Box\u003cdyn NonPrimitiveExecutor\u003cEF\u003e\u003e {\n        Box::new(self.clone())\n    }\n}\n\n/// Witness hint for binary decomposition of a field element.\n///\n/// At runtime:\n/// - It extracts the canonical `u64` representation of the input field element,\n/// - It fills the witness with its little-endian binary decomposition.\n#[derive(Debug, Clone)]\nstruct BinaryDecompositionHint\u003cBF: PrimeField64\u003e {\n    /// Phantom data for the base field type.\n    _phantom: PhantomData\u003cBF\u003e,\n}\n\nimpl\u003cBF: PrimeField64\u003e BinaryDecompositionHint\u003cBF\u003e {\n    /// Creates a new binary decomposition hint.\n    pub const fn new() -\u003e Self {\n        Self {\n            _phantom: PhantomData,\n        }\n    }\n}\n\nimpl\u003cBF: PrimeField64, EF: ExtensionField\u003cBF\u003e\u003e NonPrimitiveExecutor\u003cEF\u003e\n    for BinaryDecompositionHint\u003cBF\u003e\n{\n    fn execute(\n        \u0026self,\n        inputs: \u0026[Vec\u003ccrate::WitnessId\u003e],\n        outputs: \u0026[Vec\u003ccrate::WitnessId\u003e],\n        ctx: \u0026mut crate::op::ExecutionContext\u003c'_, EF\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        if inputs.len() != 1 || inputs[0].len() != 1 {\n            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                op: NonPrimitiveOpType::Unconstrained,\n                expected: 1.to_string(),\n                got: inputs.len(),\n            });\n        }\n\n        let felt_bits = BF::bits();\n\n        if outputs.len() \u003e felt_bits * EF::DIMENSION {\n            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                op: NonPrimitiveOpType::Unconstrained,\n                expected: format!(\"\u003c= {}\", felt_bits * EF::DIMENSION),\n                got: outputs.len(),\n            });\n        }\n        outputs.iter().try_for_each(|out| {\n            if out.len() != 1 {\n                Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                    op: NonPrimitiveOpType::Unconstrained,\n                    expected: 1.to_string(),\n                    got: out.len(),\n                })\n            } else {\n                Ok(())\n            }\n        })?;\n\n        let ext_val = ctx.get_witness(inputs[0][0])?;\n\n        let bits = ext_val\n            .as_basis_coefficients_slice()\n            .iter()\n            .map(BF::as_canonical_u64)\n            .flat_map(|val| (0..felt_bits).map(move |i| EF::from_bool(val \u003e\u003e i \u0026 1 == 1)))\n            .take(outputs.len());\n\n        for (out, bit) in outputs.iter().zip(bits) {\n            ctx.set_witness(out[0], bit)?;\n        }\n        Ok(())\n    }\n\n    fn op_type(\u0026self) -\u003e \u0026crate::NonPrimitiveOpType {\n        \u0026crate::NonPrimitiveOpType::Unconstrained\n    }\n\n    fn as_any(\u0026self) -\u003e \u0026dyn core::any::Any {\n        self\n    }\n\n    fn boxed(\u0026self) -\u003e alloc::boxed::Box\u003cdyn NonPrimitiveExecutor\u003cEF\u003e\u003e {\n        Box::new(self.clone())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::extension::BinomialExtensionField;\n\n    use super::*;\n    use crate::op::NonPrimitiveOpConfig;\n\n    #[test]\n    fn test_new_builder_initialization() {\n        let builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        assert_eq!(builder.public_input_count(), 0);\n    }\n\n    #[test]\n    fn test_default_same_as_new() {\n        let builder1 = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let builder2 = CircuitBuilder::\u003cBabyBear\u003e::default();\n        assert_eq!(builder1.public_input_count(), builder2.public_input_count());\n    }\n\n    #[test]\n    fn test_add_public_input_single() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        builder.public_input();\n        assert_eq!(builder.public_input_count(), 1);\n    }\n\n    #[test]\n    fn test_alloc_public_inputs_multiple() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let pis = builder.alloc_public_inputs(5, \"batch\");\n        assert_eq!(pis.len(), 5);\n        assert_eq!(builder.public_input_count(), 5);\n    }\n\n    #[test]\n    fn test_alloc_public_input_array() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let pis: [ExprId; 3] = builder.alloc_public_input_array(\"array\");\n        assert_eq!(pis.len(), 3);\n        assert_eq!(builder.public_input_count(), 3);\n    }\n\n    #[test]\n    fn test_public_input_count_increments() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        assert_eq!(builder.public_input_count(), 0);\n        builder.public_input();\n        assert_eq!(builder.public_input_count(), 1);\n        builder.public_input();\n        assert_eq!(builder.public_input_count(), 2);\n    }\n\n    #[test]\n    fn test_add_const_deduplication() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let c1 = builder.define_const(BabyBear::from_u64(99));\n        let c2 = builder.define_const(BabyBear::from_u64(99));\n        assert_eq!(c1, c2);\n    }\n\n    #[test]\n    fn test_exp_power_of_2_zero() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let base = builder.define_const(BabyBear::from_u64(5));\n        let result = builder.exp_power_of_2(base, 0);\n        assert_eq!(result, base);\n    }\n\n    #[test]\n    fn test_select_operation() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let b = builder.public_input();\n        let t = builder.define_const(BabyBear::from_u64(10));\n        let s = builder.define_const(BabyBear::from_u64(5));\n        let _result = builder.select(b, t, s);\n        // Should create: t_minus_s, scaled, and result\n        assert_eq!(builder.public_input_count(), 1);\n    }\n\n    #[test]\n    fn test_select_shortcuts() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let t = builder.public_input();\n        let s = builder.public_input();\n        let zero = builder.define_const(BabyBear::ZERO);\n        let one = builder.define_const(BabyBear::ONE);\n\n        // select(b, t, t) = t (identical branches)\n        assert_eq!(builder.select(zero, t, t), t);\n\n        // select(0, t, s) = s\n        assert_eq!(builder.select(zero, t, s), s);\n\n        // select(1, t, s) = t\n        assert_eq!(builder.select(one, t, s), t);\n    }\n\n    #[test]\n    #[cfg(feature = \"debugging\")]\n    fn test_scope_operations() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        builder.push_scope(\"test_scope\");\n        builder.define_const(BabyBear::ONE);\n        builder.pop_scope();\n        let scopes = builder.list_scopes();\n        assert!(scopes.contains(\u0026(\"test_scope\".to_string())));\n    }\n\n    #[test]\n    #[cfg(feature = \"debugging\")]\n    fn test_list_scopes_release() {\n        let builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        assert!(builder.list_scopes().is_empty());\n    }\n\n    #[test]\n    fn test_build_empty_circuit() {\n        let builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let circuit = builder\n            .build()\n            .expect(\"Empty circuit should build successfully\");\n\n        assert_eq!(circuit.public_flat_len, 0);\n        assert_eq!(circuit.witness_count, 1);\n        assert_eq!(circuit.ops.len(), 1);\n        assert!(circuit.public_rows.is_empty());\n        assert!(circuit.enabled_ops.is_empty());\n\n        match \u0026circuit.ops[0] {\n            crate::op::Op::Const { out, val } =\u003e {\n                assert_eq!(*out, WitnessId(0));\n                assert_eq!(*val, BabyBear::ZERO);\n            }\n            _ =\u003e panic!(\"Expected Const operation at index 0\"),\n        }\n    }\n\n    #[test]\n    fn test_build_with_public_inputs() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        builder.public_input();\n        builder.public_input();\n        let circuit = builder\n            .build()\n            .expect(\"Circuit with public inputs should build\");\n\n        assert_eq!(circuit.public_flat_len, 2);\n        assert_eq!(circuit.public_rows.len(), 2);\n        assert_eq!(circuit.witness_count, 3);\n        assert_eq!(circuit.ops.len(), 3);\n\n        match \u0026circuit.ops[0] {\n            crate::op::Op::Const { out, val } =\u003e {\n                assert_eq!(*out, WitnessId(0));\n                assert_eq!(*val, BabyBear::ZERO);\n            }\n            _ =\u003e panic!(\"Expected Const at index 0\"),\n        }\n\n        match \u0026circuit.ops[1] {\n            crate::op::Op::Public { out, public_pos } =\u003e {\n                assert_eq!(*out, WitnessId(1));\n                assert_eq!(*public_pos, 0);\n            }\n            _ =\u003e panic!(\"Expected Public at index 1\"),\n        }\n\n        match \u0026circuit.ops[2] {\n            crate::op::Op::Public { out, public_pos } =\u003e {\n                assert_eq!(*out, WitnessId(2));\n                assert_eq!(*public_pos, 1);\n            }\n            _ =\u003e panic!(\"Expected Public at index 2\"),\n        }\n\n        assert_eq!(circuit.public_rows[0], WitnessId(1));\n        assert_eq!(circuit.public_rows[1], WitnessId(2));\n    }\n\n    #[test]\n    fn test_build_with_constants() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        builder.define_const(BabyBear::from_u64(1));\n        builder.define_const(BabyBear::from_u64(2));\n        let circuit = builder\n            .build()\n            .expect(\"Circuit with constants should build\");\n\n        assert_eq!(circuit.public_flat_len, 0);\n        assert!(circuit.public_rows.is_empty());\n        assert_eq!(circuit.witness_count, 3);\n        assert_eq!(circuit.ops.len(), 3);\n\n        match \u0026circuit.ops[0] {\n            crate::op::Op::Const { out, val } =\u003e {\n                assert_eq!(*out, WitnessId(0));\n                assert_eq!(*val, BabyBear::ZERO);\n            }\n            _ =\u003e panic!(\"Expected Const at index 0\"),\n        }\n\n        match \u0026circuit.ops[1] {\n            crate::op::Op::Const { out, val } =\u003e {\n                assert_eq!(*out, WitnessId(1));\n                assert_eq!(*val, BabyBear::from_u64(1));\n            }\n            _ =\u003e panic!(\"Expected Const at index 1\"),\n        }\n\n        match \u0026circuit.ops[2] {\n            crate::op::Op::Const { out, val } =\u003e {\n                assert_eq!(*out, WitnessId(2));\n                assert_eq!(*val, BabyBear::from_u64(2));\n            }\n            _ =\u003e panic!(\"Expected Const at index 2\"),\n        }\n    }\n\n    #[test]\n    fn test_build_with_operations() {\n        // Use a public input so constant folding doesn't eliminate the Add\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let a = builder.public_input();\n        let b = builder.define_const(BabyBear::from_u64(3));\n        builder.add(a, b);\n        let circuit = builder\n            .build()\n            .expect(\"Circuit with operations should build\");\n\n        // zero const + public + const(3) + add result = 4 witnesses\n        assert_eq!(circuit.witness_count, 4);\n\n        // Should contain an ALU Add op\n        let has_alu_add = circuit.ops.iter().any(|op| {\n            matches!(\n                op,\n                crate::op::Op::Alu {\n                    kind: crate::op::AluOpKind::Add,\n                    ..\n                }\n            )\n        });\n        assert!(has_alu_add, \"Expected an ALU Add operation\");\n    }\n\n    #[test]\n    fn test_build_with_public_mapping() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let p0 = builder.public_input();\n        let p1 = builder.public_input();\n        let (circuit, mapping) = builder\n            .build_with_public_mapping()\n            .expect(\"Circuit should build with public mapping\");\n\n        assert_eq!(circuit.public_flat_len, 2);\n        assert_eq!(mapping.len(), 2);\n        assert_eq!(mapping[\u0026p0], WitnessId(1));\n        assert_eq!(mapping[\u0026p1], WitnessId(2));\n    }\n\n    #[test]\n    fn test_build_with_connect_deduplication() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let a = builder.define_const(BabyBear::from_u64(5));\n        let b = builder.define_const(BabyBear::from_u64(5));\n        builder.connect(a, b);\n        let circuit = builder\n            .build()\n            .expect(\"Circuit with constraints should build\");\n\n        assert_eq!(circuit.witness_count, 2);\n        assert_eq!(circuit.ops.len(), 2);\n    }\n\n    #[test]\n    fn test_non_primitive_outputs_ordering_and_dedup() {\n        use crate::op::Poseidon2Config;\n        use crate::ops::{Poseidon2PermCall, Poseidon2PermOps};\n\n        type Ext4 = BinomialExtensionField\u003cBabyBear, 4\u003e;\n\n        let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n        builder.enable_op(\n            NonPrimitiveOpType::Poseidon2Perm(Poseidon2Config::BabyBearD4Width16),\n            NonPrimitiveOpConfig::None,\n        );\n\n        // Use add_poseidon2_perm with out_ctl to expose outputs.\n        let z = builder.define_const(Ext4::ZERO);\n        let (op_id, outputs) = builder\n            .add_poseidon2_perm(Poseidon2PermCall {\n                config: Poseidon2Config::BabyBearD4Width16,\n                new_start: true,\n                merkle_path: false,\n                mmcs_bit: None, // Must be None when merkle_path=false\n                inputs: [Some(z), Some(z), Some(z), Some(z)],\n                out_ctl: [true, true],\n                return_all_outputs: false,\n                mmcs_index_sum: None,\n            })\n            .unwrap();\n\n        let out0 = outputs[0].unwrap();\n        let out1 = outputs[1].unwrap();\n\n        let one = builder.define_const(Ext4::ONE);\n        let sum0 = builder.add(out0, one);\n        let sum1 = builder.add(out1, one);\n\n        let circuit = builder.build().unwrap();\n\n        // Non-primitive op emitted exactly once.\n        let non_prims: Vec\u003c_\u003e = circuit\n            .ops\n            .iter()\n            .enumerate()\n            .filter_map(|(i, op)| match op {\n                crate::op::Op::NonPrimitiveOpWithExecutor { op_id: oid, .. } if *oid == op_id =\u003e {\n                    Some(i)\n                }\n                _ =\u003e None,\n            })\n            .collect();\n        assert_eq!(non_prims.len(), 1);\n        let non_prim_pos = non_prims[0];\n\n        // Exact Add matches (order of a/b may swap).\n        let w_out0 = circuit.expr_to_widx[\u0026out0];\n        let w_out1 = circuit.expr_to_widx[\u0026out1];\n        let w_one = circuit.expr_to_widx[\u0026one];\n        let w_sum0 = circuit.expr_to_widx[\u0026sum0];\n        let w_sum1 = circuit.expr_to_widx[\u0026sum1];\n\n        let add0_pos = circuit\n            .ops\n            .iter()\n            .position(|op| match op {\n                crate::op::Op::Alu {\n                    kind: crate::op::AluOpKind::Add,\n                    a,\n                    b,\n                    out,\n                    ..\n                } =\u003e {\n                    *out == w_sum0\n                        \u0026\u0026 ((*a == w_out0 \u0026\u0026 *b == w_one) || (*a == w_one \u0026\u0026 *b == w_out0))\n                }\n                _ =\u003e false,\n            })\n            .unwrap();\n\n        let add1_pos = circuit\n            .ops\n            .iter()\n            .position(|op| match op {\n                crate::op::Op::Alu {\n                    kind: crate::op::AluOpKind::Add,\n                    a,\n                    b,\n                    out,\n                    ..\n                } =\u003e {\n                    *out == w_sum1\n                        \u0026\u0026 ((*a == w_out1 \u0026\u0026 *b == w_one) || (*a == w_one \u0026\u0026 *b == w_out1))\n                }\n                _ =\u003e false,\n            })\n            .unwrap();\n\n        assert!(non_prim_pos \u003c add0_pos);\n        assert!(non_prim_pos \u003c add1_pos);\n    }\n\n    #[test]\n    fn test_basic_tagging() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let a = builder.define_const(BabyBear::from_u64(5));\n        let b = builder.define_const(BabyBear::from_u64(7));\n        let sum = builder.add(a, b);\n\n        builder.tag(sum, \"my-sum\").unwrap();\n\n        let circuit = builder.build().unwrap();\n        let runner = circuit.runner();\n        let traces = runner.run().unwrap();\n\n        let probed = traces.probe(\"my-sum\").unwrap();\n        assert_eq!(*probed, BabyBear::from_u64(12));\n    }\n\n    #[test]\n    fn test_tag_multiple_wires() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let a = builder.define_const(BabyBear::from_u64(10));\n        let b = builder.define_const(BabyBear::from_u64(20));\n        let sum = builder.add(a, b);\n        let prod = builder.mul(a, b);\n\n        builder.tag(sum, \"the-sum\").unwrap();\n        builder.tag(prod, \"the-product\").unwrap();\n\n        let circuit = builder.build().unwrap();\n        let runner = circuit.runner();\n        let traces = runner.run().unwrap();\n\n        assert_eq!(*traces.probe(\"the-sum\").unwrap(), BabyBear::from_u64(30));\n        assert_eq!(\n            *traces.probe(\"the-product\").unwrap(),\n            BabyBear::from_u64(200)\n        );\n    }\n\n    #[test]\n    fn test_probe_unknown_tag() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let a = builder.define_const(BabyBear::ONE);\n        builder.tag(a, \"known\").unwrap();\n\n        let circuit = builder.build().unwrap();\n        let runner = circuit.runner();\n        let traces = runner.run().unwrap();\n\n        assert!(traces.probe(\"known\").is_some());\n        assert!(traces.probe(\"unknown\").is_none());\n    }\n\n    #[test]\n    fn test_duplicate_tag() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let a = builder.define_const(BabyBear::ONE);\n        let b = builder.define_const(BabyBear::from_u64(2));\n\n        builder.tag(a, \"same-tag\").unwrap();\n        let result = builder.tag(b, \"same-tag\");\n\n        assert!(matches!(\n            result,\n            Err(CircuitBuilderError::DuplicateTag { tag }) if tag == \"same-tag\"\n        ));\n    }\n\n    #[test]\n    fn test_tag_with_dynamic_string() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n        for i in 0..3 {\n            let val = builder.define_const(BabyBear::from_u64(i as u64));\n            builder.tag(val, format!(\"wire-{}\", i)).unwrap();\n        }\n\n        let circuit = builder.build().unwrap();\n        let runner = circuit.runner();\n        let traces = runner.run().unwrap();\n\n        for i in 0..3 {\n            let tag = format!(\"wire-{}\", i);\n            assert_eq!(\n                *traces.probe(\u0026tag).unwrap(),\n                BabyBear::from_u64(i as u64),\n                \"wire-{} should have value {}\",\n                i,\n                i\n            );\n        }\n    }\n\n    #[test]\n    fn test_connected_tags_resolve_after_optimization() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n        let x = builder.public_input();\n        let one = builder.define_const(BabyBear::ONE);\n        let a = builder.add(x, one);\n        let b = builder.add(x, one); // b == a\n\n        builder.tag(a, \"result-a\").unwrap();\n        builder.tag(b, \"result-b\").unwrap();\n\n        // Connect them - the optimizer should alias one to the other\n        builder.connect(a, b);\n\n        let circuit = builder.build().unwrap();\n        let mut runner = circuit.runner();\n        runner.set_public_inputs(\u0026[BabyBear::from_u64(5)]).unwrap();\n        let traces = runner.run().unwrap();\n\n        // Both tags should resolve to the same value (5 + 1 = 6)\n        let expected = BabyBear::from_u64(6);\n        assert_eq!(traces.probe(\"result-a\"), Some(\u0026expected));\n        assert_eq!(traces.probe(\"result-b\"), Some(\u0026expected));\n    }\n}\n\n#[cfg(test)]\nmod proptests {\n    use alloc::vec;\n    use core::array;\n\n    use itertools::Itertools;\n    use p3_baby_bear::BabyBear;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_field::{BasedVectorSpace, PrimeCharacteristicRing};\n    use proptest::prelude::*;\n\n    use super::*;\n\n    // Strategy for generating valid field elements\n    fn field_element() -\u003e impl Strategy\u003cValue = BabyBear\u003e {\n        any::\u003cu64\u003e().prop_map(BabyBear::from_u64)\n    }\n\n    impl From\u003cExprId\u003e for WitnessId {\n        fn from(expr_id: ExprId) -\u003e Self {\n            Self(expr_id.0)\n        }\n    }\n\n    proptest! {\n        #[test]\n        fn field_add_commutative(a in field_element(), b in field_element()) {\n            let mut builder1 = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder1.define_const(a);\n            let cb = builder1.define_const(b);\n            let sum1 = builder1.add(ca, cb);\n\n            let mut builder2 = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca2 = builder2.define_const(a);\n            let cb2 = builder2.define_const(b);\n            let sum2 = builder2.add(cb2, ca2);\n\n            let circuit1 = builder1.build().unwrap();\n            let circuit2 = builder2.build().unwrap();\n\n            let runner1 = circuit1.runner();\n            let runner2 = circuit2.runner();\n\n            let traces1 = runner1.run().unwrap();\n            let traces2 = runner2.run().unwrap();\n\n            prop_assert_eq!(\n                traces1.witness_trace.get_value(sum1.into()),\n                traces2.witness_trace.get_value(sum2.into()),\n                \"addition should be commutative\"\n            );\n        }\n\n        #[test]\n        fn field_mul_commutative(a in field_element(), b in field_element()) {\n            let mut builder1 = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder1.define_const(a);\n            let cb = builder1.define_const(b);\n            let prod1 = builder1.mul(ca, cb);\n\n            let mut builder2 = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca2 = builder2.define_const(a);\n            let cb2 = builder2.define_const(b);\n            let prod2 = builder2.mul(cb2, ca2);\n\n            let circuit1 = builder1.build().unwrap();\n            let circuit2 = builder2.build().unwrap();\n\n            let runner1 = circuit1.runner();\n            let runner2 = circuit2.runner();\n\n            let traces1 = runner1.run().unwrap();\n            let traces2 = runner2.run().unwrap();\n\n            prop_assert_eq!(\n                traces1.witness_trace.get_value(prod1.into()),\n                traces2.witness_trace.get_value(prod2.into()),\n                \"multiplication should be commutative\"\n            );\n        }\n\n        #[test]\n        fn field_add_identity(a in field_element()) {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder.define_const(a);\n            let zero = builder.define_const(BabyBear::ZERO);\n            let result = builder.add(ca, zero);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            prop_assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026a,\n                \"a + 0 = a\"\n            );\n        }\n\n        #[test]\n        fn field_mul_identity(a in field_element()) {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder.define_const(a);\n            let one = builder.define_const(BabyBear::ONE);\n            let result = builder.mul(ca, one);\n\n            let circuit = builder.build().unwrap();\n            let  runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            prop_assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026a,\n                \"a * 1 = a\"\n            );\n        }\n\n        #[test]\n        fn field_add_sub(a in field_element(), b in field_element()) {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder.define_const(a);\n            let cb = builder.define_const(b);\n            let diff = builder.sub(ca, cb);\n            let result = builder.add(diff, cb);\n\n            let circuit = builder.build().unwrap();\n            let  runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            prop_assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026a,\n                \"(a - b) + b = a\"\n            );\n        }\n\n        #[test]\n        fn field_mul_div(a in field_element(), b in field_element().prop_filter(\"b must be non-zero\", |\u0026x| x != BabyBear::ZERO)) {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder.define_const(a);\n            let cb = builder.define_const(b);\n            let quot = builder.div(ca, cb);\n            let result = builder.mul(quot, cb);\n\n            let circuit = builder.build().unwrap();\n            let  runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            prop_assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026a,\n                \"(a / b) * b = a\"\n            );\n        }\n    }\n\n    #[test]\n    fn test_mul_add() {\n        // Test case 1: Basic computation (3 * 4 + 5 = 17)\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let a = builder.define_const(BabyBear::from_u64(3));\n            let b = builder.define_const(BabyBear::from_u64(4));\n            let c = builder.define_const(BabyBear::from_u64(5));\n            let result = builder.mul_add(a, b, c);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026BabyBear::from_u64(17)\n            );\n        }\n\n        // Test case 2: With zero product (0 * 7 + 9 = 9)\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let zero = builder.define_const(BabyBear::ZERO);\n            let b = builder.define_const(BabyBear::from_u64(7));\n            let c = builder.define_const(BabyBear::from_u64(9));\n            let result = builder.mul_add(zero, b, c);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026BabyBear::from_u64(9)\n            );\n        }\n    }\n\n    #[test]\n    fn test_mul_many() {\n        // Test case 1: Empty slice returns 1 (multiplicative identity)\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let result = builder.mul_many(\u0026[]);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026BabyBear::ONE\n            );\n        }\n\n        // Test case 2: Multiple elements [2, 3, 4, 5] = 120\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let vals: Vec\u003cExprId\u003e = vec![2, 3, 4, 5]\n                .into_iter()\n                .map(|v| builder.define_const(BabyBear::from_u64(v)))\n                .collect();\n            let result = builder.mul_many(\u0026vals);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026BabyBear::from_u64(120)\n            );\n        }\n\n        // Test case 3: With zero element [5, 0, 7] = 0\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let with_zero = vec![\n                builder.define_const(BabyBear::from_u64(5)),\n                builder.define_const(BabyBear::ZERO),\n                builder.define_const(BabyBear::from_u64(7)),\n            ];\n            let result = builder.mul_many(\u0026with_zero);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026BabyBear::ZERO\n            );\n        }\n    }\n\n    #[test]\n    fn test_inner_product() {\n        // Test case 1: Basic dot product [1,2,3] · [4,5,6] = 32\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let a: Vec\u003cExprId\u003e = vec![1, 2, 3]\n                .into_iter()\n                .map(|v| builder.define_const(BabyBear::from_u64(v)))\n                .collect();\n            let b: Vec\u003cExprId\u003e = vec![4, 5, 6]\n                .into_iter()\n                .map(|v| builder.define_const(BabyBear::from_u64(v)))\n                .collect();\n            let result = builder.inner_product(\u0026a, \u0026b);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026BabyBear::from_u64(32)\n            );\n        }\n\n        // Test case 2: Empty vectors [] · [] = 0\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let empty_a: Vec\u003cExprId\u003e = vec![];\n            let empty_b: Vec\u003cExprId\u003e = vec![];\n            let result = builder.inner_product(\u0026empty_a, \u0026empty_b);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026BabyBear::ZERO\n            );\n        }\n\n        // Test case 3: Zero vector [0,0,0] · [5,6,7] = 0\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let zeros: Vec\u003cExprId\u003e = (0..3)\n                .map(|_| builder.define_const(BabyBear::ZERO))\n                .collect();\n            let vals: Vec\u003cExprId\u003e = vec![5, 6, 7]\n                .into_iter()\n                .map(|v| builder.define_const(BabyBear::from_u64(v)))\n                .collect();\n            let result = builder.inner_product(\u0026zeros, \u0026vals);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026BabyBear::ZERO\n            );\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_inner_product_mismatched_lengths() {\n        // Verify that inner_product panics with mismatched vector lengths\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n        // Create vectors with different lengths: [1,2] vs [3,4,5]\n        let a: Vec\u003cExprId\u003e = vec![1, 2]\n            .into_iter()\n            .map(|v| builder.define_const(BabyBear::from_u64(v)))\n            .collect();\n        let b: Vec\u003cExprId\u003e = vec![3, 4, 5]\n            .into_iter()\n            .map(|v| builder.define_const(BabyBear::from_u64(v)))\n            .collect();\n\n        // Should panic: lengths don't match (2 != 3)\n        builder.inner_product(\u0026a, \u0026b);\n    }\n\n    proptest! {\n        #[test]\n        fn prop_mul_add_correctness(\n            a in field_element(),\n            b in field_element(),\n            c in field_element()\n        ) {\n            // Build circuit with mul_add\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder.define_const(a);\n            let cb = builder.define_const(b);\n            let cc = builder.define_const(c);\n            let result = builder.mul_add(ca, cb, cc);\n\n            // Execute circuit\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            // Compute expected value\n            let expected = a * b + c;\n\n            // Verify correctness\n            prop_assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026expected\n            );\n        }\n\n        #[test]\n        fn prop_mul_many_correctness(\n            values in prop::collection::vec(field_element(), 0..8)\n        ) {\n            // Build circuit with mul_many\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let expr_ids: Vec\u003cExprId\u003e = values\n                .iter()\n                .map(|\u0026v| builder.define_const(v))\n                .collect();\n            let result = builder.mul_many(\u0026expr_ids);\n\n            // Execute circuit\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            // Compute expected product (empty → 1, otherwise fold multiply)\n            let expected = if values.is_empty() {\n                BabyBear::ONE\n            } else {\n                values.iter().fold(BabyBear::ONE, |acc, \u0026x| acc * x)\n            };\n\n            // Verify correctness\n            prop_assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026expected\n            );\n        }\n\n        #[test]\n        fn prop_inner_product_correctness(\n            values in prop::collection::vec((field_element(), field_element()), 0..8)\n        ) {\n            // Extract equal-length vectors from paired values\n            let vec1: Vec\u003cBabyBear\u003e = values.iter().map(|(a, _)| *a).collect();\n            let vec2: Vec\u003cBabyBear\u003e = values.iter().map(|(_, b)| *b).collect();\n\n            // Build circuit with inner_product\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let a: Vec\u003cExprId\u003e = vec1.iter().map(|\u0026v| builder.define_const(v)).collect();\n            let b: Vec\u003cExprId\u003e = vec2.iter().map(|\u0026v| builder.define_const(v)).collect();\n            let result = builder.inner_product(\u0026a, \u0026b);\n\n            // Execute circuit\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            // Compute expected dot product: Σ(a_i * b_i)\n            let expected = vec1\n                .iter()\n                .zip(vec2.iter())\n                .fold(BabyBear::ZERO, |acc, (\u0026x, \u0026y)| acc + x * y);\n\n            // Verify correctness\n            prop_assert_eq!(\n                traces.witness_trace.get_value(result.into()).unwrap(),\n                \u0026expected\n            );\n        }\n    }\n\n    #[test]\n    fn test_reconstruct_index_from_bits() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n        // Test reconstructing the value 5 (binary: 101)\n        let bit0 = builder.define_const(BabyBear::ONE); // 1\n        let bit1 = builder.define_const(BabyBear::ZERO); // 0\n        let bit2 = builder.define_const(BabyBear::ONE); // 1\n\n        let bits = vec![bit0, bit1, bit2];\n        let result = builder.reconstruct_index_from_bits(\u0026bits).unwrap();\n\n        // Connect result to a public input so we can verify its value\n        let output = builder.public_input();\n        builder.connect(result, output);\n\n        // Build and run the circuit\n        let circuit = builder.build().expect(\"Failed to build circuit\");\n        let mut runner = circuit.runner();\n\n        // Set public inputs: the expected result value 5\n        let expected_result = BabyBear::from_u64(5); // 1*1 + 0*2 + 1*4 = 5\n        runner\n            .set_public_inputs(\u0026[expected_result])\n            .expect(\"Failed to set public inputs\");\n\n        let traces = runner.run().expect(\"Failed to run circuit\");\n\n        // Just verify the calculation is correct - reconstruct gives us 5\n        assert_eq!(traces.public_trace.values[0], BabyBear::from_u64(5));\n    }\n\n    type Ext4 = BinomialExtensionField\u003cBabyBear, 4\u003e;\n\n    #[test]\n    fn test_reconstruct_index_from_bits_ext_field() {\n        let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n\n        // Test reconstructing a value from an alternating 124-bit pattern (0xAAAA…)\n        let bits: [_; 124] = array::from_fn(|i| builder.define_const(Ext4::from_usize(i % 2)));\n\n        let result = builder\n            .reconstruct_index_from_bits::\u003cBabyBear\u003e(\u0026bits)\n            .unwrap();\n\n        // Connect result to a public input so we can verify its value\n        let output = builder.public_input();\n        builder.connect(result, output);\n\n        // Build and run the circuit\n        let circuit = builder.build().expect(\"Failed to build circuit\");\n        let mut runner = circuit.runner();\n\n        // Set public inputs: compute the expected result\n        let expected_result = (0..Ext4::bits() as u64)\n            .chunks(BabyBear::bits())\n            .into_iter()\n            .enumerate()\n            .map(|(chunk_idx, chunk)| {\n                chunk\n                    .into_iter()\n                    .map(|i| {\n                        let mut pow2 =\n                            [BabyBear::ZERO; \u003cExt4 as BasedVectorSpace\u003cBabyBear\u003e\u003e::DIMENSION];\n                        pow2[chunk_idx] = BabyBear::TWO.exp_u64(i % BabyBear::bits() as u64);\n                        let power = Ext4::from_basis_coefficients_slice(\u0026pow2).unwrap();\n                        Ext4::from_u8((i % 2) as u8) * power\n                    })\n                    .sum()\n            })\n            .sum();\n\n        runner\n            .set_public_inputs(\u0026[expected_result])\n            .expect(\"Failed to set public inputs\");\n\n        let traces = runner.run().expect(\"Failed to run circuit\");\n\n        // Just verify the calculation is correct - reconstruct gives us 5\n        assert_eq!(traces.public_trace.values[0], expected_result);\n    }\n\n    #[test]\n    fn test_decompose_to_bits() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n        // Create a target representing the value we want to decompose\n        let value = builder.define_const(BabyBear::from_u64(6)); // Binary: 110\n\n        // Decompose into 3 bits - this creates its own public inputs for the bits\n        let bits = builder.decompose_to_bits::\u003cBabyBear\u003e(value, 3).unwrap();\n\n        // Build and run the circuit\n        let circuit = builder.build().expect(\"Failed to build circuit\");\n        let expr_to_widx = circuit.expr_to_widx.clone();\n        let runner = circuit.runner();\n        let traces = runner.run().expect(\"Failed to run circuit\");\n\n        // Verify the bits are correctly decomposed - 6 = [0,1,1] in little-endian\n        let bit_values: Vec\u003cBabyBear\u003e = bits\n            .iter()\n            .map(|b| {\n                let w = expr_to_widx.get(b).expect(\"bit expr mapped\");\n                *traces.witness_trace.get_value(*w).unwrap()\n            })\n            .collect();\n        assert_eq!(bit_values[0], BabyBear::ZERO); // bit 0\n        assert_eq!(bit_values[1], BabyBear::ONE); // bit 1\n        assert_eq!(bit_values[2], BabyBear::ONE); // bit 2\n\n        assert_eq!(bits.len(), 3);\n    }\n\n    #[test]\n    fn test_decompose_to_bits_ext_field() {\n        let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n\n        // Create a target representing the value we want to decompose\n        let value = builder.define_const(\n            Ext4::from_basis_coefficients_slice(\u0026[\n                BabyBear::from_u32(0x40000006), // Binary: 01100000 00000000 00000000 00000001\n                BabyBear::from_u32(0x55555555), // Binary: 10101010 10101010 10101010 10101010\n                BabyBear::from_u32(0x02000000), // Binary: 00000000 00000000 00000000 01000000\n                BabyBear::ZERO,                 // Binary: 00000000 00000000 00000000 00000000\n            ])\n            .unwrap(),\n        );\n\n        // Decompose into 3 bits - this creates its own public inputs for the bits\n        let bits = builder\n            .decompose_to_bits::\u003cBabyBear\u003e(value, Ext4::bits())\n            .unwrap();\n\n        // Build and run the circuit\n        let circuit = builder.build().expect(\"Failed to build circuit\");\n        let expr_to_widx = circuit.expr_to_widx.clone();\n        let runner = circuit.runner();\n        let traces = runner.run().expect(\"Failed to run circuit\");\n\n        // Verify the bits are correctly decomposed\n        // Expected first limb binary decompostion\n        let hex_0x40000006_bin = [\n            0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 1,\n        ]\n        .map(Ext4::from_u8);\n        // Expected second limb binary decompostion\n        let hex_0x55555555_bin = [\n            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n            0, 1,\n        ]\n        .map(Ext4::from_u8);\n        // Expected third limb binary decompostion\n        let hex_0x02000000_bin = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,\n            0, 0,\n        ]\n        .map(Ext4::from_u8);\n        // Expected fourth limb binary decompostion\n        let zero_bin = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0,\n        ]\n        .map(Ext4::from_u8);\n\n        let bit_values: Vec\u003cExt4\u003e = bits\n            .iter()\n            .map(|b| {\n                let w = expr_to_widx.get(b).expect(\"bit expr mapped\");\n                *traces.witness_trace.get_value(*w).unwrap()\n            })\n            .collect();\n        let result = bit_values.chunks(31).collect::\u003cVec\u003c\u0026[Ext4]\u003e\u003e();\n        assert_eq!(result[0], hex_0x40000006_bin);\n        assert_eq!(result[1], hex_0x55555555_bin);\n        assert_eq!(result[2], hex_0x02000000_bin);\n        assert_eq!(result[3], zero_bin);\n        assert_eq!(bits.len(), Ext4::bits());\n    }\n\n    #[test]\n    fn test_recompose_base_coeffs_to_ext() {\n        type Ext4 = BinomialExtensionField\u003cBabyBear, 4\u003e;\n\n        let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n\n        let c0 = builder.define_const(Ext4::from(BabyBear::from_u64(1)));\n        let c1 = builder.define_const(Ext4::from(BabyBear::from_u64(2)));\n        let c2 = builder.define_const(Ext4::from(BabyBear::from_u64(3)));\n        let c3 = builder.define_const(Ext4::from(BabyBear::from_u64(4)));\n\n        let coeffs = [c0, c1, c2, c3];\n        let recomposed = builder\n            .recompose_base_coeffs_to_ext::\u003cBabyBear\u003e(\u0026coeffs)\n            .unwrap();\n\n        let circuit = builder.build().expect(\"Failed to build circuit\");\n        let expr_to_widx = circuit.expr_to_widx.clone();\n        let runner = circuit.runner();\n        let traces = runner.run().expect(\"Failed to run circuit\");\n\n        let w = expr_to_widx.get(\u0026recomposed).expect(\"recomposed mapped\");\n        let result = *traces.witness_trace.get_value(*w).unwrap();\n\n        let expected = Ext4::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(1),\n            BabyBear::from_u64(2),\n            BabyBear::from_u64(3),\n            BabyBear::from_u64(4),\n        ])\n        .unwrap();\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_decompose_ext_to_base_coeffs() {\n        type Ext4 = BinomialExtensionField\u003cBabyBear, 4\u003e;\n\n        let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n\n        let ext_val = Ext4::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(5),\n            BabyBear::from_u64(6),\n            BabyBear::from_u64(7),\n            BabyBear::from_u64(8),\n        ])\n        .unwrap();\n        let x = builder.define_const(ext_val);\n\n        let coeffs = builder.decompose_ext_to_base_coeffs::\u003cBabyBear\u003e(x).unwrap();\n\n        assert_eq!(coeffs.len(), 4);\n\n        let circuit = builder.build().expect(\"Failed to build circuit\");\n        let expr_to_widx = circuit.expr_to_widx.clone();\n        let runner = circuit.runner();\n        let traces = runner.run().expect(\"Failed to run circuit\");\n\n        for (i, coeff_expr) in coeffs.iter().enumerate() {\n            let w = expr_to_widx.get(coeff_expr).expect(\"coeff mapped\");\n            let coeff_val = *traces.witness_trace.get_value(*w).unwrap();\n\n            let expected_coeffs: \u0026[BabyBear] = coeff_val.as_basis_coefficients_slice();\n            assert_eq!(\n                expected_coeffs[0],\n                BabyBear::from_u64(5 + i as u64),\n                \"coefficient {} mismatch\",\n                i\n            );\n            for (j, coeff) in expected_coeffs.iter().enumerate().skip(1) {\n                assert_eq!(\n                    *coeff,\n                    BabyBear::ZERO,\n                    \"coefficient {} should have zero at position {}\",\n                    i,\n                    j\n                );\n            }\n        }\n    }\n\n    #[test]\n    fn test_decompose_recompose_round_trip() {\n        type Ext4 = BinomialExtensionField\u003cBabyBear, 4\u003e;\n\n        let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n\n        let original = Ext4::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(123),\n            BabyBear::from_u64(456),\n            BabyBear::from_u64(789),\n            BabyBear::from_u64(101112),\n        ])\n        .unwrap();\n        let x = builder.define_const(original);\n\n        let coeffs = builder.decompose_ext_to_base_coeffs::\u003cBabyBear\u003e(x).unwrap();\n        let recomposed = builder\n            .recompose_base_coeffs_to_ext::\u003cBabyBear\u003e(\u0026coeffs)\n            .unwrap();\n\n        let circuit = builder.build().expect(\"Failed to build circuit\");\n        let expr_to_widx = circuit.expr_to_widx.clone();\n        let runner = circuit.runner();\n        let traces = runner.run().expect(\"Failed to run circuit\");\n\n        let w_orig = expr_to_widx.get(\u0026x).expect(\"original mapped\");\n        let w_recomp = expr_to_widx.get(\u0026recomposed).expect(\"recomposed mapped\");\n\n        let val_orig = *traces.witness_trace.get_value(*w_orig).unwrap();\n        let val_recomp = *traces.witness_trace.get_value(*w_recomp).unwrap();\n\n        assert_eq!(val_orig, original);\n        assert_eq!(val_recomp, original);\n        assert_eq!(val_orig, val_recomp);\n    }\n\n    #[test]\n    fn test_recompose_invalid_dimension() {\n        type Ext4 = BinomialExtensionField\u003cBabyBear, 4\u003e;\n\n        let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n\n        let c0 = builder.define_const(Ext4::ONE);\n        let c1 = builder.define_const(Ext4::ONE);\n        let c2 = builder.define_const(Ext4::ONE);\n\n        let result = builder.recompose_base_coeffs_to_ext::\u003cBabyBear\u003e(\u0026[c0, c1, c2]);\n\n        assert!(result.is_err());\n        match result {\n            Err(CircuitBuilderError::InvalidDimension { expected, actual }) =\u003e {\n                assert_eq!(expected, 4);\n                assert_eq!(actual, 3);\n            }\n            _ =\u003e panic!(\"Expected InvalidDimension error\"),\n        }\n    }\n\n    #[test]\n    fn test_bool_check_fusion() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n        let b = builder.public_input();\n        builder.assert_bool(b);\n\n        let circuit = builder.build().unwrap();\n\n        let mut runner = circuit.runner();\n        runner.set_public_inputs(\u0026[BabyBear::ZERO]).unwrap();\n        let traces = runner.run().unwrap();\n        assert!(\n            !traces.alu_trace.is_empty(),\n            \"ALU trace should not be empty\"\n        );\n\n        let mut builder2 = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let b2 = builder2.public_input();\n        builder2.assert_bool(b2);\n        let circuit2 = builder2.build().unwrap();\n        let mut runner2 = circuit2.runner();\n        runner2.set_public_inputs(\u0026[BabyBear::ONE]).unwrap();\n        let traces2 = runner2.run().unwrap();\n        assert!(\n            !traces2.alu_trace.is_empty(),\n            \"ALU trace should not be empty\"\n        );\n    }\n}\n","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[7121992],"length":1,"stats":{"Line":1}},{"line":108,"address":[7162022,7160960,7162028,7161484,7161504,7161478],"length":1,"stats":{"Line":32}},{"line":110,"address":[6039766,6040326],"length":1,"stats":{"Line":31}},{"line":111,"address":[12416843,12417403,12418523,12416283,12417963],"length":1,"stats":{"Line":29}},{"line":112,"address":[5930304],"length":1,"stats":{"Line":30}},{"line":113,"address":[5840967,5840407],"length":1,"stats":{"Line":29}},{"line":114,"address":[4199206],"length":1,"stats":{"Line":30}},{"line":115,"address":[5930394],"length":1,"stats":{"Line":29}},{"line":116,"address":[5930446],"length":1,"stats":{"Line":30}},{"line":117,"address":[12417090,12416530,12417650,12418770,12418210],"length":1,"stats":{"Line":29}},{"line":122,"address":[7165392],"length":1,"stats":{"Line":1}},{"line":123,"address":[7165407],"length":1,"stats":{"Line":1}},{"line":133,"address":[2880272,2880552,2880581],"length":1,"stats":{"Line":12}},{"line":143,"address":[2230422],"length":1,"stats":{"Line":13}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[4945462],"length":1,"stats":{"Line":12}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[6017878,6018096],"length":1,"stats":{"Line":27}},{"line":158,"address":[7137185],"length":1,"stats":{"Line":12}},{"line":159,"address":[4945900,4945805],"length":1,"stats":{"Line":24}},{"line":160,"address":[4183665],"length":1,"stats":{"Line":12}},{"line":161,"address":[5918856,5919485],"length":1,"stats":{"Line":12}},{"line":162,"address":[2231008],"length":1,"stats":{"Line":12}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[2881698],"length":1,"stats":{"Line":12}},{"line":170,"address":[7137505],"length":1,"stats":{"Line":12}},{"line":173,"address":[7137557],"length":1,"stats":{"Line":12}},{"line":174,"address":[6019108,6018703],"length":1,"stats":{"Line":22}},{"line":175,"address":[5409836,5410025,5409772],"length":1,"stats":{"Line":24}},{"line":176,"address":[2231553,2231627,2231495,2231579],"length":1,"stats":{"Line":36}},{"line":177,"address":[5819604],"length":1,"stats":{"Line":12}},{"line":179,"address":[2881320],"length":1,"stats":{"Line":13}},{"line":182,"address":[],"length":0,"stats":{"Line":26}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[7137022],"length":1,"stats":{"Line":14}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":13}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[4801072,4801346,4801375],"length":1,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[4801434,4801174,4801392],"length":1,"stats":{"Line":3}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[4801322],"length":1,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[12385856,12385824,12385888,12385952,12385920],"length":1,"stats":{"Line":13}},{"line":240,"address":[2878270],"length":1,"stats":{"Line":17}},{"line":243,"address":[2879920],"length":1,"stats":{"Line":14}},{"line":248,"address":[2230054],"length":1,"stats":{"Line":16}},{"line":249,"address":[2230105],"length":1,"stats":{"Line":0}},{"line":251,"address":[4945135],"length":1,"stats":{"Line":13}},{"line":257,"address":[5815936],"length":1,"stats":{"Line":18}},{"line":258,"address":[2877989],"length":1,"stats":{"Line":18}},{"line":266,"address":[6017472,6017552],"length":1,"stats":{"Line":25}},{"line":267,"address":[6017505,6017585],"length":1,"stats":{"Line":26}},{"line":268,"address":[2230212],"length":1,"stats":{"Line":25}},{"line":272,"address":[7136672],"length":1,"stats":{"Line":11}},{"line":273,"address":[4945377,4945360,4945304],"length":1,"stats":{"Line":35}},{"line":277,"address":[2882928],"length":1,"stats":{"Line":11}},{"line":278,"address":[7140480,7140497,7140459],"length":1,"stats":{"Line":32}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[12385520,12385584,12385552],"length":1,"stats":{"Line":21}},{"line":291,"address":[1486349],"length":1,"stats":{"Line":19}},{"line":297,"address":[1486288],"length":1,"stats":{"Line":24}},{"line":298,"address":[4180514],"length":1,"stats":{"Line":20}},{"line":304,"address":[],"length":0,"stats":{"Line":26}},{"line":305,"address":[5430497],"length":1,"stats":{"Line":30}},{"line":311,"address":[],"length":0,"stats":{"Line":28}},{"line":312,"address":[5843435,5843483],"length":1,"stats":{"Line":30}},{"line":318,"address":[5431744],"length":1,"stats":{"Line":20}},{"line":319,"address":[2243121],"length":1,"stats":{"Line":20}},{"line":325,"address":[2898400],"length":1,"stats":{"Line":20}},{"line":326,"address":[6043115],"length":1,"stats":{"Line":20}},{"line":332,"address":[5430576],"length":1,"stats":{"Line":25}},{"line":333,"address":[2242513],"length":1,"stats":{"Line":26}},{"line":339,"address":[2898352],"length":1,"stats":{"Line":25}},{"line":340,"address":[2898379],"length":1,"stats":{"Line":25}},{"line":355,"address":[5842976],"length":1,"stats":{"Line":10}},{"line":356,"address":[4962909],"length":1,"stats":{"Line":9}},{"line":357,"address":[5843024],"length":1,"stats":{"Line":10}},{"line":370,"address":[6042512],"length":1,"stats":{"Line":10}},{"line":372,"address":[4810588],"length":1,"stats":{"Line":10}},{"line":373,"address":[4810615],"length":1,"stats":{"Line":1}},{"line":375,"address":[4200698],"length":1,"stats":{"Line":10}},{"line":376,"address":[4963139,4963212],"length":1,"stats":{"Line":8}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[2898226,2898118,2898208,2898085],"length":1,"stats":{"Line":31}},{"line":402,"address":[4180816],"length":1,"stats":{"Line":8}},{"line":403,"address":[5406409],"length":1,"stats":{"Line":9}},{"line":406,"address":[4181019,4180947,4180992],"length":1,"stats":{"Line":25}},{"line":412,"address":[7160816],"length":1,"stats":{"Line":9}},{"line":413,"address":[2242465],"length":1,"stats":{"Line":10}},{"line":419,"address":[],"length":0,"stats":{"Line":9}},{"line":420,"address":[4963371],"length":1,"stats":{"Line":10}},{"line":426,"address":[5406224],"length":1,"stats":{"Line":18}},{"line":427,"address":[12385437,12385373,12385469,12385501,12385405],"length":1,"stats":{"Line":17}},{"line":434,"address":[7132400,7132528],"length":1,"stats":{"Line":12}},{"line":435,"address":[2877782],"length":1,"stats":{"Line":12}},{"line":436,"address":[4791791],"length":1,"stats":{"Line":12}},{"line":437,"address":[4791811],"length":1,"stats":{"Line":12}},{"line":438,"address":[2229707],"length":1,"stats":{"Line":12}},{"line":444,"address":[4200512],"length":1,"stats":{"Line":29}},{"line":445,"address":[1493745],"length":1,"stats":{"Line":25}},{"line":454,"address":[7164384],"length":1,"stats":{"Line":9}},{"line":456,"address":[5842750],"length":1,"stats":{"Line":10}},{"line":457,"address":[],"length":0,"stats":{"Line":5}},{"line":460,"address":[],"length":0,"stats":{"Line":10}},{"line":461,"address":[7164483],"length":1,"stats":{"Line":11}},{"line":463,"address":[2897704],"length":1,"stats":{"Line":9}},{"line":464,"address":[7164557],"length":1,"stats":{"Line":1}},{"line":466,"address":[6042274],"length":1,"stats":{"Line":9}},{"line":467,"address":[6042302],"length":1,"stats":{"Line":9}},{"line":468,"address":[5433198],"length":1,"stats":{"Line":9}},{"line":472,"address":[6015584],"length":1,"stats":{"Line":10}},{"line":473,"address":[4181121],"length":1,"stats":{"Line":11}},{"line":474,"address":[5816309,5816374],"length":1,"stats":{"Line":20}},{"line":475,"address":[4792257],"length":1,"stats":{"Line":10}},{"line":476,"address":[4181186],"length":1,"stats":{"Line":9}},{"line":478,"address":[6015688],"length":1,"stats":{"Line":10}},{"line":486,"address":[6036800,6038756,6038850],"length":1,"stats":{"Line":17}},{"line":494,"address":[2240602,2240450],"length":1,"stats":{"Line":32}},{"line":496,"address":[4196529],"length":1,"stats":{"Line":15}},{"line":497,"address":[4196737,4196679],"length":1,"stats":{"Line":33}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[4806615],"length":1,"stats":{"Line":15}},{"line":501,"address":[5837920,5839388],"length":1,"stats":{"Line":16}},{"line":502,"address":[],"length":0,"stats":{"Line":32}},{"line":503,"address":[5428608,5428498,5428727],"length":1,"stats":{"Line":48}},{"line":504,"address":[4197722,4198169,4197258],"length":1,"stats":{"Line":47}},{"line":505,"address":[5429307],"length":1,"stats":{"Line":17}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":17}},{"line":508,"address":[4807687,4808078],"length":1,"stats":{"Line":15}},{"line":509,"address":[4808028],"length":1,"stats":{"Line":17}},{"line":513,"address":[7159867,7159761,7157697,7157803],"length":1,"stats":{"Line":34}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[5428885],"length":1,"stats":{"Line":15}},{"line":517,"address":[4197380],"length":1,"stats":{"Line":17}},{"line":518,"address":[1497836],"length":1,"stats":{"Line":15}},{"line":521,"address":[5838768],"length":1,"stats":{"Line":14}},{"line":532,"address":[4946912,4947408,4947387,4947853,4947883,4947357],"length":1,"stats":{"Line":23}},{"line":539,"address":[5410687,5411183,5410413,5410909],"length":1,"stats":{"Line":48}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[5820077,5820573],"length":1,"stats":{"Line":23}},{"line":542,"address":[5820180,5820615,5820119,5820976,5820676,5820986,5821008,5821018],"length":1,"stats":{"Line":94}},{"line":543,"address":[4794444,4794940],"length":1,"stats":{"Line":23}},{"line":544,"address":[4794867,4794371],"length":1,"stats":{"Line":24}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[4180480],"length":1,"stats":{"Line":18}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[2898448],"length":1,"stats":{"Line":16}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":3}},{"line":584,"address":[],"length":0,"stats":{"Line":3}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[5433360,5433376],"length":1,"stats":{"Line":24}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[7162633,7162144,7162640,7163086,7163115,7162604],"length":1,"stats":{"Line":2}},{"line":646,"address":[],"length":0,"stats":{"Line":2}},{"line":647,"address":[],"length":0,"stats":{"Line":6}},{"line":648,"address":[7162380,7162862],"length":1,"stats":{"Line":1}},{"line":650,"address":[7163001,7162519],"length":1,"stats":{"Line":2}},{"line":651,"address":[7162580,7163062],"length":1,"stats":{"Line":2}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[5432384,5433000,5431792,5433008,5432376,5432416],"length":1,"stats":{"Line":23}},{"line":690,"address":[6040942,6041566],"length":1,"stats":{"Line":25}},{"line":692,"address":[4962131,4962622],"length":1,"stats":{"Line":26}},{"line":693,"address":[1500541],"length":1,"stats":{"Line":26}},{"line":698,"address":[2887114,2883024],"length":1,"stats":{"Line":24}},{"line":702,"address":[5827069,5821178,5821405,5826842],"length":1,"stats":{"Line":54}},{"line":703,"address":[1487819,1492328],"length":1,"stats":{"Line":26}},{"line":706,"address":[],"length":0,"stats":{"Line":26}},{"line":707,"address":[2232943],"length":1,"stats":{"Line":26}},{"line":708,"address":[1487120],"length":1,"stats":{"Line":28}},{"line":709,"address":[12398877,12393213,12404541,12387549,12410205],"length":1,"stats":{"Line":27}},{"line":710,"address":[2233101],"length":1,"stats":{"Line":31}},{"line":712,"address":[4952931,4948685],"length":1,"stats":{"Line":30}},{"line":715,"address":[4796485],"length":1,"stats":{"Line":27}},{"line":716,"address":[2233737],"length":1,"stats":{"Line":30}},{"line":718,"address":[4949464,4953741,4953728],"length":1,"stats":{"Line":75}},{"line":719,"address":[5412912,5418576],"length":1,"stats":{"Line":26}},{"line":721,"address":[2888688,2884576,2888719],"length":1,"stats":{"Line":76}},{"line":723,"address":[2234206,2234102],"length":1,"stats":{"Line":51}},{"line":726,"address":[2234272],"length":1,"stats":{"Line":22}},{"line":727,"address":[6028072,6022408],"length":1,"stats":{"Line":27}},{"line":728,"address":[],"length":0,"stats":{"Line":26}},{"line":729,"address":[4950577,4950273,4950328],"length":1,"stats":{"Line":66}},{"line":730,"address":[4950334,4950484],"length":1,"stats":{"Line":14}},{"line":732,"address":[4797709,4797840],"length":1,"stats":{"Line":54}},{"line":733,"address":[12412216,12395224,12406552,12400888,12389560],"length":1,"stats":{"Line":27}},{"line":734,"address":[5922993],"length":1,"stats":{"Line":25}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[1489638,1489706],"length":1,"stats":{"Line":52}},{"line":741,"address":[4188801],"length":1,"stats":{"Line":27}},{"line":744,"address":[1490048,1491111,1489883],"length":1,"stats":{"Line":52}},{"line":745,"address":[1490939,1491595],"length":1,"stats":{"Line":2}},{"line":746,"address":[7144723,7150371],"length":1,"stats":{"Line":1}},{"line":748,"address":[5421493,5415829],"length":1,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[2887309],"length":1,"stats":{"Line":0}},{"line":756,"address":[2886581],"length":1,"stats":{"Line":25}},{"line":758,"address":[6024246,6029910],"length":1,"stats":{"Line":26}},{"line":785,"address":[4182674,4181216,4182680],"length":1,"stats":{"Line":11}},{"line":794,"address":[5816462],"length":1,"stats":{"Line":11}},{"line":797,"address":[4181303],"length":1,"stats":{"Line":11}},{"line":798,"address":[6015880],"length":1,"stats":{"Line":0}},{"line":799,"address":[4181366],"length":1,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[4792406],"length":1,"stats":{"Line":11}},{"line":806,"address":[5407341,5407393,5407520,5407594],"length":1,"stats":{"Line":31}},{"line":807,"address":[2878981],"length":1,"stats":{"Line":11}},{"line":808,"address":[6015923,6017204,6016205,6015829],"length":1,"stats":{"Line":11}},{"line":810,"address":[5816881],"length":1,"stats":{"Line":11}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[5817184,5817099],"length":1,"stats":{"Line":9}},{"line":820,"address":[4182154,4182238],"length":1,"stats":{"Line":19}},{"line":821,"address":[5408048],"length":1,"stats":{"Line":9}},{"line":824,"address":[5817676],"length":1,"stats":{"Line":9}},{"line":825,"address":[5817730],"length":1,"stats":{"Line":10}},{"line":826,"address":[4793646],"length":1,"stats":{"Line":9}},{"line":852,"address":[5832656,5833930,5833924],"length":1,"stats":{"Line":9}},{"line":860,"address":[4953906],"length":1,"stats":{"Line":10}},{"line":862,"address":[6032147],"length":1,"stats":{"Line":9}},{"line":863,"address":[2889139],"length":1,"stats":{"Line":0}},{"line":864,"address":[2889115],"length":1,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[4801617],"length":1,"stats":{"Line":10}},{"line":872,"address":[4801631,4801854],"length":1,"stats":{"Line":19}},{"line":874,"address":[7152553,7153816],"length":1,"stats":{"Line":9}},{"line":875,"address":[5423576,5423694],"length":1,"stats":{"Line":19}},{"line":876,"address":[4954508],"length":1,"stats":{"Line":10}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[7154530,7152794,7153279,7154073],"length":1,"stats":{"Line":19}},{"line":880,"address":[4192503,4192535],"length":1,"stats":{"Line":21}},{"line":882,"address":[],"length":0,"stats":{"Line":11}},{"line":885,"address":[5833860],"length":1,"stats":{"Line":10}},{"line":886,"address":[7153250,7154501],"length":1,"stats":{"Line":9}},{"line":890,"address":[],"length":0,"stats":{"Line":9}},{"line":891,"address":[4192080],"length":1,"stats":{"Line":10}},{"line":913,"address":[1494448,1495224,1495230],"length":1,"stats":{"Line":14}},{"line":921,"address":[5425624],"length":1,"stats":{"Line":14}},{"line":922,"address":[2891583],"length":1,"stats":{"Line":1}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[4956439],"length":1,"stats":{"Line":14}},{"line":930,"address":[4804077],"length":1,"stats":{"Line":14}},{"line":932,"address":[4194185,4194329],"length":1,"stats":{"Line":28}},{"line":934,"address":[4804367],"length":1,"stats":{"Line":14}},{"line":935,"address":[6035135,6035026],"length":1,"stats":{"Line":30}},{"line":936,"address":[2891885],"length":1,"stats":{"Line":17}},{"line":940,"address":[6035238],"length":1,"stats":{"Line":14}},{"line":941,"address":[6035293],"length":1,"stats":{"Line":15}},{"line":942,"address":[4194760],"length":1,"stats":{"Line":15}},{"line":945,"address":[2891786],"length":1,"stats":{"Line":14}},{"line":946,"address":[2239988],"length":1,"stats":{"Line":14}},{"line":967,"address":[7154560,7155763,7155769],"length":1,"stats":{"Line":15}},{"line":975,"address":[],"length":0,"stats":{"Line":11}},{"line":978,"address":[6033410],"length":1,"stats":{"Line":13}},{"line":979,"address":[],"length":0,"stats":{"Line":26}},{"line":980,"address":[5424724],"length":1,"stats":{"Line":14}},{"line":981,"address":[4194015,4192865,4193398],"length":1,"stats":{"Line":12}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[7155183,7155089],"length":1,"stats":{"Line":13}},{"line":992,"address":[5834715,5834794],"length":1,"stats":{"Line":25}},{"line":993,"address":[2891164],"length":1,"stats":{"Line":11}},{"line":995,"address":[7155648],"length":1,"stats":{"Line":10}},{"line":996,"address":[1494308],"length":1,"stats":{"Line":13}},{"line":1018,"address":[4804736],"length":1,"stats":{"Line":9}},{"line":1023,"address":[1495304],"length":1,"stats":{"Line":8}},{"line":1029,"address":[4957356,4957589],"length":1,"stats":{"Line":8}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[1495347],"length":1,"stats":{"Line":8}},{"line":1035,"address":[2892215],"length":1,"stats":{"Line":10}},{"line":1036,"address":[5836090],"length":1,"stats":{"Line":10}},{"line":1037,"address":[],"length":0,"stats":{"Line":8}},{"line":1038,"address":[4804832],"length":1,"stats":{"Line":10}},{"line":1040,"address":[6035564],"length":1,"stats":{"Line":10}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[1496568],"length":1,"stats":{"Line":11}},{"line":1046,"address":[],"length":0,"stats":{"Line":10}},{"line":1047,"address":[4957923],"length":1,"stats":{"Line":7}},{"line":1048,"address":[],"length":0,"stats":{"Line":11}},{"line":1049,"address":[2893253],"length":1,"stats":{"Line":7}},{"line":1052,"address":[1496596],"length":1,"stats":{"Line":7}},{"line":1053,"address":[],"length":0,"stats":{"Line":11}},{"line":1075,"address":[6038880],"length":1,"stats":{"Line":1}},{"line":1080,"address":[2895671],"length":1,"stats":{"Line":1}},{"line":1086,"address":[2895759,2895916],"length":1,"stats":{"Line":1}},{"line":1087,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[6038957],"length":1,"stats":{"Line":1}},{"line":1090,"address":[1498852],"length":1,"stats":{"Line":1}},{"line":1094,"address":[6039392,6039416,6039306],"length":1,"stats":{"Line":3}},{"line":1095,"address":[],"length":0,"stats":{"Line":0}},{"line":1097,"address":[1499185],"length":1,"stats":{"Line":1}},{"line":1098,"address":[4198778],"length":1,"stats":{"Line":1}},{"line":1112,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[5455812,5455806,5453872],"length":1,"stats":{"Line":11}},{"line":1128,"address":[5954599,5954426],"length":1,"stats":{"Line":22}},{"line":1129,"address":[5954489],"length":1,"stats":{"Line":0}},{"line":1130,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[6045429],"length":1,"stats":{"Line":0}},{"line":1132,"address":[],"length":0,"stats":{"Line":0}},{"line":1136,"address":[6045618],"length":1,"stats":{"Line":11}},{"line":1137,"address":[2249270],"length":1,"stats":{"Line":0}},{"line":1138,"address":[],"length":0,"stats":{"Line":0}},{"line":1139,"address":[5850640],"length":1,"stats":{"Line":0}},{"line":1140,"address":[],"length":0,"stats":{"Line":0}},{"line":1144,"address":[4821969,4820121,4820498,4821975,4821712],"length":1,"stats":{"Line":22}},{"line":1145,"address":[2250920,2250718,2250747],"length":1,"stats":{"Line":21}},{"line":1146,"address":[5956483],"length":1,"stats":{"Line":0}},{"line":1147,"address":[],"length":0,"stats":{"Line":0}},{"line":1148,"address":[7205725],"length":1,"stats":{"Line":0}},{"line":1149,"address":[4204744],"length":1,"stats":{"Line":0}},{"line":1152,"address":[1508286],"length":1,"stats":{"Line":11}},{"line":1156,"address":[1507014],"length":1,"stats":{"Line":12}},{"line":1157,"address":[4203706],"length":1,"stats":{"Line":10}},{"line":1159,"address":[5851280,5851370],"length":1,"stats":{"Line":22}},{"line":1161,"address":[5955625],"length":1,"stats":{"Line":12}},{"line":1162,"address":[5851516,5851627],"length":1,"stats":{"Line":21}},{"line":1163,"address":[5851637],"length":1,"stats":{"Line":12}},{"line":1165,"address":[6046832],"length":1,"stats":{"Line":11}},{"line":1168,"address":[2902313],"length":1,"stats":{"Line":11}},{"line":1171,"address":[5456112],"length":1,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1175,"address":[2900960],"length":1,"stats":{"Line":0}},{"line":1176,"address":[],"length":0,"stats":{"Line":0}},{"line":1179,"address":[4202624],"length":1,"stats":{"Line":13}},{"line":1180,"address":[1506169],"length":1,"stats":{"Line":13}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1207,"address":[6047616],"length":1,"stats":{"Line":9}},{"line":1213,"address":[4972174,4972026],"length":1,"stats":{"Line":18}},{"line":1214,"address":[2903631],"length":1,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[5853057],"length":1,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1221,"address":[4205253],"length":1,"stats":{"Line":9}},{"line":1223,"address":[4972226],"length":1,"stats":{"Line":9}},{"line":1224,"address":[4823560],"length":1,"stats":{"Line":0}},{"line":1225,"address":[],"length":0,"stats":{"Line":0}},{"line":1226,"address":[7206506,7209345,7207476,7208209,7207728,7209093],"length":1,"stats":{"Line":0}},{"line":1227,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[7206567,7209662,7209982,7209656,7206404,7209976,7208270,7209728,7208107,7209408],"length":1,"stats":{"Line":18}},{"line":1231,"address":[5459203,5459035,5459006],"length":1,"stats":{"Line":18}},{"line":1232,"address":[7209578,7209898],"length":1,"stats":{"Line":0}},{"line":1233,"address":[],"length":0,"stats":{"Line":0}},{"line":1234,"address":[4823757],"length":1,"stats":{"Line":0}},{"line":1235,"address":[5854739],"length":1,"stats":{"Line":0}},{"line":1238,"address":[6049374],"length":1,"stats":{"Line":9}},{"line":1242,"address":[5853524],"length":1,"stats":{"Line":9}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1247,"address":[5853830],"length":1,"stats":{"Line":9}},{"line":1248,"address":[4206992,4206968,4205870,4207021,4206944],"length":1,"stats":{"Line":45}},{"line":1249,"address":[4205896],"length":1,"stats":{"Line":9}},{"line":1251,"address":[7208659,7208778,7206999,7207118],"length":1,"stats":{"Line":18}},{"line":1252,"address":[],"length":0,"stats":{"Line":9}},{"line":1254,"address":[4973254],"length":1,"stats":{"Line":9}},{"line":1257,"address":[2905616],"length":1,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1265,"address":[6047568],"length":1,"stats":{"Line":10}},{"line":1266,"address":[4204933],"length":1,"stats":{"Line":9}}],"covered":292,"coverable":412},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","compiler","expression_lowerer.rs"],"content":"use alloc::boxed::Box;\nuse alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::hash::Hash;\n\nuse hashbrown::{HashMap, HashSet};\nuse p3_field::{Field, PrimeCharacteristicRing};\n\nuse crate::builder::CircuitBuilderError;\nuse crate::builder::circuit_builder::{NonPrimitiveOpParams, NonPrimitiveOperationData};\nuse crate::builder::compiler::get_witness_id;\nuse crate::expr::{Expr, ExpressionGraph};\nuse crate::op::{NonPrimitiveOpType, Op};\nuse crate::ops::Poseidon2PermExecutor;\nuse crate::types::{ExprId, NonPrimitiveOpId, WitnessAllocator, WitnessId};\n\n/// Sparse disjoint-set \"find\" with path compression over a HashMap (iterative).\n/// If `x` is not present, it's its own representative and is not inserted.\n#[inline]\nfn dsu_find(parents: \u0026mut HashMap\u003cusize, usize\u003e, x: usize) -\u003e usize {\n    let mut v = x;\n    let mut trail: Vec\u003cusize\u003e = Vec::new();\n    while let Some(\u0026p) = parents.get(\u0026v) {\n        if p == v {\n            break;\n        }\n        trail.push(v);\n        v = p;\n    }\n    let root = v;\n    for u in trail {\n        parents.insert(u, root);\n    }\n    root\n}\n\n/// Sparse disjoint-set \"union\" by attaching `b`'s root under `a`'s root.\n#[inline]\nfn dsu_union(parents: \u0026mut HashMap\u003cusize, usize\u003e, a: usize, b: usize) {\n    let ra = dsu_find(parents, a);\n    let rb = dsu_find(parents, b);\n    if ra != rb {\n        parents.insert(rb, ra);\n    }\n}\n\n/// Build a sparse disjoint-set forest honoring all pending connects.\n/// Returns a parent map keyed only by ExprIds that appear in `connects`.\nfn build_connect_dsu(connects: \u0026[(ExprId, ExprId)]) -\u003e HashMap\u003cusize, usize\u003e {\n    let mut parents: HashMap\u003cusize, usize\u003e = HashMap::new();\n    for (a, b) in connects {\n        let ai = a.0 as usize;\n        let bi = b.0 as usize;\n        dsu_union(\u0026mut parents, ai, bi);\n    }\n    parents\n}\n\n/// Responsible for lowering expression graphs to primitive operations.\n///\n/// This component handles:\n/// - Converting high-level expressions to primitive operations (Const, Public, Add, Mul, etc.)\n/// - Managing witness allocation during lowering\n/// - Implementing the DSU-based connection strategy for witness sharing\n/// - Building the mapping from ExprId to WitnessId\n#[derive(Debug)]\npub struct ExpressionLowerer\u003c'a, F: Field\u003e {\n    /// Reference to the expression graph to lower\n    graph: \u0026'a ExpressionGraph\u003cF\u003e,\n\n    /// Non-primitive operations to lower (referenced by `Expr::NonPrimitiveOutput`)\n    non_primitive_ops: \u0026'a [NonPrimitiveOperationData\u003cF\u003e],\n\n    /// Pending connections between expressions\n    pending_connects: \u0026'a [(ExprId, ExprId)],\n\n    /// Number of public inputs\n    public_input_count: usize,\n\n    /// Witness allocator\n    witness_alloc: WitnessAllocator,\n}\n\nimpl\u003c'a, F\u003e ExpressionLowerer\u003c'a, F\u003e\nwhere\n    F: Field + Clone + PrimeCharacteristicRing + PartialEq + Eq + Hash,\n{\n    /// Creates a new expression lowerer.\n    pub const fn new(\n        graph: \u0026'a ExpressionGraph\u003cF\u003e,\n        non_primitive_ops: \u0026'a [NonPrimitiveOperationData\u003cF\u003e],\n        pending_connects: \u0026'a [(ExprId, ExprId)],\n        public_input_count: usize,\n        witness_alloc: WitnessAllocator,\n    ) -\u003e Self {\n        Self {\n            graph,\n            non_primitive_ops,\n            pending_connects,\n            public_input_count,\n            witness_alloc,\n        }\n    }\n\n    fn emit_non_primitive_op\u003cAllocFn\u003e(\n        data: \u0026NonPrimitiveOperationData\u003cF\u003e,\n        output_exprs: \u0026[(u32, ExprId)],\n        expr_to_widx: \u0026mut HashMap\u003cExprId, WitnessId\u003e,\n        alloc_witness_id_for_expr: \u0026mut AllocFn,\n        ops: \u0026mut Vec\u003cOp\u003cF\u003e\u003e,\n    ) -\u003e Result\u003c(), CircuitBuilderError\u003e\n    where\n        AllocFn: FnMut(usize) -\u003e WitnessId,\n    {\n        for (_output_idx, expr_id) in output_exprs {\n            expr_to_widx\n                .entry(*expr_id)\n                .or_insert_with(|| alloc_witness_id_for_expr(expr_id.0 as usize));\n        }\n\n        match \u0026data.op_type {\n            NonPrimitiveOpType::Poseidon2Perm(config) =\u003e {\n                let (new_start, merkle_path) = match data.params.as_ref().ok_or(\n                    CircuitBuilderError::InvalidNonPrimitiveOpConfiguration { op: data.op_type },\n                )? {\n                    NonPrimitiveOpParams::Poseidon2Perm {\n                        new_start,\n                        merkle_path,\n                    } =\u003e (*new_start, *merkle_path),\n                    _ =\u003e {\n                        return Err(CircuitBuilderError::InvalidNonPrimitiveOpConfiguration {\n                            op: NonPrimitiveOpType::Poseidon2Perm(*config),\n                        });\n                    }\n                };\n\n                // Detect D=1 (base field) vs D=4 (extension field) based on input count\n                // D=4 mode: 6 inputs [in0..3, mmcs_index_sum, mmcs_bit], 2 or 4 outputs\n                // D=1 mode: 16 inputs [in0..15], 8 or 16 outputs (no merkle support)\n                let is_d1_mode = data.input_exprs.len() == 16;\n                let is_d4_mode = data.input_exprs.len() == 6;\n\n                if !is_d1_mode \u0026\u0026 !is_d4_mode {\n                    return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                        op: \"Poseidon2Perm\",\n                        expected: \"6 inputs (D=4 mode) or 16 inputs (D=1 mode)\".to_string(),\n                        got: data.input_exprs.len(),\n                    });\n                }\n\n                // Validate output count based on mode\n                let valid_output_count = if is_d1_mode {\n                    // D=1: 8 (rate only) or 16 (with capacity)\n                    data.output_exprs.len() == 8 || data.output_exprs.len() == 16\n                } else {\n                    // D=4: 2 (rate only) or 4 (with capacity)\n                    data.output_exprs.len() == 2 || data.output_exprs.len() == 4\n                };\n\n                if !valid_output_count {\n                    return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                        op: \"Poseidon2Perm\",\n                        expected: if is_d1_mode {\n                            \"8 or 16 outputs for D=1 mode\".to_string()\n                        } else {\n                            \"2 or 4 outputs for D=4 mode\".to_string()\n                        },\n                        got: data.output_exprs.len(),\n                    });\n                }\n\n                let mut inputs_widx: Vec\u003cVec\u003cWitnessId\u003e\u003e =\n                    Vec::with_capacity(data.input_exprs.len());\n\n                if is_d1_mode {\n                    // D=1 mode: 16 input elements (no mmcs_index_sum, no mmcs_bit)\n                    for (i, limb_exprs) in data.input_exprs.iter().enumerate() {\n                        if !(limb_exprs.is_empty() || limb_exprs.len() == 1) {\n                            return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                                op: \"Poseidon2Perm\",\n                                expected: \"0 or 1 base field element per input\".to_string(),\n                                got: limb_exprs.len(),\n                            });\n                        }\n                        let limb_widx = limb_exprs\n                            .iter()\n                            .map(|\u0026expr| {\n                                get_witness_id(\n                                    expr_to_widx,\n                                    expr,\n                                    \u0026format!(\"Poseidon2Perm D=1 input {i}\"),\n                                )\n                            })\n                            .collect::\u003cResult\u003cVec\u003cWitnessId\u003e, _\u003e\u003e()?;\n                        inputs_widx.push(limb_widx);\n                    }\n                } else {\n                    // D=4 mode: Inputs (Limbs 0-3)\n                    for (i, limb_exprs) in data.input_exprs.iter().take(4).enumerate() {\n                        if !(limb_exprs.is_empty() || limb_exprs.len() == 1) {\n                            return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                                op: \"Poseidon2Perm\",\n                                expected: \"0 or 1 extension element per input limb\".to_string(),\n                                got: limb_exprs.len(),\n                            });\n                        }\n                        let limb_widx = limb_exprs\n                            .iter()\n                            .map(|\u0026expr| {\n                                get_witness_id(\n                                    expr_to_widx,\n                                    expr,\n                                    \u0026format!(\"Poseidon2Perm input limb {i}\"),\n                                )\n                            })\n                            .collect::\u003cResult\u003cVec\u003cWitnessId\u003e, _\u003e\u003e()?;\n                        inputs_widx.push(limb_widx);\n                    }\n\n                    // mmcs_index_sum (0 or 1 element)\n                    let mmcs_exprs = \u0026data.input_exprs[4];\n                    if !(mmcs_exprs.is_empty() || mmcs_exprs.len() == 1) {\n                        return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                            op: \"Poseidon2Perm\",\n                            expected: \"0 or 1 element for mmcs_index_sum\".to_string(),\n                            got: mmcs_exprs.len(),\n                        });\n                    }\n                    let mmcs_widx = mmcs_exprs\n                        .iter()\n                        .map(|\u0026expr| {\n                            get_witness_id(expr_to_widx, expr, \"Poseidon2Perm mmcs_index_sum input\")\n                        })\n                        .collect::\u003cResult\u003cVec\u003cWitnessId\u003e, _\u003e\u003e()?;\n                    inputs_widx.push(mmcs_widx);\n\n                    // mmcs_bit (0 or 1 element)\n                    let mmcs_bit_exprs = \u0026data.input_exprs[5];\n                    if !(mmcs_bit_exprs.is_empty() || mmcs_bit_exprs.len() == 1) {\n                        return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                            op: \"Poseidon2Perm\",\n                            expected: \"0 or 1 element for mmcs_bit\".to_string(),\n                            got: mmcs_bit_exprs.len(),\n                        });\n                    }\n                    let mmcs_bit_widx = mmcs_bit_exprs\n                        .iter()\n                        .map(|\u0026expr| {\n                            get_witness_id(expr_to_widx, expr, \"Poseidon2Perm mmcs_bit input\")\n                        })\n                        .collect::\u003cResult\u003cVec\u003cWitnessId\u003e, _\u003e\u003e()?;\n                    inputs_widx.push(mmcs_bit_widx);\n                }\n\n                // Output CTL exposures (0 or 1 element each).\n                //\n                // For Poseidon2Perm we take outputs exclusively from `data.output_exprs` to avoid\n                // generating multiple witness ids per output limb (which breaks both execution and\n                // trace building).\n                let mut poseidon2_outputs: Vec\u003cVec\u003cWitnessId\u003e\u003e =\n                    Vec::with_capacity(data.output_exprs.len());\n                for (i, limb_exprs) in data.output_exprs.iter().enumerate() {\n                    if !(limb_exprs.is_empty() || limb_exprs.len() == 1) {\n                        return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                            op: \"Poseidon2Perm\",\n                            expected: \"0 or 1 element per output\".to_string(),\n                            got: limb_exprs.len(),\n                        });\n                    }\n                    if let Some(\u0026expr) = limb_exprs.first() {\n                        let w = get_witness_id(\n                            expr_to_widx,\n                            expr,\n                            \u0026format!(\"Poseidon2Perm output {i}\"),\n                        )?;\n                        poseidon2_outputs.push(vec![w]);\n                    } else {\n                        poseidon2_outputs.push(Vec::new());\n                    }\n                }\n\n                ops.push(Op::NonPrimitiveOpWithExecutor {\n                    inputs: inputs_widx,\n                    outputs: poseidon2_outputs,\n                    executor: Box::new(Poseidon2PermExecutor::new(\n                        data.op_type,\n                        new_start,\n                        merkle_path,\n                    )),\n                    op_id: data.op_id,\n                });\n            }\n            NonPrimitiveOpType::Unconstrained =\u003e {\n                let executor = match data.params.as_ref().ok_or(\n                    CircuitBuilderError::InvalidNonPrimitiveOpConfiguration { op: data.op_type },\n                )? {\n                    NonPrimitiveOpParams::Unconstrained { executor } =\u003e executor.clone(),\n                    _ =\u003e {\n                        return Err(CircuitBuilderError::InvalidNonPrimitiveOpConfiguration {\n                            op: NonPrimitiveOpType::Unconstrained,\n                        });\n                    }\n                };\n\n                // Expected layout: [in]\n                if data.input_exprs.len() != 1 {\n                    return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                        op: \"Unconstrained\",\n                        expected: \"1 [in]\".to_string(),\n                        got: data.input_exprs.len(),\n                    });\n                }\n\n                let inputs = vec![\n                    data.input_exprs[0]\n                        .iter()\n                        .map(|\u0026expr| {\n                            get_witness_id(expr_to_widx, expr, \"Unconstrained operation input\")\n                        })\n                        .collect::\u003cResult\u003c_, _\u003e\u003e()?,\n                ];\n                let mut outputs: Vec\u003cVec\u003cWitnessId\u003e\u003e = Vec::with_capacity(output_exprs.len());\n                for (_output_idx, expr_idx) in output_exprs {\n                    let widx = *expr_to_widx\n                        .entry(*expr_idx)\n                        .or_insert_with(|| alloc_witness_id_for_expr(expr_idx.0 as usize));\n                    outputs.push(vec![widx]);\n                }\n                ops.push(Op::NonPrimitiveOpWithExecutor {\n                    inputs,\n                    outputs,\n                    executor,\n                    op_id: data.op_id,\n                });\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Lowers the expression graph to operations.\n    ///\n    /// Returns:\n    /// - Vector of operations\n    /// - Vector mapping public input positions to witness IDs\n    /// - HashMap mapping expression IDs to witness IDs\n    /// - HashMap mapping public input expression IDs to witness IDs\n    /// - Total witness count\n    #[allow(clippy::type_complexity)]\n    pub fn lower(\n        mut self,\n    ) -\u003e Result\u003c\n        (\n            Vec\u003cOp\u003cF\u003e\u003e,\n            Vec\u003cWitnessId\u003e,\n            HashMap\u003cExprId, WitnessId\u003e,\n            HashMap\u003cExprId, WitnessId\u003e,\n            u32,\n        ),\n        CircuitBuilderError,\n    \u003e {\n        // Precompute mapping from op_id -\u003e output expression nodes, to allow emitting an op once\n        // while still producing witness ids for all of its outputs.\n        let mut op_id_to_output_exprs: HashMap\u003cu32, Vec\u003c(u32, ExprId)\u003e\u003e = HashMap::new();\n        for (expr_idx, expr) in self.graph.nodes().iter().enumerate() {\n            if let Expr::NonPrimitiveOutput { call, output_idx } = expr {\n                // Look up the call expression to get the op_id\n                let Expr::NonPrimitiveCall { op_id, .. } = self.graph.get_expr(*call) else {\n                    return Err(CircuitBuilderError::MissingExprMapping {\n                        expr_id: *call,\n                        context: \"NonPrimitiveOutput.call must reference a NonPrimitiveCall\"\n                            .to_string(),\n                    });\n                };\n                op_id_to_output_exprs\n                    .entry(op_id.0)\n                    .or_default()\n                    .push((*output_idx, ExprId(expr_idx as u32)));\n            }\n        }\n        for outputs in op_id_to_output_exprs.values_mut() {\n            outputs.sort_by_key(|(output_idx, _)| *output_idx);\n        }\n        for (\u0026op_id_u32, outputs) in \u0026op_id_to_output_exprs {\n            // Enforce a simple invariant: output indices are a contiguous 0..N-1 range with no\n            // duplicates. This avoids silent mis-wiring due to gaps or repeated indices.\n            for (pos, (output_idx, _)) in outputs.iter().enumerate() {\n                if pos \u003e 0 \u0026\u0026 outputs[pos - 1].0 == *output_idx {\n                    return Err(CircuitBuilderError::MalformedNonPrimitiveOutputs {\n                        op_id: NonPrimitiveOpId(op_id_u32),\n                        details: format!(\"duplicate output_idx {output_idx}\"),\n                    });\n                }\n                if *output_idx != pos as u32 {\n                    return Err(CircuitBuilderError::MalformedNonPrimitiveOutputs {\n                        op_id: NonPrimitiveOpId(op_id_u32),\n                        details: format!(\n                            \"expected output_idx {expected}, got {output_idx}\",\n                            expected = pos as u32\n                        ),\n                    });\n                }\n            }\n        }\n\n        // Build DSU over expression IDs to honor connect(a, b)\n        let mut parents = build_connect_dsu(self.pending_connects);\n\n        // Track nodes that participate in any connect\n        let in_connect: HashSet\u003cusize\u003e = self\n            .pending_connects\n            .iter()\n            .flat_map(|(a, b)| [a.0 as usize, b.0 as usize])\n            .collect();\n\n        let mut ops = Vec::new();\n        let mut expr_to_widx: HashMap\u003cExprId, WitnessId\u003e = HashMap::new();\n        let mut public_rows: Vec\u003cWitnessId\u003e = vec![WitnessId(0); self.public_input_count];\n        let mut public_mappings = HashMap::new();\n\n        // Unified class slot map: DSU root -\u003e chosen out slot\n        let mut root_to_widx: HashMap\u003cusize, WitnessId\u003e = HashMap::new();\n\n        // Pass A: emit constants (once per Const node; Expr-level dedup ensures one per value)\n        for (expr_idx, expr) in self.graph.nodes().iter().enumerate() {\n            if let Expr::Const(val) = expr {\n                let id = ExprId(expr_idx as u32);\n                let w = self.witness_alloc.alloc();\n                ops.push(Op::Const { out: w, val: *val });\n                expr_to_widx.insert(id, w);\n\n                // If this Const participates in a connect class, bind the class to the const slot\n                if in_connect.contains(\u0026expr_idx) {\n                    let root = dsu_find(\u0026mut parents, expr_idx);\n                    root_to_widx.insert(root, w);\n                }\n            }\n        }\n\n        let mut alloc_witness_id_for_expr = |expr_idx: usize| {\n            if in_connect.contains(\u0026expr_idx) {\n                let root = dsu_find(\u0026mut parents, expr_idx);\n                *root_to_widx\n                    .entry(root)\n                    .or_insert_with(|| self.witness_alloc.alloc())\n            } else {\n                self.witness_alloc.alloc()\n            }\n        };\n\n        // Pass B: emit public inputs\n        for (expr_idx, expr) in self.graph.nodes().iter().enumerate() {\n            if let Expr::Public(pos) = expr {\n                let id = ExprId(expr_idx as u32);\n\n                let out_widx = alloc_witness_id_for_expr(expr_idx);\n\n                ops.push(Op::Public {\n                    out: out_widx,\n                    public_pos: *pos,\n                });\n                expr_to_widx.insert(id, out_widx);\n                public_rows[*pos] = out_widx;\n                public_mappings.insert(id, out_widx);\n            }\n        }\n\n        // Pass C: emit arithmetic and unconstrained ops in creation order; tie outputs to class slot if connected\n        let mut emitted_non_primitive_ops: HashSet\u003cu32\u003e = HashSet::new();\n\n        for (expr_idx, expr) in self.graph.nodes().iter().enumerate() {\n            let expr_id = ExprId(expr_idx as u32);\n            match expr {\n                Expr::Const(_) | Expr::Public(_) =\u003e { /* handled above */ }\n                Expr::Add { lhs, rhs } =\u003e {\n                    let out_widx = alloc_witness_id_for_expr(expr_idx);\n                    let a_widx =\n                        get_witness_id(\u0026expr_to_widx, *lhs, \u0026format!(\"Add lhs for {expr_id:?}\"))?;\n                    let b_widx =\n                        get_witness_id(\u0026expr_to_widx, *rhs, \u0026format!(\"Add rhs for {expr_id:?}\"))?;\n                    ops.push(Op::add(a_widx, b_widx, out_widx));\n                    expr_to_widx.insert(expr_id, out_widx);\n                }\n                Expr::Sub { lhs, rhs } =\u003e {\n                    // Fast path: algebraic rewrite for `a * b - c` where `c` is a constant.\n                    //\n                    // Expression-level: lhs = a * b, rhs = c\n                    // We rewrite:\n                    //     result = lhs - rhs\n                    // into:\n                    //     result = lhs + (-c)\n                    //\n                    // This produces a forward add that the MulAdd optimizer can fuse with the\n                    // preceding Mul, instead of the default backwards-add encoding.\n                    let lhs_expr = self.graph.get_expr(*lhs);\n                    let rhs_expr = self.graph.get_expr(*rhs);\n\n                    // Allocate witness for the subtraction result expression.\n                    let result_widx = alloc_witness_id_for_expr(expr_idx);\n\n                    // Get the witness for the mul result (lhs of the subtraction).\n                    let lhs_widx = get_witness_id(\n                        \u0026expr_to_widx,\n                        *lhs,\n                        \u0026format!(\"Sub lhs (mul result) for {expr_id:?}\"),\n                    )?;\n\n                    if let (Expr::Mul { .. }, Expr::Const(const_val)) = (lhs_expr, rhs_expr) {\n                        // Emit a fresh constant witness for -c.\n                        //\n                        // We allocate a synthetic witness index that is not tied to any\n                        // particular expression node (beyond the current graph size),\n                        // so it does not participate in connect-based aliasing.\n                        let synthetic_idx = self.graph.nodes().len();\n                        let neg_const_widx = alloc_witness_id_for_expr(synthetic_idx);\n                        ops.push(Op::Const {\n                            out: neg_const_widx,\n                            val: -(*const_val),\n                        });\n\n                        // Encode result = lhs + (-c) as a forward add.\n                        ops.push(Op::add(lhs_widx, neg_const_widx, result_widx));\n                    } else {\n                        // Generic encoding: lhs - rhs = result as result + rhs = lhs.\n                        let rhs_widx = get_witness_id(\n                            \u0026expr_to_widx,\n                            *rhs,\n                            \u0026format!(\"Sub rhs for {expr_id:?}\"),\n                        )?;\n                        ops.push(Op::add(rhs_widx, result_widx, lhs_widx));\n                    }\n                    expr_to_widx.insert(expr_id, result_widx);\n                }\n                Expr::Mul { lhs, rhs } =\u003e {\n                    let out_widx = alloc_witness_id_for_expr(expr_idx);\n                    let a_widx =\n                        get_witness_id(\u0026expr_to_widx, *lhs, \u0026format!(\"Mul lhs for {expr_id:?}\"))?;\n                    let b_widx =\n                        get_witness_id(\u0026expr_to_widx, *rhs, \u0026format!(\"Mul rhs for {expr_id:?}\"))?;\n                    ops.push(Op::mul(a_widx, b_widx, out_widx));\n                    expr_to_widx.insert(expr_id, out_widx);\n                }\n                Expr::Div { lhs, rhs } =\u003e {\n                    // lhs / rhs = out  is encoded as rhs * out = lhs\n                    let b_widx = alloc_witness_id_for_expr(expr_idx);\n                    let out_widx =\n                        get_witness_id(\u0026expr_to_widx, *lhs, \u0026format!(\"Div lhs for {expr_id:?}\"))?;\n                    let a_widx =\n                        get_witness_id(\u0026expr_to_widx, *rhs, \u0026format!(\"Div rhs for {expr_id:?}\"))?;\n                    ops.push(Op::mul(a_widx, b_widx, out_widx));\n                    // The output of Div is the b_widx.\n                    expr_to_widx.insert(expr_id, b_widx);\n                }\n                Expr::NonPrimitiveCall { op_id, inputs: _ } =\u003e {\n                    // The `inputs` field encodes DAG dependencies for ordering purposes.\n                    // Actual input data is read from NonPrimitiveOperationData.\n                    if emitted_non_primitive_ops.insert(op_id.0) {\n                        let data = self\n                            .non_primitive_ops\n                            .get(op_id.0 as usize)\n                            .ok_or(CircuitBuilderError::MissingNonPrimitiveOp { op_id: *op_id })?;\n                        let outputs = op_id_to_output_exprs\n                            .get(\u0026op_id.0)\n                            .map(Vec::as_slice)\n                            .unwrap_or(\u0026[]);\n                        Self::emit_non_primitive_op(\n                            data,\n                            outputs,\n                            \u0026mut expr_to_widx,\n                            \u0026mut alloc_witness_id_for_expr,\n                            \u0026mut ops,\n                        )?;\n                    }\n                }\n                Expr::NonPrimitiveOutput {\n                    call,\n                    output_idx: _,\n                } =\u003e {\n                    // Look up the call expression to get the op_id\n                    let Expr::NonPrimitiveCall { op_id, .. } = self.graph.get_expr(*call) else {\n                        return Err(CircuitBuilderError::MissingExprMapping {\n                            expr_id: *call,\n                            context: \"NonPrimitiveOutput.call must reference a NonPrimitiveCall\"\n                                .to_string(),\n                        });\n                    };\n\n                    if emitted_non_primitive_ops.insert(op_id.0) {\n                        let data = self\n                            .non_primitive_ops\n                            .get(op_id.0 as usize)\n                            .ok_or(CircuitBuilderError::MissingNonPrimitiveOp { op_id: *op_id })?;\n                        let outputs = op_id_to_output_exprs\n                            .get(\u0026op_id.0)\n                            .map(Vec::as_slice)\n                            .unwrap_or(\u0026[]);\n                        Self::emit_non_primitive_op(\n                            data,\n                            outputs,\n                            \u0026mut expr_to_widx,\n                            \u0026mut alloc_witness_id_for_expr,\n                            \u0026mut ops,\n                        )?;\n                    }\n\n                    // This output node itself should now have a witness id assigned.\n                    expr_to_widx\n                        .entry(expr_id)\n                        .or_insert_with(|| alloc_witness_id_for_expr(expr_idx));\n                }\n            }\n        }\n\n        if emitted_non_primitive_ops.len() != self.non_primitive_ops.len() {\n            for data in self.non_primitive_ops {\n                if !emitted_non_primitive_ops.contains(\u0026data.op_id.0) {\n                    return Err(CircuitBuilderError::UnanchoredNonPrimitiveOp {\n                        op_id: data.op_id,\n                    });\n                }\n            }\n        }\n\n        // Populate expr_to_widx for all expressions in connect classes.\n        // This ensures that expressions merged via DSU still have a mapping,\n        // so tags attached to them can be resolved after optimization.\n        for \u0026expr_idx in \u0026in_connect {\n            let id = ExprId(expr_idx as u32);\n            if !expr_to_widx.contains_key(\u0026id) {\n                let root = dsu_find(\u0026mut parents, expr_idx);\n                if let Some(\u0026widx) = root_to_widx.get(\u0026root) {\n                    expr_to_widx.insert(id, widx);\n                }\n            }\n        }\n\n        let witness_count = self.witness_alloc.witness_count();\n        Ok((\n            ops,\n            public_rows,\n            expr_to_widx,\n            public_mappings,\n            witness_count,\n        ))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_baby_bear::BabyBear;\n\n    use super::*;\n    use crate::AluOpKind;\n\n    /// Helper to create an expression graph with a zero constant pre-allocated.\n    fn create_graph_with_zero() -\u003e ExpressionGraph\u003cBabyBear\u003e {\n        let mut graph = ExpressionGraph::new();\n        graph.add_expr(Expr::Const(BabyBear::ZERO));\n        graph\n    }\n\n    #[test]\n    fn test_dsu_utilities() {\n        // Single element is its own root when not in the map\n        let mut parents = HashMap::new();\n        assert_eq!(dsu_find(\u0026mut parents, 5), 5);\n\n        // Path compression: chain 1 -\u003e 2 -\u003e 3 where 3 is root\n        parents.clear();\n        parents.insert(1, 2);\n        parents.insert(2, 3);\n        parents.insert(3, 3);\n        assert_eq!(dsu_find(\u0026mut parents, 1), 3);\n        assert_eq!(parents[\u00261], 3); // Path compression applies\n\n        // Union merges two elements\n        parents.clear();\n        dsu_union(\u0026mut parents, 10, 20);\n        assert_eq!(dsu_find(\u0026mut parents, 10), dsu_find(\u0026mut parents, 20));\n\n        // Union is idempotent\n        parents.clear();\n        dsu_union(\u0026mut parents, 7, 7);\n        assert_eq!(dsu_find(\u0026mut parents, 7), 7);\n    }\n\n    #[test]\n    fn test_build_connect_dsu() {\n        // Empty connections\n        let connects = vec![];\n        let parents = build_connect_dsu(\u0026connects);\n        assert!(parents.is_empty());\n\n        // Single pair connection\n        let connects = vec![(ExprId(1), ExprId(2))];\n        let mut parents = build_connect_dsu(\u0026connects);\n        assert_eq!(dsu_find(\u0026mut parents, 1), dsu_find(\u0026mut parents, 2));\n\n        // Transitive chain: 0 -\u003e 1 -\u003e 2 -\u003e 3 all share same root\n        let connects = vec![\n            (ExprId(0), ExprId(1)),\n            (ExprId(1), ExprId(2)),\n            (ExprId(2), ExprId(3)),\n        ];\n        let mut parents = build_connect_dsu(\u0026connects);\n        let root = dsu_find(\u0026mut parents, 0);\n        assert_eq!(root, dsu_find(\u0026mut parents, 1));\n        assert_eq!(root, dsu_find(\u0026mut parents, 2));\n        assert_eq!(root, dsu_find(\u0026mut parents, 3));\n\n        // Multiple disjoint components: (0,1) separate from (2,3)\n        let connects = vec![(ExprId(0), ExprId(1)), (ExprId(2), ExprId(3))];\n        let mut parents = build_connect_dsu(\u0026connects);\n        let root01 = dsu_find(\u0026mut parents, 0);\n        assert_eq!(root01, dsu_find(\u0026mut parents, 1));\n        let root23 = dsu_find(\u0026mut parents, 2);\n        assert_eq!(root23, dsu_find(\u0026mut parents, 3));\n        assert_ne!(root01, root23);\n    }\n\n    #[test]\n    fn test_lowering() {\n        // Build a circuit exercising all primitive types and operations:\n        // - Multiple constants (zero, one, 3, 7)\n        // - Public inputs (positions 0, 1, 2)\n        // - Arithmetic operations: Add, Sub, Mul, Div\n        // - Circuit computes: ((p0 + p1) * c3 - c7) / p2\n        let mut graph = create_graph_with_zero();\n\n        // Constants\n        let c_zero = ExprId::ZERO; // Pre-allocated\n        let c_one = graph.add_expr(Expr::Const(BabyBear::ONE));\n        let c_three = graph.add_expr(Expr::Const(BabyBear::from_u64(3)));\n        let c_seven = graph.add_expr(Expr::Const(BabyBear::from_u64(7)));\n\n        // Public inputs\n        let p0 = graph.add_expr(Expr::Public(0));\n        let p1 = graph.add_expr(Expr::Public(1));\n        let p2 = graph.add_expr(Expr::Public(2));\n\n        // Operations: (p0 + p1) * c3 - c7\n        let sum = graph.add_expr(Expr::Add { lhs: p0, rhs: p1 });\n        let prod = graph.add_expr(Expr::Mul {\n            lhs: sum,\n            rhs: c_three,\n        });\n        let diff = graph.add_expr(Expr::Sub {\n            lhs: prod,\n            rhs: c_seven,\n        });\n\n        // Final division: diff / p2\n        let quot = graph.add_expr(Expr::Div { lhs: diff, rhs: p2 });\n\n        let connects = vec![];\n        let alloc = WitnessAllocator::new();\n\n        let lowerer = ExpressionLowerer::new(\u0026graph, \u0026[], \u0026connects, 3, alloc);\n        let (prims, public_rows, expr_map, public_map, witness_count) = lowerer.lower().unwrap();\n\n        // Verify Primitives\n        //\n        // Expected:\n        // - 4 Const from Pass A: zero, one, three, seven\n        // - 1 extra Const for the algebraic rewrite of `-7` in `Mul - Const`\n        // - 3 Public\n        // - 1 Add (sum)\n        // - 1 Mul\n        // - 1 Add (Sub lowered as forward add with -7)\n        // - 1 Mul (Div)\n        // =\u003e 12 total primitives\n        assert_eq!(prims.len(), 12);\n\n        // Constants (Pass A): zero, one, three, seven\n        match \u0026prims[0] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 0);\n                assert_eq!(*val, BabyBear::ZERO);\n            }\n            _ =\u003e panic!(\"Expected Const at position 0\"),\n        }\n        match \u0026prims[1] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 1);\n                assert_eq!(*val, BabyBear::ONE);\n            }\n            _ =\u003e panic!(\"Expected Const at position 1\"),\n        }\n        match \u0026prims[2] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 2);\n                assert_eq!(*val, BabyBear::from_u64(3));\n            }\n            _ =\u003e panic!(\"Expected Const at position 2\"),\n        }\n        match \u0026prims[3] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 3);\n                assert_eq!(*val, BabyBear::from_u64(7));\n            }\n            _ =\u003e panic!(\"Expected Const at position 3\"),\n        }\n\n        // Public inputs (Pass B): p0, p1, p2\n        match \u0026prims[4] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 4);\n                assert_eq!(*public_pos, 0);\n            }\n            _ =\u003e panic!(\"Expected Public at position 4\"),\n        }\n        match \u0026prims[5] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 5);\n                assert_eq!(*public_pos, 1);\n            }\n            _ =\u003e panic!(\"Expected Public at position 5\"),\n        }\n        match \u0026prims[6] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 6);\n                assert_eq!(*public_pos, 2);\n            }\n            _ =\u003e panic!(\"Expected Public at position 6\"),\n        }\n\n        // Arithmetic operations (Pass C): Add, Mul, Add (encoding Sub), Mul (encoding Div)\n        // Add: sum = p0 + p1\n        match \u0026prims[7] {\n            Op::Alu {\n                kind: AluOpKind::Add,\n                a,\n                b,\n                out,\n                ..\n            } =\u003e {\n                assert_eq!(*a, WitnessId(4)); // p0\n                assert_eq!(*b, WitnessId(5)); // p1\n                assert_eq!(out.0, 7); // sum\n            }\n            _ =\u003e panic!(\"Expected ALU Add at position 7\"),\n        }\n\n        // Mul: prod = sum * c3\n        match \u0026prims[8] {\n            Op::Alu {\n                kind: AluOpKind::Mul,\n                a,\n                b,\n                out,\n                ..\n            } =\u003e {\n                assert_eq!(*a, WitnessId(7)); // sum\n                assert_eq!(*b, WitnessId(2)); // c_three\n                assert_eq!(out.0, 8); // prod\n            }\n            _ =\u003e panic!(\"Expected ALU Mul at position 8\"),\n        }\n\n        // Sub encoded as Add with algebraic rewrite:\n        // diff = prod - c7  ==\u003e  diff = prod + (-c7)\n        //\n        // We insert:\n        // - an extra Const at position 9 for -7\n        // - a forward Add at position 10: prod + (-7) = diff\n        match \u0026prims[9] {\n            Op::Const { out: _, val } =\u003e {\n                assert_eq!(*val, -BabyBear::from_u64(7));\n            }\n            _ =\u003e panic!(\"Expected Const(-7) at position 9\"),\n        }\n\n        match \u0026prims[10] {\n            Op::Alu {\n                kind: AluOpKind::Add,\n                a,\n                b: _,\n                out,\n                ..\n            } =\u003e {\n                assert_eq!(*a, WitnessId(8)); // prod (mul result)\n                assert_eq!(*out, WitnessId(9)); // diff (sub result)\n            }\n            _ =\u003e panic!(\"Expected ALU Add (Sub encoding) at position 10\"),\n        }\n\n        // Div encoded as Mul: p2 * quot = diff\n        match \u0026prims[11] {\n            Op::Alu {\n                kind: AluOpKind::Mul,\n                a,\n                b: _,\n                out,\n                ..\n            } =\u003e {\n                assert_eq!(*a, WitnessId(6)); // p2 (divisor)\n                assert_eq!(*out, WitnessId(9)); // diff (dividend)\n            }\n            _ =\u003e panic!(\"Expected ALU Mul (Div encoding) at position 10\"),\n        }\n\n        // Verify Public Rows\n        assert_eq!(public_rows.len(), 3);\n        assert_eq!(public_rows[0], WitnessId(4)); // p0\n        assert_eq!(public_rows[1], WitnessId(5)); // p1\n        assert_eq!(public_rows[2], WitnessId(6)); // p2\n\n        // Verify Expression to Witness Mapping\n        assert_eq!(expr_map.len(), 11); // All 11 expressions mapped\n        assert_eq!(expr_map[\u0026c_zero], WitnessId(0));\n        assert_eq!(expr_map[\u0026c_one], WitnessId(1));\n        assert_eq!(expr_map[\u0026c_three], WitnessId(2));\n        assert_eq!(expr_map[\u0026c_seven], WitnessId(3));\n        assert_eq!(expr_map[\u0026p0], WitnessId(4));\n        assert_eq!(expr_map[\u0026p1], WitnessId(5));\n        assert_eq!(expr_map[\u0026p2], WitnessId(6));\n        assert_eq!(expr_map[\u0026sum], WitnessId(7));\n        assert_eq!(expr_map[\u0026prod], WitnessId(8));\n        assert_eq!(expr_map[\u0026diff], WitnessId(9));\n        assert_eq!(expr_map[\u0026quot], WitnessId(11));\n\n        // Verify Public Mapping\n        assert_eq!(public_map.len(), 3);\n        assert_eq!(public_map[\u0026p0], WitnessId(4));\n        assert_eq!(public_map[\u0026p1], WitnessId(5));\n        assert_eq!(public_map[\u0026p2], WitnessId(6));\n\n        // Verify Witness Count\n        // 4 Const + 1 extra Const(-7) + 3 Public + 1 Add + 1 Mul + 1 Add (Sub) + 1 Mul (Div) = 12\n        assert_eq!(witness_count, 12);\n    }\n\n    #[test]\n    fn test_witness_sharing() {\n        // Test witness sharing scenarios:\n        // 1. Constants connected to publics (const binds the shared witness)\n        // 2. Transitive connections among publics (all share one witness)\n        // 3. Operation results connected to other expressions\n        // 4. Multiple disjoint connection groups\n        //\n        // Circuit: c42 ~ p0, p1 ~ p2 ~ p3, (p0 + c1) ~ p4, c99 (standalone)\n        let mut graph = create_graph_with_zero();\n\n        // Constants\n        let c_zero = ExprId::ZERO;\n        let c_one = graph.add_expr(Expr::Const(BabyBear::ONE));\n        let c_42 = graph.add_expr(Expr::Const(BabyBear::from_u64(42)));\n        let c_99 = graph.add_expr(Expr::Const(BabyBear::from_u64(99)));\n\n        // Public inputs\n        let p0 = graph.add_expr(Expr::Public(0));\n        let p1 = graph.add_expr(Expr::Public(1));\n        let p2 = graph.add_expr(Expr::Public(2));\n        let p3 = graph.add_expr(Expr::Public(3));\n        let p4 = graph.add_expr(Expr::Public(4));\n\n        // Operation: sum = p0 + c1\n        let sum = graph.add_expr(Expr::Add {\n            lhs: p0,\n            rhs: c_one,\n        });\n\n        // Connections:\n        // Group A: c42 ~ p0 (const binds witness)\n        // Group B: p1 ~ p2 ~ p3 (transitive)\n        // Group C: sum ~ p4 (operation result shared)\n        let connects = vec![(c_42, p0), (p1, p2), (p2, p3), (sum, p4)];\n        let alloc = WitnessAllocator::new();\n\n        let lowerer = ExpressionLowerer::new(\u0026graph, \u0026[], \u0026connects, 5, alloc);\n        let (prims, public_rows, expr_map, public_map, witness_count) = lowerer.lower().unwrap();\n\n        // Verify Primitives\n        //\n        // 4 Const + 5 Public + 1 Add = 10 primitives\n        assert_eq!(prims.len(), 10);\n\n        // Constants\n        match \u0026prims[0] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 0);\n                assert_eq!(*val, BabyBear::ZERO);\n            }\n            _ =\u003e panic!(\"Expected Const(0) at position 0\"),\n        }\n        match \u0026prims[1] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 1);\n                assert_eq!(*val, BabyBear::ONE);\n            }\n            _ =\u003e panic!(\"Expected Const(1) at position 1\"),\n        }\n        match \u0026prims[2] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 2); // c42's witness (will be shared with p0)\n                assert_eq!(*val, BabyBear::from_u64(42));\n            }\n            _ =\u003e panic!(\"Expected Const(42) at position 2\"),\n        }\n        match \u0026prims[3] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 3);\n                assert_eq!(*val, BabyBear::from_u64(99));\n            }\n            _ =\u003e panic!(\"Expected Const(99) at position 3\"),\n        }\n\n        // Public inputs\n        match \u0026prims[4] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 2); // Shares witness with c42\n                assert_eq!(*public_pos, 0);\n            }\n            _ =\u003e panic!(\"Expected Public(0) at position 4\"),\n        }\n        match \u0026prims[5] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 4); // New witness for p1 group\n                assert_eq!(*public_pos, 1);\n            }\n            _ =\u003e panic!(\"Expected Public(1) at position 5\"),\n        }\n        match \u0026prims[6] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 4); // Shares witness with p1\n                assert_eq!(*public_pos, 2);\n            }\n            _ =\u003e panic!(\"Expected Public(2) at position 6\"),\n        }\n        match \u0026prims[7] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 4); // Shares witness with p1, p2\n                assert_eq!(*public_pos, 3);\n            }\n            _ =\u003e panic!(\"Expected Public(3) at position 7\"),\n        }\n        match \u0026prims[8] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 5); // New witness for p4 group\n                assert_eq!(*public_pos, 4);\n            }\n            _ =\u003e panic!(\"Expected Public(4) at position 8\"),\n        }\n\n        // Add operation: sum = p0 + c1\n        match \u0026prims[9] {\n            Op::Alu {\n                kind: AluOpKind::Add,\n                a,\n                b,\n                out,\n                ..\n            } =\u003e {\n                assert_eq!(*a, WitnessId(2)); // p0 (shares with c42)\n                assert_eq!(*b, WitnessId(1)); // c1\n                assert_eq!(*out, WitnessId(5)); // sum (shares with p4)\n            }\n            _ =\u003e panic!(\"Expected Add at position 9\"),\n        }\n\n        // Verify Public Rows\n        assert_eq!(public_rows.len(), 5);\n        assert_eq!(public_rows[0], WitnessId(2)); // p0 shares with c42\n        assert_eq!(public_rows[1], WitnessId(4)); // p1, p2, p3 all share\n        assert_eq!(public_rows[2], WitnessId(4));\n        assert_eq!(public_rows[3], WitnessId(4));\n        assert_eq!(public_rows[4], WitnessId(5)); // p4 shares with sum\n\n        // Verify Expression to Witness Mapping\n        assert_eq!(expr_map.len(), 10);\n\n        // Group A: c42 ~ p0 both map to witness 2\n        assert_eq!(expr_map[\u0026c_42], WitnessId(2));\n        assert_eq!(expr_map[\u0026p0], WitnessId(2));\n\n        // Group B: p1, p2, p3 all map to witness 4\n        assert_eq!(expr_map[\u0026p1], WitnessId(4));\n        assert_eq!(expr_map[\u0026p2], WitnessId(4));\n        assert_eq!(expr_map[\u0026p3], WitnessId(4));\n\n        // Group C: sum ~ p4 both map to witness 5\n        assert_eq!(expr_map[\u0026sum], WitnessId(5));\n        assert_eq!(expr_map[\u0026p4], WitnessId(5));\n\n        // Standalone expressions\n        assert_eq!(expr_map[\u0026c_zero], WitnessId(0));\n        assert_eq!(expr_map[\u0026c_one], WitnessId(1));\n        assert_eq!(expr_map[\u0026c_99], WitnessId(3));\n\n        // Verify Public Mapping\n        assert_eq!(public_map.len(), 5);\n        assert_eq!(public_map[\u0026p0], WitnessId(2));\n        assert_eq!(public_map[\u0026p1], WitnessId(4));\n        assert_eq!(public_map[\u0026p2], WitnessId(4));\n        assert_eq!(public_map[\u0026p3], WitnessId(4));\n        assert_eq!(public_map[\u0026p4], WitnessId(5));\n\n        // Verify Witness Count\n        //\n        // Witnesses: 0 (zero), 1 (one), 2 (c42/p0), 3 (c99), 4 (p1/p2/p3), 5 (sum/p4)\n        assert_eq!(witness_count, 6);\n    }\n\n    #[test]\n    fn test_error_handling() {\n        // Test 1: Missing expression in Add operand\n        let mut graph = create_graph_with_zero();\n        graph.add_expr(Expr::Add {\n            lhs: ExprId(99), // Non-existent\n            rhs: ExprId::ZERO,\n        });\n\n        let connects = vec![];\n        let alloc = WitnessAllocator::new();\n        let lowerer = ExpressionLowerer::new(\u0026graph, \u0026[], \u0026connects, 0, alloc);\n        let result = lowerer.lower();\n\n        assert!(result.is_err());\n        match result {\n            Err(CircuitBuilderError::MissingExprMapping { expr_id, context }) =\u003e {\n                assert_eq!(expr_id, ExprId(99));\n                assert!(context.contains(\"Add lhs\"));\n            }\n            _ =\u003e panic!(\"Expected MissingExprMapping error for Add lhs\"),\n        }\n\n        // Test 2: Missing expression in Mul operand\n        let mut graph = create_graph_with_zero();\n        graph.add_expr(Expr::Mul {\n            lhs: ExprId::ZERO,\n            rhs: ExprId(88), // Non-existent\n        });\n\n        let connects = vec![];\n        let alloc = WitnessAllocator::new();\n        let lowerer = ExpressionLowerer::new(\u0026graph, \u0026[], \u0026connects, 0, alloc);\n        let result = lowerer.lower();\n\n        assert!(result.is_err());\n        match result {\n            Err(CircuitBuilderError::MissingExprMapping { expr_id, context }) =\u003e {\n                assert_eq!(expr_id, ExprId(88));\n                assert!(context.contains(\"Mul rhs\"));\n            }\n            _ =\u003e panic!(\"Expected MissingExprMapping error for Mul rhs\"),\n        }\n\n        // Test 3: Helper function error propagation\n        let expr_map = HashMap::new();\n        let result = get_witness_id(\u0026expr_map, ExprId(77), \"test context\");\n\n        match result {\n            Err(CircuitBuilderError::MissingExprMapping { expr_id, context }) =\u003e {\n                assert_eq!(expr_id, ExprId(77));\n                assert_eq!(context, \"test context\");\n            }\n            _ =\u003e panic!(\"Expected MissingExprMapping error from get_witness_id\"),\n        }\n    }\n\n    // Property-based tests for DSU utilities and connect DSU construction\n    #[cfg(test)]\n    mod proptests {\n        use proptest::prelude::*;\n\n        use super::*;\n\n        // Strategy for generating lists of ExprId connect relations\n        fn connections(max_id: u32) -\u003e impl Strategy\u003cValue = Vec\u003c(ExprId, ExprId)\u003e\u003e {\n            prop::collection::vec((0..max_id, 0..max_id), 0..20).prop_map(|pairs| {\n                pairs\n                    .into_iter()\n                    .map(|(a, b)| (ExprId(a), ExprId(b)))\n                    .collect()\n            })\n        }\n\n        proptest! {\n            #[test]\n            fn dsu_find_idempotent(connects in connections(50)) {\n                let mut parents = build_connect_dsu(\u0026connects);\n                let test_ids: Vec\u003cusize\u003e = (0..50).collect();\n\n                for \u0026id in \u0026test_ids {\n                    let root1 = dsu_find(\u0026mut parents, id);\n                    let root2 = dsu_find(\u0026mut parents, id);\n                    prop_assert_eq!(root1, root2, \"dsu_find should be idempotent\");\n                }\n            }\n\n            #[test]\n            fn dsu_union_transitivity(connects in connections(30)) {\n                let mut parents = build_connect_dsu(\u0026connects);\n\n                // Check that all explicitly connected pairs have the same root\n                for (a, b) in \u0026connects {\n                    let ra = dsu_find(\u0026mut parents, a.0 as usize);\n                    let rb = dsu_find(\u0026mut parents, b.0 as usize);\n                    prop_assert_eq!(ra, rb, \"connected nodes should have same root\");\n                }\n            }\n\n            #[test]\n            fn dsu_union_commutative(a in 0u32..100, b in 0u32..100) {\n                let mut parents1 = HashMap::new();\n                let mut parents2 = HashMap::new();\n\n                dsu_union(\u0026mut parents1, a as usize, b as usize);\n                dsu_union(\u0026mut parents2, b as usize, a as usize);\n\n                let r1a = dsu_find(\u0026mut parents1, a as usize);\n                let r1b = dsu_find(\u0026mut parents1, b as usize);\n                let r2a = dsu_find(\u0026mut parents2, a as usize);\n                let r2b = dsu_find(\u0026mut parents2, b as usize);\n\n                prop_assert_eq!(r1a, r1b, \"union should connect a and b\");\n                prop_assert_eq!(r2a, r2b, \"union should connect b and a\");\n            }\n        }\n    }\n}\n","traces":[{"line":21,"address":[2573568,2574126,2574120],"length":1,"stats":{"Line":36}},{"line":22,"address":[15686668],"length":1,"stats":{"Line":34}},{"line":23,"address":[4876521],"length":1,"stats":{"Line":37}},{"line":24,"address":[2925313,2925380,2925548],"length":1,"stats":{"Line":98}},{"line":25,"address":[6456298],"length":1,"stats":{"Line":25}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[5700765],"length":1,"stats":{"Line":25}},{"line":29,"address":[8897127],"length":1,"stats":{"Line":25}},{"line":31,"address":[11592945],"length":1,"stats":{"Line":32}},{"line":32,"address":[3165139,3165233,3165368],"length":1,"stats":{"Line":101}},{"line":33,"address":[],"length":0,"stats":{"Line":51}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[3959216],"length":1,"stats":{"Line":19}},{"line":41,"address":[2925868],"length":1,"stats":{"Line":15}},{"line":42,"address":[2365476],"length":1,"stats":{"Line":16}},{"line":43,"address":[7805483],"length":1,"stats":{"Line":17}},{"line":44,"address":[7805507],"length":1,"stats":{"Line":16}},{"line":50,"address":[8961008,8961325,8961319],"length":1,"stats":{"Line":15}},{"line":51,"address":[8961048],"length":1,"stats":{"Line":22}},{"line":52,"address":[6773952,6774024],"length":1,"stats":{"Line":36}},{"line":53,"address":[8896732],"length":1,"stats":{"Line":15}},{"line":54,"address":[4411512],"length":1,"stats":{"Line":19}},{"line":55,"address":[6774154,6774194],"length":1,"stats":{"Line":32}},{"line":57,"address":[8896774],"length":1,"stats":{"Line":16}},{"line":90,"address":[3150608],"length":1,"stats":{"Line":24}},{"line":106,"address":[3765492,3765498,3764160],"length":1,"stats":{"Line":13}},{"line":116,"address":[6430761,6430668],"length":1,"stats":{"Line":27}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[2112468],"length":1,"stats":{"Line":14}},{"line":119,"address":[7774928,7754244,7776238,7774942,7776224,7764596],"length":1,"stats":{"Line":40}},{"line":122,"address":[1608798],"length":1,"stats":{"Line":15}},{"line":123,"address":[3506092,3495564],"length":1,"stats":{"Line":15}},{"line":124,"address":[4010070,4010165,4010036,4010396],"length":1,"stats":{"Line":42}},{"line":125,"address":[],"length":0,"stats":{"Line":16}},{"line":127,"address":[3757225],"length":1,"stats":{"Line":11}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[7754708,7765060],"length":1,"stats":{"Line":0}},{"line":133,"address":[5736498,5746834,5767506,5757170,5777842],"length":1,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":14}},{"line":142,"address":[7754871,7765223],"length":1,"stats":{"Line":16}},{"line":144,"address":[3757362],"length":1,"stats":{"Line":14}},{"line":145,"address":[5736855,5778199,5757527,5747191,5767863],"length":1,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[4010535],"length":1,"stats":{"Line":0}},{"line":148,"address":[2113240],"length":1,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":16}},{"line":155,"address":[3765544,3765624],"length":1,"stats":{"Line":2}},{"line":158,"address":[2113521,2113471],"length":1,"stats":{"Line":28}},{"line":161,"address":[7765656,7755304],"length":1,"stats":{"Line":14}},{"line":162,"address":[3765874],"length":1,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[3140772],"length":1,"stats":{"Line":0}},{"line":165,"address":[3507106,3496578],"length":1,"stats":{"Line":0}},{"line":167,"address":[3496551,3507079],"length":1,"stats":{"Line":0}},{"line":169,"address":[5747619,5778627,5737283,5757955,5768291],"length":1,"stats":{"Line":0}},{"line":173,"address":[3757830],"length":1,"stats":{"Line":15}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[3757870],"length":1,"stats":{"Line":15}},{"line":178,"address":[3769165,3772360,3766031],"length":1,"stats":{"Line":3}},{"line":179,"address":[5666867,5656515,5654292,5656444,5666796,5664644],"length":1,"stats":{"Line":3}},{"line":180,"address":[6438124],"length":1,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[4016938],"length":1,"stats":{"Line":0}},{"line":183,"address":[6438049],"length":1,"stats":{"Line":0}},{"line":186,"address":[2119544,2119933,2120043],"length":1,"stats":{"Line":2}},{"line":188,"address":[6441658,6441652,6441376,6441408,6438317],"length":1,"stats":{"Line":3}},{"line":189,"address":[3150553],"length":1,"stats":{"Line":1}},{"line":190,"address":[3767085],"length":1,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[5669904,5669813,5671248,5671157],"length":1,"stats":{"Line":1}},{"line":196,"address":[4017562],"length":1,"stats":{"Line":1}},{"line":200,"address":[3766118,3765996,3769113],"length":1,"stats":{"Line":41}},{"line":201,"address":[1612603,1610645,1612532],"length":1,"stats":{"Line":41}},{"line":202,"address":[6434865],"length":1,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[5739873,5750209,5760545,5770881,5781217],"length":1,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[5761004,5739833,5750169,5750668,5771340,5760894,5760505,5740332,5770841,5781676,5750558,5781177,5771230,5781566,5740222],"length":1,"stats":{"Line":28}},{"line":210,"address":[6738330,6736816,6737098,6737092,6738324,6738048,6730802,6720434,6736848,6738080],"length":1,"stats":{"Line":41}},{"line":211,"address":[3517410,3517090],"length":1,"stats":{"Line":15}},{"line":212,"address":[1619309],"length":1,"stats":{"Line":15}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[7775525,7775173],"length":1,"stats":{"Line":15}},{"line":218,"address":[7769071,7758719],"length":1,"stats":{"Line":15}},{"line":222,"address":[5748270,5758606,5737934,5768942,5779278],"length":1,"stats":{"Line":15}},{"line":223,"address":[3141689,3141597],"length":1,"stats":{"Line":13}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[1610815],"length":1,"stats":{"Line":0}},{"line":227,"address":[1610850],"length":1,"stats":{"Line":0}},{"line":230,"address":[7756769,7758006,7767121,7756659,7766605,7768358,7767011,7756253],"length":1,"stats":{"Line":28}},{"line":232,"address":[2114859,2123168,2123190],"length":1,"stats":{"Line":13}},{"line":233,"address":[1618780],"length":1,"stats":{"Line":0}},{"line":236,"address":[3498040,3508568],"length":1,"stats":{"Line":15}},{"line":239,"address":[6433698],"length":1,"stats":{"Line":13}},{"line":240,"address":[6719121,6729489,6719213,6729581],"length":1,"stats":{"Line":20}},{"line":241,"address":[6433957],"length":1,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[4012771],"length":1,"stats":{"Line":0}},{"line":244,"address":[4012810],"length":1,"stats":{"Line":0}},{"line":247,"address":[5652305,5652694,5662657,5663046,5663156,5652804],"length":1,"stats":{"Line":26}},{"line":249,"address":[7774886,7767846,7774864,7776118,7757494,7776096],"length":1,"stats":{"Line":27}},{"line":250,"address":[4020636],"length":1,"stats":{"Line":5}},{"line":253,"address":[6434467],"length":1,"stats":{"Line":14}},{"line":261,"address":[5664677,5653089,5663441,5654325],"length":1,"stats":{"Line":29}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[3769568,3769484],"length":1,"stats":{"Line":30}},{"line":264,"address":[1429520,1429591,1429011],"length":1,"stats":{"Line":46}},{"line":265,"address":[3762689],"length":1,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[5783245,5772909,5762573,5741901,5752237],"length":1,"stats":{"Line":0}},{"line":268,"address":[3145717],"length":1,"stats":{"Line":0}},{"line":271,"address":[4015968,4015671],"length":1,"stats":{"Line":30}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[4016107,4016062],"length":1,"stats":{"Line":32}},{"line":277,"address":[5656191,5666543],"length":1,"stats":{"Line":14}},{"line":279,"address":[3771518,3770795],"length":1,"stats":{"Line":16}},{"line":283,"address":[1429354],"length":1,"stats":{"Line":15}},{"line":284,"address":[1429050],"length":1,"stats":{"Line":15}},{"line":285,"address":[7769972,7759620],"length":1,"stats":{"Line":15}},{"line":286,"address":[4015324,4015244],"length":1,"stats":{"Line":30}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[6721913,6732281],"length":1,"stats":{"Line":15}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[7754316,7754350,7764668,7764702,7772510,7762158],"length":1,"stats":{"Line":27}},{"line":296,"address":[3764636],"length":1,"stats":{"Line":15}},{"line":298,"address":[6438939],"length":1,"stats":{"Line":15}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[3147898],"length":1,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[5667843,5667952,5657600,5657491],"length":1,"stats":{"Line":30}},{"line":308,"address":[3774336],"length":1,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[5766425,5776761,5787097,5756089,5745753],"length":1,"stats":{"Line":0}},{"line":315,"address":[1616951,1618401,1618471,1617049,1617006,1617449],"length":1,"stats":{"Line":40}},{"line":316,"address":[7762810,7762512,7772864,7773162,7762700,7773052,7762584,7772936],"length":1,"stats":{"Line":42}},{"line":317,"address":[3765067],"length":1,"stats":{"Line":14}},{"line":318,"address":[7776160,7773006,7762654,7775014,7776182,7774992],"length":1,"stats":{"Line":42}},{"line":319,"address":[7776188,7775020],"length":1,"stats":{"Line":14}},{"line":321,"address":[1617179,1617248],"length":1,"stats":{"Line":14}},{"line":323,"address":[2121338,2121402],"length":1,"stats":{"Line":28}},{"line":324,"address":[],"length":0,"stats":{"Line":26}},{"line":325,"address":[3766146],"length":1,"stats":{"Line":12}},{"line":326,"address":[5668896,5658544],"length":1,"stats":{"Line":12}},{"line":327,"address":[3766672,3766129,3766686],"length":1,"stats":{"Line":12}},{"line":328,"address":[1618210],"length":1,"stats":{"Line":12}},{"line":330,"address":[3773799],"length":1,"stats":{"Line":12}},{"line":331,"address":[6440078],"length":1,"stats":{"Line":12}},{"line":332,"address":[3504744,3515272],"length":1,"stats":{"Line":12}},{"line":333,"address":[3149047],"length":1,"stats":{"Line":12}},{"line":334,"address":[1618020],"length":1,"stats":{"Line":12}},{"line":339,"address":[5655167,5665519],"length":1,"stats":{"Line":16}},{"line":351,"address":[6752528,6744153,6758157,6738512,6766476,6752510],"length":1,"stats":{"Line":25}},{"line":365,"address":[6441882],"length":1,"stats":{"Line":31}},{"line":366,"address":[5847937,5820037,5806117,5806035,5792079,5792161,5833969,5847855,5833887,5819955],"length":1,"stats":{"Line":61}},{"line":367,"address":[],"length":0,"stats":{"Line":45}},{"line":369,"address":[7790019,7803921],"length":1,"stats":{"Line":14}},{"line":370,"address":[5685591,5699817],"length":1,"stats":{"Line":0}},{"line":371,"address":[6455608],"length":1,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[7804048,7790146],"length":1,"stats":{"Line":0}},{"line":376,"address":[2137198],"length":1,"stats":{"Line":15}},{"line":377,"address":[4034505],"length":1,"stats":{"Line":16}},{"line":379,"address":[3781425],"length":1,"stats":{"Line":15}},{"line":382,"address":[6739044,6753048],"length":1,"stats":{"Line":29}},{"line":383,"address":[3781584,3781161,3768278,3781594],"length":1,"stats":{"Line":57}},{"line":385,"address":[3776140],"length":1,"stats":{"Line":28}},{"line":388,"address":[6751111,6739403,6753407,6765077],"length":1,"stats":{"Line":28}},{"line":389,"address":[1632448,1632409],"length":1,"stats":{"Line":24}},{"line":390,"address":[7789824,7803726],"length":1,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[6751495,6765461,6751861,6765827],"length":1,"stats":{"Line":0}},{"line":395,"address":[7789214,7803116],"length":1,"stats":{"Line":16}},{"line":396,"address":[1632796],"length":1,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[5684699,5698925],"length":1,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[3531038,3545212],"length":1,"stats":{"Line":0}},{"line":408,"address":[1435533],"length":1,"stats":{"Line":30}},{"line":411,"address":[6739472,6753476],"length":1,"stats":{"Line":28}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[3164864,3164880,3151747],"length":1,"stats":{"Line":76}},{"line":417,"address":[3776521],"length":1,"stats":{"Line":31}},{"line":418,"address":[6442965],"length":1,"stats":{"Line":26}},{"line":419,"address":[5834986,5848915,5821054,5793245,5807134,5821121,5848982,5807201,5835053,5793178],"length":1,"stats":{"Line":53}},{"line":420,"address":[2124669],"length":1,"stats":{"Line":29}},{"line":423,"address":[3533406,3519194],"length":1,"stats":{"Line":26}},{"line":426,"address":[7777815,7777894,7791834,7791755],"length":1,"stats":{"Line":58}},{"line":427,"address":[4032954,4022497],"length":1,"stats":{"Line":53}},{"line":428,"address":[5698114,5683906],"length":1,"stats":{"Line":26}},{"line":429,"address":[3162895],"length":1,"stats":{"Line":25}},{"line":430,"address":[5683971,5698179],"length":1,"stats":{"Line":25}},{"line":431,"address":[1631946],"length":1,"stats":{"Line":26}},{"line":434,"address":[6750919,6764885],"length":1,"stats":{"Line":25}},{"line":435,"address":[6750949,6764915],"length":1,"stats":{"Line":22}},{"line":436,"address":[6751011,6764977],"length":1,"stats":{"Line":22}},{"line":441,"address":[4022561,4034880],"length":1,"stats":{"Line":53}},{"line":442,"address":[2137362],"length":1,"stats":{"Line":25}},{"line":443,"address":[3546683,3546363],"length":1,"stats":{"Line":25}},{"line":444,"address":[7804484,7804660,7804516,7804692],"length":1,"stats":{"Line":50}},{"line":445,"address":[],"length":0,"stats":{"Line":27}},{"line":446,"address":[4034983,4035024,4035029],"length":1,"stats":{"Line":64}},{"line":448,"address":[2137383],"length":1,"stats":{"Line":25}},{"line":453,"address":[5807796,5849538,5835648,5821716,5793840],"length":1,"stats":{"Line":25}},{"line":454,"address":[3769785,3779517],"length":1,"stats":{"Line":52}},{"line":455,"address":[7788313,7802233],"length":1,"stats":{"Line":23}},{"line":457,"address":[5859450,5831765,5803909,5845717,5817845],"length":1,"stats":{"Line":24}},{"line":459,"address":[4032768],"length":1,"stats":{"Line":24}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[2135353],"length":1,"stats":{"Line":23}},{"line":463,"address":[1631674],"length":1,"stats":{"Line":23}},{"line":464,"address":[6750621,6764605],"length":1,"stats":{"Line":24}},{"line":465,"address":[3162826],"length":1,"stats":{"Line":22}},{"line":470,"address":[5836021,5808169,5822089,5794213,5849872],"length":1,"stats":{"Line":22}},{"line":472,"address":[1621978,1621896],"length":1,"stats":{"Line":50}},{"line":473,"address":[3153289],"length":1,"stats":{"Line":28}},{"line":474,"address":[1622251],"length":1,"stats":{"Line":24}},{"line":476,"address":[4024732],"length":1,"stats":{"Line":22}},{"line":477,"address":[1623659,1624083],"length":1,"stats":{"Line":48}},{"line":478,"address":[5810378,5852052,5811563,5797607,5838230,5839415,5824298,5825483,5796422,5853237],"length":1,"stats":{"Line":29}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[6757510,6743506,6758135,6744131],"length":1,"stats":{"Line":27}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[1625183],"length":1,"stats":{"Line":24}},{"line":483,"address":[7781984,7795924],"length":1,"stats":{"Line":24}},{"line":485,"address":[6445896],"length":1,"stats":{"Line":19}},{"line":496,"address":[3773297,3771722],"length":1,"stats":{"Line":38}},{"line":497,"address":[],"length":0,"stats":{"Line":19}},{"line":500,"address":[1440337],"length":1,"stats":{"Line":19}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[1440389],"length":1,"stats":{"Line":17}},{"line":506,"address":[3773410],"length":1,"stats":{"Line":20}},{"line":509,"address":[4027085,4027254],"length":1,"stats":{"Line":27}},{"line":515,"address":[5692313,5678125],"length":1,"stats":{"Line":8}},{"line":516,"address":[5692355,5678167],"length":1,"stats":{"Line":8}},{"line":517,"address":[5678233,5692432],"length":1,"stats":{"Line":8}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[5692391,5678203],"length":1,"stats":{"Line":8}},{"line":523,"address":[3774318],"length":1,"stats":{"Line":8}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[6448267],"length":1,"stats":{"Line":19}},{"line":529,"address":[3781872,3782210],"length":1,"stats":{"Line":42}},{"line":531,"address":[3539448,3525256],"length":1,"stats":{"Line":19}},{"line":533,"address":[],"length":0,"stats":{"Line":40}},{"line":535,"address":[3154838],"length":1,"stats":{"Line":23}},{"line":536,"address":[],"length":0,"stats":{"Line":44}},{"line":537,"address":[4028174,4029361],"length":1,"stats":{"Line":25}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[5814467,5813846,5800531,5827766,5842339,5855490,5856111,5828387,5841718,5799910],"length":1,"stats":{"Line":26}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[1628115],"length":1,"stats":{"Line":22}},{"line":542,"address":[7784932,7798852],"length":1,"stats":{"Line":22}},{"line":544,"address":[4024986],"length":1,"stats":{"Line":10}},{"line":546,"address":[3154965,3159310],"length":1,"stats":{"Line":20}},{"line":547,"address":[],"length":0,"stats":{"Line":12}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[7799481,7786182,7800102,7785561],"length":1,"stats":{"Line":13}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[1629338],"length":1,"stats":{"Line":10}},{"line":553,"address":[4030543],"length":1,"stats":{"Line":10}},{"line":555,"address":[1438926],"length":1,"stats":{"Line":14}},{"line":558,"address":[5675881,5695765,5690069,5681557],"length":1,"stats":{"Line":26}},{"line":559,"address":[6762599,6748615,6763124,6749140,6748505,6762390,6762489,6748406],"length":1,"stats":{"Line":25}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[6762398,6748414],"length":1,"stats":{"Line":14}},{"line":562,"address":[5681727,5695833,5695935,5681625],"length":1,"stats":{"Line":15}},{"line":563,"address":[1444926],"length":1,"stats":{"Line":14}},{"line":564,"address":[],"length":0,"stats":{"Line":13}},{"line":565,"address":[3785647],"length":1,"stats":{"Line":15}},{"line":566,"address":[7786667,7800587],"length":1,"stats":{"Line":13}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[2127761],"length":1,"stats":{"Line":15}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[2127784,2133985],"length":1,"stats":{"Line":32}},{"line":582,"address":[4032399],"length":1,"stats":{"Line":0}},{"line":583,"address":[4031504],"length":1,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[2134105],"length":1,"stats":{"Line":0}},{"line":589,"address":[5802734,5816670,5816591,5844542,5858275,5830590,5830511,5844463,5858196,5802655],"length":1,"stats":{"Line":32}},{"line":590,"address":[3528976,3529647,3543069,3543168,3543278,3529086,3543839,3528877],"length":1,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[1445437],"length":1,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[5682997,5697205],"length":1,"stats":{"Line":0}},{"line":595,"address":[1445767],"length":1,"stats":{"Line":0}},{"line":596,"address":[5697110,5682902],"length":1,"stats":{"Line":0}},{"line":597,"address":[7801550,7787630],"length":1,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[4032369,4031560],"length":1,"stats":{"Line":32}},{"line":609,"address":[7787195,7801115],"length":1,"stats":{"Line":16}},{"line":610,"address":[6766496,6766528,6764106,6766542,6750122,6766510],"length":1,"stats":{"Line":16}},{"line":615,"address":[1622322],"length":1,"stats":{"Line":25}},{"line":616,"address":[7793105,7779165],"length":1,"stats":{"Line":0}},{"line":617,"address":[6755434,6756381,6741430,6742377],"length":1,"stats":{"Line":0}},{"line":618,"address":[3771498],"length":1,"stats":{"Line":0}},{"line":619,"address":[6756407,6742403],"length":1,"stats":{"Line":0}},{"line":628,"address":[3153635,3153427],"length":1,"stats":{"Line":55}},{"line":629,"address":[3770674],"length":1,"stats":{"Line":29}},{"line":630,"address":[],"length":0,"stats":{"Line":56}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[5675288,5689476],"length":1,"stats":{"Line":0}},{"line":633,"address":[6742343,6756347],"length":1,"stats":{"Line":0}},{"line":638,"address":[7793466,7779526],"length":1,"stats":{"Line":27}},{"line":639,"address":[2126730],"length":1,"stats":{"Line":31}},{"line":640,"address":[3153850],"length":1,"stats":{"Line":31}},{"line":641,"address":[6445026],"length":1,"stats":{"Line":27}},{"line":642,"address":[5688970,5674782],"length":1,"stats":{"Line":31}},{"line":643,"address":[3153986],"length":1,"stats":{"Line":27}},{"line":644,"address":[],"length":0,"stats":{"Line":0}}],"covered":212,"coverable":326},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","compiler","mod.rs"],"content":"//! Circuit compilation and lowering subsystem.\n\nmod expression_lowerer;\nmod optimizer;\n\npub use expression_lowerer::ExpressionLowerer;\nuse hashbrown::HashMap;\npub use optimizer::Optimizer;\n\nuse crate::{CircuitBuilderError, ExprId, WitnessId};\n\n// Utility functions\n\n/// Helper function to get WitnessId with descriptive error messages\nfn get_witness_id(\n    expr_to_widx: \u0026HashMap\u003cExprId, WitnessId\u003e,\n    expr_id: ExprId,\n    context: \u0026str,\n) -\u003e Result\u003cWitnessId, CircuitBuilderError\u003e {\n    expr_to_widx\n        .get(\u0026expr_id)\n        .copied()\n        .ok_or_else(|| CircuitBuilderError::MissingExprMapping {\n            expr_id,\n            context: context.into(),\n        })\n}\n","traces":[{"line":15,"address":[3958032],"length":1,"stats":{"Line":16}},{"line":21,"address":[6773688],"length":1,"stats":{"Line":18}},{"line":23,"address":[4875981,4876098,4876032],"length":1,"stats":{"Line":18}},{"line":24,"address":[8960913],"length":1,"stats":{"Line":1}},{"line":25,"address":[4876058],"length":1,"stats":{"Line":1}}],"covered":5,"coverable":5},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","compiler","optimizer.rs"],"content":"use alloc::vec::Vec;\n\nuse hashbrown::HashMap;\nuse p3_field::Field;\n\nuse crate::op::{AluOpKind, Op};\nuse crate::types::WitnessId;\n\n/// Responsible for performing optimization passes on primitive operations.\n#[derive(Debug, Default)]\npub struct Optimizer;\n\n/// Information about an operation definition.\n#[derive(Clone, Debug)]\nenum OpDef\u003cF\u003e {\n    Const(F),\n    Add { a: WitnessId, b: WitnessId },\n    Mul { a: WitnessId, b: WitnessId },\n    Other,\n}\n\n// MulAddCandidate struct removed - now using inline tuple returns\n\nimpl Optimizer {\n    /// Creates a new optimizer.\n    pub const fn new() -\u003e Self {\n        Self\n    }\n\n    /// Optimizes primitive operations.\n    ///\n    /// Returns the optimized op list and a rewrite map: any witness ID that was removed\n    /// as a duplicate points to its canonical witness. The caller should apply this map\n    /// to expr_to_widx, public_rows, and tag_to_witness so no reference stays to removed IDs.\n    ///\n    /// Currently implements:\n    /// - ALU deduplication: removes duplicate ALU ops (identical or same inputs via connect)\n    /// - BoolCheck fusion: detects `b * (b - 1) = 0` patterns and fuses them into BoolCheck ops\n    /// - MulAdd fusion: detects `a * b + c` patterns and fuses them into MulAdd ops\n    ///\n    /// Future passes that can be added here:\n    /// - Dead code elimination\n    pub fn optimize\u003cF: Field\u003e(\n        \u0026self,\n        primitive_ops: Vec\u003cOp\u003cF\u003e\u003e,\n    ) -\u003e (Vec\u003cOp\u003cF\u003e\u003e, HashMap\u003cWitnessId, WitnessId\u003e) {\n        let (ops, rewrite) = self.deduplicate_alu_ops(primitive_ops);\n        let ops = self.fuse_bool_checks(ops);\n        let ops = self.fuse_mul_adds(ops);\n        (ops, rewrite)\n    }\n\n    /// Resolves a witness ID through the rewrite map (follows chain to canonical ID).\n    pub fn resolve_witness(rewrite: \u0026HashMap\u003cWitnessId, WitnessId\u003e, id: WitnessId) -\u003e WitnessId {\n        let mut cur = id;\n        while let Some(\u0026next) = rewrite.get(\u0026cur) {\n            cur = next;\n        }\n        cur\n    }\n\n    /// Removes duplicate ALU operations: same kind and same inputs (commutative ops normalized).\n    /// When a duplicate is found, its output is rewritten to the first op's output in all later ops.\n    /// Returns the optimized ops and a map from removed output IDs to their canonical output.\n    fn deduplicate_alu_ops\u003cF: Field\u003e(\n        \u0026self,\n        ops: Vec\u003cOp\u003cF\u003e\u003e,\n    ) -\u003e (Vec\u003cOp\u003cF\u003e\u003e, HashMap\u003cWitnessId, WitnessId\u003e) {\n        #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n        struct AluKey {\n            kind: AluOpKind,\n            a: u32,\n            b: u32,\n            c: u32,\n        }\n\n        fn resolve(id: WitnessId, rewrite: \u0026HashMap\u003cWitnessId, WitnessId\u003e) -\u003e WitnessId {\n            let mut cur = id;\n            while let Some(\u0026next) = rewrite.get(\u0026cur) {\n                cur = next;\n            }\n            cur\n        }\n\n        let mut rewrite: HashMap\u003cWitnessId, WitnessId\u003e = HashMap::new();\n        let mut seen: HashMap\u003cAluKey, WitnessId\u003e = HashMap::new();\n        let mut result = Vec::with_capacity(ops.len());\n\n        for mut op in ops {\n            op.apply_witness_rewrite(\u0026rewrite);\n\n            let (is_dup, dup_out, canonical_out) = match \u0026op {\n                Op::Alu {\n                    kind, a, b, c, out, ..\n                } =\u003e {\n                    let (a, b, c) = (\n                        resolve(*a, \u0026rewrite),\n                        resolve(*b, \u0026rewrite),\n                        c.map(|id| resolve(id, \u0026rewrite)),\n                    );\n                    let key = match kind {\n                        AluOpKind::Add | AluOpKind::Mul =\u003e {\n                            let (x, y) = if a.0 \u003c= b.0 { (a.0, b.0) } else { (b.0, a.0) };\n                            AluKey {\n                                kind: *kind,\n                                a: x,\n                                b: y,\n                                c: 0,\n                            }\n                        }\n                        AluOpKind::BoolCheck =\u003e AluKey {\n                            kind: *kind,\n                            a: a.0,\n                            b: b.0,\n                            c: 0,\n                        },\n                        AluOpKind::MulAdd =\u003e AluKey {\n                            kind: *kind,\n                            a: a.0,\n                            b: b.0,\n                            c: c.unwrap_or(WitnessId(0)).0,\n                        },\n                    };\n                    if let Some(\u0026first_out) = seen.get(\u0026key) {\n                        (true, *out, first_out)\n                    } else {\n                        seen.insert(key, *out);\n                        (false, WitnessId(0), WitnessId(0))\n                    }\n                }\n                _ =\u003e (false, WitnessId(0), WitnessId(0)),\n            };\n\n            if is_dup {\n                let root = resolve(canonical_out, \u0026rewrite);\n                if dup_out != root {\n                    rewrite.insert(dup_out, root);\n                }\n                continue;\n            }\n\n            result.push(op);\n        }\n\n        (result, rewrite)\n    }\n\n    /// Detects and fuses `a * b + c` patterns into MulAdd operations.\n    ///\n    /// Pattern: add(mul(a, b), c) where the mul result is only used by this add.\n    /// This saves one row in the ALU table by combining the mul and add into one operation.\n    ///\n    /// Uses a two-phase approach to handle chained patterns correctly:\n    /// 1. Identify all potential fusions (ignoring ordering)\n    /// 2. Filter to only keep fusions where the addend is available at the mul's position\n    fn fuse_mul_adds\u003cF: Field\u003e(\u0026self, ops: Vec\u003cOp\u003cF\u003e\u003e) -\u003e Vec\u003cOp\u003cF\u003e\u003e {\n        // Build use counts for each witness ID (counting ALL uses, not just ALU)\n        let mut use_counts: HashMap\u003cWitnessId, usize\u003e = HashMap::new();\n        for op in \u0026ops {\n            match op {\n                Op::Alu { a, b, c, .. } =\u003e {\n                    *use_counts.entry(*a).or_insert(0) += 1;\n                    *use_counts.entry(*b).or_insert(0) += 1;\n                    if let Some(c_id) = c {\n                        *use_counts.entry(*c_id).or_insert(0) += 1;\n                    }\n                }\n                Op::NonPrimitiveOpWithExecutor { inputs, .. } =\u003e {\n                    for input_group in inputs {\n                        for witness_id in input_group {\n                            *use_counts.entry(*witness_id).or_insert(0) += 1;\n                        }\n                    }\n                }\n                _ =\u003e {}\n            }\n        }\n\n        // Build a map from output witness ID to operation definition.\n        // Important: Const entries are never overwritten because witness slots shared\n        // via connect() should keep the Const definition.\n        let mut defs: HashMap\u003cWitnessId, (usize, OpDef\u003cF\u003e)\u003e = HashMap::new();\n\n        // Also track witnesses computed by backwards adds.\n        // In a backwards add(a, b, out), if `out` is already defined, then `b` is computed.\n        // We need to track where `b` is computed so we don't treat it as always available.\n        let mut backwards_add_computed: HashMap\u003cWitnessId, usize\u003e = HashMap::new();\n\n        for (idx, op) in ops.iter().enumerate() {\n            match op {\n                Op::Const { out, val } =\u003e {\n                    defs.insert(*out, (idx, OpDef::Const(*val)));\n                }\n                Op::Alu {\n                    kind: AluOpKind::Mul,\n                    a,\n                    b,\n                    out,\n                    c: None,\n                    ..\n                } =\u003e {\n                    if !matches!(defs.get(out), Some((_, OpDef::Const(_)))) {\n                        // Check if this is a backwards mul (division)\n                        // If `out` is already defined, then `b` is computed\n                        if let Some((out_def_idx, _)) = defs.get(out)\n                            \u0026\u0026 *out_def_idx \u003c idx\n                        {\n                            backwards_add_computed.insert(*b, idx);\n                            // Also track the computed value in defs so subsequent\n                            // backwards adds can detect their output is defined\n                            if !matches!(defs.get(b), Some((_, OpDef::Const(_)))) {\n                                defs.insert(*b, (idx, OpDef::Other));\n                            }\n                        }\n                        defs.insert(*out, (idx, OpDef::Mul { a: *a, b: *b }));\n                    }\n                }\n                Op::Alu {\n                    kind: AluOpKind::Add,\n                    a,\n                    b,\n                    out,\n                    c: None,\n                    ..\n                } =\u003e {\n                    if !matches!(defs.get(out), Some((_, OpDef::Const(_)))) {\n                        // Check if this is a backwards add (subtraction)\n                        // If `out` is already defined, then `b` is computed\n                        if let Some((out_def_idx, _)) = defs.get(out)\n                            \u0026\u0026 *out_def_idx \u003c idx\n                        {\n                            backwards_add_computed.insert(*b, idx);\n                            // Also track the computed value in defs so subsequent\n                            // backwards adds can detect their output is defined\n                            if !matches!(defs.get(b), Some((_, OpDef::Const(_)))) {\n                                defs.insert(*b, (idx, OpDef::Other));\n                            }\n                        }\n                        defs.insert(*out, (idx, OpDef::Add { a: *a, b: *b }));\n                    }\n                }\n                Op::Alu { out, .. } =\u003e {\n                    if !matches!(defs.get(out), Some((_, OpDef::Const(_)))) {\n                        defs.insert(*out, (idx, OpDef::Other));\n                    }\n                }\n                Op::Public { out, .. } =\u003e {\n                    if !matches!(defs.get(out), Some((_, OpDef::Const(_)))) {\n                        defs.insert(*out, (idx, OpDef::Other));\n                    }\n                }\n                Op::NonPrimitiveOpWithExecutor { outputs, .. } =\u003e {\n                    for output_group in outputs {\n                        for out_id in output_group {\n                            if !matches!(defs.get(out_id), Some((_, OpDef::Const(_)))) {\n                                defs.insert(*out_id, (idx, OpDef::Other));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Phase 1: Identify ALL potential fusions (without ordering checks)\n        // Store: add_idx -\u003e (mul_idx, MulAdd op, addend)\n        let mut potential_fusions: HashMap\u003cusize, (usize, Op\u003cF\u003e, WitnessId)\u003e = HashMap::new();\n\n        for (add_idx, op) in ops.iter().enumerate() {\n            if let Op::Alu {\n                kind: AluOpKind::Add,\n                a: add_a,\n                b: add_b,\n                c: None,\n                out,\n                ..\n            } = op\n            {\n                // Skip adds where output is a Const (connect aliasing)\n                if matches!(defs.get(out), Some((_, OpDef::Const(_)))) {\n                    continue;\n                }\n\n                // Detect backwards adds: if `out` is defined BEFORE this add,\n                // then this add computes one of its inputs (a or b), not `out`.\n                // We cannot fuse backwards adds.\n                let is_backwards_add = defs\n                    .get(out)\n                    .map(|(def_idx, _)| *def_idx \u003c add_idx)\n                    .unwrap_or(false);\n                if is_backwards_add {\n                    continue;\n                }\n\n                // Try add_a as mul result\n                if let Some((mul_idx, muladd_op, addend)) = self.try_create_muladd_candidate(\n                    *add_a,\n                    *add_b,\n                    *out,\n                    add_idx,\n                    \u0026defs,\n                    \u0026use_counts,\n                    \u0026backwards_add_computed,\n                ) {\n                    potential_fusions.insert(add_idx, (mul_idx, muladd_op, addend));\n                    continue;\n                }\n\n                // Try add_b as mul result (symmetric)\n                if let Some((mul_idx, muladd_op, addend)) = self.try_create_muladd_candidate(\n                    *add_b,\n                    *add_a,\n                    *out,\n                    add_idx,\n                    \u0026defs,\n                    \u0026use_counts,\n                    \u0026backwards_add_computed,\n                ) {\n                    potential_fusions.insert(add_idx, (mul_idx, muladd_op, addend));\n                }\n            }\n        }\n\n        // Phase 2: Iteratively filter fusions based on ordering constraints\n        // We iterate until no more fusions are invalidated.\n        //\n        // A fusion is valid if its addend is available at the mul's position.\n        // The addend's effective position depends on whether the op producing it will be fused.\n\n        let mut valid_add_indices: hashbrown::HashSet\u003cusize\u003e =\n            potential_fusions.keys().copied().collect();\n\n        loop {\n            // Build map: add_out -\u003e mul_idx for CURRENTLY valid fusions only\n            let mut add_out_to_mul_idx: HashMap\u003cWitnessId, usize\u003e = HashMap::new();\n            for \u0026add_idx in \u0026valid_add_indices {\n                if let Some((mul_idx, _, _)) = potential_fusions.get(\u0026add_idx)\n                    \u0026\u0026 let Some(Op::Alu { out, .. }) = ops.get(add_idx)\n                {\n                    add_out_to_mul_idx.insert(*out, *mul_idx);\n                }\n            }\n\n            // Check each currently valid fusion\n            let mut to_remove: Vec\u003cusize\u003e = Vec::new();\n\n            for \u0026add_idx in \u0026valid_add_indices {\n                if let Some((mul_idx, _, addend)) = potential_fusions.get(\u0026add_idx) {\n                    let addend_available_at =\n                        self.compute_effective_position(*addend, \u0026defs, \u0026add_out_to_mul_idx);\n\n                    // Invalid if addend isn't available when MulAdd runs\n                    // None means always available (witness/public input), which is fine\n                    if let Some(pos) = addend_available_at\n                        \u0026\u0026 pos \u003e= *mul_idx\n                    {\n                        to_remove.push(add_idx);\n                    }\n                }\n            }\n\n            if to_remove.is_empty() {\n                break; // Fixed point reached\n            }\n\n            for add_idx in to_remove {\n                valid_add_indices.remove(\u0026add_idx);\n            }\n        }\n\n        // Build valid_fusions from the remaining valid indices\n        let mut valid_fusions: HashMap\u003cusize, (usize, Op\u003cF\u003e)\u003e = HashMap::new();\n        for add_idx in valid_add_indices {\n            if let Some((mul_idx, muladd_op, _addend)) = potential_fusions.remove(\u0026add_idx) {\n                valid_fusions.insert(add_idx, (mul_idx, muladd_op));\n            }\n        }\n\n        // Build the result\n        let mut consumed_adds: hashbrown::HashSet\u003cusize\u003e = hashbrown::HashSet::new();\n        let mut mul_to_muladd: HashMap\u003cusize, Op\u003cF\u003e\u003e = HashMap::new();\n\n        for (add_idx, (mul_idx, muladd_op)) in valid_fusions {\n            // Avoid double-fusing the same mul\n            if !mul_to_muladd.contains_key(\u0026mul_idx) {\n                mul_to_muladd.insert(mul_idx, muladd_op);\n                consumed_adds.insert(add_idx);\n            }\n        }\n\n        let mut result = Vec::with_capacity(ops.len() - consumed_adds.len());\n\n        for (idx, op) in ops.into_iter().enumerate() {\n            if consumed_adds.contains(\u0026idx) {\n                continue;\n            }\n\n            if let Some(muladd_op) = mul_to_muladd.remove(\u0026idx) {\n                result.push(muladd_op);\n                continue;\n            }\n\n            result.push(op);\n        }\n\n        result\n    }\n\n    /// Creates a MulAdd candidate without full ordering checks.\n    /// Returns (mul_idx, MulAdd op, addend) if the pattern matches.\n    #[allow(clippy::too_many_arguments)]\n    fn try_create_muladd_candidate\u003cF: Field\u003e(\n        \u0026self,\n        mul_result: WitnessId,\n        addend: WitnessId,\n        out: WitnessId,\n        add_idx: usize,\n        defs: \u0026HashMap\u003cWitnessId, (usize, OpDef\u003cF\u003e)\u003e,\n        use_counts: \u0026HashMap\u003cWitnessId, usize\u003e,\n        backwards_add_computed: \u0026HashMap\u003cWitnessId, usize\u003e,\n    ) -\u003e Option\u003c(usize, Op\u003cF\u003e, WitnessId)\u003e {\n        // Check if mul_result is from a Mul operation\n        let (mul_idx, mul_def) = defs.get(\u0026mul_result)?;\n        let (mul_a, mul_b) = match mul_def {\n            OpDef::Mul { a, b } =\u003e (*a, *b),\n            _ =\u003e return None,\n        };\n\n        // Check that mul_result is only used once (by this add)\n        let use_count = use_counts.get(\u0026mul_result).copied().unwrap_or(0);\n        if use_count != 1 {\n            return None;\n        }\n\n        // Don't fuse if mul_result is a constant (connect aliasing)\n        if matches!(defs.get(\u0026mul_result), Some((_, OpDef::Const(_)))) {\n            return None;\n        }\n\n        // Don't fuse if the addend isn't defined yet (would be computed by this add)\n        if let Some((addend_def_idx, _)) = defs.get(\u0026addend)\n            \u0026\u0026 *addend_def_idx \u003e= add_idx\n        {\n            return None;\n        }\n\n        // Don't fuse if the addend is computed by a backwards add that runs at or after mul_idx\n        // (the MulAdd would run at mul_idx but the addend wouldn't be available yet)\n        if let Some(\u0026computed_at_idx) = backwards_add_computed.get(\u0026addend)\n            \u0026\u0026 computed_at_idx \u003e= *mul_idx\n        {\n            return None;\n        }\n\n        // Don't fuse if the Mul's b is produced by a later op.\n        // The MulAdd would run at mul_idx but b wouldn't be available yet.\n        if let Some((b_def_idx, _)) = defs.get(\u0026mul_b)\n            \u0026\u0026 *b_def_idx \u003e= *mul_idx\n        {\n            return None;\n        }\n\n        let muladd_op = Op::Alu {\n            kind: AluOpKind::MulAdd,\n            a: mul_a,\n            b: mul_b,\n            c: Some(addend),\n            out,\n            intermediate_out: Some(mul_result),\n        };\n\n        Some((*mul_idx, muladd_op, addend))\n    }\n\n    /// Computes the effective position where a witness will be available.\n    /// Takes into account that an Add's output might be moved if it gets fused.\n    /// Returns None for witnesses that are always available (public inputs, witness inputs).\n    fn compute_effective_position\u003cF\u003e(\n        \u0026self,\n        witness: WitnessId,\n        defs: \u0026HashMap\u003cWitnessId, (usize, OpDef\u003cF\u003e)\u003e,\n        add_out_to_mul_idx: \u0026HashMap\u003cWitnessId, usize\u003e,\n    ) -\u003e Option\u003cusize\u003e {\n        // If this witness is the output of an Add that will be fused,\n        // its effective position is the corresponding Mul's position\n        if let Some(\u0026mul_idx) = add_out_to_mul_idx.get(\u0026witness) {\n            return Some(mul_idx);\n        }\n\n        // Otherwise, use the original definition position\n        // If not in defs (witness/public input), it's always available\n        defs.get(\u0026witness).map(|(idx, _)| *idx)\n    }\n\n    /// Detects and fuses `assert_bool` patterns into BoolCheck operations.\n    ///\n    /// Pattern: `b * (b - 1) = 0` which appears as:\n    /// 1. `neg_one = mul(one, const_neg_1)` (creates -1)\n    /// 2. `b_minus_1 = add(b, neg_one)` (b - 1)\n    /// 3. `product = mul(b, b_minus_1)` (b * (b-1))\n    /// 4. The product is connected to zero (assert_zero)\n    ///\n    /// We detect step 3 and transform it into a BoolCheck if the pattern matches.\n    fn fuse_bool_checks\u003cF: Field\u003e(\u0026self, ops: Vec\u003cOp\u003cF\u003e\u003e) -\u003e Vec\u003cOp\u003cF\u003e\u003e {\n        // Build a map from output witness ID to operation info\n        let mut defs: HashMap\u003cWitnessId, OpDef\u003cF\u003e\u003e = HashMap::new();\n\n        for op in \u0026ops {\n            match op {\n                Op::Const { out, val } =\u003e {\n                    defs.insert(*out, OpDef::Const(*val));\n                }\n                Op::Public { out, .. } =\u003e {\n                    defs.insert(*out, OpDef::Other);\n                }\n                Op::Alu {\n                    kind: AluOpKind::Add,\n                    a,\n                    b,\n                    out,\n                    ..\n                } =\u003e {\n                    defs.insert(*out, OpDef::Add { a: *a, b: *b });\n                }\n                Op::Alu {\n                    kind: AluOpKind::Mul,\n                    a,\n                    b,\n                    out,\n                    ..\n                } =\u003e {\n                    defs.insert(*out, OpDef::Mul { a: *a, b: *b });\n                }\n                Op::Alu { out, .. } =\u003e {\n                    defs.insert(*out, OpDef::Other);\n                }\n                Op::NonPrimitiveOpWithExecutor { .. } =\u003e {}\n            }\n        }\n\n        let mut result = Vec::with_capacity(ops.len());\n\n        for op in ops {\n            // Check if this is a mul that could be a BoolCheck\n            if let Op::Alu {\n                kind: AluOpKind::Mul,\n                a,\n                b,\n                c: None,\n                out,\n                ..\n            } = \u0026op\n            {\n                // Check if this matches the pattern: mul(X, add(X, -1))\n                // where the second operand is X - 1\n                if let Some(bool_check_input) = self.detect_bool_check_pattern(*a, *b, \u0026defs) {\n                    // Replace with BoolCheck: a * (a - 1) = 0, out = a\n                    result.push(Op::Alu {\n                        kind: AluOpKind::BoolCheck,\n                        a: bool_check_input,\n                        b: *b, // Keep original b for structural compatibility\n                        c: None,\n                        out: *out,\n                        intermediate_out: None,\n                    });\n                    continue;\n                }\n            }\n\n            result.push(op);\n        }\n\n        result\n    }\n\n    /// Detects if `mul(a, b)` matches the pattern `X * (X - 1)`.\n    ///\n    /// Returns `Some(X)` if the pattern matches, `None` otherwise.\n    fn detect_bool_check_pattern\u003cF: Field\u003e(\n        \u0026self,\n        mul_a: WitnessId,\n        mul_b: WitnessId,\n        defs: \u0026HashMap\u003cWitnessId, OpDef\u003cF\u003e\u003e,\n    ) -\u003e Option\u003cWitnessId\u003e {\n        // Check if b = add(a, -1) or b = add(a, neg_one_result)\n        // where neg_one_result is the result of some computation that equals -1\n        if let Some(OpDef::Add { a: add_a, b: add_b }) = defs.get(\u0026mul_b) {\n            // Pattern: mul(a, add(a, X)) where X = -1\n            if *add_a == mul_a \u0026\u0026 self.is_neg_one(*add_b, defs) {\n                return Some(mul_a);\n            }\n        }\n\n        // Also check symmetric case: mul(add(a, X), a) where X = -1\n        if let Some(OpDef::Add { a: add_a, b: add_b }) = defs.get(\u0026mul_a)\n            \u0026\u0026 *add_a == mul_b\n            \u0026\u0026 self.is_neg_one(*add_b, defs)\n        {\n            return Some(mul_b);\n        }\n\n        None\n    }\n\n    /// Checks if a witness ID holds the value -1 (either directly or through computation).\n    fn is_neg_one\u003cF: Field\u003e(\u0026self, id: WitnessId, defs: \u0026HashMap\u003cWitnessId, OpDef\u003cF\u003e\u003e) -\u003e bool {\n        match defs.get(\u0026id) {\n            // Direct constant check\n            Some(OpDef::Const(val)) =\u003e *val == -F::ONE,\n\n            // Check if it's the result of mul(1, -1) = -1\n            // This is how sub(a, b) creates the negation\n            Some(OpDef::Mul { a, b }) =\u003e {\n                let a_is_one = matches!(defs.get(a), Some(OpDef::Const(v)) if *v == F::ONE);\n                let b_is_neg_one = matches!(defs.get(b), Some(OpDef::Const(v)) if *v == -F::ONE);\n                let a_is_neg_one = matches!(defs.get(a), Some(OpDef::Const(v)) if *v == -F::ONE);\n                let b_is_one = matches!(defs.get(b), Some(OpDef::Const(v)) if *v == F::ONE);\n\n                (a_is_one \u0026\u0026 b_is_neg_one) || (a_is_neg_one \u0026\u0026 b_is_one)\n            }\n\n            _ =\u003e false,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n    use crate::CircuitBuilder;\n    use crate::op::AluOpKind;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_optimizer_passthrough() {\n        let optimizer = Optimizer::new();\n\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![\n            Op::Const {\n                out: WitnessId(0),\n                val: F::ZERO,\n            },\n            Op::add(WitnessId(0), WitnessId(1), WitnessId(2)),\n        ];\n\n        let (optimized, _) = optimizer.optimize(ops.clone());\n        assert_eq!(optimized, ops);\n    }\n\n    #[test]\n    fn test_bool_check_fusion() {\n        let optimizer = Optimizer::new();\n\n        // Simulate the pattern created by assert_bool(b):\n        // 1. one = Const(1) at WitnessId(1)\n        // 2. neg_one = Const(-1) at WitnessId(2)\n        // 3. one_times_neg_one = mul(one, neg_one) = -1 at WitnessId(3)\n        // 4. b_minus_one = add(b, one_times_neg_one) = b - 1 at WitnessId(4)\n        // 5. product = mul(b, b_minus_one) = b * (b-1) at WitnessId(5)\n        //\n        // After BoolCheck fusion: op 5 becomes BoolCheck(b)\n        let b = WitnessId(0);\n        let one = WitnessId(1);\n        let neg_one = WitnessId(2);\n        let one_times_neg_one = WitnessId(3);\n        let b_minus_one = WitnessId(4);\n        let product = WitnessId(5);\n\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![\n            Op::Const {\n                out: one,\n                val: F::ONE,\n            },\n            Op::Const {\n                out: neg_one,\n                val: -F::ONE,\n            },\n            Op::mul(one, neg_one, one_times_neg_one),   // -1\n            Op::add(b, one_times_neg_one, b_minus_one), // b - 1\n            Op::mul(b, b_minus_one, product),           // b * (b - 1) - this should be fused\n        ];\n\n        let (optimized, _) = optimizer.optimize(ops);\n\n        // BoolCheck fusion converts mul(b, b_minus_one) into BoolCheck\n        // MulAdd fusion fuses mul(one, neg_one) + add(b, ...) into MulAdd\n        // Result: 2 Const + 1 MulAdd + 1 BoolCheck = 4 ops\n        assert_eq!(optimized.len(), 4, \"Expected 4 ops, got {:?}\", optimized);\n\n        // Check that there's a BoolCheck\n        let bool_check_count = optimized\n            .iter()\n            .filter(|op| {\n                matches!(\n                    op,\n                    Op::Alu {\n                        kind: AluOpKind::BoolCheck,\n                        ..\n                    }\n                )\n            })\n            .count();\n        assert_eq!(bool_check_count, 1, \"Expected 1 BoolCheck\");\n\n        // Check that there's a MulAdd\n        let muladd_count = optimized\n            .iter()\n            .filter(|op| {\n                matches!(\n                    op,\n                    Op::Alu {\n                        kind: AluOpKind::MulAdd,\n                        ..\n                    }\n                )\n            })\n            .count();\n        assert_eq!(muladd_count, 1, \"Expected 1 MulAdd\");\n    }\n\n    #[test]\n    fn test_no_false_positive_bool_check() {\n        let optimizer = Optimizer::new();\n\n        // A regular mul that doesn't match the pattern\n        let a = WitnessId(0);\n        let b = WitnessId(1);\n        let out = WitnessId(2);\n\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![Op::mul(a, b, out)];\n\n        let (optimized, _) = optimizer.optimize(ops.clone());\n\n        // Should remain unchanged\n        assert_eq!(optimized, ops);\n    }\n\n    #[test]\n    fn test_muladd_fusion_chained() {\n        // Test chained mul+add pattern like in decompose_to_bits:\n        // acc0 = const\n        // term0 = mul(bit0, pow0)\n        // acc1 = add(acc0, term0)\n        // term1 = mul(bit1, pow1)\n        // acc2 = add(acc1, term1)\n        let optimizer = Optimizer::new();\n\n        let acc0 = WitnessId(0);\n        let bit0 = WitnessId(1);\n        let pow0 = WitnessId(2);\n        let term0 = WitnessId(3);\n        let acc1 = WitnessId(4);\n        let bit1 = WitnessId(5);\n        let pow1 = WitnessId(6);\n        let term1 = WitnessId(7);\n        let acc2 = WitnessId(8);\n\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![\n            Op::Const {\n                out: acc0,\n                val: F::ZERO,\n            }, // idx 0: acc0 = 0\n            Op::Const {\n                out: pow0,\n                val: F::ONE,\n            }, // idx 1: pow0 = 1\n            Op::Const {\n                out: pow1,\n                val: F::TWO,\n            }, // idx 2: pow1 = 2\n            // bit0 and bit1 would be from a hint, but they're just witness IDs here\n            Op::mul(bit0, pow0, term0), // idx 3: term0 = bit0 * pow0\n            Op::add(acc0, term0, acc1), // idx 4: acc1 = acc0 + term0\n            Op::mul(bit1, pow1, term1), // idx 5: term1 = bit1 * pow1\n            Op::add(acc1, term1, acc2), // idx 6: acc2 = acc1 + term1\n        ];\n\n        let optimized = optimizer.fuse_mul_adds(ops);\n\n        // Both fusions should happen:\n        // - First: mul(bit0, pow0) + add(acc0, term0) -\u003e MulAdd (acc0 is Const, available at mul's position)\n        // - Second: mul(bit1, pow1) + add(acc1, term1) -\u003e MulAdd (acc1 is from first MulAdd, runs at mul0's position which is before mul1)\n        // Result: 3 consts + 2 MulAdds = 5 ops\n        assert_eq!(\n            optimized.len(),\n            5,\n            \"Should have 3 consts + 2 MulAdds, got {} ops: {:?}\",\n            optimized.len(),\n            optimized\n        );\n\n        // Verify both MulAdds exist\n        let muladd_count = optimized\n            .iter()\n            .filter(|op| {\n                matches!(\n                    op,\n                    Op::Alu {\n                        kind: AluOpKind::MulAdd,\n                        ..\n                    }\n                )\n            })\n            .count();\n        assert_eq!(muladd_count, 2, \"Expected 2 MulAdds\");\n    }\n\n    #[test]\n    fn test_muladd_fusion_with_sub_pattern() {\n        // Test that backwards adds from sub() are NOT fused\n        // Pattern from assert_bool: sub(b, one) -\u003e b_minus_one\n        // Encoded as: add(one, b_minus_one) = b (out is already defined)\n        let optimizer = Optimizer::new();\n\n        let b = WitnessId(0); // bit from hint\n        let one = WitnessId(1); // const 1\n        let b_minus_one = WitnessId(2); // result of sub\n        let pow = WitnessId(3); // const power of 2\n        let term = WitnessId(4); // mul result\n        let acc = WitnessId(5); // initial accumulator\n        let new_acc = WitnessId(6); // result of add\n\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![\n            Op::Const {\n                out: one,\n                val: F::ONE,\n            }, // idx 0\n            Op::Const {\n                out: pow,\n                val: F::TWO,\n            }, // idx 1\n            Op::Const {\n                out: acc,\n                val: F::ZERO,\n            }, // idx 2\n            // Sub encoded as backwards add: one + b_minus_one = b\n            // Note: 'b' (WitnessId(0)) is NOT defined by any op here - simulating hint output\n            Op::add(one, b_minus_one, b), // idx 3: backwards add (b is already defined)\n            Op::mul(b, pow, term),        // idx 4: term = b * pow\n            Op::add(acc, term, new_acc),  // idx 5: new_acc = acc + term\n        ];\n\n        let optimized = optimizer.fuse_mul_adds(ops);\n\n        // The backwards add at idx 3 should NOT be fused (b is not in defs, so out_def_idx check fails)\n        // The forward add at idx 5 CAN be fused with mul at idx 4\n        // Result: 3 consts + 1 backwards add + 1 MulAdd = 5 ops\n        assert_eq!(\n            optimized.len(),\n            5,\n            \"Should have 3 consts + backwards add + MulAdd, got {} ops: {:?}\",\n            optimized.len(),\n            optimized\n        );\n    }\n\n    #[test]\n    fn test_muladd_fusion_internal() {\n        // Test the fuse_mul_adds method directly (bypassing the disabled public API)\n        let optimizer = Optimizer::new();\n\n        // Pattern: a * b + c where mul result is only used once\n        let a = WitnessId(0);\n        let b = WitnessId(1);\n        let c = WitnessId(2);\n        let mul_result = WitnessId(3);\n        let add_result = WitnessId(4);\n\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![\n            Op::mul(a, b, mul_result),          // a * b\n            Op::add(mul_result, c, add_result), // (a * b) + c\n        ];\n\n        // Call fuse_mul_adds directly\n        let optimized = optimizer.fuse_mul_adds(ops);\n\n        // Should fuse into a single MulAdd\n        assert_eq!(\n            optimized.len(),\n            1,\n            \"Should have fused mul+add into one MulAdd\"\n        );\n\n        match \u0026optimized[0] {\n            Op::Alu {\n                kind: AluOpKind::MulAdd,\n                a: mul_a,\n                b: mul_b,\n                c: Some(add_c),\n                out,\n                ..\n            } =\u003e {\n                assert_eq!(*mul_a, a, \"MulAdd a should be from original mul\");\n                assert_eq!(*mul_b, b, \"MulAdd b should be from original mul\");\n                assert_eq!(*add_c, c, \"MulAdd c should be the addend\");\n                assert_eq!(*out, add_result, \"MulAdd out should be the add result\");\n            }\n            _ =\u003e panic!(\"Expected MulAdd, got {:?}\", optimized[0]),\n        }\n    }\n\n    #[test]\n    fn test_muladd_fusion_symmetric_internal() {\n        // Test the fuse_mul_adds method directly (bypassing the disabled public API)\n        let optimizer = Optimizer::new();\n\n        // Pattern: c + a * b (addend first, mul second)\n        let a = WitnessId(0);\n        let b = WitnessId(1);\n        let c = WitnessId(2);\n        let mul_result = WitnessId(3);\n        let add_result = WitnessId(4);\n\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![\n            Op::mul(a, b, mul_result),          // a * b\n            Op::add(c, mul_result, add_result), // c + (a * b)\n        ];\n\n        // Call fuse_mul_adds directly\n        let optimized = optimizer.fuse_mul_adds(ops);\n\n        // Should fuse into a single MulAdd\n        assert_eq!(\n            optimized.len(),\n            1,\n            \"Should have fused mul+add into one MulAdd\"\n        );\n\n        match \u0026optimized[0] {\n            Op::Alu {\n                kind: AluOpKind::MulAdd,\n                a: mul_a,\n                b: mul_b,\n                c: Some(add_c),\n                out,\n                ..\n            } =\u003e {\n                assert_eq!(*mul_a, a, \"MulAdd a should be from original mul\");\n                assert_eq!(*mul_b, b, \"MulAdd b should be from original mul\");\n                assert_eq!(*add_c, c, \"MulAdd c should be the addend\");\n                assert_eq!(*out, add_result, \"MulAdd out should be the add result\");\n            }\n            _ =\u003e panic!(\"Expected MulAdd, got {:?}\", optimized[0]),\n        }\n    }\n\n    #[test]\n    fn test_no_muladd_fusion_when_mul_has_multiple_uses_internal() {\n        // Test the fuse_mul_adds method directly (bypassing the disabled public API)\n        let optimizer = Optimizer::new();\n\n        // Pattern: mul result is used twice (in add and elsewhere)\n        let a = WitnessId(0);\n        let b = WitnessId(1);\n        let c = WitnessId(2);\n        let mul_result = WitnessId(3);\n        let add_result = WitnessId(4);\n        let other_result = WitnessId(5);\n\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![\n            Op::mul(a, b, mul_result),            // a * b\n            Op::add(mul_result, c, add_result),   // (a * b) + c\n            Op::add(mul_result, a, other_result), // mul_result used again!\n        ];\n\n        // Call fuse_mul_adds directly\n        let optimized = optimizer.fuse_mul_adds(ops);\n\n        // Should NOT fuse because mul_result has use count \u003e 1\n        assert_eq!(\n            optimized.len(),\n            3,\n            \"Should not fuse when mul has multiple uses\"\n        );\n\n        // First op should still be mul\n        assert!(\n            matches!(\n                optimized[0],\n                Op::Alu {\n                    kind: AluOpKind::Mul,\n                    ..\n                }\n            ),\n            \"First op should remain Mul\"\n        );\n    }\n\n    #[test]\n    fn test_duplicated_op_fusion() {\n        let optimizer = Optimizer::new();\n\n        let a = WitnessId(0);\n        let b = WitnessId(1);\n        let c = WitnessId(2);\n        let mul_result = WitnessId(3);\n        let add_result = WitnessId(4);\n\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![\n            Op::mul(a, b, mul_result),\n            Op::mul(a, b, mul_result), // identical op\n            Op::add(mul_result, c, add_result),\n        ];\n\n        let (optimized, _) = optimizer.optimize(ops);\n\n        assert_eq!(optimized.len(), 1);\n        assert!(optimized[0].is_alu_kind(AluOpKind::MulAdd));\n    }\n\n    #[test]\n    fn test_duplicated_op_fusion_in_builder() {\n        let mut builder = CircuitBuilder::\u003cF\u003e::new();\n        let a = builder.define_const(F::TWO);\n        let b = builder.public_input();\n        let c = builder.public_input();\n\n        builder.connect(b, c);\n\n        builder.alloc_mul(a, b, \"mul_result1\");\n        builder.alloc_mul(a, c, \"mul_result2\"); // identical op via connect\n\n        let circuit = builder.build().unwrap();\n        let mut runner = circuit.runner();\n        runner\n            .set_public_inputs(\u0026[F::from_u32(42), F::from_u32(42)])\n            .unwrap();\n\n        let traces = runner.run().unwrap();\n\n        assert_eq!(traces.alu_trace.len(), 1);\n    }\n}\n","traces":[{"line":43,"address":[8103056,8103931,8103947,8103483,8103520,8103467],"length":1,"stats":{"Line":28}},{"line":47,"address":[4942926],"length":1,"stats":{"Line":30}},{"line":48,"address":[3226839],"length":1,"stats":{"Line":23}},{"line":49,"address":[2545754],"length":1,"stats":{"Line":29}},{"line":50,"address":[2522321],"length":1,"stats":{"Line":27}},{"line":54,"address":[7185696],"length":1,"stats":{"Line":20}},{"line":55,"address":[13433441],"length":1,"stats":{"Line":16}},{"line":56,"address":[8091651,8091593],"length":1,"stats":{"Line":31}},{"line":57,"address":[8091647],"length":1,"stats":{"Line":14}},{"line":59,"address":[8921686],"length":1,"stats":{"Line":16}},{"line":65,"address":[3901376,3903534,3903510],"length":1,"stats":{"Line":28}},{"line":77,"address":[7185792],"length":1,"stats":{"Line":21}},{"line":78,"address":[15711522],"length":1,"stats":{"Line":19}},{"line":79,"address":[2950139,2950198],"length":1,"stats":{"Line":21}},{"line":80,"address":[8921778],"length":1,"stats":{"Line":0}},{"line":82,"address":[15711592],"length":1,"stats":{"Line":18}},{"line":85,"address":[],"length":0,"stats":{"Line":30}},{"line":86,"address":[3223007],"length":1,"stats":{"Line":28}},{"line":87,"address":[3529508,3531762,3529570,3531700],"length":1,"stats":{"Line":58}},{"line":89,"address":[3223374,3224880,3223247,3223153],"length":1,"stats":{"Line":114}},{"line":90,"address":[],"length":0,"stats":{"Line":26}},{"line":92,"address":[1724015,1724881],"length":1,"stats":{"Line":65}},{"line":93,"address":[3532455,3530263],"length":1,"stats":{"Line":28}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[4940288],"length":1,"stats":{"Line":27}},{"line":97,"address":[4613179,4615371],"length":1,"stats":{"Line":27}},{"line":98,"address":[],"length":0,"stats":{"Line":27}},{"line":99,"address":[3225096,3224031,3225072],"length":1,"stats":{"Line":26}},{"line":101,"address":[8096648,8098824],"length":1,"stats":{"Line":28}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[6595517,6595618],"length":1,"stats":{"Line":53}},{"line":105,"address":[5222713,5224905],"length":1,"stats":{"Line":25}},{"line":112,"address":[3902736],"length":1,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[3532916,3530724],"length":1,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[6595596],"length":1,"stats":{"Line":0}},{"line":124,"address":[6595739,6595804,6596028,6595889],"length":1,"stats":{"Line":97}},{"line":125,"address":[5222889,5225081],"length":1,"stats":{"Line":16}},{"line":127,"address":[3224600],"length":1,"stats":{"Line":26}},{"line":128,"address":[2520030],"length":1,"stats":{"Line":27}},{"line":131,"address":[1990505],"length":1,"stats":{"Line":27}},{"line":134,"address":[3903188],"length":1,"stats":{"Line":28}},{"line":135,"address":[8099529,8097325,8097353,8099501],"length":1,"stats":{"Line":30}},{"line":136,"address":[6596192],"length":1,"stats":{"Line":15}},{"line":137,"address":[4941160],"length":1,"stats":{"Line":15}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[4940942],"length":1,"stats":{"Line":33}},{"line":145,"address":[3223548],"length":1,"stats":{"Line":27}},{"line":156,"address":[8081062,8081104,8083431,8091470,8070720,8073047],"length":1,"stats":{"Line":27}},{"line":158,"address":[2505982],"length":1,"stats":{"Line":31}},{"line":159,"address":[5207298,5207222,5196838,5196914],"length":1,"stats":{"Line":59}},{"line":160,"address":[2529776],"length":1,"stats":{"Line":29}},{"line":161,"address":[1986672],"length":1,"stats":{"Line":27}},{"line":162,"address":[2515583,2515666,2515503],"length":1,"stats":{"Line":53}},{"line":163,"address":[2515772,2515699,2515641],"length":1,"stats":{"Line":53}},{"line":164,"address":[4607952,4597400,4597444,4607805,4607849,4597547],"length":1,"stats":{"Line":24}},{"line":165,"address":[5206624,5216936,5206531,5217029],"length":1,"stats":{"Line":0}},{"line":168,"address":[3898705],"length":1,"stats":{"Line":17}},{"line":169,"address":[1986775,1987170],"length":1,"stats":{"Line":34}},{"line":170,"address":[9507178,9527998,9496828,9507392,9517582,9538374,9496614,9517796,9528212,9538588],"length":1,"stats":{"Line":34}},{"line":171,"address":[3899433,3899341],"length":1,"stats":{"Line":19}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[2506370],"length":1,"stats":{"Line":29}},{"line":187,"address":[4588049,4598433],"length":1,"stats":{"Line":23}},{"line":189,"address":[9508052,9518376,9487108,9528868,9528792,9507976,9518452,9487032,9497492,9497416],"length":1,"stats":{"Line":50}},{"line":190,"address":[3522147,3522507,3512105,3505631,3511745,3516015],"length":1,"stats":{"Line":78}},{"line":191,"address":[3895880],"length":1,"stats":{"Line":25}},{"line":192,"address":[2536495,2536230],"length":1,"stats":{"Line":53}},{"line":194,"address":[1985284],"length":1,"stats":{"Line":22}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[8089289,8078887],"length":1,"stats":{"Line":24}},{"line":205,"address":[3218906],"length":1,"stats":{"Line":22}},{"line":206,"address":[6590288],"length":1,"stats":{"Line":7}},{"line":208,"address":[1719392],"length":1,"stats":{"Line":7}},{"line":211,"address":[3219185],"length":1,"stats":{"Line":7}},{"line":212,"address":[2538130],"length":1,"stats":{"Line":7}},{"line":215,"address":[5215481,5205079,5205447,5215849],"length":1,"stats":{"Line":46}},{"line":218,"address":[3522598,3512196],"length":1,"stats":{"Line":22}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[3522626,3512224],"length":1,"stats":{"Line":25}},{"line":229,"address":[],"length":0,"stats":{"Line":24}},{"line":230,"address":[4934503],"length":1,"stats":{"Line":23}},{"line":232,"address":[3218441],"length":1,"stats":{"Line":23}},{"line":235,"address":[1718714],"length":1,"stats":{"Line":22}},{"line":236,"address":[5204649,5215051],"length":1,"stats":{"Line":21}},{"line":239,"address":[3512848,3512480,3522882,3523250],"length":1,"stats":{"Line":47}},{"line":242,"address":[1718133],"length":1,"stats":{"Line":1}},{"line":243,"address":[1984479,1985972],"length":1,"stats":{"Line":2}},{"line":244,"address":[4606896,4596494],"length":1,"stats":{"Line":1}},{"line":247,"address":[8077646,8088048],"length":1,"stats":{"Line":23}},{"line":248,"address":[3896060,3896188],"length":1,"stats":{"Line":46}},{"line":249,"address":[1984356],"length":1,"stats":{"Line":20}},{"line":252,"address":[4605017,4594615],"length":1,"stats":{"Line":14}},{"line":253,"address":[4605029,4596597,4594627,4606999],"length":1,"stats":{"Line":27}},{"line":254,"address":[3898225],"length":1,"stats":{"Line":12}},{"line":255,"address":[5205936,5216338],"length":1,"stats":{"Line":15}},{"line":256,"address":[4607395,4596993],"length":1,"stats":{"Line":12}},{"line":266,"address":[3211526],"length":1,"stats":{"Line":25}},{"line":268,"address":[4927781,4927860],"length":1,"stats":{"Line":55}},{"line":269,"address":[4932454,4928160,4932475],"length":1,"stats":{"Line":73}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[2535071],"length":1,"stats":{"Line":21}},{"line":272,"address":[5202342,5212726],"length":1,"stats":{"Line":23}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[2511629],"length":1,"stats":{"Line":22}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[1982905],"length":1,"stats":{"Line":22}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[1983116],"length":1,"stats":{"Line":22}},{"line":287,"address":[5202522,5212906],"length":1,"stats":{"Line":22}},{"line":288,"address":[1987552,1983065,1987562],"length":1,"stats":{"Line":68}},{"line":290,"address":[2535368],"length":1,"stats":{"Line":23}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[4593591,4603975],"length":1,"stats":{"Line":25}},{"line":296,"address":[3510768,3521152],"length":1,"stats":{"Line":22}},{"line":297,"address":[9492514,9502898,9513458,9523858,9534274],"length":1,"stats":{"Line":23}},{"line":298,"address":[3895092],"length":1,"stats":{"Line":24}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[4933293,4933051],"length":1,"stats":{"Line":32}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[6588280,6588359],"length":1,"stats":{"Line":45}},{"line":310,"address":[3895473],"length":1,"stats":{"Line":23}},{"line":311,"address":[9513843,9534659,9492899,9503283,9524243],"length":1,"stats":{"Line":26}},{"line":312,"address":[3511157,3521541],"length":1,"stats":{"Line":22}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[3521774,3511390],"length":1,"stats":{"Line":19}},{"line":329,"address":[3506127,3516511],"length":1,"stats":{"Line":27}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[3516580,3506196],"length":1,"stats":{"Line":27}},{"line":335,"address":[2507412,2507456],"length":1,"stats":{"Line":52}},{"line":336,"address":[9498563,9523140,9488179,9491796,9509123,9512740,9533556,9502180,9519523,9529939],"length":1,"stats":{"Line":42}},{"line":337,"address":[8086467,8076083],"length":1,"stats":{"Line":20}},{"line":339,"address":[4593150,4603534],"length":1,"stats":{"Line":23}},{"line":344,"address":[2531093],"length":1,"stats":{"Line":27}},{"line":346,"address":[9509160,9529976,9530048,9509232,9519560,9498600,9519632,9488288,9488216,9498672],"length":1,"stats":{"Line":56}},{"line":347,"address":[2534403,2531315],"length":1,"stats":{"Line":43}},{"line":348,"address":[5201753,5212137],"length":1,"stats":{"Line":21}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[2511091],"length":1,"stats":{"Line":20}},{"line":354,"address":[1982381],"length":1,"stats":{"Line":20}},{"line":356,"address":[1716054],"length":1,"stats":{"Line":11}},{"line":361,"address":[2531341],"length":1,"stats":{"Line":29}},{"line":365,"address":[5209248,5198616,5198864,5209000,5198705,5209089],"length":1,"stats":{"Line":34}},{"line":366,"address":[4589906,4589854,4600238,4600290],"length":1,"stats":{"Line":24}},{"line":371,"address":[2508284],"length":1,"stats":{"Line":25}},{"line":372,"address":[2532017,2531779,2531907],"length":1,"stats":{"Line":83}},{"line":373,"address":[4602641,4600647,4592257,4590263],"length":1,"stats":{"Line":42}},{"line":374,"address":[8085928,8075544],"length":1,"stats":{"Line":19}},{"line":379,"address":[2532120],"length":1,"stats":{"Line":29}},{"line":380,"address":[1979895],"length":1,"stats":{"Line":27}},{"line":382,"address":[4929606,4929811,4929725,4931467],"length":1,"stats":{"Line":107}},{"line":384,"address":[2509084,2510358],"length":1,"stats":{"Line":43}},{"line":385,"address":[4602563,4592032,4592179,4602416],"length":1,"stats":{"Line":42}},{"line":386,"address":[3893706],"length":1,"stats":{"Line":21}},{"line":390,"address":[5199860,5210244],"length":1,"stats":{"Line":26}},{"line":392,"address":[9511810,9490069,9500453,9501250,9500224,9522210,9531600,9521413,9511013,9490866,9521184,9489840,9510784,9500334,9489950,9531829,9521294,9532626,9510894,9531710],"length":1,"stats":{"Line":103}},{"line":393,"address":[3892806,3893039],"length":1,"stats":{"Line":50}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[2533389,2533414],"length":1,"stats":{"Line":50}},{"line":398,"address":[2533535,2533749],"length":1,"stats":{"Line":41}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[8074950,8085334],"length":1,"stats":{"Line":23}},{"line":405,"address":[],"length":0,"stats":{"Line":22}},{"line":411,"address":[9565152,9564160,9562176,9563168,9566144],"length":1,"stats":{"Line":24}},{"line":422,"address":[2521122],"length":1,"stats":{"Line":25}},{"line":423,"address":[4942173,4942114],"length":1,"stats":{"Line":47}},{"line":424,"address":[5227061,5228053],"length":1,"stats":{"Line":19}},{"line":425,"address":[3904527],"length":1,"stats":{"Line":25}},{"line":429,"address":[5227112,5228104],"length":1,"stats":{"Line":21}},{"line":430,"address":[2521346],"length":1,"stats":{"Line":23}},{"line":431,"address":[2521432],"length":1,"stats":{"Line":13}},{"line":435,"address":[],"length":0,"stats":{"Line":45}},{"line":436,"address":[4619268,4618276],"length":1,"stats":{"Line":0}},{"line":440,"address":[8101522,8102584,8101592,8102514],"length":1,"stats":{"Line":43}},{"line":441,"address":[2545061],"length":1,"stats":{"Line":22}},{"line":443,"address":[6597601],"length":1,"stats":{"Line":9}},{"line":448,"address":[3536495,3535584,3535503,3536576],"length":1,"stats":{"Line":29}},{"line":449,"address":[5228480,5227488],"length":1,"stats":{"Line":9}},{"line":451,"address":[1726658],"length":1,"stats":{"Line":4}},{"line":456,"address":[5227574,5228490,5228566,5227498],"length":1,"stats":{"Line":41}},{"line":457,"address":[1726694],"length":1,"stats":{"Line":21}},{"line":459,"address":[3536895,3535903],"length":1,"stats":{"Line":0}},{"line":466,"address":[9562959,9566927,9564943,9565935,9563951],"length":1,"stats":{"Line":20}},{"line":468,"address":[1726723],"length":1,"stats":{"Line":21}},{"line":471,"address":[1726814],"length":1,"stats":{"Line":20}},{"line":477,"address":[3225504],"length":1,"stats":{"Line":22}},{"line":485,"address":[2520873],"length":1,"stats":{"Line":19}},{"line":486,"address":[3225601],"length":1,"stats":{"Line":14}},{"line":491,"address":[3225685,3225622,3225680],"length":1,"stats":{"Line":58}},{"line":503,"address":[5217504,5221164,5219360,5219328,5220657,5218801],"length":1,"stats":{"Line":25}},{"line":505,"address":[1721299],"length":1,"stats":{"Line":23}},{"line":507,"address":[],"length":0,"stats":{"Line":52}},{"line":508,"address":[1987863,1989043],"length":1,"stats":{"Line":52}},{"line":509,"address":[4611598,4609742],"length":1,"stats":{"Line":24}},{"line":510,"address":[2541180,2541350],"length":1,"stats":{"Line":54}},{"line":512,"address":[4609847,4611685],"length":1,"stats":{"Line":25}},{"line":513,"address":[],"length":0,"stats":{"Line":46}},{"line":515,"address":[3527201,3529061],"length":1,"stats":{"Line":22}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[8095139,8095313,8093279,8093453],"length":1,"stats":{"Line":47}},{"line":524,"address":[4610164,4612000],"length":1,"stats":{"Line":20}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[1989311,1989378],"length":1,"stats":{"Line":42}},{"line":533,"address":[6593845],"length":1,"stats":{"Line":0}},{"line":534,"address":[2541659,2541380],"length":1,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[8093845,8092005],"length":1,"stats":{"Line":27}},{"line":542,"address":[4610666,4609031,4608810,4610887,4608904,4610760,4609706,4611562],"length":1,"stats":{"Line":101}},{"line":544,"address":[4938175,4938048,4937964],"length":1,"stats":{"Line":73}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[4609376,4611232],"length":1,"stats":{"Line":24}},{"line":547,"address":[],"length":0,"stats":{"Line":24}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[4938229],"length":1,"stats":{"Line":25}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[4938250,4938333],"length":1,"stats":{"Line":46}},{"line":557,"address":[5218650,5220506],"length":1,"stats":{"Line":1}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[1722406],"length":1,"stats":{"Line":1}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[4611432,4609576],"length":1,"stats":{"Line":1}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[3526422,3528262],"length":1,"stats":{"Line":25}},{"line":572,"address":[2540584],"length":1,"stats":{"Line":24}},{"line":578,"address":[1725360],"length":1,"stats":{"Line":26}},{"line":586,"address":[4617143,4616653,4617037,4616759],"length":1,"stats":{"Line":38}},{"line":588,"address":[3225304],"length":1,"stats":{"Line":12}},{"line":589,"address":[1991892],"length":1,"stats":{"Line":1}},{"line":594,"address":[4941434,4941585,4941608],"length":1,"stats":{"Line":60}},{"line":595,"address":[5226376,5225992],"length":1,"stats":{"Line":11}},{"line":596,"address":[3225462],"length":1,"stats":{"Line":0}},{"line":598,"address":[8100643,8100259],"length":1,"stats":{"Line":0}},{"line":601,"address":[2544206],"length":1,"stats":{"Line":25}},{"line":605,"address":[2504864],"length":1,"stats":{"Line":1}},{"line":606,"address":[],"length":0,"stats":{"Line":1}},{"line":608,"address":[4926034],"length":1,"stats":{"Line":0}},{"line":612,"address":[9481570,9484756,9485778,9483700,9482566],"length":1,"stats":{"Line":1}},{"line":613,"address":[5195932,5194964,5195872,5194910],"length":1,"stats":{"Line":2}},{"line":614,"address":[9485962,9483915,9481754,9482802,9484971],"length":1,"stats":{"Line":1}},{"line":615,"address":[8069373,8070325],"length":1,"stats":{"Line":1}},{"line":616,"address":[6581663],"length":1,"stats":{"Line":1}},{"line":618,"address":[3503766,3504693],"length":1,"stats":{"Line":1}},{"line":621,"address":[8069912,8068856],"length":1,"stats":{"Line":0}}],"covered":202,"coverable":280},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","config.rs"],"content":"use hashbrown::HashMap;\n\nuse crate::op::{NonPrimitiveOpConfig, NonPrimitiveOpType};\n\n/// Configuration for the circuit builder.\n#[derive(Debug)]\npub struct BuilderConfig\u003cF\u003e {\n    /// Enabled non-primitive operation types with their respective configuration.\n    enabled_ops: HashMap\u003cNonPrimitiveOpType, NonPrimitiveOpConfig\u003cF\u003e\u003e,\n}\n\nimpl\u003cF\u003e Default for BuilderConfig\u003cF\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cF\u003e Clone for BuilderConfig\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            enabled_ops: self.enabled_ops.clone(),\n        }\n    }\n}\n\nimpl\u003cF\u003e BuilderConfig\u003cF\u003e {\n    /// Creates a new builder configuration.\n    pub fn new() -\u003e Self {\n        Self {\n            enabled_ops: HashMap::new(),\n        }\n    }\n\n    /// Enables a non-primitive operation type with its configuration.\n    pub fn enable_op(\u0026mut self, op: NonPrimitiveOpType, cfg: NonPrimitiveOpConfig\u003cF\u003e) {\n        self.enabled_ops.insert(op, cfg);\n    }\n\n    /// Checks whether an operation type is enabled.\n    pub fn is_op_enabled(\u0026self, op: \u0026NonPrimitiveOpType) -\u003e bool {\n        self.enabled_ops.contains_key(op)\n    }\n\n    /// Gets the configuration for an operation type, if enabled.\n    pub fn get_op_config(\u0026self, op: \u0026NonPrimitiveOpType) -\u003e Option\u003c\u0026NonPrimitiveOpConfig\u003cF\u003e\u003e {\n        self.enabled_ops.get(op)\n    }\n\n    /// Consumes the config and returns the enabled operations map.\n    pub fn into_enabled_ops(self) -\u003e HashMap\u003cNonPrimitiveOpType, NonPrimitiveOpConfig\u003cF\u003e\u003e {\n        self.enabled_ops\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_baby_bear::BabyBear;\n\n    use super::*;\n    use crate::op::Poseidon2Config;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_builder_config_default() {\n        let config = BuilderConfig::\u003cF\u003e::default();\n        assert!(!config.is_op_enabled(\u0026NonPrimitiveOpType::Poseidon2Perm(\n            Poseidon2Config::BabyBearD4Width16,\n        )));\n    }\n\n    #[test]\n    fn test_builder_config_enable_op() {\n        let mut config = BuilderConfig::\u003cF\u003e::new();\n\n        config.enable_op(\n            NonPrimitiveOpType::Poseidon2Perm(Poseidon2Config::BabyBearD4Width16),\n            NonPrimitiveOpConfig::None,\n        );\n\n        assert!(config.is_op_enabled(\u0026NonPrimitiveOpType::Poseidon2Perm(\n            Poseidon2Config::BabyBearD4Width16,\n        )));\n    }\n}\n","traces":[{"line":13,"address":[7120480],"length":1,"stats":{"Line":1}},{"line":14,"address":[7120488],"length":1,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[7077328,7077392],"length":1,"stats":{"Line":29}},{"line":30,"address":[3267901],"length":1,"stats":{"Line":30}},{"line":35,"address":[4510208],"length":1,"stats":{"Line":14}},{"line":36,"address":[1625410],"length":1,"stats":{"Line":13}},{"line":40,"address":[4017264],"length":1,"stats":{"Line":13}},{"line":41,"address":[1709902],"length":1,"stats":{"Line":17}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[1625296],"length":1,"stats":{"Line":26}},{"line":51,"address":[1625304],"length":1,"stats":{"Line":26}}],"covered":10,"coverable":14},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","errors.rs"],"content":"use alloc::string::String;\n\nuse thiserror::Error;\n\nuse crate::ExprId;\nuse crate::op::NonPrimitiveOpType;\nuse crate::types::NonPrimitiveOpId;\n\n/// Errors that can occur during circuit building/lowering.\n#[derive(Debug, Error)]\npub enum CircuitBuilderError {\n    /// Expression not found in the witness mapping during lowering.\n    #[error(\"Expression {expr_id:?} not found in witness mapping: {context}\")]\n    MissingExprMapping { expr_id: ExprId, context: String },\n\n    /// Non-primitive op received an unexpected number of input expressions.\n    #[error(\"{op} expects exactly {expected} witness expressions, got {got}\")]\n    NonPrimitiveOpArity {\n        op: \u0026'static str,\n        expected: String,\n        got: usize,\n    },\n\n    /// Non-primitive operation referenced by id was not found.\n    #[error(\"Non-primitive operation id {op_id:?} not found\")]\n    MissingNonPrimitiveOp { op_id: NonPrimitiveOpId },\n\n    /// Non-primitive output indices for an op are malformed (duplicates or gaps).\n    #[error(\"Non-primitive output indices malformed for op {op_id:?}: {details}\")]\n    MalformedNonPrimitiveOutputs {\n        op_id: NonPrimitiveOpId,\n        details: String,\n    },\n\n    /// Non-primitive operation exists in the builder but was never anchored in the expression DAG,\n    /// so the lowerer cannot place it in a well-defined execution order.\n    #[error(\"Non-primitive operation {op_id:?} is not anchored in the expression DAG\")]\n    UnanchoredNonPrimitiveOp { op_id: NonPrimitiveOpId },\n\n    /// Non-primitive operation rejected by the active policy/profile.\n    #[error(\"Operation {op:?} is not allowed by the current profile\")]\n    OpNotAllowed { op: NonPrimitiveOpType },\n\n    /// Non-primitive operation is recognized but not implemented in lowering.\n    #[error(\"Operation {op:?} is not implemented in lowering\")]\n    UnsupportedNonPrimitiveOp { op: NonPrimitiveOpType },\n\n    /// Mismatched non-primitive operation configuration\n    #[error(\"Invalid configuration for operation {op:?}\")]\n    InvalidNonPrimitiveOpConfiguration { op: NonPrimitiveOpType },\n\n    /// Merkle-path Poseidon2 rows require a direction bit.\n    #[error(\"Poseidon2Perm merkle_path=true requires mmcs_bit\")]\n    Poseidon2MerkleMissingMmcsBit,\n\n    /// Non-merkle Poseidon2 rows should not have mmcs_bit set.\n    #[error(\"Poseidon2Perm merkle_path=false must not have mmcs_bit (it has no effect)\")]\n    Poseidon2NonMerkleWithMmcsBit,\n\n    /// Poseidon2 configuration mismatch.\n    #[error(\"Poseidon2 config mismatch: expected {expected}, got {got}\")]\n    Poseidon2ConfigMismatch { expected: String, got: String },\n\n    /// Requested bit length exceeds the maximum allowed for binary decomposition.\n    #[error(\"Too many bits for binary decomposition: expected at most {expected}, got {n_bits}\")]\n    BinaryDecompositionTooManyBits { expected: usize, n_bits: usize },\n\n    /// Missing output\n    #[error(\"An output was expected but none was given\")]\n    MissingOutput,\n\n    /// Duplicate tag: a tag with this name was already registered.\n    #[error(\"Duplicate tag: '{tag}' is already registered\")]\n    DuplicateTag { tag: String },\n\n    /// Wrong batch size passed to recursive MMCS verifier: expected one length, got another.\n    #[error(\"Wrong batch size: expected {expected}, got {got}\")]\n    WrongBatchSize { expected: usize, got: usize },\n\n    /// Failed to format openings for MMCS preprocessing; preserves some context.\n    #[error(\"Failed to format openings for operation {op:?}: {details}\")]\n    FormatOpeningsFailed {\n        op: NonPrimitiveOpType,\n        details: String,\n    },\n\n    /// Invalid dimension: expected a specific number of elements.\n    #[error(\"Invalid dimension: expected {expected}, got {actual}\")]\n    InvalidDimension { expected: usize, actual: usize },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","expression_builder.rs"],"content":"//! Expression graph construction and constant pooling.\n//!\n//! The [`ExpressionBuilder`] is the layer for building arithmetic circuits.\n//!\n//! It manages a directed acyclic graph (DAG) of expressions where\n//! - nodes represent field operations,\n//! - edges represent dependencies between expressions.\n\nuse alloc::string::String;\n#[cfg(feature = \"debugging\")]\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::hash::Hash;\n\nuse hashbrown::HashMap;\nuse p3_field::PrimeCharacteristicRing;\n\nuse crate::NonPrimitiveOpType;\nuse crate::expr::{Expr, ExpressionGraph};\nuse crate::types::{ExprId, NonPrimitiveOpId};\n#[cfg(feature = \"debugging\")]\nuse crate::{AllocationEntry, AllocationType};\n\n/// Per-operation counters for profiling expression allocations.\n///\n/// This is only compiled when the `profiling` feature is enabled on the `p3-circuit` crate.\n#[cfg(feature = \"profiling\")]\n#[derive(Debug, Clone, Default)]\npub struct OpCounts {\n    /// Number of public input expressions allocated.\n    pub publics: u64,\n    /// Number of constant expressions allocated.\n    pub consts: u64,\n    /// Number of addition expressions allocated.\n    pub adds: u64,\n    /// Number of subtraction expressions allocated.\n    pub subs: u64,\n    /// Number of multiplication expressions allocated.\n    pub muls: u64,\n    /// Number of division expressions allocated.\n    pub divs: u64,\n    /// Number of non-primitive calls allocated, broken down by type.\n    pub non_primitives: HashMap\u003cNonPrimitiveOpType, u64\u003e,\n}\n\n/// Internal profiling state tracking global and per-scope counts.\n#[cfg(feature = \"profiling\")]\n#[derive(Debug, Default)]\npub struct ProfilingState {\n    pub(crate) global: OpCounts,\n    pub(crate) per_scope: HashMap\u003cString, OpCounts\u003e,\n    /// Dedicated scope stack for profiling so it can be enabled independently of debug assertions.\n    pub(crate) scope_stack: Vec\u003cString\u003e,\n}\n\n#[cfg(feature = \"profiling\")]\nimpl ProfilingState {\n    #[inline]\n    fn bump_with(\u0026mut self, mut f: impl FnMut(\u0026mut OpCounts)) {\n        // Global totals.\n        f(\u0026mut self.global);\n\n        // Per-scope totals (if a scope is active).\n        if let Some(scope) = self.scope_stack.last().cloned() {\n            let entry = self.per_scope.entry(scope).or_default();\n            f(entry);\n        }\n    }\n\n    #[inline]\n    fn bump_const(\u0026mut self) {\n        self.bump_with(|c| c.consts += 1);\n    }\n\n    #[inline]\n    fn bump_public(\u0026mut self) {\n        self.bump_with(|c| c.publics += 1);\n    }\n\n    #[inline]\n    fn bump_add(\u0026mut self) {\n        self.bump_with(|c| c.adds += 1);\n    }\n\n    #[inline]\n    fn bump_sub(\u0026mut self) {\n        self.bump_with(|c| c.subs += 1);\n    }\n\n    #[inline]\n    fn bump_mul(\u0026mut self) {\n        self.bump_with(|c| c.muls += 1);\n    }\n\n    #[inline]\n    fn bump_div(\u0026mut self) {\n        self.bump_with(|c| c.divs += 1);\n    }\n\n    #[inline]\n    fn bump_non_primitive(\u0026mut self, op_type: NonPrimitiveOpType) {\n        // Global totals.\n        *self.global.non_primitives.entry(op_type).or_default() += 1;\n\n        // Per-scope totals (if a scope is active).\n        if let Some(scope) = self.scope_stack.last().cloned() {\n            let entry = self.per_scope.entry(scope).or_default();\n            *entry.non_primitives.entry(op_type).or_default() += 1;\n        }\n    }\n}\n\n/// Manages expression graph construction, constant pooling, and debug instrumentation.\n///\n/// The expression builder provides a high-level interface for constructing arithmetic\n/// circuits as directed acyclic graphs (DAGs).\n///\n/// Each node in the graph represents a field operation or a special value\n/// (constant, public input, witness hint).\n#[derive(Debug)]\npub struct ExpressionBuilder\u003cF\u003e {\n    /// The underlying expression graph storage.\n    ///\n    /// This graph holds all expression nodes in a flat vector, indexed by [`ExprId`].\n    ///\n    /// The graph is append-only: once an expression is added, it never moves or gets\n    /// removed, ensuring stable handles.\n    graph: ExpressionGraph\u003cF\u003e,\n\n    /// Constant deduplication pool.\n    ///\n    /// Maps field values to their unique [`ExprId`] in the graph.\n    ///\n    /// When a constant is requested via [`define_const`](Self::define_const), this pool is checked first.\n    ///\n    /// If the value exists, the cached ID is returned immediately, avoiding duplicate nodes.\n    const_pool: HashMap\u003cF, ExprId\u003e,\n\n    /// Pending equality constraints.\n    ///\n    /// Each entry `(a, b)` represents a constraint that expressions `a` and `b` must\n    /// evaluate to the same value. These constraints are resolved during the lowering\n    /// phase using Union-Find (DSU) to merge witness slots.\n    ///\n    /// Self-connections `(a, a)` are filtered out to avoid unnecessary work.\n    pending_connects: Vec\u003c(ExprId, ExprId)\u003e,\n\n    /// Complete allocation history for debugging.\n    ///\n    /// Tracks every expression added to the graph, including metadata:\n    /// - Allocation type (Const, Add, Mul, etc.)\n    /// - Human-readable label\n    /// - Expression dependencies\n    /// - Scope context\n    ///\n    /// **Only present in debug builds.**\n    #[cfg(feature = \"debugging\")]\n    allocation_log: Vec\u003cAllocationEntry\u003e,\n\n    /// Hierarchical scope stack for organizing allocations.\n    ///\n    /// Users can push/pop named scopes to organize the allocation log into logical\n    /// groups (e.g., \"fibonacci_step\", \"mmcs_verify\", etc.).\n    ///\n    /// The current scope is attached to each allocation.\n    ///\n    /// **Only present in debug builds.**\n    #[cfg(feature = \"debugging\")]\n    scope_stack: Vec\u003cString\u003e,\n\n    /// Optional profiling state for counting allocations by type and scope.\n    ///\n    /// This is only compiled when the `profiling` feature is enabled to avoid\n    /// any runtime overhead in normal builds.\n    #[cfg(feature = \"profiling\")]\n    profiling: ProfilingState,\n}\n\nimpl\u003cF\u003e ExpressionBuilder\u003cF\u003e\nwhere\n    F: Clone + PrimeCharacteristicRing + Eq + Hash,\n{\n    #[inline]\n    pub(crate) fn is_const_zero(\u0026self, id: ExprId) -\u003e bool {\n        matches!(self.graph.get_expr(id), Expr::Const(val) if *val == F::ZERO)\n    }\n\n    #[inline]\n    pub(crate) fn is_const_one(\u0026self, id: ExprId) -\u003e bool {\n        matches!(self.graph.get_expr(id), Expr::Const(val) if *val == F::ONE)\n    }\n\n    #[inline]\n    fn get_const_value(\u0026self, id: ExprId) -\u003e Option\u003cF\u003e {\n        match self.graph.get_expr(id) {\n            Expr::Const(val) =\u003e Some(val.clone()),\n            _ =\u003e None,\n        }\n    }\n\n    /// Creates a new expression builder with zero constant pre-allocated.\n    ///\n    /// The zero constant is always the first node in the graph, accessible via\n    /// [`ExprId::ZERO`].\n    ///\n    /// # Postconditions\n    ///\n    /// After construction:\n    /// - The graph contains exactly one node: `Expr::Const(F::ZERO)`\n    /// - The constant pool contains one entry: `F::ZERO → ExprId::ZERO`\n    /// - All other collections (pending_connects, hints_fillers) are empty\n    pub fn new() -\u003e Self {\n        // Initialize an empty expression graph.\n        let mut graph = ExpressionGraph::new();\n\n        // Pre-allocate the zero constant as the first node.\n        //\n        // This ensures ExprId::ZERO (which is ExprId(0)) always refers to zero.\n        let zero_val = F::ZERO;\n        let zero_id = graph.add_expr(Expr::Const(zero_val.clone()));\n\n        // Pre-populate the constant pool with zero.\n        let const_pool = [(zero_val, zero_id)].into();\n\n        Self {\n            graph,\n            const_pool,\n            pending_connects: Vec::new(),\n            #[cfg(feature = \"debugging\")]\n            allocation_log: Vec::new(),\n            #[cfg(feature = \"debugging\")]\n            scope_stack: Vec::new(),\n            #[cfg(feature = \"profiling\")]\n            profiling: ProfilingState::default(),\n        }\n    }\n\n    /// Adds a constant to the expression graph with automatic deduplication.\n    ///\n    /// If this constant value was previously added, returns the existing [`ExprId`]\n    /// handle instead of creating a duplicate node. This ensures the graph contains\n    /// at most one node per unique constant value.\n    ///\n    /// # Arguments\n    ///\n    /// - `val`: The constant field value to add\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the constant. If `val` was seen before, returns the\n    /// cached ID. Otherwise, creates a new node and returns its ID.\n    ///\n    /// # Debug Behavior\n    ///\n    /// In debug builds, logs the allocation to the allocation log with:\n    /// - Type: `AllocationType::Const`\n    /// - Label: the provided label\n    /// - Dependencies: empty (constants have no dependencies)\n    /// - Scope: the current scope from the scope stack\n    ///\n    /// **Important**: Only new allocations are logged. Returning a cached constant\n    /// does not create a new log entry.\n    pub fn define_const(\u0026mut self, val: F, label: \u0026'static str) -\u003e ExprId {\n        // Check if this constant already exists in the pool.\n        if let Some(\u0026cached_id) = self.const_pool.get(\u0026val) {\n            // Found a cached entry. Return it immediately without allocating.\n            return cached_id;\n        }\n\n        // This is a new constant. Add it to the expression graph.\n        let expr_id = self.graph.add_expr(Expr::Const(val.clone()));\n\n        // Insert into the constant pool for future lookups.\n        self.const_pool.insert(val, expr_id);\n\n        // Count constant allocations when profiling is enabled.\n        #[cfg(feature = \"profiling\")]\n        self.profiling.bump_const();\n\n        // Log the allocation in debug builds only.\n        //\n        // When the `debugging` feature is disabled, this compiles to a no-op.\n        #[cfg(feature = \"debugging\")]\n        self.log_alloc(expr_id, label, || (AllocationType::Const, vec![]));\n        #[cfg(not(feature = \"debugging\"))]\n        self.log_alloc(expr_id, label, || ());\n\n        expr_id\n    }\n\n    /// Adds a public input expression to the graph.\n    ///\n    /// Public inputs are values known to both the prover and verifier. They are\n    /// identified by their position in the public input vector.\n    ///\n    /// **Important**: Unlike constants, public inputs are **not** deduplicated. Each\n    /// call creates a new expression node, even if the position is the same. This is\n    /// intentional: multiple references to the same public input are treated as\n    /// independent expressions that happen to read from the same source.\n    ///\n    /// # Arguments\n    ///\n    /// - `pos`: Zero-based index into the public input vector\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// A new [`ExprId`] handle to the public input expression.\n    pub fn public(\u0026mut self, pos: usize, label: \u0026'static str) -\u003e ExprId {\n        // Create a new Public expression node in the graph.\n        //\n        // The `pos` field indicates which public input slot this expression reads from.\n        let expr_id = self.graph.add_expr(Expr::Public(pos));\n\n        // Count public input allocations when profiling is enabled.\n        #[cfg(feature = \"profiling\")]\n        self.profiling.bump_public();\n\n        // Log the allocation in debug builds.\n        //\n        // Public inputs have no dependencies (they are leaf nodes in the expression DAG).\n        #[cfg(feature = \"debugging\")]\n        self.log_alloc(expr_id, label, || (AllocationType::Public, vec![]));\n        #[cfg(not(feature = \"debugging\"))]\n        self.log_alloc(expr_id, label, || ());\n\n        expr_id\n    }\n\n    /// Adds an addition expression to the graph.\n    ///\n    /// Represents the field addition operation: `result = lhs + rhs`.\n    ///\n    /// # Arguments\n    ///\n    /// - `lhs`: Left operand expression\n    /// - `rhs`: Right operand expression\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the addition expression.\n    pub fn add(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        // x + 0 = x, 0 + x = x\n        if self.is_const_zero(lhs) {\n            return rhs;\n        }\n        if self.is_const_zero(rhs) {\n            return lhs;\n        }\n\n        // Constant folding: const + const = const\n        if let (Some(a), Some(b)) = (self.get_const_value(lhs), self.get_const_value(rhs)) {\n            return self.define_const(a + b, label);\n        }\n\n        #[cfg(feature = \"profiling\")]\n        self.profiling.bump_add();\n\n        self.add_bin_op(\n            Expr::Add { lhs, rhs },\n            label,\n            #[cfg(feature = \"debugging\")]\n            AllocationType::Add,\n            lhs,\n            rhs,\n        )\n    }\n\n    /// Adds a subtraction expression to the graph.\n    ///\n    /// Represents the field subtraction operation: `result = lhs - rhs`.\n    ///\n    /// **Note**: During lowering, subtraction is encoded as an addition row in the ALU table:\n    /// `lhs - rhs = result` becomes `result + rhs = lhs` with the `add` selector enabled.\n    ///\n    /// # Arguments\n    ///\n    /// - `lhs`: Left operand (minuend)\n    /// - `rhs`: Right operand (subtrahend)\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the subtraction expression.\n    pub fn sub(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        // x - 0 = x\n        if self.is_const_zero(rhs) {\n            return lhs;\n        }\n        // x - x = 0\n        if lhs == rhs {\n            return ExprId::ZERO;\n        }\n\n        // Constant folding: const - const = const\n        if let (Some(a), Some(b)) = (self.get_const_value(lhs), self.get_const_value(rhs)) {\n            return self.define_const(a - b, label);\n        }\n\n        #[cfg(feature = \"profiling\")]\n        self.profiling.bump_sub();\n\n        self.add_bin_op(\n            Expr::Sub { lhs, rhs },\n            label,\n            #[cfg(feature = \"debugging\")]\n            AllocationType::Sub,\n            lhs,\n            rhs,\n        )\n    }\n\n    /// Adds a multiplication expression to the graph.\n    ///\n    /// Represents the field multiplication operation: `result = lhs * rhs`.\n    ///\n    /// # Arguments\n    ///\n    /// - `lhs`: Left operand\n    /// - `rhs`: Right operand\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the multiplication expression.\n    pub fn mul(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        // x * 0 = 0, 0 * x = 0\n        if self.is_const_zero(lhs) || self.is_const_zero(rhs) {\n            return ExprId::ZERO;\n        }\n\n        // x * 1 = x, 1 * x = x\n        if self.is_const_one(lhs) {\n            return rhs;\n        }\n        if self.is_const_one(rhs) {\n            return lhs;\n        }\n\n        // Constant folding: const * const = const\n        if let (Some(a), Some(b)) = (self.get_const_value(lhs), self.get_const_value(rhs)) {\n            return self.define_const(a * b, label);\n        }\n\n        #[cfg(feature = \"profiling\")]\n        self.profiling.bump_mul();\n\n        self.add_bin_op(\n            Expr::Mul { lhs, rhs },\n            label,\n            #[cfg(feature = \"debugging\")]\n            AllocationType::Mul,\n            lhs,\n            rhs,\n        )\n    }\n\n    /// Adds a division expression to the graph.\n    ///\n    /// Represents the field division operation: `result = lhs / rhs`.\n    ///\n    /// **Note**: During lowering, division is encoded as a multiplication row in the ALU table:\n    /// `lhs / rhs = result` becomes `result * rhs = lhs` with the `mul` selector enabled.\n    ///\n    /// # Arguments\n    ///\n    /// - `lhs`: Left operand (dividend)\n    /// - `rhs`: Right operand (divisor, must be non-zero)\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the division expression.\n    pub fn div(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        // x / 1 = x\n        if self.is_const_one(rhs) {\n            return lhs;\n        }\n        // 0 / x = 0\n        if self.is_const_zero(lhs) {\n            return ExprId::ZERO;\n        }\n        // x / x = 1\n        if lhs == rhs {\n            return self.define_const(F::ONE, label);\n        }\n\n        #[cfg(feature = \"profiling\")]\n        self.profiling.bump_div();\n\n        self.add_bin_op(\n            Expr::Div { lhs, rhs },\n            label,\n            #[cfg(feature = \"debugging\")]\n            AllocationType::Div,\n            lhs,\n            rhs,\n        )\n    }\n\n    /// Adds a non-primitive output expression to the graph.\n    ///\n    /// This expression represents a value produced by a non-primitive operation.\n    /// The `call` parameter is the `ExprId` of the `NonPrimitiveCall` node, making\n    /// the dependency explicit in the DAG structure.\n    pub fn add_non_primitive_output(\n        \u0026mut self,\n        call: ExprId,\n        output_idx: u32,\n        label: \u0026'static str,\n    ) -\u003e ExprId {\n        let expr_id = self\n            .graph\n            .add_expr(Expr::NonPrimitiveOutput { call, output_idx });\n\n        #[cfg(feature = \"debugging\")]\n        self.log_alloc(expr_id, label, || {\n            (AllocationType::NonPrimitiveOutput, vec![vec![call]])\n        });\n        #[cfg(not(feature = \"debugging\"))]\n        self.log_alloc(expr_id, label, || ());\n\n        expr_id\n    }\n\n    /// Adds a non-primitive call anchor expression to the graph.\n    ///\n    /// This expression has no witness value, but provides an explicit point in the expression DAG\n    /// for the lowerer to emit the non-primitive op in the correct execution order.\n    ///\n    /// The `inputs` parameter contains all input expressions (flattened), making dependencies\n    /// explicit in the DAG structure. For stateful ops with chaining (e.g., `in_ctl=false`),\n    /// `inputs` may be empty since chained values are not in the witness table.\n    #[allow(unused)]\n    pub fn add_non_primitive_call(\n        \u0026mut self,\n        op_id: NonPrimitiveOpId,\n        op_type: NonPrimitiveOpType,\n        inputs: Vec\u003cExprId\u003e,\n        label: \u0026'static str,\n    ) -\u003e ExprId {\n        #[cfg(feature = \"debugging\")]\n        let dependencies: Vec\u003cVec\u003cExprId\u003e\u003e = inputs.iter().map(|\u0026id| vec![id]).collect();\n\n        let expr_id = self\n            .graph\n            .add_expr(Expr::NonPrimitiveCall { op_id, inputs });\n\n        // Count non-primitive calls when profiling is enabled.\n        #[cfg(feature = \"profiling\")]\n        self.profiling.bump_non_primitive(op_type);\n\n        #[cfg(feature = \"debugging\")]\n        self.log_alloc(expr_id, label, || {\n            (AllocationType::NonPrimitiveOp(op_type), dependencies)\n        });\n        #[cfg(not(feature = \"debugging\"))]\n        self.log_alloc(expr_id, label, || ());\n\n        expr_id\n    }\n\n    /// Internal helper for adding binary operations.\n    ///\n    /// # Arguments\n    ///\n    /// - `expr`: The binary expression variant to add (Add/Sub/Mul/Div)\n    /// - `label`: Human-readable label for debug logging\n    /// - `alloc_type`: Allocation type for debug logging (only exists in debug builds)\n    /// - `lhs`: Left operand dependency\n    /// - `rhs`: Right operand dependency\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the newly created expression.\n    #[inline(always)]\n    #[allow(unused_variables)]\n    fn add_bin_op(\n        \u0026mut self,\n        expr: Expr\u003cF\u003e,\n        label: \u0026'static str,\n        #[cfg(feature = \"debugging\")] alloc_type: AllocationType,\n        lhs: ExprId,\n        rhs: ExprId,\n    ) -\u003e ExprId {\n        // Add the expression to the graph.\n        let expr_id = self.graph.add_expr(expr);\n\n        // Log the allocation with dependencies.\n        //\n        // Binary operations have two dependencies: one for lhs, one for rhs.\n        #[cfg(feature = \"debugging\")]\n        self.log_alloc(expr_id, label, || (alloc_type, vec![vec![lhs], vec![rhs]]));\n        #[cfg(not(feature = \"debugging\"))]\n        self.log_alloc(expr_id, label, || ());\n\n        expr_id\n    }\n\n    /// Enforces equality between two expressions.\n    ///\n    /// Adds a pending constraint that expressions `a` and `b` must evaluate to\n    /// the same value. During the lowering phase, these constraints are resolved\n    /// using Union-Find (DSU) to merge the witness slots for `a` and `b`.\n    ///\n    /// # Arguments\n    ///\n    /// - `a`: First expression\n    /// - `b`: Second expression\n    ///\n    /// # Self-Connection Optimization\n    ///\n    /// If `a == b` (same expression), this is a no-op. No constraint is added\n    /// because an expression is trivially equal to itself.\n    ///\n    /// # Constraint Resolution\n    ///\n    /// Constraints are not resolved immediately. They are stored in the\n    /// `pending_connects` vector and processed during circuit compilation.\n    pub fn connect(\u0026mut self, a: ExprId, b: ExprId) {\n        // Skip self-connections as they are trivially satisfied.\n        if a != b {\n            self.pending_connects.push((a, b));\n        }\n    }\n\n    /// Returns an immutable reference to the underlying expression graph.\n    ///\n    /// The graph provides access to all expression nodes and their relationships.\n    ///\n    /// # Returns\n    ///\n    /// A reference to the [`ExpressionGraph`] containing all expressions.\n    #[inline]\n    pub const fn graph(\u0026self) -\u003e \u0026ExpressionGraph\u003cF\u003e {\n        \u0026self.graph\n    }\n\n    /// Returns a slice of pending equality constraints.\n    ///\n    /// Each constraint `(a, b)` represents an assertion that expressions `a` and `b`\n    /// must evaluate to the same value.\n    ///\n    /// # Returns\n    ///\n    /// A slice of `(ExprId, ExprId)` pairs representing pending connections.\n    #[inline]\n    pub fn pending_connects(\u0026self) -\u003e \u0026[(ExprId, ExprId)] {\n        \u0026self.pending_connects\n    }\n\n    /// Centralized logging helper for debug builds.\n    ///\n    /// # Arguments\n    ///\n    /// - `id`: The expression ID being logged\n    /// - `label`: Human-readable label\n    /// - `info_fn`: Closure that produces allocation metadata **only when needed**\n    #[cfg(feature = \"debugging\")]\n    #[inline(always)]\n    fn log_alloc\u003cInfo\u003e(\u0026mut self, id: ExprId, label: \u0026'static str, info_fn: Info)\n    where\n        Info: FnOnce() -\u003e (AllocationType, Vec\u003cVec\u003cExprId\u003e\u003e),\n    {\n        // Execute the closure to get allocation metadata.\n        let (alloc_type, dependencies) = info_fn();\n\n        // Capture the current scope from the stack.\n        let scope = self.scope_stack.last().cloned();\n\n        // Add an entry to the allocation log.\n        self.allocation_log.push(AllocationEntry {\n            expr_id: id,\n            alloc_type,\n            label,\n            dependencies,\n            scope,\n        });\n    }\n\n    /// No-op logging helper for release builds.\n    #[cfg(not(feature = \"debugging\"))]\n    #[inline(always)]\n    #[allow(clippy::needless_pass_by_ref_mut)]\n    fn log_alloc\u003cInfo\u003e(\u0026mut self, _id: ExprId, _label: \u0026'static str, _info_fn: Info)\n    where\n        Info: FnOnce(),\n    {\n        // Intentionally empty - compiles to nothing in release builds.\n    }\n\n    /// Logs a non-primitive operation allocation (debug builds only).\n    ///\n    /// Non-primitive operations (MMCS, FRI, Poseidon2, etc.) are not part of the\n    /// standard expression types but need to be tracked in the allocation log.\n    ///\n    /// # Arguments\n    ///\n    /// - `op_id`: The non-primitive operation ID\n    /// - `op_type`: The type of operation (e.g., `NonPrimitiveOpType::MmcsVerify`)\n    /// - `input_deps`: Input expression dependencies for this operation\n    /// - `output_deps`: Output expression dependencies for this operation\n    /// - `label`: Human-readable label\n    #[cfg(feature = \"debugging\")]\n    pub fn log_non_primitive_op(\n        \u0026mut self,\n        op_id: crate::types::NonPrimitiveOpId,\n        op_type: crate::op::NonPrimitiveOpType,\n        input_deps: Vec\u003cVec\u003cExprId\u003e\u003e,\n        output_deps: Vec\u003cVec\u003cExprId\u003e\u003e,\n        label: \u0026'static str,\n    ) {\n        // Capture the current scope.\n        let scope = self.scope_stack.last().cloned();\n\n        // Combine inputs and outputs for dependency tracking.\n        // Use a separator to distinguish inputs from outputs in the log.\n        let mut dependencies = input_deps;\n        dependencies.extend(output_deps);\n\n        // Add to allocation log.\n        //\n        // Non-primitive operations are stored with a special allocation type\n        // that includes the operation variant.\n        self.allocation_log.push(AllocationEntry {\n            expr_id: ExprId(op_id.0),\n            alloc_type: AllocationType::NonPrimitiveOp(op_type),\n            label,\n            dependencies,\n            scope,\n        });\n    }\n\n    /// Pushes a new scope onto the scope stack (debug builds only).\n    ///\n    /// Scopes provide hierarchical organization for the allocation log. Subsequent\n    /// allocations will be tagged with this scope until it is popped.\n    ///\n    /// # Arguments\n    ///\n    /// - `scope`: Human-readable scope name\n    #[allow(unused_variables)]\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn push_scope(\u0026mut self, scope: \u0026str) {\n        #[cfg(any(feature = \"debugging\", feature = \"profiling\"))]\n        {\n            let scope = String::from(scope);\n            #[cfg(all(feature = \"debugging\", feature = \"profiling\"))]\n            {\n                // When both features are enabled, clone once and use for both\n                let scope_clone = scope.clone();\n                self.scope_stack.push(scope_clone);\n                self.profiling.scope_stack.push(scope);\n            }\n            #[cfg(all(feature = \"debugging\", not(feature = \"profiling\")))]\n            {\n                self.scope_stack.push(scope);\n            }\n            #[cfg(all(feature = \"profiling\", not(feature = \"debugging\")))]\n            {\n                self.profiling.scope_stack.push(scope);\n            }\n        }\n    }\n\n    /// Pops the current scope from the scope stack (debug builds only).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the scope stack is empty (mismatched push/pop).\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn pop_scope(\u0026mut self) {\n        #[cfg(feature = \"debugging\")]\n        self.scope_stack.pop();\n        #[cfg(feature = \"profiling\")]\n        self.profiling.scope_stack.pop();\n    }\n\n    /// Returns the current scope (debug builds only).\n    ///\n    /// Returns the name of the most recently pushed scope, or `None` if no scope is active.\n    ///\n    /// # Returns\n    ///\n    /// - `Some(\u0026'static str)` - The name of the current scope\n    /// - `None` - No active scope\n    #[cfg(feature = \"debugging\")]\n    pub fn current_scope(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.scope_stack.last().map(|s| s.as_str())\n    }\n\n    /// Returns a reference to the allocation log (debug builds only).\n    ///\n    /// Provides read-only access to all allocation entries recorded during circuit\n    /// construction. Useful for testing and verifying allocation behavior.\n    ///\n    /// # Returns\n    ///\n    /// A slice of [`AllocationEntry`] containing all recorded allocations.\n    #[cfg(feature = \"debugging\")]\n    pub fn allocation_log(\u0026self) -\u003e \u0026[AllocationEntry] {\n        \u0026self.allocation_log\n    }\n\n    /// Dumps the allocation log for specific `ExprId`s.\n    ///\n    /// If debug_assertions are not enabled, this is a no-op.\n    #[allow(clippy::missing_const_for_fn)]\n    #[allow(unused_variables)]\n    pub fn dump_expr_ids(\u0026self, expr_ids: \u0026[ExprId]) {\n        #[cfg(feature = \"debugging\")]\n        crate::alloc_entry::dump_expr_ids(\u0026self.allocation_log, expr_ids);\n    }\n\n    /// Dumps the allocation log to stdout (debug builds only).\n    ///\n    /// Prints a formatted view of all allocations, including their types, labels,\n    /// dependencies, and scopes. Useful for debugging circuit construction.\n    ///\n    /// # Output\n    ///\n    /// In debug builds, outputs a detailed allocation report. In release builds,\n    /// this method does nothing.\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn dump_allocation_log(\u0026self) {\n        #[cfg(feature = \"debugging\")]\n        crate::alloc_entry::dump_allocation_log(\u0026self.allocation_log);\n    }\n\n    /// Lists all unique scopes in the allocation log.\n    ///\n    /// Returns a vector of scope names that appear in the allocation log,\n    /// with duplicates removed.\n    ///\n    /// # Returns\n    ///\n    /// - **Debug builds**: Vector of unique scope names\n    /// - **Release builds**: Empty vector (no scopes tracked)\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn list_scopes(\u0026self) -\u003e Vec\u003cString\u003e {\n        #[cfg(feature = \"debugging\")]\n        {\n            crate::alloc_entry::list_scopes(\u0026self.allocation_log)\n        }\n        #[cfg(not(feature = \"debugging\"))]\n        {\n            Vec::new()\n        }\n    }\n\n    /// Returns the global and per-scope operation counts when profiling is enabled.\n    #[cfg(feature = \"profiling\")]\n    pub const fn profiling_counts(\u0026self) -\u003e (\u0026OpCounts, \u0026HashMap\u003cString, OpCounts\u003e) {\n        (\u0026self.profiling.global, \u0026self.profiling.per_scope)\n    }\n}\n\nimpl\u003cF\u003e Default for ExpressionBuilder\u003cF\u003e\nwhere\n    F: Clone + PrimeCharacteristicRing + Eq + Hash,\n{\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_baby_bear::BabyBear;\n\n    use super::*;\n    #[cfg(feature = \"debugging\")]\n    use crate::alloc::string::ToString;\n\n    #[test]\n    fn test_new_builder_has_zero_constant() {\n        // New builder should pre-allocate zero constant\n        let builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        // Zero should be in the graph at ExprId::ZERO\n        assert_eq!(builder.graph().nodes().len(), 1);\n        match \u0026builder.graph().nodes()[0] {\n            Expr::Const(val) =\u003e assert_eq!(*val, BabyBear::ZERO),\n            _ =\u003e panic!(\"Expected Const(0) at ExprId::ZERO\"),\n        }\n\n        // Const pool should contain zero\n        let mut expected_const_pool = HashMap::new();\n        expected_const_pool.insert(BabyBear::ZERO, ExprId::ZERO);\n        assert_eq!(builder.const_pool, expected_const_pool);\n\n        // No pending connections\n        assert!(builder.pending_connects.is_empty());\n    }\n\n    #[test]\n    fn test_add_const_single() {\n        // Adding a single constant should work\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let c1 = builder.define_const(BabyBear::ONE, \"test_const\");\n\n        // Should have 2 nodes: zero + one\n        assert_eq!(builder.graph().nodes().len(), 2);\n        assert_eq!(c1, ExprId(1));\n\n        // Verify the constant was added to graph\n        match \u0026builder.graph().nodes()[1] {\n            Expr::Const(val) =\u003e assert_eq!(*val, BabyBear::ONE),\n            _ =\u003e panic!(\"Expected Const(1)\"),\n        }\n\n        // Const pool should have both zero and one\n        assert_eq!(builder.const_pool.len(), 2);\n    }\n\n    #[test]\n    fn test_add_const_deduplication() {\n        // Adding the same constant twice should return same ExprId\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let c1 = builder.define_const(BabyBear::from_u64(42), \"first\");\n        let c2 = builder.define_const(BabyBear::from_u64(42), \"second\");\n\n        // Should return same ExprId\n        assert_eq!(c1, c2);\n\n        // Should only have 2 nodes (zero + 42), not 3\n        assert_eq!(builder.graph().nodes().len(), 2);\n\n        // Const pool should only have 2 entries\n        assert_eq!(builder.const_pool.len(), 2);\n    }\n\n    #[test]\n    fn test_add_const_multiple_different() {\n        // Adding different constants should create distinct ExprIds\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let c1 = builder.define_const(BabyBear::from_u64(1), \"one\");\n        let c2 = builder.define_const(BabyBear::from_u64(2), \"two\");\n        let c3 = builder.define_const(BabyBear::from_u64(3), \"three\");\n\n        // All should be different\n        assert_ne!(c1, c2);\n        assert_ne!(c2, c3);\n        assert_ne!(c1, c3);\n\n        // Should have 4 nodes: zero + 1 + 2 + 3\n        assert_eq!(builder.graph().nodes().len(), 4);\n        assert_eq!(builder.const_pool.len(), 4);\n    }\n\n    #[test]\n    fn test_add_const_zero_deduplicates_with_prealloc() {\n        // Adding zero constant should return pre-allocated ExprId::ZERO\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let zero = builder.define_const(BabyBear::ZERO, \"explicit_zero\");\n\n        // Should return ExprId::ZERO (the pre-allocated one)\n        assert_eq!(zero, ExprId::ZERO);\n\n        // Should still have only 1 node\n        assert_eq!(builder.graph().nodes().len(), 1);\n        assert_eq!(builder.const_pool.len(), 1);\n    }\n\n    #[test]\n    fn test_add_public_single() {\n        // Adding a single public input\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let p0 = builder.public(0, \"public_0\");\n\n        // Should have 2 nodes: zero + public\n        assert_eq!(builder.graph().nodes().len(), 2);\n        assert_eq!(p0, ExprId(1));\n\n        // Verify it's a Public node\n        match \u0026builder.graph().nodes()[1] {\n            Expr::Public(pos) =\u003e assert_eq!(*pos, 0),\n            _ =\u003e panic!(\"Expected Public(0)\"),\n        }\n    }\n\n    #[test]\n    fn test_add_public_multiple() {\n        // Adding multiple public inputs with different positions\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let p0 = builder.public(0, \"p0\");\n        let p1 = builder.public(1, \"p1\");\n        let p2 = builder.public(2, \"p2\");\n\n        // All should be different\n        assert_ne!(p0, p1);\n        assert_ne!(p1, p2);\n\n        // Should have 4 nodes: zero + 3 publics\n        assert_eq!(builder.graph().nodes().len(), 4);\n\n        // Verify positions\n        match \u0026builder.graph().nodes()[1] {\n            Expr::Public(pos) =\u003e assert_eq!(*pos, 0),\n            _ =\u003e panic!(\"Expected Public(0)\"),\n        }\n        match \u0026builder.graph().nodes()[2] {\n            Expr::Public(pos) =\u003e assert_eq!(*pos, 1),\n            _ =\u003e panic!(\"Expected Public(1)\"),\n        }\n        match \u0026builder.graph().nodes()[3] {\n            Expr::Public(pos) =\u003e assert_eq!(*pos, 2),\n            _ =\u003e panic!(\"Expected Public(2)\"),\n        }\n    }\n\n    #[test]\n    fn test_add_public_same_position_creates_different_nodes() {\n        // Adding public inputs with same position creates different nodes\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let p0_a = builder.public(0, \"first\");\n        let p0_b = builder.public(0, \"second\");\n\n        // Should be different ExprIds (no deduplication for Public)\n        assert_ne!(p0_a, p0_b);\n\n        // Should have 3 nodes\n        assert_eq!(builder.graph().nodes().len(), 3);\n    }\n\n    #[test]\n    fn test_add_operation() {\n        // Test Add operation with non-constant operands (constant folding applies to const+const)\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.public(0, \"a\");\n        let b = builder.public(1, \"b\");\n        let _sum = builder.add(a, b, \"sum\");\n\n        // Should have 4 nodes: zero + pub_a + pub_b + add\n        assert_eq!(builder.graph().nodes().len(), 4);\n\n        // Verify Add node\n        match \u0026builder.graph().nodes()[3] {\n            Expr::Add { lhs, rhs } =\u003e {\n                assert_eq!(*lhs, a);\n                assert_eq!(*rhs, b);\n            }\n            _ =\u003e panic!(\"Expected Add operation\"),\n        }\n    }\n\n    #[test]\n    fn test_add_const_folding() {\n        // Test that const + const is folded at build time\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.define_const(BabyBear::from_u64(2), \"a\");\n        let b = builder.define_const(BabyBear::from_u64(3), \"b\");\n        let sum = builder.add(a, b, \"sum\");\n\n        // Should have 4 nodes: zero + 2 + 3 + 5 (folded constant, no Add node)\n        assert_eq!(builder.graph().nodes().len(), 4);\n        match \u0026builder.graph().nodes()[sum.0 as usize] {\n            Expr::Const(val) =\u003e assert_eq!(*val, BabyBear::from_u64(5)),\n            _ =\u003e panic!(\"Expected constant folding to produce Const(5)\"),\n        }\n    }\n\n    #[test]\n    fn test_sub_operation() {\n        // Test Sub operation with non-constant operands\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.public(0, \"a\");\n        let b = builder.public(1, \"b\");\n        let _diff = builder.sub(a, b, \"diff\");\n\n        assert_eq!(builder.graph().nodes().len(), 4);\n\n        match \u0026builder.graph().nodes()[3] {\n            Expr::Sub { lhs, rhs } =\u003e {\n                assert_eq!(*lhs, a);\n                assert_eq!(*rhs, b);\n            }\n            _ =\u003e panic!(\"Expected Sub operation\"),\n        }\n    }\n\n    #[test]\n    fn test_sub_const_folding() {\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.define_const(BabyBear::from_u64(5), \"a\");\n        let b = builder.define_const(BabyBear::from_u64(3), \"b\");\n        let diff = builder.sub(a, b, \"diff\");\n\n        match \u0026builder.graph().nodes()[diff.0 as usize] {\n            Expr::Const(val) =\u003e assert_eq!(*val, BabyBear::from_u64(2)),\n            _ =\u003e panic!(\"Expected constant folding to produce Const(2)\"),\n        }\n    }\n\n    #[test]\n    fn test_sub_identity() {\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n        let a = builder.public(0, \"a\");\n        let zero = builder.define_const(BabyBear::ZERO, \"zero\");\n\n        // x - 0 = x\n        assert_eq!(builder.sub(a, zero, \"sub_zero\"), a);\n        // x - x = 0\n        assert_eq!(builder.sub(a, a, \"sub_self\"), ExprId::ZERO);\n    }\n\n    #[test]\n    fn test_mul_operation() {\n        // Test Mul operation with non-constant operands\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.public(0, \"a\");\n        let b = builder.public(1, \"b\");\n        let _prod = builder.mul(a, b, \"prod\");\n\n        assert_eq!(builder.graph().nodes().len(), 4);\n\n        match \u0026builder.graph().nodes()[3] {\n            Expr::Mul { lhs, rhs } =\u003e {\n                assert_eq!(*lhs, a);\n                assert_eq!(*rhs, b);\n            }\n            _ =\u003e panic!(\"Expected Mul operation\"),\n        }\n    }\n\n    #[test]\n    fn test_mul_const_folding() {\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.define_const(BabyBear::from_u64(7), \"a\");\n        let b = builder.define_const(BabyBear::from_u64(6), \"b\");\n        let prod = builder.mul(a, b, \"prod\");\n\n        match \u0026builder.graph().nodes()[prod.0 as usize] {\n            Expr::Const(val) =\u003e assert_eq!(*val, BabyBear::from_u64(42)),\n            _ =\u003e panic!(\"Expected constant folding to produce Const(42)\"),\n        }\n    }\n\n    #[test]\n    fn test_div_operation() {\n        // Test Div operation\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.define_const(BabyBear::from_u64(10), \"a\");\n        let b = builder.define_const(BabyBear::from_u64(2), \"b\");\n        let _quot = builder.div(a, b, \"quot\");\n\n        assert_eq!(builder.graph().nodes().len(), 4);\n\n        match \u0026builder.graph().nodes()[3] {\n            Expr::Div { lhs, rhs } =\u003e {\n                assert_eq!(*lhs, a);\n                assert_eq!(*rhs, b);\n            }\n            _ =\u003e panic!(\"Expected Div operation\"),\n        }\n    }\n\n    #[test]\n    fn test_div_identity() {\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n        let a = builder.public(0, \"a\");\n        let one = builder.define_const(BabyBear::ONE, \"one\");\n        let zero = ExprId::ZERO;\n\n        // x / 1 = x\n        assert_eq!(builder.div(a, one, \"div_one\"), a);\n        // 0 / x = 0\n        assert_eq!(builder.div(zero, a, \"zero_div\"), ExprId::ZERO);\n        // x / x = 1\n        let result = builder.div(a, a, \"div_self\");\n        match builder.graph().get_expr(result) {\n            Expr::Const(val) =\u003e assert_eq!(*val, BabyBear::ONE),\n            _ =\u003e panic!(\"Expected div(x,x) to produce Const(1)\"),\n        }\n    }\n\n    #[test]\n    fn test_nested_operations() {\n        // Test nested operations with non-constant inputs: (a + b) * (c - d)\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.public(0, \"a\");\n        let b = builder.public(1, \"b\");\n        let c = builder.public(2, \"c\");\n        let d = builder.public(3, \"d\");\n\n        let sum = builder.add(a, b, \"sum\");\n        let diff = builder.sub(c, d, \"diff\");\n        let _prod = builder.mul(sum, diff, \"prod\");\n\n        // zero + 4 publics + 3 ops = 8 nodes\n        assert_eq!(builder.graph().nodes().len(), 8);\n\n        // Verify final operation references intermediate results\n        match \u0026builder.graph().nodes()[7] {\n            Expr::Mul { lhs, rhs } =\u003e {\n                assert_eq!(*lhs, sum);\n                assert_eq!(*rhs, diff);\n            }\n            _ =\u003e panic!(\"Expected Mul operation\"),\n        }\n    }\n\n    #[test]\n    fn test_nested_const_folding() {\n        // Constant folding should chain: (1+2) * (3-4) = 3 * (-1) = -3\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.define_const(BabyBear::from_u64(1), \"a\");\n        let b = builder.define_const(BabyBear::from_u64(2), \"b\");\n        let c = builder.define_const(BabyBear::from_u64(3), \"c\");\n        let d = builder.define_const(BabyBear::from_u64(4), \"d\");\n\n        // folded to Const(3) — same as c, deduplicated\n        let sum = builder.add(a, b, \"sum\");\n        // folded to Const(-1)\n        let diff = builder.sub(c, d, \"diff\");\n        // folded to Const(-3)\n        let prod = builder.mul(sum, diff, \"prod\");\n\n        // All intermediates are constant-folded\n        match \u0026builder.graph().nodes()[prod.0 as usize] {\n            Expr::Const(val) =\u003e assert_eq!(*val, -BabyBear::from_u64(3)),\n            _ =\u003e panic!(\"Expected full constant folding\"),\n        }\n    }\n\n    #[test]\n    fn test_connect_different_expressions() {\n        // Connecting different expressions should add to pending_connects\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.define_const(BabyBear::ONE, \"a\");\n        let b = builder.define_const(BabyBear::from_u64(2), \"b\");\n\n        builder.connect(a, b);\n\n        // Should have one pending connection\n        assert_eq!(builder.pending_connects.len(), 1);\n        assert_eq!(builder.pending_connects[0], (a, b));\n    }\n\n    #[test]\n    fn test_connect_same_expression_no_op() {\n        // Connecting an expression to itself should be a no-op\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.define_const(BabyBear::ONE, \"a\");\n\n        builder.connect(a, a);\n\n        // Should not add to pending_connects\n        assert!(builder.pending_connects.is_empty());\n    }\n\n    #[test]\n    fn test_connect_multiple() {\n        // Multiple connections should all be tracked\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.define_const(BabyBear::from_u64(1), \"a\");\n        let b = builder.define_const(BabyBear::from_u64(2), \"b\");\n        let c = builder.define_const(BabyBear::from_u64(3), \"c\");\n\n        builder.connect(a, b);\n        builder.connect(b, c);\n\n        assert_eq!(builder.pending_connects.len(), 2);\n        assert_eq!(builder.pending_connects[0], (a, b));\n        assert_eq!(builder.pending_connects[1], (b, c));\n    }\n\n    #[test]\n    fn test_connect_with_operations() {\n        // Can connect operation results\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.define_const(BabyBear::ONE, \"a\");\n        let b = builder.define_const(BabyBear::from_u64(2), \"b\");\n        let sum = builder.add(a, b, \"sum\");\n        let c = builder.public(0, \"c\");\n\n        builder.connect(sum, c);\n\n        assert_eq!(builder.pending_connects.len(), 1);\n        assert_eq!(builder.pending_connects[0], (sum, c));\n    }\n\n    #[test]\n    fn test_graph_accessor() {\n        // graph() should return reference to underlying graph\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        builder.define_const(BabyBear::ONE, \"one\");\n\n        let graph = builder.graph();\n        assert_eq!(graph.nodes().len(), 2); // zero + one\n    }\n\n    #[test]\n    fn test_pending_connects_accessor() {\n        // pending_connects() should return slice of connections\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.define_const(BabyBear::ONE, \"a\");\n        let b = builder.define_const(BabyBear::from_u64(2), \"b\");\n\n        builder.connect(a, b);\n\n        let connects = builder.pending_connects();\n        assert_eq!(connects.len(), 1);\n        assert_eq!(connects[0], (a, b));\n    }\n\n    #[test]\n    #[cfg(feature = \"debugging\")]\n    fn test_scope_stack() {\n        // Test scope push/pop functionality\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        // Initially no scope\n        assert!(builder.current_scope().is_none());\n\n        // Push a scope\n        builder.push_scope(\"test_scope\");\n        assert_eq!(builder.current_scope(), Some(\"test_scope\"));\n\n        // Push nested scope\n        builder.push_scope(\"nested_scope\");\n        assert_eq!(builder.current_scope(), Some(\"nested_scope\"));\n\n        // Pop scope\n        builder.pop_scope();\n        assert_eq!(builder.current_scope(), Some(\"test_scope\"));\n\n        // Pop last scope\n        builder.pop_scope();\n        assert!(builder.current_scope().is_none());\n    }\n\n    #[test]\n    #[cfg(feature = \"debugging\")]\n    fn test_allocation_log() {\n        // Allocation log should track all allocations\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        // Initial log has zero const\n        assert_eq!(builder.allocation_log().len(), 0); // Zero is pre-allocated without logging\n\n        // Add a const\n        builder.define_const(BabyBear::ONE, \"test_const\");\n        assert_eq!(builder.allocation_log().len(), 1);\n\n        // Add a public\n        builder.public(0, \"test_public\");\n        assert_eq!(builder.allocation_log().len(), 2);\n\n        // Add an operation\n        let a = builder.define_const(BabyBear::from_u64(2), \"a\");\n        let b = builder.define_const(BabyBear::from_u64(3), \"b\");\n        builder.add(a, b, \"sum\");\n        assert_eq!(builder.allocation_log().len(), 5); // +3 more (2 consts + 1 add)\n    }\n\n    #[test]\n    #[cfg(feature = \"debugging\")]\n    fn test_list_scopes() {\n        // list_scopes should return unique scopes\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        builder.push_scope(\"scope_a\");\n        builder.define_const(BabyBear::ONE, \"in_a\");\n\n        builder.push_scope(\"scope_b\");\n        builder.define_const(BabyBear::from_u64(2), \"in_b\");\n\n        builder.pop_scope();\n        builder.define_const(BabyBear::from_u64(3), \"in_a_again\");\n\n        let scopes = builder.list_scopes();\n        assert!(scopes.contains(\u0026(\"scope_a\".to_string())));\n        assert!(scopes.contains(\u0026(\"scope_b\".to_string())));\n    }\n\n    #[test]\n    #[cfg(not(debug_assertions))]\n    fn test_list_scopes_release() {\n        // In release mode, list_scopes should return empty vec\n        let builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n        assert!(builder.list_scopes().is_empty());\n    }\n}\n","traces":[{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[1494640,1494770],"length":1,"stats":{"Line":26}},{"line":185,"address":[6100589,6100736],"length":1,"stats":{"Line":48}},{"line":189,"address":[3444432,3444566],"length":1,"stats":{"Line":26}},{"line":190,"address":[],"length":0,"stats":{"Line":45}},{"line":194,"address":[],"length":0,"stats":{"Line":27}},{"line":195,"address":[10458783,10458493,10458621,10459135,10458975],"length":1,"stats":{"Line":28}},{"line":196,"address":[3893785],"length":1,"stats":{"Line":22}},{"line":197,"address":[3893814],"length":1,"stats":{"Line":27}},{"line":212,"address":[],"length":0,"stats":{"Line":34}},{"line":214,"address":[7171729,7172353],"length":1,"stats":{"Line":31}},{"line":219,"address":[],"length":0,"stats":{"Line":32}},{"line":220,"address":[10466626,10466674,10468515,10468580,10469165,10467923,10467988,10469117,10467309,10467357],"length":1,"stats":{"Line":62}},{"line":223,"address":[3886342],"length":1,"stats":{"Line":29}},{"line":228,"address":[10468192,10467604,10466976,10469410,10468784],"length":1,"stats":{"Line":30}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[5222599,5222997,5222256,5222624],"length":1,"stats":{"Line":25}},{"line":266,"address":[3188665,3188739,3189043,3189121],"length":1,"stats":{"Line":46}},{"line":268,"address":[3893122],"length":1,"stats":{"Line":19}},{"line":272,"address":[3037800,3037424,3037448,3037841],"length":1,"stats":{"Line":45}},{"line":275,"address":[1621686],"length":1,"stats":{"Line":20}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[3893294],"length":1,"stats":{"Line":24}},{"line":310,"address":[3164032],"length":1,"stats":{"Line":25}},{"line":314,"address":[],"length":0,"stats":{"Line":24}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[5225088,5224240,5225479,5224799],"length":1,"stats":{"Line":27}},{"line":346,"address":[3160451],"length":1,"stats":{"Line":29}},{"line":347,"address":[],"length":0,"stats":{"Line":17}},{"line":349,"address":[3445396],"length":1,"stats":{"Line":25}},{"line":350,"address":[3522870],"length":1,"stats":{"Line":12}},{"line":354,"address":[3522879,3522841,3523023],"length":1,"stats":{"Line":39}},{"line":355,"address":[3190656],"length":1,"stats":{"Line":13}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[5225715,5225063],"length":1,"stats":{"Line":24}},{"line":362,"address":[1495424],"length":1,"stats":{"Line":24}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[3887345,3886784],"length":1,"stats":{"Line":20}},{"line":389,"address":[6103670],"length":1,"stats":{"Line":20}},{"line":390,"address":[3525576],"length":1,"stats":{"Line":1}},{"line":393,"address":[5228339],"length":1,"stats":{"Line":20}},{"line":394,"address":[5228413],"length":1,"stats":{"Line":2}},{"line":398,"address":[1497091,1497038,1497197],"length":1,"stats":{"Line":31}},{"line":399,"address":[5228638],"length":1,"stats":{"Line":10}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[3194467,3194291],"length":1,"stats":{"Line":43}},{"line":406,"address":[1497354],"length":1,"stats":{"Line":20}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[3041738,3042000,3042608,3041296],"length":1,"stats":{"Line":25}},{"line":430,"address":[3042067,3041361],"length":1,"stats":{"Line":25}},{"line":431,"address":[3885375],"length":1,"stats":{"Line":13}},{"line":435,"address":[3524084],"length":1,"stats":{"Line":25}},{"line":436,"address":[3895311],"length":1,"stats":{"Line":14}},{"line":438,"address":[10465984,10462517,10463413,10464304,10465013],"length":1,"stats":{"Line":26}},{"line":439,"address":[3191735],"length":1,"stats":{"Line":16}},{"line":443,"address":[1495859,1495809,1495966],"length":1,"stats":{"Line":35}},{"line":444,"address":[3041662,3042433],"length":1,"stats":{"Line":8}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[5227016],"length":1,"stats":{"Line":26}},{"line":451,"address":[7171489,7170611],"length":1,"stats":{"Line":25}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":9}},{"line":478,"address":[3161276],"length":1,"stats":{"Line":10}},{"line":479,"address":[3191196],"length":1,"stats":{"Line":4}},{"line":482,"address":[3161293],"length":1,"stats":{"Line":9}},{"line":483,"address":[3884978],"length":1,"stats":{"Line":1}},{"line":486,"address":[5225833],"length":1,"stats":{"Line":10}},{"line":487,"address":[3446493],"length":1,"stats":{"Line":4}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[3041225,3041068],"length":1,"stats":{"Line":20}},{"line":494,"address":[3161373],"length":1,"stats":{"Line":9}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[3039264],"length":1,"stats":{"Line":17}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[3039309],"length":1,"stats":{"Line":15}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[3039120],"length":1,"stats":{"Line":17}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[3893903],"length":1,"stats":{"Line":14}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[3892816],"length":1,"stats":{"Line":0}},{"line":589,"address":[3162375,3161444,3163857,3159007,3161078],"length":1,"stats":{"Line":81}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[6104624],"length":1,"stats":{"Line":28}},{"line":624,"address":[10474485,10474325,10474405,10474645,10474565],"length":1,"stats":{"Line":24}},{"line":625,"address":[1625106],"length":1,"stats":{"Line":29}},{"line":637,"address":[3526336],"length":1,"stats":{"Line":28}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[3893840],"length":1,"stats":{"Line":27}},{"line":651,"address":[3522421],"length":1,"stats":{"Line":29}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[3045456,3045424,3045648,3045616,3045520,3045488,3045552,3045584],"length":1,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[3160096],"length":1,"stats":{"Line":3}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}}],"covered":72,"coverable":189},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","mod.rs"],"content":"//! Circuit builder module with specialized sub-components.\n\nmod circuit_builder;\npub mod compiler;\nmod config;\nmod errors;\nmod expression_builder;\nmod public_input_tracker;\n\npub use circuit_builder::{CircuitBuilder, NonPrimitiveOpParams, NonPrimitiveOperationData};\npub use config::BuilderConfig;\npub use errors::CircuitBuilderError;\npub use expression_builder::ExpressionBuilder;\n#[cfg(feature = \"profiling\")]\npub use expression_builder::OpCounts;\npub use public_input_tracker::PublicInputTracker;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","public_input_tracker.rs"],"content":"/// Manages public input declarations and tracking.\n#[derive(Debug, Clone, Default)]\npub struct PublicInputTracker {\n    /// The number of public inputs declared\n    count: usize,\n}\n\nimpl PublicInputTracker {\n    /// Creates a new public input tracker.\n    pub const fn new() -\u003e Self {\n        Self { count: 0 }\n    }\n\n    /// Allocates the next public input position.\n    ///\n    /// Returns the position of the newly allocated public input.\n    pub const fn alloc(\u0026mut self) -\u003e usize {\n        let pos = self.count;\n        self.count += 1;\n        pos\n    }\n\n    /// Returns the total count of public inputs.\n    pub const fn count(\u0026self) -\u003e usize {\n        self.count\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_public_input_tracker_basic() {\n        let mut tracker = PublicInputTracker::new();\n        assert_eq!(tracker.count(), 0);\n\n        let pos0 = tracker.alloc();\n        assert_eq!(pos0, 0);\n        assert_eq!(tracker.count(), 1);\n\n        let pos1 = tracker.alloc();\n        assert_eq!(pos1, 1);\n        assert_eq!(tracker.count(), 2);\n\n        let pos2 = tracker.alloc();\n        assert_eq!(pos2, 2);\n        assert_eq!(tracker.count(), 3);\n    }\n\n    #[test]\n    fn test_public_input_tracker_default() {\n        let tracker = PublicInputTracker::default();\n        assert_eq!(tracker.count(), 0);\n    }\n}\n","traces":[{"line":17,"address":[3957920],"length":1,"stats":{"Line":17}},{"line":18,"address":[6773533],"length":1,"stats":{"Line":17}},{"line":19,"address":[4875844,4875802],"length":1,"stats":{"Line":16}},{"line":24,"address":[8960736],"length":1,"stats":{"Line":19}},{"line":25,"address":[4875877],"length":1,"stats":{"Line":14}}],"covered":5,"coverable":5},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","circuit.rs"],"content":"use alloc::string::String;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::fmt::Debug;\nuse core::ops::{Add, Mul, Sub};\n\nuse hashbrown::HashMap;\nuse p3_field::Field;\nuse strum::EnumCount;\n\nuse crate::op::{\n    NonPrimitiveOpConfig, NonPrimitiveOpType, NonPrimitivePreprocessedMap, Op, PrimitiveOpType,\n};\nuse crate::tables::{CircuitRunner, TraceGeneratorFn};\nuse crate::types::{ExprId, NonPrimitiveOpId, WitnessId};\nuse crate::{AluOpKind, CircuitError};\n\n/// Trait encapsulating the required field operations for circuits\npub trait CircuitField:\n    Clone\n    + Default\n    + Add\u003cOutput = Self\u003e\n    + Sub\u003cOutput = Self\u003e\n    + Mul\u003cOutput = Self\u003e\n    + PartialEq\n    + Debug\n    + Field\n{\n}\n\nimpl\u003cF\u003e CircuitField for F where\n    F: Clone\n        + Default\n        + Add\u003cOutput = F\u003e\n        + Sub\u003cOutput = F\u003e\n        + Mul\u003cOutput = F\u003e\n        + PartialEq\n        + Debug\n        + Field\n{\n}\n\n/// Preprocessed data for primitive and non-primitive operation tables.\npub struct PreprocessedColumns\u003cF\u003e {\n    pub primitive: Vec\u003cVec\u003cF\u003e\u003e,\n    pub non_primitive: NonPrimitivePreprocessedMap\u003cF\u003e,\n}\n\nimpl\u003cF: Field + Clone\u003e Clone for PreprocessedColumns\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            primitive: self.primitive.clone(),\n            non_primitive: self.non_primitive.clone(),\n        }\n    }\n}\n\nimpl\u003cF: Field\u003e PreprocessedColumns\u003cF\u003e {\n    /// Creates an empty [`PreprocessedColumns`] with one primitive entry per [`PrimitiveOpType`].\n    pub fn new() -\u003e Self {\n        Self {\n            primitive: vec![vec![]; PrimitiveOpType::COUNT],\n            non_primitive: NonPrimitivePreprocessedMap::new(),\n        }\n    }\n\n    /// Updates the witness table multiplicities for all the given witness indices.\n    pub fn update_witness_multiplicities(\n        \u0026mut self,\n        wids: \u0026[WitnessId],\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        if self.primitive.len() != PrimitiveOpType::COUNT {\n            return Err(CircuitError::InvalidPreprocessing {\n                reason: \"primitive vector length does not match PrimitiveOpType::COUNT\",\n            });\n        }\n\n        const WITNESS_TABLE_IDX: usize = PrimitiveOpType::Witness as usize;\n        for wid in wids {\n            let idx = wid.0 as usize;\n            if idx \u003e= self.primitive[WITNESS_TABLE_IDX].len() {\n                self.primitive[WITNESS_TABLE_IDX].resize(idx + 1, F::ZERO);\n            }\n            self.primitive[WITNESS_TABLE_IDX][idx] += F::ONE;\n        }\n        Ok(())\n    }\n\n    /// Extends the preprocessed data of `op_type`'s primitive operation\n    /// with `wids`'s witness indices, and updates the witness multiplicities.\n    pub fn register_primitive_witness_reads(\n        \u0026mut self,\n        op_type: PrimitiveOpType,\n        wids: \u0026[WitnessId],\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        if matches!(op_type, PrimitiveOpType::Witness) {\n            return Err(CircuitError::InvalidPreprocessing {\n                reason: \"Witness reads cannot be made from the Witness bus\",\n            });\n        }\n\n        if self.primitive.len() != PrimitiveOpType::COUNT {\n            return Err(CircuitError::InvalidPreprocessing {\n                reason: \"primitive vector length does not match PrimitiveOpType::COUNT\",\n            });\n        }\n\n        let wids_field = wids.iter().map(|wid| F::from_u32(wid.0));\n        self.primitive[op_type as usize].extend(wids_field);\n\n        self.update_witness_multiplicities(wids)?;\n\n        Ok(())\n    }\n\n    /// Extends the preprocessed data of `op_type`'s non-primitive operation\n    /// with `wids`'s witness indices, and updates the witness multiplicities.\n    pub fn register_non_primitive_witness_reads(\n        \u0026mut self,\n        op_type: NonPrimitiveOpType,\n        wids: \u0026[WitnessId],\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        let entry = self.non_primitive.entry(op_type).or_default();\n\n        let wids_field = wids.iter().map(|wid| F::from_u32(wid.0));\n        entry.extend(wids_field);\n\n        self.update_witness_multiplicities(wids)?;\n\n        Ok(())\n    }\n\n    /// Extends the preprocessed data of `op_type`'s primitive operation\n    /// with `wid`'s witness index, and updates the witness multiplicity.\n    pub fn register_primitive_witness_read(\n        \u0026mut self,\n        op_type: PrimitiveOpType,\n        wid: WitnessId,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        self.register_primitive_witness_reads(op_type, \u0026[wid])\n    }\n\n    /// Extends the preprocessed data of `op_type`'s non-primitive operation\n    /// with `wid`'s witness index, and updates the witness multiplicity.\n    pub fn register_non_primitive_witness_read(\n        \u0026mut self,\n        op_type: NonPrimitiveOpType,\n        wid: WitnessId,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        self.register_non_primitive_witness_reads(op_type, \u0026[wid])\n    }\n\n    /// Extends the preprocessed data of `op_type`'s primitive operation with `values`.\n    /// Does not update witness multiplicities.\n    pub fn register_primitive_preprocessed_no_read(\n        \u0026mut self,\n        op_type: PrimitiveOpType,\n        values: \u0026[F],\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        if self.primitive.len() != PrimitiveOpType::COUNT {\n            return Err(CircuitError::InvalidPreprocessing {\n                reason: \"primitive vector length does not match PrimitiveOpType::COUNT\",\n            });\n        }\n        if matches!(op_type, PrimitiveOpType::Witness) {\n            return Err(CircuitError::InvalidPreprocessing {\n                reason: \"cannot use register_primitive_preprocessed_no_read for Witness table\",\n            });\n        }\n\n        self.primitive[op_type as usize].extend(values);\n\n        Ok(())\n    }\n\n    /// Extends the preprocessed data of `op_type`'s non-primitive operation with `values`.\n    /// Does not update witness multiplicities.\n    pub fn register_non_primitive_preprocessed_no_read(\n        \u0026mut self,\n        op_type: NonPrimitiveOpType,\n        values: \u0026[F],\n    ) {\n        let entry = self.non_primitive.entry(op_type).or_default();\n        entry.extend(values);\n    }\n}\n\nimpl\u003cF: Field\u003e Default for PreprocessedColumns\u003cF\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Static circuit specification containing constraint system and metadata\n///\n/// This represents the compiled output of a `CircuitBuilder`. It contains:\n/// - Primitive operations (add, multiply, subtract, constants, public inputs)\n/// - Non-primitive operations (complex operations like MMCS verification)\n/// - Public input metadata and witness table structure\n///\n/// The circuit is static and serializable. Use `.runner()` to create\n/// a `CircuitRunner` for execution with specific input values.\n#[derive(Debug)]\npub struct Circuit\u003cF\u003e {\n    /// Number of witness table rows\n    pub witness_count: u32,\n    /// Operations in execution order (primitive + non-primitive).\n    pub ops: Vec\u003cOp\u003cF\u003e\u003e,\n    /// Public input witness indices\n    pub public_rows: Vec\u003cWitnessId\u003e,\n    /// Total number of public field elements\n    pub public_flat_len: usize,\n    /// Enabled non-primitive operation types with their respective configuration\n    pub enabled_ops: HashMap\u003cNonPrimitiveOpType, NonPrimitiveOpConfig\u003cF\u003e\u003e,\n    /// Expression to witness index map\n    pub expr_to_widx: HashMap\u003cExprId, WitnessId\u003e,\n    /// Registered non-primitive trace generators.\n    pub non_primitive_trace_generators: HashMap\u003cNonPrimitiveOpType, TraceGeneratorFn\u003cF\u003e\u003e,\n    /// Sorted keys of `non_primitive_trace_generators` for deterministic iteration without sorting each run.\n    pub non_primitive_trace_generator_order: Vec\u003cNonPrimitiveOpType\u003e,\n    /// Tag to witness index mapping for probing values by name.\n    pub tag_to_witness: HashMap\u003cString, WitnessId\u003e,\n    /// Tag to non-primitive operation ID mapping.\n    pub tag_to_op_id: HashMap\u003cString, NonPrimitiveOpId\u003e,\n    /// After ALU deduplication, duplicate outputs are rewritten to canonical.\n    /// This map is used by the runner to fill those slots.\n    pub witness_rewrite: Option\u003cHashMap\u003cWitnessId, WitnessId\u003e\u003e,\n}\n\nimpl\u003cF: Field + Clone\u003e Clone for Circuit\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            witness_count: self.witness_count,\n            ops: self.ops.clone(),\n            public_rows: self.public_rows.clone(),\n            public_flat_len: self.public_flat_len,\n            enabled_ops: self.enabled_ops.clone(),\n            expr_to_widx: self.expr_to_widx.clone(),\n            non_primitive_trace_generators: self.non_primitive_trace_generators.clone(),\n            non_primitive_trace_generator_order: self.non_primitive_trace_generator_order.clone(),\n            tag_to_witness: self.tag_to_witness.clone(),\n            tag_to_op_id: self.tag_to_op_id.clone(),\n            witness_rewrite: self.witness_rewrite.clone(),\n        }\n    }\n}\n\nimpl\u003cF: Field\u003e Circuit\u003cF\u003e {\n    /// Create a new circuit with the given witness count and expression to witness index map.\n    pub fn new(witness_count: u32, expr_to_widx: HashMap\u003cExprId, WitnessId\u003e) -\u003e Self {\n        Self {\n            witness_count,\n            ops: Vec::new(),\n            public_rows: Vec::new(),\n            public_flat_len: 0,\n            enabled_ops: HashMap::new(),\n            expr_to_widx,\n            non_primitive_trace_generators: HashMap::new(),\n            non_primitive_trace_generator_order: Vec::new(),\n            tag_to_witness: HashMap::new(),\n            tag_to_op_id: HashMap::new(),\n            witness_rewrite: None,\n        }\n    }\n\n    /// Generates preprocessed columns for all primitive operation types.\n    ///\n    /// Returns a [`PreprocessedColumns`] with one primitive entry per [`PrimitiveOpType`]:\n    ///\n    /// | Index | Operation | Column Layout                                                       | Width (per op) |\n    /// |-------|-----------|---------------------------------------------------------------------|----------------|\n    /// | 0     | Witness   | `[mul_0, mul_1, ...]`                                               | 1              |\n    /// | 1     | Const     | `[out_0, out_1, ...]`                                               | 1              |\n    /// | 2     | Public    | `[out_0, out_1, ...]`                                               | 1              |\n    /// | 3     | Alu       | `[sel_add_vs_mul, sel_bool, sel_muladd, a_idx, b_idx, c_idx, out_idx, ...]` | 7 |\n    ///\n    /// Note that `mul_i` in the Witness table preprocessed column indicates how many times\n    /// each witness index appears in the circuit.\n    /// ALU rows include selectors followed by indices; multiplicity is handled when building the ALU table.\n    pub fn generate_preprocessed_columns(\u0026self) -\u003e Result\u003cPreprocessedColumns\u003cF\u003e, CircuitError\u003e {\n        let mut preprocessed = PreprocessedColumns::new();\n\n        // We know that the Witness table has at least one entry for index 0 (multiplicity 0 at the start).\n        preprocessed.primitive[PrimitiveOpType::Witness as usize].push(F::ZERO);\n\n        // Process each primitive operation, extracting its witness indices.\n        for op in \u0026self.ops {\n            match op {\n                // Const: stores a constant value at witness[out].\n                // Preprocessed data: the output witness index.\n                // Since the values in ConstAir are looked up in WitnessAir,\n                // we register the read to update multiplicities.\n                Op::Const { out, .. } =\u003e {\n                    preprocessed\n                        .register_primitive_witness_reads(PrimitiveOpType::Const, \u0026[*out])?;\n                }\n                // Public: loads a public input into witness[out].\n                // Preprocessed data: the output witness index.\n                // Since the values in PublicAir are looked up in WitnessAir,\n                // we register the read to update multiplicities.\n                Op::Public { out, .. } =\u003e {\n                    preprocessed\n                        .register_primitive_witness_reads(PrimitiveOpType::Public, \u0026[*out])?;\n                }\n                // Unified ALU operations with selectors for operation kind.\n                // Preprocessed per op (without multiplicity):\n                // [sel_add_vs_mul, sel_bool, sel_muladd, a_idx, b_idx, c_idx, out_idx]\n                Op::Alu {\n                    kind, a, b, c, out, ..\n                } =\u003e {\n                    // Encode operation kind as:\n                    // - sel_add_vs_mul: 1 for Add, 0 for Mul (when Bool/MulAdd are 0)\n                    // - sel_bool: 1 for BoolCheck\n                    // - sel_muladd: 1 for MulAdd\n                    let (sel_add_vs_mul, sel_bool, sel_muladd) = match kind {\n                        AluOpKind::Add =\u003e (F::ONE, F::ZERO, F::ZERO),\n                        AluOpKind::Mul =\u003e (F::ZERO, F::ZERO, F::ZERO),\n                        AluOpKind::BoolCheck =\u003e (F::ZERO, F::ONE, F::ZERO),\n                        AluOpKind::MulAdd =\u003e (F::ZERO, F::ZERO, F::ONE),\n                    };\n\n                    preprocessed.register_primitive_preprocessed_no_read(\n                        PrimitiveOpType::Alu,\n                        \u0026[sel_add_vs_mul, sel_bool, sel_muladd],\n                    )?;\n\n                    // Witness indices contribute to multiplicities and follow the selectors in order.\n                    preprocessed.register_primitive_witness_reads(\n                        PrimitiveOpType::Alu,\n                        \u0026[\n                            *a,\n                            *b,\n                            c.unwrap_or(WitnessId(0)), // c is for non MulAdd operations\n                            *out,\n                        ],\n                    )?;\n                }\n                Op::NonPrimitiveOpWithExecutor {\n                    executor,\n                    inputs,\n                    outputs,\n                    ..\n                } =\u003e {\n                    // Delegate preprocessing to the non-primitive operation.\n                    executor.preprocess(inputs, outputs, \u0026mut preprocessed)?;\n                }\n            }\n        }\n\n        // After optimization passes, some witness slots may be unreferenced,\n        // so we need to resize the witness table to match the witness_count.\n        const WITNESS_IDX: usize = PrimitiveOpType::Witness as usize;\n        let size = self.witness_count as usize;\n        if preprocessed.primitive[WITNESS_IDX].len() \u003c size {\n            preprocessed.primitive[WITNESS_IDX].resize(size, F::ZERO);\n        }\n\n        Ok(preprocessed)\n    }\n}\n\nimpl\u003cF: CircuitField\u003e Circuit\u003cF\u003e {\n    /// Create a circuit runner for execution and trace generation\n    pub fn runner(self) -\u003e CircuitRunner\u003cF\u003e {\n        CircuitRunner::new(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use hashbrown::HashMap;\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n    use strum::EnumCount;\n\n    use super::*;\n    use crate::op::PrimitiveOpType;\n    use crate::types::WitnessId;\n\n    type F = BabyBear;\n\n    fn make_circuit(ops: Vec\u003cOp\u003cF\u003e\u003e) -\u003e Circuit\u003cF\u003e {\n        let mut circuit = Circuit::new(0, HashMap::new());\n        circuit.ops = ops;\n        circuit\n    }\n\n    #[test]\n    fn test_empty_circuit() {\n        let circuit: Circuit\u003cF\u003e = make_circuit(vec![]);\n        let result = circuit.generate_preprocessed_columns().unwrap();\n\n        assert_eq!(result.primitive.len(), PrimitiveOpType::COUNT);\n        assert_eq!(\n            result.primitive[PrimitiveOpType::Witness as usize],\n            vec![F::ZERO]\n        );\n        assert!(result.primitive[PrimitiveOpType::Const as usize].is_empty());\n        assert!(result.primitive[PrimitiveOpType::Public as usize].is_empty());\n        assert!(result.primitive[PrimitiveOpType::Alu as usize].is_empty());\n    }\n\n    #[test]\n    fn test_mixed_operations() {\n        // Test covering various operation types and behaviors:\n        // - Each operation type populates its correct column\n        // - Multiplicities in Witness table are accurate\n        // - Column data preserves operation order\n        let ops = vec![\n            Op::Const {\n                out: WitnessId(0),\n                val: F::from_u64(100),\n            },\n            Op::Public {\n                out: WitnessId(1),\n                public_pos: 0,\n            },\n            Op::Const {\n                out: WitnessId(2),\n                val: F::from_u64(200),\n            },\n            Op::add(WitnessId(0), WitnessId(1), WitnessId(3)),\n            Op::add(WitnessId(3), WitnessId(2), WitnessId(4)),\n            Op::mul(WitnessId(4), WitnessId(2), WitnessId(5)),\n        ];\n\n        let circuit = make_circuit(ops);\n        let result = circuit.generate_preprocessed_columns().unwrap();\n\n        // Const column: output indices in order\n        assert_eq!(\n            result.primitive[PrimitiveOpType::Const as usize],\n            vec![F::ZERO, F::from_u32(2)]\n        );\n\n        // Public column: output index\n        assert_eq!(\n            result.primitive[PrimitiveOpType::Public as usize],\n            vec![F::from_u32(1)]\n        );\n\n        // ALU column: [sel_add_vs_mul, sel_bool, sel_muladd, a, b, c, out] per op\n        // Layout per op: [sel_add_vs_mul, sel_bool, sel_muladd, a, b, c, out]\n        // Op 1: add(0, 1, 3) -\u003e [1, 0, 0, 0, 1, 0, 3]\n        // Op 2: add(3, 2, 4) -\u003e [1, 0, 0, 3, 2, 0, 4]\n        // Op 3: mul(4, 2, 5) -\u003e [0, 0, 0, 4, 2, 0, 5]\n        let expected_alu = vec![\n            // add(0, 1, 3)\n            F::ONE,\n            F::ZERO,\n            F::ZERO,\n            F::ZERO,\n            F::from_u32(1),\n            F::ZERO,\n            F::from_u32(3),\n            // add(3, 2, 4)\n            F::ONE,\n            F::ZERO,\n            F::ZERO,\n            F::from_u32(3),\n            F::from_u32(2),\n            F::ZERO,\n            F::from_u32(4),\n            // mul(4, 2, 5)\n            F::ZERO,\n            F::ZERO,\n            F::ZERO,\n            F::from_u32(4),\n            F::from_u32(2),\n            F::ZERO,\n            F::from_u32(5),\n        ];\n        assert_eq!(\n            result.primitive[PrimitiveOpType::Alu as usize],\n            expected_alu\n        );\n\n        // We should have the following multiplicities in the Witness table, for indices 0 to 5:\n        // Index 0: 2 (const out) + 3 (c_idx for 3 ALU ops that use c=0) = 5\n        // Index 1: 2 (public out + add input a)\n        // Index 2: 3 (const out + add input b + mul input b)\n        // Index 3: 2 (add output + add input a)\n        // Index 4: 2 (add output + mul input a)\n        // Index 5: 1 (mul output)\n        let expected_multiplicities = vec![\n            F::from_u16(5), // Index 0: const + 3x c_idx (for add, add, mul operations)\n            F::from_u16(2),\n            F::from_u16(3),\n            F::from_u16(2),\n            F::from_u16(2),\n            F::from_u16(1),\n        ];\n        assert_eq!(\n            result.primitive[PrimitiveOpType::Witness as usize],\n            expected_multiplicities\n        );\n    }\n\n    #[test]\n    fn test_input_indices_contribute_to_max_idx() {\n        // Ensures input indices that exceed outputs are tracked for witness table size\n        let ops = vec![Op::add(\n            WitnessId(0),\n            WitnessId(15), // Highest index is an input, not output\n            WitnessId(5),\n        )];\n\n        let circuit = make_circuit(ops);\n        let result = circuit.generate_preprocessed_columns().unwrap();\n\n        // Index 0 has multiplicity 2 (once for 'a', once for 'c' which defaults to 0)\n        // Index 5 and 15 have multiplicity 1\n        let expected_witness: Vec\u003cF\u003e = (0..=15)\n            .map(|i| {\n                if i == 0 {\n                    F::from_u16(2) // a + c_idx (c defaults to 0)\n                } else if i == 5 || i == 15 {\n                    F::ONE\n                } else {\n                    F::ZERO\n                }\n            })\n            .collect();\n        assert_eq!(\n            result.primitive[PrimitiveOpType::Witness as usize],\n            expected_witness\n        );\n    }\n\n    #[test]\n    fn test_muladd_operation() {\n        // Test the MulAdd operation preprocessed format\n        let ops = vec![\n            Op::Const {\n                out: WitnessId(0),\n                val: F::from_u64(3),\n            },\n            Op::Const {\n                out: WitnessId(1),\n                val: F::from_u64(5),\n            },\n            Op::Const {\n                out: WitnessId(2),\n                val: F::from_u64(7),\n            },\n            Op::mul_add(WitnessId(0), WitnessId(1), WitnessId(2), WitnessId(3)), // 3*5+7=22\n        ];\n\n        let circuit = make_circuit(ops);\n        let result = circuit.generate_preprocessed_columns().unwrap();\n\n        // ALU column for MulAdd: [sel_add_vs_mul=0, sel_bool=0, sel_muladd=1, a=0, b=1, c=2, out=3]\n        let expected_alu = vec![\n            F::ZERO,\n            F::ZERO,\n            F::ONE,\n            F::ZERO,\n            F::from_u32(1),\n            F::from_u32(2),\n            F::from_u32(3),\n        ];\n        assert_eq!(\n            result.primitive[PrimitiveOpType::Alu as usize],\n            expected_alu\n        );\n\n        // Multiplicities: 0,1,2,3 each appear once in const or ALU\n        // Index 0: const out + ALU a = 2\n        // Index 1: const out + ALU b = 2\n        // Index 2: const out + ALU c = 2\n        // Index 3: ALU out = 1\n        let expected_multiplicities = vec![\n            F::from_u16(2),\n            F::from_u16(2),\n            F::from_u16(2),\n            F::from_u16(1),\n        ];\n        assert_eq!(\n            result.primitive[PrimitiveOpType::Witness as usize],\n            expected_multiplicities\n        );\n    }\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[3545362,3545368,3545200],"length":1,"stats":{"Line":14}},{"line":62,"address":[5893147,5893323,5893499,5892971,5892795],"length":1,"stats":{"Line":13}},{"line":63,"address":[5893001,5893177,5892825,5893353,5893529],"length":1,"stats":{"Line":14}},{"line":68,"address":[4846272,4846752],"length":1,"stats":{"Line":12}},{"line":72,"address":[2009104],"length":1,"stats":{"Line":13}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[4397925,4398009],"length":1,"stats":{"Line":24}},{"line":80,"address":[7384482,7384962],"length":1,"stats":{"Line":11}},{"line":81,"address":[4398097],"length":1,"stats":{"Line":13}},{"line":82,"address":[3543400,3542887],"length":1,"stats":{"Line":11}},{"line":84,"address":[4483340],"length":1,"stats":{"Line":11}},{"line":86,"address":[7348205,7347661],"length":1,"stats":{"Line":14}},{"line":91,"address":[7385264],"length":1,"stats":{"Line":12}},{"line":96,"address":[5886885,5886341,5887973,5888517,5887429],"length":1,"stats":{"Line":14}},{"line":97,"address":[3543625],"length":1,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[4847379,4847923],"length":1,"stats":{"Line":12}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[7385435,7385808,7385822],"length":1,"stats":{"Line":38}},{"line":109,"address":[5887040,5888128,5886496,5887584,5888672],"length":1,"stats":{"Line":12}},{"line":111,"address":[],"length":0,"stats":{"Line":14}},{"line":113,"address":[],"length":0,"stats":{"Line":11}},{"line":118,"address":[3544448,3544096],"length":1,"stats":{"Line":3}},{"line":123,"address":[4398385],"length":1,"stats":{"Line":3}},{"line":125,"address":[],"length":0,"stats":{"Line":9}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[7386015,7386367],"length":1,"stats":{"Line":3}},{"line":130,"address":[7350225,7349873],"length":1,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[3544880],"length":1,"stats":{"Line":8}},{"line":160,"address":[3544957],"length":1,"stats":{"Line":10}},{"line":161,"address":[3544988],"length":1,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[5891260,5892220,5891900,5892540,5891580],"length":1,"stats":{"Line":8}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[5891661,5891981,5891341,5892301,5892621],"length":1,"stats":{"Line":10}},{"line":173,"address":[7386837],"length":1,"stats":{"Line":8}},{"line":178,"address":[2009984],"length":1,"stats":{"Line":3}},{"line":183,"address":[4850389,4850293],"length":1,"stats":{"Line":3}},{"line":184,"address":[1688721],"length":1,"stats":{"Line":3}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[2099099,2099105,2098256],"length":1,"stats":{"Line":1}},{"line":233,"address":[2098286],"length":1,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[2098369],"length":1,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[2098435],"length":1,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[2098557],"length":1,"stats":{"Line":1}},{"line":241,"address":[2098618],"length":1,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[2098746],"length":1,"stats":{"Line":1}},{"line":250,"address":[4844512,4845292,4845271,4845328,4846087,4846108],"length":1,"stats":{"Line":28}},{"line":253,"address":[],"length":0,"stats":{"Line":23}},{"line":254,"address":[1993803],"length":1,"stats":{"Line":28}},{"line":256,"address":[4844665,4845481],"length":1,"stats":{"Line":23}},{"line":258,"address":[2008410],"length":1,"stats":{"Line":28}},{"line":259,"address":[4845633,4844817],"length":1,"stats":{"Line":23}},{"line":260,"address":[3790613],"length":1,"stats":{"Line":29}},{"line":261,"address":[4482537],"length":1,"stats":{"Line":22}},{"line":280,"address":[7339536,7345577,7342700,7342720,7345583,7342694],"length":1,"stats":{"Line":11}},{"line":281,"address":[],"length":0,"stats":{"Line":13}},{"line":284,"address":[5867140,5873508,5863476,5867265,5870449,5863601,5876388,5870324,5873635,5876515],"length":1,"stats":{"Line":30}},{"line":287,"address":[],"length":0,"stats":{"Line":14}},{"line":288,"address":[5873799,5876679,5870632,5867448,5863792],"length":1,"stats":{"Line":15}},{"line":293,"address":[5874139,5867805,5877019,5870989,5864157],"length":1,"stats":{"Line":12}},{"line":294,"address":[7343798,7340648,7343934,7340784],"length":1,"stats":{"Line":15}},{"line":295,"address":[5874154,5877470,5867820,5864172,5868256,5871004,5871440,5877034,5864608,5874590],"length":1,"stats":{"Line":14}},{"line":301,"address":[],"length":0,"stats":{"Line":11}},{"line":302,"address":[7380952,7381088],"length":1,"stats":{"Line":14}},{"line":303,"address":[3539264,3538632],"length":1,"stats":{"Line":14}},{"line":308,"address":[7380439],"length":1,"stats":{"Line":9}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[4839419,4843365,4840449,4842569],"length":1,"stats":{"Line":22}},{"line":316,"address":[3539451],"length":1,"stats":{"Line":9}},{"line":317,"address":[7344350,7341260],"length":1,"stats":{"Line":7}},{"line":318,"address":[4843297,4840267],"length":1,"stats":{"Line":0}},{"line":319,"address":[3539556],"length":1,"stats":{"Line":6}},{"line":322,"address":[5878326,5875287,5869379,5875947,5869220,5878167,5866691,5878827,5875446,5869880,5866031,5873064,5872404,5872563,5866190],"length":1,"stats":{"Line":10}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[7344495,7341585],"length":1,"stats":{"Line":9}},{"line":328,"address":[7344945,7345104,7342062,7342221],"length":1,"stats":{"Line":9}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[7381762],"length":1,"stats":{"Line":10}},{"line":331,"address":[3539966],"length":1,"stats":{"Line":10}},{"line":332,"address":[5866316,5872689,5869505,5875572,5878452],"length":1,"stats":{"Line":8}},{"line":333,"address":[7341959,7344842],"length":1,"stats":{"Line":10}},{"line":334,"address":[],"length":0,"stats":{"Line":8}},{"line":338,"address":[7340551,7343701],"length":1,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[7382121,7380624],"length":1,"stats":{"Line":4}},{"line":353,"address":[4838879,4842046],"length":1,"stats":{"Line":13}},{"line":354,"address":[],"length":0,"stats":{"Line":11}},{"line":355,"address":[4842225,4839058],"length":1,"stats":{"Line":1}},{"line":358,"address":[4838979,4842146],"length":1,"stats":{"Line":13}},{"line":364,"address":[2396480],"length":1,"stats":{"Line":27}},{"line":365,"address":[4482960],"length":1,"stats":{"Line":27}}],"covered":84,"coverable":111},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","errors.rs"],"content":"use alloc::string::String;\nuse alloc::vec::Vec;\n\nuse thiserror::Error;\n\nuse crate::op::NonPrimitiveOpType;\nuse crate::types::NonPrimitiveOpId;\nuse crate::{CircuitBuilderError, ExprId, WitnessId};\n\n/// Errors that can occur during circuit execution and trace generation.\n#[derive(Debug, Error)]\npub enum CircuitError {\n    /// Public input length mismatch.\n    #[error(\"Public input length mismatch: expected {expected}, got {got}\")]\n    PublicInputLengthMismatch { expected: usize, got: usize },\n\n    /// Circuit missing public_rows mapping.\n    #[error(\"Circuit missing public_rows mapping\")]\n    MissingPublicRowsMapping,\n\n    /// NonPrimitiveOpId out of range.\n    #[error(\"NonPrimitiveOpId {op_id} out of range (circuit has {max_ops} complex ops)\")]\n    NonPrimitiveOpIdOutOfRange { op_id: u32, max_ops: usize },\n\n    /// Public input not set for a WitnessId.\n    #[error(\"Public input not set for WitnessId({witness_id})\")]\n    PublicInputNotSet { witness_id: WitnessId },\n\n    /// Witness not set for a WitnessId.\n    #[error(\"Witness not set for WitnessId({witness_id})\")]\n    WitnessNotSet { witness_id: WitnessId },\n\n    /// WitnessId out of bounds.\n    #[error(\"WitnessId({witness_id}) out of bounds\")]\n    WitnessIdOutOfBounds { witness_id: WitnessId },\n\n    /// Witness conflict: trying to reassign to a different value.\n    #[error(\n        \"Witness conflict: WitnessId({witness_id}) already set to {existing}, cannot reassign to {new}; corresponding ExprIds: {expr_ids:?}\"\n    )]\n    WitnessConflict {\n        witness_id: WitnessId,\n        existing: String,\n        new: String,\n        expr_ids: Vec\u003cExprId\u003e,\n    },\n\n    /// Witness not set for an index during trace generation.\n    #[error(\"Witness not set for index {index}\")]\n    WitnessNotSetForIndex { index: usize },\n\n    /// Non-primitive op attempted to read a witness value that was not set.\n    #[error(\"Witness value not set for non-primitive operation {operation_index}\")]\n    NonPrimitiveOpWitnessNotSet { operation_index: NonPrimitiveOpId },\n\n    /// Missing private data for a non-primitive operation.\n    #[error(\"Missing private data for non-primitive operation {operation_index}\")]\n    NonPrimitiveOpMissingPrivateData { operation_index: NonPrimitiveOpId },\n\n    /// Division by zero encountered.\n    #[error(\"Division by zero encountered\")]\n    DivisionByZero,\n\n    /// Invalid bit value in SampleBits bit decomposition (must be 0 or 1).\n    #[error(\n        \"Invalid bit value in SampleBits bit decomposition for WitnessId({input_witness_id}): {bit_value} (must be 0 or 1)\"\n    )]\n    InvalidBitValue {\n        input_witness_id: WitnessId,\n        bit_value: String,\n    },\n\n    /// Bit decomposition doesn't reconstruct to the input value.\n    #[error(\n        \"Bit decomposition for WitnessId({input_witness_id}) doesn't match input: expected {expected}, reconstructed {reconstructed}\"\n    )]\n    BitDecompositionMismatch {\n        input_witness_id: WitnessId,\n        expected: String,\n        reconstructed: String,\n    },\n\n    /// Mismatched non-primitive operation configuration\n    #[error(\"Invalid configuration for operation {op:?}\")]\n    InvalidNonPrimitiveOpConfiguration { op: NonPrimitiveOpType },\n\n    /// Non-primitive operation has incorrect input/output layout.\n    #[error(\"Incorrect layout for operation {op:?}: expected {expected}, got {got}\")]\n    NonPrimitiveOpLayoutMismatch {\n        op: NonPrimitiveOpType,\n        expected: String,\n        got: usize,\n    },\n\n    /// Incorrect size of private data provided for a non-primitive operation.\n    #[error(\n        \"Incorrect size of private data provided for operation {op:?}: expected {expected}, got {got}\"\n    )]\n    IncorrectNonPrimitiveOpPrivateDataSize {\n        op: NonPrimitiveOpType,\n        expected: String,\n        got: usize,\n    },\n\n    /// Incorrect input size provided for a non-primitive operation.\n    #[error(\"Incorrect input size provided for operation {op:?}: expected {expected}, got {got}\")]\n    IncorrectNonPrimitiveOpInputSize {\n        op: NonPrimitiveOpType,\n        expected: String,\n        got: usize,\n    },\n\n    /// Non primitive private data is not correct\n    #[error(\n        \"Incorrect private data provided for op {op:?} (operation {operation_index}): expected {expected}, got {got}\"\n    )]\n    IncorrectNonPrimitiveOpPrivateData {\n        op: NonPrimitiveOpType,\n        operation_index: NonPrimitiveOpId,\n        expected: String,\n        got: String,\n    },\n\n    /// ExprId not found.\n    #[error(\"ExprId {expr_id} not found\")]\n    ExprIdNotFound { expr_id: ExprId },\n\n    /// Invalid Circuit\n    #[error(\"Failed to build circuit: {error}\")]\n    InvalidCircuit { error: CircuitBuilderError },\n\n    /// Unconstrained operation is given an incorrect number of inputs.\n    #[error(\"Unconstrained operation input length mismatch: expected {op} {expected}, got {got}\")]\n    UnconstrainedOpInputLengthMismatch {\n        op: String,\n        expected: usize,\n        got: usize,\n    },\n\n    /// Requested bit length exceeds the maximum allowed for binary decomposition.\n    #[error(\"Too many bits for binary decomposition: expected at most {expected}, got {n_bits}\")]\n    BinaryDecompositionTooManyBits { expected: usize, n_bits: usize },\n\n    /// Invalid preprocessed values\n    #[error(\"Preprocessed values should be base field elements\")]\n    InvalidPreprocessedValues,\n\n    /// Invalid preprocessing operation\n    #[error(\"Invalid preprocessing: {reason}\")]\n    InvalidPreprocessing { reason: \u0026'static str },\n\n    /// Inconsistent matrix heights when formatting openings: heights that round up\n    /// to the same power of two must be equal.\n    #[error(\"Inconsistent matrix heights: {details}\")]\n    InconsistentMatrixHeights { details: String },\n\n    /// Poseidon2 chaining requires previous state but none was available.\n    #[error(\n        \"Poseidon2 chain missing previous state for operation {operation_index} (new_start=false but no previous permutation)\"\n    )]\n    Poseidon2ChainMissingPreviousState { operation_index: NonPrimitiveOpId },\n\n    /// Poseidon2 merkle path mode requires a sibling input limb (which limbs are required depends on `mmcs_bit`).\n    #[error(\n        \"Poseidon2 merkle path missing sibling input for operation {operation_index}, limb {limb}\"\n    )]\n    Poseidon2MerkleMissingSiblingInput {\n        operation_index: NonPrimitiveOpId,\n        limb: usize,\n    },\n\n    /// Poseidon2 operation is missing required input limb.\n    #[error(\n        \"Poseidon2 operation {operation_index} missing input for limb {limb} (new_start=true requires all inputs)\"\n    )]\n    Poseidon2MissingInput {\n        operation_index: NonPrimitiveOpId,\n        limb: usize,\n    },\n\n    /// Unknown tag: the tag was not registered during circuit construction.\n    #[error(\"Unknown tag: '{tag}'\")]\n    UnknownTag { tag: String },\n}\n\nimpl From\u003cCircuitBuilderError\u003e for CircuitError {\n    fn from(error: CircuitBuilderError) -\u003e Self {\n        Self::InvalidCircuit { error }\n    }\n}\n","traces":[{"line":187,"address":[4949760],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","expr.rs"],"content":"use alloc::vec::Vec;\n\nuse crate::types::{ExprId, NonPrimitiveOpId};\n\n/// Expression DAG for field operations\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum Expr\u003cF\u003e {\n    /// Constant field element\n    Const(F),\n    /// Public input at declaration position\n    Public(usize),\n    /// Addition of two expressions\n    Add { lhs: ExprId, rhs: ExprId },\n    /// Subtraction of two expressions\n    Sub { lhs: ExprId, rhs: ExprId },\n    /// Multiplication of two expressions\n    Mul { lhs: ExprId, rhs: ExprId },\n    /// Division of two expressions\n    Div { lhs: ExprId, rhs: ExprId },\n    /// Anchor node for a non-primitive operation in the expression DAG.\n    ///\n    /// This node has no witness value itself, but it fixes the relative execution order\n    /// of non-primitive ops w.r.t. other expressions during lowering.\n    ///\n    /// The `inputs` field contains all input expressions (flattened from witness_exprs),\n    /// making dependencies explicit in the DAG structure. This enables proper topological\n    /// analysis and ensures the lowerer emits ops after their inputs are available.\n    ///\n    /// For stateful ops (e.g., Poseidon2 perm chaining with `in_ctl=false`), `inputs` may\n    /// be empty since chained values flow internally and are not materialized in the\n    /// witness table. Execution order for such ops is determined by their position in\n    /// the ops list during lowering.\n    NonPrimitiveCall {\n        op_id: NonPrimitiveOpId,\n        inputs: Vec\u003cExprId\u003e,\n    },\n    /// Output of a non-primitive operation.\n    ///\n    /// This node represents a value produced by a non-primitive op. The `call` field\n    /// points to the `NonPrimitiveCall` expression node, making the dependency explicit\n    /// in the DAG structure. `output_idx` selects which output of that op this refers to.\n    NonPrimitiveOutput { call: ExprId, output_idx: u32 },\n}\n\n/// Graph for storing expression DAG nodes\n#[derive(Debug, Clone, Default)]\npub struct ExpressionGraph\u003cF\u003e {\n    nodes: Vec\u003cExpr\u003cF\u003e\u003e,\n}\n\nimpl\u003cF\u003e ExpressionGraph\u003cF\u003e {\n    pub const fn new() -\u003e Self {\n        Self { nodes: Vec::new() }\n    }\n\n    /// Add an expression to the graph, returning its ID\n    pub fn add_expr(\u0026mut self, expr: Expr\u003cF\u003e) -\u003e ExprId {\n        let id = ExprId(self.nodes.len() as u32);\n        self.nodes.push(expr);\n        id\n    }\n\n    /// Get an expression by ID\n    pub fn get_expr(\u0026self, id: ExprId) -\u003e \u0026Expr\u003cF\u003e {\n        \u0026self.nodes[id.0 as usize]\n    }\n\n    /// Get all nodes in the graph\n    pub fn nodes(\u0026self) -\u003e \u0026[Expr\u003cF\u003e] {\n        \u0026self.nodes\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Mock extension field element for testing\n    #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n    struct MockExtField(u64);\n\n    #[test]\n    fn test_expression_graph() {\n        let mut graph = ExpressionGraph::\u003cMockExtField\u003e::new();\n\n        let const_expr = Expr::Const(MockExtField(42));\n        let public_expr = Expr::Public(0);\n\n        let const_id = graph.add_expr(const_expr.clone());\n        let public_id = graph.add_expr(public_expr.clone());\n\n        assert_eq!(const_id, ExprId::ZERO);\n        assert_eq!(public_id, ExprId(1));\n\n        assert_eq!(graph.get_expr(const_id), \u0026const_expr);\n        assert_eq!(graph.get_expr(public_id), \u0026public_expr);\n\n        let add_expr = Expr::Add {\n            lhs: const_id,\n            rhs: public_id,\n        };\n        let add_id = graph.add_expr(add_expr.clone());\n        assert_eq!(add_id, ExprId(2));\n        assert_eq!(graph.get_expr(add_id), \u0026add_expr);\n    }\n\n    #[cfg(test)]\n    mod proptests {\n        use proptest::prelude::*;\n\n        use super::*;\n\n        proptest! {\n            #[test]\n            fn expr_get_returns_added(vals in prop::collection::vec(any::\u003cu64\u003e().prop_map(MockExtField), 1..30)) {\n                let mut graph = ExpressionGraph::\u003cMockExtField\u003e::new();\n                let mut ids = Vec::new();\n\n                for val in \u0026vals {\n                    let expr = Expr::Const(val.clone());\n                    let id = graph.add_expr(expr.clone());\n                    ids.push(id);\n                }\n\n                for (id, val) in ids.iter().zip(vals.iter()) {\n                    let retrieved = graph.get_expr(*id);\n                    prop_assert_eq!(retrieved, \u0026Expr::Const(val.clone()), \"get should return added expression\");\n                }\n            }\n\n            #[test]\n            fn expr_primitive_ops(val1 in any::\u003cu64\u003e().prop_map(MockExtField), val2 in any::\u003cu64\u003e().prop_map(MockExtField)) {\n                let mut graph = ExpressionGraph::\u003cMockExtField\u003e::new();\n\n                let id1 = graph.add_expr(Expr::Const(val1));\n                let id2 = graph.add_expr(Expr::Const(val2));\n\n                let add_id = graph.add_expr(Expr::Add { lhs: id1, rhs: id2 });\n                match graph.get_expr(add_id) {\n                    Expr::Add { lhs, rhs } =\u003e {\n                        prop_assert_eq!(*lhs, id1);\n                        prop_assert_eq!(*rhs, id2);\n                    }\n                    _ =\u003e prop_assert!(false, \"expected Add expr\"),\n                }\n\n                let sub_id = graph.add_expr(Expr::Sub { lhs: id1, rhs: id2 });\n                match graph.get_expr(sub_id) {\n                    Expr::Sub { lhs, rhs } =\u003e {\n                        prop_assert_eq!(*lhs, id1);\n                        prop_assert_eq!(*rhs, id2);\n                    }\n                    _ =\u003e prop_assert!(false, \"expected Sub expr\"),\n                }\n\n                let mul_id = graph.add_expr(Expr::Mul { lhs: id1, rhs: id2 });\n                match graph.get_expr(mul_id) {\n                    Expr::Mul { lhs, rhs } =\u003e {\n                        prop_assert_eq!(*lhs, id1);\n                        prop_assert_eq!(*rhs, id2);\n                    }\n                    _ =\u003e prop_assert!(false, \"expected Mul expr\"),\n                }\n\n                let div_id = graph.add_expr(Expr::Div { lhs: id1, rhs: id2 });\n                match graph.get_expr(div_id) {\n                    Expr::Div { lhs, rhs } =\u003e {\n                        prop_assert_eq!(*lhs, id1);\n                        prop_assert_eq!(*rhs, id2);\n                    }\n                    _ =\u003e prop_assert!(false, \"expected Div expr\"),\n                }\n            }\n\n            #[test]\n            fn expr_public_positions(positions in prop::collection::vec(0usize..100, 0..20)) {\n                let mut graph = ExpressionGraph::\u003cMockExtField\u003e::new();\n                let mut ids = Vec::new();\n\n                for \u0026pos in \u0026positions {\n                    let id = graph.add_expr(Expr::Public(pos));\n                    ids.push(id);\n                }\n\n                for (\u0026id, \u0026expected_pos) in ids.iter().zip(positions.iter()) {\n                    match graph.get_expr(id) {\n                        Expr::Public(pos) =\u003e {\n                            prop_assert_eq!(*pos, expected_pos, \"public position should match\");\n                        }\n                        _ =\u003e prop_assert!(false, \"expected Public expr\"),\n                    }\n                }\n            }\n\n            #[test]\n            fn expr_equality(val in any::\u003cu64\u003e().prop_map(MockExtField)) {\n                let expr1 = Expr::Const(val.clone());\n                let expr2 = Expr::Const(val.clone());\n                let expr3 = Expr::Const(MockExtField(val.0 + 1));\n\n                prop_assert_eq!(\u0026expr1, \u0026expr2, \"same expressions should be equal\");\n                prop_assert_ne!(\u0026expr1, \u0026expr3, \"different expressions should not be equal\");\n            }\n        }\n    }\n}\n","traces":[{"line":52,"address":[3443600],"length":1,"stats":{"Line":35}},{"line":53,"address":[6222173,6222109,6222045,6222301,6222237],"length":1,"stats":{"Line":32}},{"line":57,"address":[1397764,1397786,1397632],"length":1,"stats":{"Line":32}},{"line":58,"address":[4803331,4803397],"length":1,"stats":{"Line":63}},{"line":59,"address":[3209417],"length":1,"stats":{"Line":32}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[7458800,7458704,7458752],"length":1,"stats":{"Line":29}},{"line":65,"address":[2225501],"length":1,"stats":{"Line":31}},{"line":69,"address":[6480560,6480544],"length":1,"stats":{"Line":33}},{"line":70,"address":[],"length":0,"stats":{"Line":26}}],"covered":9,"coverable":10},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","lib.rs"],"content":"#![no_std]\nextern crate alloc;\n#[cfg(feature = \"debugging\")]\npub mod alloc_entry;\n\npub mod builder;\npub mod circuit;\npub mod errors;\npub mod expr;\npub mod op;\npub mod ops;\npub mod policy;\npub mod tables;\npub mod test_utils;\npub mod types;\npub mod utils;\n\n// Re-export public API\n#[cfg(feature = \"debugging\")]\npub use alloc_entry::{AllocationEntry, AllocationType, dump_expr_ids};\npub use builder::{CircuitBuilder, CircuitBuilderError};\npub use circuit::{Circuit, CircuitField, PreprocessedColumns};\npub use errors::CircuitError;\npub use expr::{Expr, ExpressionGraph};\npub use op::{AluOpKind, NonPrimitiveOpPrivateData, NonPrimitiveOpType, Op};\npub use ops::Poseidon2PermOps;\npub use tables::{CircuitRunner, Traces};\npub use types::{ExprId, NonPrimitiveOpId, WitnessAllocator, WitnessId};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","op.rs"],"content":"use alloc::boxed::Box;\nuse alloc::collections::BTreeMap;\nuse alloc::sync::Arc;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::any::Any;\nuse core::fmt::Debug;\nuse core::hash::Hash;\n\nuse hashbrown::HashMap;\nuse p3_field::{Field, PrimeCharacteristicRing};\nuse serde::{Deserialize, Serialize};\nuse strum_macros::EnumCount;\n\nuse crate::ops::Poseidon2PermPrivateData;\nuse crate::types::{NonPrimitiveOpId, WitnessId};\nuse crate::{CircuitError, PreprocessedColumns};\n\n/// ALU operation kinds for the unified arithmetic table.\n///\n/// This enum defines the different arithmetic operations that can be performed\n/// in a single ALU row, selected by preprocessed selectors.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum AluOpKind {\n    /// Addition: out = a + b\n    Add,\n    /// Multiplication: out = a * b\n    Mul,\n    /// Boolean check: a * (a - 1) = 0, out = a\n    BoolCheck,\n    /// Fused multiply-add: out = a * b + c\n    MulAdd,\n}\n\n/// Circuit operations.\n///\n/// Operations are distinguised as primitive and non-primitive:\n///\n/// # Primitive operations\n///\n/// Primitive operations that represent basic field arithmetic\n///\n/// These operations form the core computational primitives after expression lowering.\n/// All primitive operations:\n/// - Operate on witness table slots (WitnessId)\n/// - Can be heavily optimized (constant folding, CSE, etc.)\n/// - Are executed in topological order during circuit evaluation\n/// - Form a directed acyclic graph (DAG) of dependencies\n///\n/// # Non-primitive operations\n///\n/// Non-primitive operations may represent complex computations that would require too many,\n/// primitive operations to be expressed equivalently.\n///\n/// They can be user-defined and selected at runtime, have private data that does not appear\n/// in the central Witness bus, and are subject to their own optimization passes.\n#[derive(Debug)]\npub enum Op\u003cF\u003e {\n    /// Load a constant value into the witness table\n    ///\n    /// Sets `witness[out] = val`. Used for literal constants and\n    /// supports constant pooling optimization where identical constants\n    /// reuse the same witness slot.\n    Const { out: WitnessId, val: F },\n\n    /// Load a public input value into the witness table\n    ///\n    /// Sets `witness[out] = public_inputs[public_pos]`. Public inputs\n    /// are values known to both prover and verifier, typically used\n    /// for circuit inputs and expected outputs.\n    Public { out: WitnessId, public_pos: usize },\n\n    /// Unified ALU operation supporting multiple arithmetic operations.\n    ///\n    /// The `kind` field determines the operation:\n    /// - `Add`: out = a + b\n    /// - `Mul`: out = a * b\n    /// - `BoolCheck`: a * (a - 1) = 0, out = a\n    /// - `MulAdd`: out = a * b + c\n    Alu {\n        kind: AluOpKind,\n        a: WitnessId,\n        b: WitnessId,\n        /// Third operand, only used for MulAdd\n        c: Option\u003cWitnessId\u003e,\n        out: WitnessId,\n        /// Intermediate output for MulAdd: stores a * b when fused from separate mul + add.\n        /// The runner sets this witness value so dependent operations still work.\n        intermediate_out: Option\u003cWitnessId\u003e,\n    },\n\n    /// Non-primitive operation with executor-based dispatch\n    NonPrimitiveOpWithExecutor {\n        inputs: Vec\u003cVec\u003cWitnessId\u003e\u003e,\n        outputs: Vec\u003cVec\u003cWitnessId\u003e\u003e,\n        executor: Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e,\n        /// For private data lookup and error reporting\n        op_id: NonPrimitiveOpId,\n    },\n}\n\nimpl\u003cF\u003e Op\u003cF\u003e {\n    /// Create an addition operation (convenience wrapper for Op::Alu with AluOpKind::Add).\n    pub const fn add(a: WitnessId, b: WitnessId, out: WitnessId) -\u003e Self {\n        Self::Alu {\n            kind: AluOpKind::Add,\n            a,\n            b,\n            c: None,\n            out,\n            intermediate_out: None,\n        }\n    }\n\n    /// Create a multiplication operation (convenience wrapper for Op::Alu with AluOpKind::Mul).\n    pub const fn mul(a: WitnessId, b: WitnessId, out: WitnessId) -\u003e Self {\n        Self::Alu {\n            kind: AluOpKind::Mul,\n            a,\n            b,\n            c: None,\n            out,\n            intermediate_out: None,\n        }\n    }\n\n    /// Create a fused multiply-add operation: out = a * b + c.\n    pub const fn mul_add(a: WitnessId, b: WitnessId, c: WitnessId, out: WitnessId) -\u003e Self {\n        Self::Alu {\n            kind: AluOpKind::MulAdd,\n            a,\n            b,\n            c: Some(c),\n            out,\n            intermediate_out: None,\n        }\n    }\n\n    /// Create a boolean check operation: a * (a - 1) = 0.\n    pub const fn bool_check(a: WitnessId, b: WitnessId, out: WitnessId) -\u003e Self {\n        Self::Alu {\n            kind: AluOpKind::BoolCheck,\n            a,\n            b,\n            c: None,\n            out,\n            intermediate_out: None,\n        }\n    }\n\n    /// Check if this is an ALU operation of the given kind.\n    pub fn is_alu_kind(\u0026self, kind: AluOpKind) -\u003e bool {\n        matches!(self, Self::Alu { kind: k, .. } if *k == kind)\n    }\n\n    /// Check if this is an addition operation.\n    pub fn is_add(\u0026self) -\u003e bool {\n        self.is_alu_kind(AluOpKind::Add)\n    }\n\n    /// Check if this is a multiplication operation.\n    pub fn is_mul(\u0026self) -\u003e bool {\n        self.is_alu_kind(AluOpKind::Mul)\n    }\n\n    /// Rewrite witness IDs in place using the given map (follows chains to canonical ID).\n    /// Used by the optimizer to apply ALU dedup without re-boxing non-primitive executors.\n    pub fn apply_witness_rewrite(\u0026mut self, rewrite: \u0026HashMap\u003cWitnessId, WitnessId\u003e) {\n        if rewrite.is_empty() {\n            return;\n        }\n        let resolve = |id: WitnessId| {\n            let mut cur = id;\n            while let Some(\u0026next) = rewrite.get(\u0026cur) {\n                cur = next;\n            }\n            cur\n        };\n        match self {\n            Self::Const { out, .. } =\u003e *out = resolve(*out),\n            Self::Public { out, .. } =\u003e *out = resolve(*out),\n            Self::Alu {\n                a,\n                b,\n                c,\n                out,\n                intermediate_out,\n                ..\n            } =\u003e {\n                *a = resolve(*a);\n                *b = resolve(*b);\n                *c = c.map(resolve);\n                *out = resolve(*out);\n                *intermediate_out = intermediate_out.map(resolve);\n            }\n            Self::NonPrimitiveOpWithExecutor {\n                inputs, outputs, ..\n            } =\u003e {\n                for g in inputs.iter_mut() {\n                    for w in g.iter_mut() {\n                        *w = resolve(*w);\n                    }\n                }\n                for g in outputs.iter_mut() {\n                    for w in g.iter_mut() {\n                        *w = resolve(*w);\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[derive(EnumCount, Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum PrimitiveOpType {\n    Witness = 0,\n    Const = 1,\n    Public = 2,\n    /// Unified ALU table (combines Add, Mul, BoolCheck, MulAdd)\n    Alu = 3,\n}\n\n#[allow(clippy::fallible_impl_from)]\nimpl From\u003cusize\u003e for PrimitiveOpType {\n    fn from(value: usize) -\u003e Self {\n        match value {\n            0 =\u003e Self::Witness,\n            1 =\u003e Self::Const,\n            2 =\u003e Self::Public,\n            3 =\u003e Self::Alu,\n            _ =\u003e panic!(\"Invalid PrimitiveOpType value: {}\", value),\n        }\n    }\n}\n\n// Custom Clone implementation for Op\nimpl\u003cF: Field + Clone\u003e Clone for Op\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        match self {\n            Self::Const { out, val } =\u003e Self::Const {\n                out: *out,\n                val: *val,\n            },\n            Self::Public { out, public_pos } =\u003e Self::Public {\n                out: *out,\n                public_pos: *public_pos,\n            },\n            Self::Alu {\n                kind,\n                a,\n                b,\n                c,\n                out,\n                intermediate_out,\n            } =\u003e Self::Alu {\n                kind: *kind,\n                a: *a,\n                b: *b,\n                c: *c,\n                out: *out,\n                intermediate_out: *intermediate_out,\n            },\n            Self::NonPrimitiveOpWithExecutor {\n                inputs,\n                outputs,\n                executor,\n                op_id,\n            } =\u003e Self::NonPrimitiveOpWithExecutor {\n                inputs: inputs.clone(),\n                outputs: outputs.clone(),\n                executor: executor.boxed(),\n                op_id: *op_id,\n            },\n        }\n    }\n}\n\n// Custom PartialEq implementation for Op\nimpl\u003cF: Field + PartialEq\u003e PartialEq for Op\u003cF\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (Self::Const { out: o1, val: v1 }, Self::Const { out: o2, val: v2 }) =\u003e {\n                o1 == o2 \u0026\u0026 v1 == v2\n            }\n            (\n                Self::Public {\n                    out: o1,\n                    public_pos: p1,\n                },\n                Self::Public {\n                    out: o2,\n                    public_pos: p2,\n                },\n            ) =\u003e o1 == o2 \u0026\u0026 p1 == p2,\n            (\n                Self::Alu {\n                    kind: k1,\n                    a: a1,\n                    b: b1,\n                    c: c1,\n                    out: o1,\n                    intermediate_out: io1,\n                },\n                Self::Alu {\n                    kind: k2,\n                    a: a2,\n                    b: b2,\n                    c: c2,\n                    out: o2,\n                    intermediate_out: io2,\n                },\n            ) =\u003e k1 == k2 \u0026\u0026 a1 == a2 \u0026\u0026 b1 == b2 \u0026\u0026 c1 == c2 \u0026\u0026 o1 == o2 \u0026\u0026 io1 == io2,\n            (\n                Self::NonPrimitiveOpWithExecutor {\n                    inputs: i1,\n                    outputs: o1,\n                    executor: e1,\n                    op_id: id1,\n                },\n                Self::NonPrimitiveOpWithExecutor {\n                    inputs: i2,\n                    outputs: o2,\n                    executor: e2,\n                    op_id: id2,\n                },\n            ) =\u003e i1 == i2 \u0026\u0026 o1 == o2 \u0026\u0026 e1.op_type() == e2.op_type() \u0026\u0026 id1 == id2,\n            _ =\u003e false,\n        }\n    }\n}\n\n/// Non-primitive operation types.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd, Serialize, Deserialize)]\npub enum NonPrimitiveOpType {\n    /// Poseidon2 permutation operation (one Poseidon2 call / table row).\n    Poseidon2Perm(Poseidon2Config),\n    /// Unconstrained operation, used to set outputs to non-deterministic advices.\n    Unconstrained,\n}\n\n// Re-export Poseidon2 config types from their canonical location\npub use crate::ops::poseidon2_perm::{Poseidon2Config, Poseidon2PermExec, Poseidon2PermExecBase};\n\n/// Preprocessed data for non-primitive tables, keyed by operation type.\npub type NonPrimitivePreprocessedMap\u003cF\u003e = HashMap\u003cNonPrimitiveOpType, Vec\u003cF\u003e\u003e;\n\n/// Non-primitive operation configuration.\n///\n/// Contains operation-specific configuration data, such as execution closures.\npub enum NonPrimitiveOpConfig\u003cF\u003e {\n    /// No configuration needed (placeholder for future operations).\n    None,\n    /// Poseidon2 permutation configuration with exec closure (D=4, 4 extension elements).\n    Poseidon2Perm {\n        config: Poseidon2Config,\n        exec: Poseidon2PermExec\u003cF, 4\u003e,\n    },\n    /// Poseidon2 permutation configuration for base field (D=1, 16 base elements).\n    Poseidon2PermBase {\n        config: Poseidon2Config,\n        exec: Poseidon2PermExecBase\u003cF\u003e,\n    },\n}\n\nimpl\u003cF\u003e Clone for NonPrimitiveOpConfig\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        match self {\n            Self::None =\u003e Self::None,\n            Self::Poseidon2Perm { config, exec } =\u003e Self::Poseidon2Perm {\n                config: *config,\n                exec: Arc::clone(exec),\n            },\n            Self::Poseidon2PermBase { config, exec } =\u003e Self::Poseidon2PermBase {\n                config: *config,\n                exec: Arc::clone(exec),\n            },\n        }\n    }\n}\n\nimpl\u003cF\u003e Debug for NonPrimitiveOpConfig\u003cF\u003e {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        match self {\n            Self::None =\u003e write!(f, \"None\"),\n            Self::Poseidon2Perm { config, .. } =\u003e f\n                .debug_struct(\"Poseidon2Perm\")\n                .field(\"config\", config)\n                .field(\"exec\", \u0026\"\u003cclosure\u003e\")\n                .finish(),\n            Self::Poseidon2PermBase { config, .. } =\u003e f\n                .debug_struct(\"Poseidon2PermBase\")\n                .field(\"config\", config)\n                .field(\"exec\", \u0026\"\u003cclosure\u003e\")\n                .finish(),\n        }\n    }\n}\n\n// Compare/Hash by variant/config only (ignore closure contents)\nimpl\u003cF\u003e PartialEq for NonPrimitiveOpConfig\u003cF\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (Self::None, Self::None) =\u003e true,\n            (Self::Poseidon2Perm { config: c1, .. }, Self::Poseidon2Perm { config: c2, .. }) =\u003e {\n                c1 == c2\n            }\n            (\n                Self::Poseidon2PermBase { config: c1, .. },\n                Self::Poseidon2PermBase { config: c2, .. },\n            ) =\u003e c1 == c2,\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl\u003cF\u003e Eq for NonPrimitiveOpConfig\u003cF\u003e {}\n\nimpl\u003cF\u003e Hash for NonPrimitiveOpConfig\u003cF\u003e {\n    fn hash\u003cH: core::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        core::mem::discriminant(self).hash(state);\n        match self {\n            Self::Poseidon2Perm { config, .. } | Self::Poseidon2PermBase { config, .. } =\u003e {\n                config.hash(state);\n            }\n            Self::None =\u003e {}\n        }\n    }\n}\n\n/// Non-primitive operations representing complex cryptographic constraints.\n///\n/// These operations implement sophisticated cryptographic primitives that:\n/// - Have dedicated AIR tables for constraint verification\n/// - Take witness values as public interface\n/// - May require separate private data for complete specification\n/// - Are NOT subject to primitive optimizations (CSE, constant folding)\n/// - Enable modular addition of complex functionality\n///\n/// Non-primitive operations are isolated from primitive optimizations to:\n/// 1. Maintain clean separation between basic arithmetic and complex crypto\n/// 2. Allow specialized constraint systems for each operation type\n/// 3. Enable parallel development of different cryptographic primitives\n/// 4. Avoid optimization passes breaking complex constraint relationships\n///\n/// Private auxiliary data for non-primitive operations\n///\n/// This data is NOT part of the witness table but provides additional\n/// parameters needed to fully specify complex operations. Private data:\n/// - Is set during circuit execution via `NonPrimitiveOpId`\n/// - Contains sensitive information like cryptographic witnesses\n/// - Is used by AIR tables to generate the appropriate constraints\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum NonPrimitiveOpPrivateData\u003cF\u003e {\n    Poseidon2Perm(Poseidon2PermPrivateData\u003cF, 2\u003e),\n}\n\n/// Trait for operation-specific execution state.\n///\n/// Each non-primitive operation type can define its own state struct that persists\n/// across invocations during circuit execution. This enables features like:\n/// - Permutation chaining (storing previous output for next input)\n/// - Recording execution data for canonical trace generation\n///\n/// Implementors must support downcasting via `Any` for type-safe retrieval.\npub trait OpExecutionState: Any + Send + Sync + Debug {\n    /// Downcast to concrete type for reading.\n    fn as_any(\u0026self) -\u003e \u0026dyn Any;\n    /// Downcast to concrete type for mutation.\n    fn as_any_mut(\u0026mut self) -\u003e \u0026mut dyn Any;\n}\n\n/// Type-erased storage for operation execution states.\n///\n/// This allows each operation type to maintain its own state without\n/// coupling `ExecutionContext` to specific operation implementations.\npub type OpStateMap = BTreeMap\u003cNonPrimitiveOpType, Box\u003cdyn OpExecutionState\u003e\u003e;\n\n/// Execution context providing operations access to witness table, private data, and configs\n///\n/// This context is passed to operation executors to give them access to all necessary\n/// runtime state without exposing internal implementation details.\npub struct ExecutionContext\u003c'a, F\u003e {\n    /// Mutable reference to witness table for reading/writing values\n    witness: \u0026'a mut [Option\u003cF\u003e],\n    /// Private data map for non-primitive operations\n    non_primitive_op_private_data: \u0026'a [Option\u003cNonPrimitiveOpPrivateData\u003cF\u003e\u003e],\n    /// Operation configurations\n    enabled_ops: \u0026'a HashMap\u003cNonPrimitiveOpType, NonPrimitiveOpConfig\u003cF\u003e\u003e,\n    /// Current operation's NonPrimitiveOpId for error reporting\n    operation_id: NonPrimitiveOpId,\n    /// Operation-specific execution state storage.\n    /// Each operation type can store its own state (e.g., chaining state, row records).\n    op_states: \u0026'a mut OpStateMap,\n}\n\nimpl\u003c'a, F: PrimeCharacteristicRing + Eq + Clone\u003e ExecutionContext\u003c'a, F\u003e {\n    /// Create a new execution context\n    pub fn new(\n        witness: \u0026'a mut [Option\u003cF\u003e],\n        non_primitive_op_private_data: \u0026'a [Option\u003cNonPrimitiveOpPrivateData\u003cF\u003e\u003e],\n        enabled_ops: \u0026'a HashMap\u003cNonPrimitiveOpType, NonPrimitiveOpConfig\u003cF\u003e\u003e,\n        operation_id: NonPrimitiveOpId,\n        op_states: \u0026'a mut OpStateMap,\n    ) -\u003e Self {\n        Self {\n            witness,\n            non_primitive_op_private_data,\n            enabled_ops,\n            operation_id,\n            op_states,\n        }\n    }\n\n    /// Get witness value at the given index\n    #[inline]\n    pub fn get_witness(\u0026self, widx: WitnessId) -\u003e Result\u003cF, CircuitError\u003e {\n        self.witness\n            .get(widx.0 as usize)\n            .and_then(|opt| opt.as_ref())\n            .cloned()\n            .ok_or(CircuitError::WitnessNotSet { witness_id: widx })\n    }\n\n    /// Set witness value at the given index\n    #[inline]\n    pub fn set_witness(\u0026mut self, widx: WitnessId, value: F) -\u003e Result\u003c(), CircuitError\u003e {\n        if widx.0 as usize \u003e= self.witness.len() {\n            return Err(CircuitError::WitnessIdOutOfBounds { witness_id: widx });\n        }\n\n        let slot = \u0026mut self.witness[widx.0 as usize];\n\n        // Check for conflicting reassignment\n        if let Some(existing_value) = slot.as_ref() {\n            if *existing_value == value {\n                // Same value - this is fine (duplicate set via connect)\n                return Ok(());\n            }\n            return Err(CircuitError::WitnessConflict {\n                witness_id: widx,\n                existing: format!(\"{existing_value:?}\"),\n                new: format!(\"{value:?}\"),\n                expr_ids: vec![], // TODO: Could be filled with expression IDs if tracked\n            });\n        }\n\n        *slot = Some(value);\n        Ok(())\n    }\n\n    /// Get private data for the current operation\n    pub fn get_private_data(\u0026self) -\u003e Result\u003c\u0026NonPrimitiveOpPrivateData\u003cF\u003e, CircuitError\u003e {\n        self.non_primitive_op_private_data\n            .get(self.operation_id.0 as usize)\n            .and_then(|opt| opt.as_ref())\n            .ok_or(CircuitError::NonPrimitiveOpMissingPrivateData {\n                operation_index: self.operation_id,\n            })\n    }\n\n    /// Get operation configuration by type\n    pub fn get_config(\n        \u0026self,\n        op_type: \u0026NonPrimitiveOpType,\n    ) -\u003e Result\u003c\u0026NonPrimitiveOpConfig\u003cF\u003e, CircuitError\u003e {\n        self.enabled_ops\n            .get(op_type)\n            .ok_or(CircuitError::InvalidNonPrimitiveOpConfiguration { op: *op_type })\n    }\n\n    /// Get the current operation ID\n    pub const fn operation_id(\u0026self) -\u003e NonPrimitiveOpId {\n        self.operation_id\n    }\n\n    /// Get operation-specific state for reading.\n    ///\n    /// Returns `None` if no state has been initialized for this operation type.\n    pub fn get_op_state\u003cT: OpExecutionState + 'static\u003e(\n        \u0026self,\n        op_type: \u0026NonPrimitiveOpType,\n    ) -\u003e Option\u003c\u0026T\u003e {\n        self.op_states\n            .get(op_type)\n            .and_then(|state| state.as_any().downcast_ref::\u003cT\u003e())\n    }\n\n    /// Get operation-specific state for mutation, creating default if not present.\n    ///\n    /// This is the primary way executors should access their state.\n    pub fn get_op_state_mut\u003cT: OpExecutionState + Default + 'static\u003e(\n        \u0026mut self,\n        op_type: \u0026NonPrimitiveOpType,\n    ) -\u003e \u0026mut T {\n        // Entry API with type-erased storage\n        if !self.op_states.contains_key(op_type) {\n            self.op_states.insert(*op_type, Box::new(T::default()));\n        }\n        self.op_states\n            .get_mut(op_type)\n            .and_then(|state| state.as_any_mut().downcast_mut::\u003cT\u003e())\n            .expect(\"type mismatch in op state - this is a bug\")\n    }\n}\n\n/// Trait for executable non-primitive operations\n///\n/// This trait enables dynamic dispatch and allows each operation to control\n/// its own execution logic with full access to the execution context.\npub trait NonPrimitiveExecutor\u003cF: Field\u003e: Debug {\n    /// Execute the operation with full context access\n    ///\n    /// # Arguments\n    /// * `inputs` - Input witness indices\n    /// * `outputs` - Output witness indices\n    /// * `ctx` - Execution context with access to witness table, private data, and configs\n    fn execute(\n        \u0026self,\n        inputs: \u0026[Vec\u003cWitnessId\u003e],\n        outputs: \u0026[Vec\u003cWitnessId\u003e],\n        ctx: \u0026mut ExecutionContext\u003c'_, F\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e;\n\n    /// Get operation type identifier (for config lookup, error reporting)\n    fn op_type(\u0026self) -\u003e \u0026NonPrimitiveOpType;\n\n    /// Allow downcasting to concrete executor types\n    fn as_any(\u0026self) -\u003e \u0026dyn core::any::Any;\n\n    /// Update the preprocessed values related to this operation. This consists of:\n    /// - the preprocessed values for the associated table\n    /// - the multiplicity for the `Witness` table.\n    ///\n    /// Uses the `PreprocessedColumns` API to ensure witness multiplicities are updated\n    /// consistently when reading from the witness table.\n    fn preprocess(\n        \u0026self,\n        _inputs: \u0026[Vec\u003cWitnessId\u003e],\n        _outputs: \u0026[Vec\u003cWitnessId\u003e],\n        _preprocessed: \u0026mut PreprocessedColumns\u003cF\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        Ok(())\n    }\n\n    /// Clone as trait object\n    fn boxed(\u0026self) -\u003e Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e;\n}\n\n// Implement Clone for Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e\nimpl\u003cF: Field\u003e Clone for Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        self.boxed()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n    use crate::ops::poseidon2_perm::Poseidon2PermPrivateData;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_op_partial_eq_different_variants() {\n        // Create operations of completely different types\n        let const_op = Op::Const {\n            out: WitnessId(0),\n            val: F::from_u64(5),\n        };\n\n        let alu_op = Op::add(WitnessId(0), WitnessId(1), WitnessId(2));\n\n        // Operations of different variants should never be equal\n        assert_ne!(const_op, alu_op);\n    }\n\n    #[test]\n    fn test_op_partial_eq_same_variant_different_values() {\n        // Create two ALU operations with different witness indices\n        let alu_op1: Op\u003cF\u003e = Op::add(WitnessId(0), WitnessId(1), WitnessId(2));\n        let alu_op2: Op\u003cF\u003e = Op::add(WitnessId(3), WitnessId(4), WitnessId(5));\n\n        // Same variant but different values should not be equal\n        assert_ne!(alu_op1, alu_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_alu_add_same_values() {\n        // Create two identical ALU addition operations\n        let a = WitnessId(0);\n        let b = WitnessId(1);\n        let out = WitnessId(2);\n\n        let alu_op1: Op\u003cF\u003e = Op::add(a, b, out);\n        let alu_op2: Op\u003cF\u003e = Op::add(a, b, out);\n\n        // Identical operations should be equal\n        assert_eq!(alu_op1, alu_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_const_different_values() {\n        // Create two constant operations with different values\n        let out = WitnessId(0);\n        let val1 = F::from_u64(10);\n        let val2 = F::from_u64(20);\n\n        let const_op1: Op\u003cF\u003e = Op::Const { out, val: val1 };\n        let const_op2: Op\u003cF\u003e = Op::Const { out, val: val2 };\n\n        // Same output but different values should not be equal\n        assert_ne!(const_op1, const_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_const_different_outputs() {\n        // Create two constant operations with same value but different outputs\n        let val = F::from_u64(42);\n        let out1 = WitnessId(0);\n        let out2 = WitnessId(1);\n\n        let const_op1: Op\u003cF\u003e = Op::Const { out: out1, val };\n        let const_op2: Op\u003cF\u003e = Op::Const { out: out2, val };\n\n        // Same value but different outputs should not be equal\n        assert_ne!(const_op1, const_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_const_same_values() {\n        // Create two identical constant operations\n        let out = WitnessId(0);\n        let val = F::from_u64(99);\n\n        let const_op1: Op\u003cF\u003e = Op::Const { out, val };\n        let const_op2: Op\u003cF\u003e = Op::Const { out, val };\n\n        // Identical constant operations should be equal\n        assert_eq!(const_op1, const_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_public_different_positions() {\n        // Create two public input operations with different positions\n        let out = WitnessId(0);\n        let pos1 = 0;\n        let pos2 = 1;\n\n        let public_op1: Op\u003cF\u003e = Op::Public {\n            out,\n            public_pos: pos1,\n        };\n        let public_op2: Op\u003cF\u003e = Op::Public {\n            out,\n            public_pos: pos2,\n        };\n\n        // Same output but different positions should not be equal\n        assert_ne!(public_op1, public_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_public_same_values() {\n        // Create two identical public input operations\n        let out = WitnessId(5);\n        let public_pos = 3;\n\n        let public_op1: Op\u003cF\u003e = Op::Public { out, public_pos };\n        let public_op2: Op\u003cF\u003e = Op::Public { out, public_pos };\n\n        // Identical public operations should be equal\n        assert_eq!(public_op1, public_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_alu_mul_different_values() {\n        // Create two ALU multiplication operations with different witness indices\n        let mul_op1: Op\u003cF\u003e = Op::mul(WitnessId(0), WitnessId(1), WitnessId(2));\n        let mul_op2: Op\u003cF\u003e = Op::mul(WitnessId(10), WitnessId(11), WitnessId(12));\n\n        // Different witness indices should not be equal\n        assert_ne!(mul_op1, mul_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_alu_mul_same_values() {\n        // Create two identical ALU multiplication operations\n        let a = WitnessId(7);\n        let b = WitnessId(8);\n        let out = WitnessId(9);\n\n        let mul_op1: Op\u003cF\u003e = Op::mul(a, b, out);\n        let mul_op2: Op\u003cF\u003e = Op::mul(a, b, out);\n\n        // Identical multiplication operations should be equal\n        assert_eq!(mul_op1, mul_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_alu_partial_match() {\n        // Create two ALU operations where only some fields match\n        let alu_op1: Op\u003cF\u003e = Op::add(WitnessId(0), WitnessId(1), WitnessId(2));\n        let alu_op2: Op\u003cF\u003e = Op::add(WitnessId(0), WitnessId(1), WitnessId(99)); // Different output\n\n        // Partial match is not enough for equality\n        assert_ne!(alu_op1, alu_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_alu_different_kinds() {\n        // Create two ALU operations with same operands but different kinds\n        let add_op: Op\u003cF\u003e = Op::add(WitnessId(0), WitnessId(1), WitnessId(2));\n        let mul_op: Op\u003cF\u003e = Op::mul(WitnessId(0), WitnessId(1), WitnessId(2));\n\n        // Different operation kinds should not be equal\n        assert_ne!(add_op, mul_op);\n    }\n\n    #[test]\n    fn test_op_partial_eq_alu_muladd() {\n        // Create two identical MulAdd operations\n        let muladd_op1: Op\u003cF\u003e = Op::mul_add(WitnessId(0), WitnessId(1), WitnessId(2), WitnessId(3));\n        let muladd_op2: Op\u003cF\u003e = Op::mul_add(WitnessId(0), WitnessId(1), WitnessId(2), WitnessId(3));\n\n        assert_eq!(muladd_op1, muladd_op2);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Invalid PrimitiveOpType value\")]\n    fn test_primitive_op_type_invalid_conversion() {\n        // Attempt to convert an invalid index to an operation type\n        //\n        // This should panic\n        let _ = PrimitiveOpType::from(999);\n    }\n\n    #[test]\n    fn test_execution_context_get_witness() {\n        // Create a witness table with known test values\n        let val = F::from_u64(42);\n        let mut witness = vec![Some(val), Some(F::from_u64(100))];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut op_states = BTreeMap::new();\n\n        // Create an execution context for operations to access the witness\n        let ctx =\n            ExecutionContext::new(\u0026mut witness, \u0026private_data, \u0026configs, op_id, \u0026mut op_states);\n\n        // Read a value from the witness table\n        let result = ctx.get_witness(WitnessId(0));\n\n        // Verify the read operation succeeded and returned the correct value\n        assert_eq!(result.unwrap(), val);\n    }\n\n    #[test]\n    fn test_execution_context_get_witness_unset() {\n        // Create a witness table where some values are not yet set\n        let mut witness = vec![None, Some(F::from_u64(100))];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut op_states = BTreeMap::new();\n\n        // Create execution context\n        let ctx =\n            ExecutionContext::new(\u0026mut witness, \u0026private_data, \u0026configs, op_id, \u0026mut op_states);\n\n        // Attempt to read a value that hasn't been set yet\n        let result = ctx.get_witness(WitnessId(0));\n\n        // Reading unset values should produce an error\n        assert!(result.is_err());\n        match result {\n            Err(CircuitError::WitnessNotSet { witness_id }) =\u003e {\n                assert_eq!(witness_id, WitnessId(0));\n            }\n            _ =\u003e panic!(\"Expected WitnessNotSet error\"),\n        }\n    }\n\n    #[test]\n    fn test_execution_context_set_witness() {\n        // Create an empty witness table to be populated\n        let mut witness = vec![None, None];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut op_states = BTreeMap::new();\n\n        // Create execution context with mutable access to witness\n        let mut ctx =\n            ExecutionContext::new(\u0026mut witness, \u0026private_data, \u0026configs, op_id, \u0026mut op_states);\n\n        // Write a computed value into the witness table\n        let val = F::from_u64(99);\n        let result = ctx.set_witness(WitnessId(0), val);\n\n        // Verify the write operation succeeded\n        assert!(result.is_ok());\n\n        // Verify the value was actually written to the witness table\n        assert_eq!(witness[0], Some(val));\n    }\n\n    #[test]\n    fn test_execution_context_set_witness_conflict() {\n        // Create a witness table with an existing value\n        let existing_val = F::from_u64(50);\n        let mut witness = vec![Some(existing_val)];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut op_states = BTreeMap::new();\n\n        // Create execution context\n        let mut ctx =\n            ExecutionContext::new(\u0026mut witness, \u0026private_data, \u0026configs, op_id, \u0026mut op_states);\n\n        // Attempt to write a different value to the same slot\n        //\n        // This represents a conflicting constraint in the circuit\n        let new_val = F::from_u64(99);\n        let result = ctx.set_witness(WitnessId(0), new_val);\n\n        // Conflicting writes must be detected and reported as errors\n        assert!(result.is_err());\n        match result {\n            Err(CircuitError::WitnessConflict { witness_id, .. }) =\u003e {\n                assert_eq!(witness_id, WitnessId(0));\n            }\n            _ =\u003e panic!(\"Expected WitnessConflict error\"),\n        }\n    }\n\n    #[test]\n    fn test_execution_context_set_witness_idempotent() {\n        // Create a witness table with an existing value\n        let val = F::from_u64(50);\n        let mut witness = vec![Some(val)];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut op_states = BTreeMap::new();\n\n        // Create execution context\n        let mut ctx =\n            ExecutionContext::new(\u0026mut witness, \u0026private_data, \u0026configs, op_id, \u0026mut op_states);\n\n        // Write the same value again to the same slot\n        //\n        // This is allowed and represents consistent constraints\n        let result = ctx.set_witness(WitnessId(0), val);\n\n        // Idempotent writes should succeed without error\n        assert!(result.is_ok());\n        assert_eq!(witness[0], Some(val));\n    }\n\n    #[test]\n    fn test_execution_context_set_witness_out_of_bounds() {\n        // Create a small witness table with limited capacity\n        let mut witness = vec![None];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut op_states = BTreeMap::new();\n\n        // Create execution context\n        let mut ctx =\n            ExecutionContext::new(\u0026mut witness, \u0026private_data, \u0026configs, op_id, \u0026mut op_states);\n\n        // Attempt to write to an index beyond the table bounds\n        let result = ctx.set_witness(WitnessId(10), F::from_u64(1));\n\n        // Out of bounds writes must be caught to prevent memory corruption\n        assert!(result.is_err());\n        match result {\n            Err(CircuitError::WitnessIdOutOfBounds { witness_id }) =\u003e {\n                assert_eq!(witness_id, WitnessId(10));\n            }\n            _ =\u003e panic!(\"Expected WitnessIdOutOfBounds error\"),\n        }\n    }\n\n    #[test]\n    fn test_execution_context_get_private_data() {\n        // Create private auxiliary data for a verification operation\n        let poseidon2_data: Poseidon2PermPrivateData\u003cF, 2\u003e = Poseidon2PermPrivateData {\n            sibling: [F::ZERO, F::ZERO],\n        };\n        let private_data = vec![Some(NonPrimitiveOpPrivateData::Poseidon2Perm(\n            poseidon2_data.clone(),\n        ))];\n\n        // Create execution context with access to private data\n        let mut witness = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut op_states = BTreeMap::new();\n        let ctx =\n            ExecutionContext::new(\u0026mut witness, \u0026private_data, \u0026configs, op_id, \u0026mut op_states);\n\n        // Operations can access their private data through the context\n        let result = ctx.get_private_data();\n\n        // Verify private data access succeeded\n        assert_eq!(\n            *result.unwrap(),\n            NonPrimitiveOpPrivateData::Poseidon2Perm(poseidon2_data)\n        );\n    }\n\n    #[test]\n    fn test_execution_context_get_private_data_missing() {\n        // Create an execution context without private data\n        let private_data = vec![];\n        let mut witness = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut op_states = BTreeMap::new();\n\n        // Create execution context\n        let ctx: ExecutionContext\u003c'_, F\u003e =\n            ExecutionContext::new(\u0026mut witness, \u0026private_data, \u0026configs, op_id, \u0026mut op_states);\n\n        // Attempt to access private data that wasn't provided\n        let result = ctx.get_private_data();\n\n        // Missing private data should be reported as an error\n        assert!(result.is_err());\n        match result {\n            Err(CircuitError::NonPrimitiveOpMissingPrivateData { operation_index }) =\u003e {\n                assert_eq!(operation_index, op_id);\n            }\n            _ =\u003e panic!(\"Expected NonPrimitiveOpMissingPrivateData error\"),\n        }\n    }\n\n    #[test]\n    fn test_execution_context_get_config() {\n        // Create a configuration map for operation parameters\n        let mut configs = HashMap::new();\n        let op_type = NonPrimitiveOpType::Poseidon2Perm(Poseidon2Config::BabyBearD4Width16);\n        configs.insert(op_type, NonPrimitiveOpConfig::None);\n\n        // Create execution context with configurations\n        let mut witness = vec![];\n        let private_data = vec![];\n        let op_id = NonPrimitiveOpId(0);\n        let mut op_states = BTreeMap::new();\n        let ctx: ExecutionContext\u003c'_, F\u003e =\n            ExecutionContext::new(\u0026mut witness, \u0026private_data, \u0026configs, op_id, \u0026mut op_states);\n\n        // Operations can query their configuration at runtime\n        let result = ctx.get_config(\u0026op_type);\n\n        // Verify configuration lookup succeeded\n        assert_eq!(*result.unwrap(), NonPrimitiveOpConfig::None);\n    }\n\n    #[test]\n    fn test_execution_context_get_config_missing() {\n        // Create an empty configuration map\n        let configs = HashMap::new();\n        let mut witness = vec![];\n        let private_data = vec![];\n        let op_id = NonPrimitiveOpId(0);\n        let mut op_states = BTreeMap::new();\n\n        // Create execution context\n        let ctx: ExecutionContext\u003c'_, F\u003e =\n            ExecutionContext::new(\u0026mut witness, \u0026private_data, \u0026configs, op_id, \u0026mut op_states);\n\n        // Attempt to access a configuration that wasn't registered\n        let op_type = NonPrimitiveOpType::Poseidon2Perm(Poseidon2Config::BabyBearD4Width16);\n        let result = ctx.get_config(\u0026op_type);\n\n        // Missing configurations indicate setup errors\n        assert!(result.is_err());\n        match result {\n            Err(CircuitError::InvalidNonPrimitiveOpConfiguration { op }) =\u003e {\n                assert_eq!(op, op_type);\n            }\n            _ =\u003e panic!(\"Expected InvalidNonPrimitiveOpConfiguration error\"),\n        }\n    }\n\n    #[test]\n    fn test_execution_context_operation_id() {\n        // Create execution context with a specific operation identifier\n        let mut witness = vec![];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let expected_id = NonPrimitiveOpId(42);\n        let mut op_states = BTreeMap::new();\n        let ctx: ExecutionContext\u003c'_, F\u003e = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            expected_id,\n            \u0026mut op_states,\n        );\n\n        // Retrieve the operation ID from the context\n        let retrieved_id = ctx.operation_id();\n\n        // Verify the ID is correctly preserved\n        assert_eq!(retrieved_id, expected_id);\n    }\n\n    /// Test state type for verifying generic state management.\n    #[derive(Debug, Default)]\n    struct TestOpState {\n        value: Option\u003cu64\u003e,\n    }\n\n    impl OpExecutionState for TestOpState {\n        fn as_any(\u0026self) -\u003e \u0026dyn core::any::Any {\n            self\n        }\n        fn as_any_mut(\u0026mut self) -\u003e \u0026mut dyn core::any::Any {\n            self\n        }\n    }\n\n    #[test]\n    fn test_execution_context_op_state() {\n        // Test the generic operation state accessors\n        let mut witness: Vec\u003cOption\u003cF\u003e\u003e = vec![];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut op_states = BTreeMap::new();\n\n        let mut ctx =\n            ExecutionContext::new(\u0026mut witness, \u0026private_data, \u0026configs, op_id, \u0026mut op_states);\n\n        // Initially, no state should be present\n        assert!(\n            ctx.get_op_state::\u003cTestOpState\u003e(\u0026NonPrimitiveOpType::Poseidon2Perm(\n                Poseidon2Config::BabyBearD4Width16,\n            ))\n            .is_none()\n        );\n\n        // Get or create state (should create default)\n        let state = ctx.get_op_state_mut::\u003cTestOpState\u003e(\u0026NonPrimitiveOpType::Poseidon2Perm(\n            Poseidon2Config::BabyBearD4Width16,\n        ));\n        assert!(state.value.is_none());\n\n        // Modify the state\n        state.value = Some(42);\n\n        // Verify the state was stored and can be retrieved\n        let state_ref = ctx\n            .get_op_state::\u003cTestOpState\u003e(\u0026NonPrimitiveOpType::Poseidon2Perm(\n                Poseidon2Config::BabyBearD4Width16,\n            ))\n            .unwrap();\n        assert_eq!(state_ref.value, Some(42));\n    }\n}\n","traces":[{"line":104,"address":[1464304],"length":1,"stats":{"Line":21}},{"line":116,"address":[],"length":0,"stats":{"Line":20}},{"line":128,"address":[7875040],"length":1,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[7872432],"length":1,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[7872516],"length":1,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[4617904,4616944],"length":1,"stats":{"Line":32}},{"line":169,"address":[8152734,8154654,8151774,8153694,8155614],"length":1,"stats":{"Line":27}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":28}},{"line":173,"address":[2694161],"length":1,"stats":{"Line":15}},{"line":174,"address":[4618951,4619001,4619063,4618889],"length":1,"stats":{"Line":28}},{"line":175,"address":[],"length":0,"stats":{"Line":14}},{"line":177,"address":[1464281],"length":1,"stats":{"Line":14}},{"line":179,"address":[4571302],"length":1,"stats":{"Line":14}},{"line":180,"address":[7872782,7873742],"length":1,"stats":{"Line":7}},{"line":181,"address":[5216843,5215883],"length":1,"stats":{"Line":0}},{"line":182,"address":[4617236,4618196],"length":1,"stats":{"Line":14}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[4571539],"length":1,"stats":{"Line":14}},{"line":191,"address":[4014410],"length":1,"stats":{"Line":15}},{"line":192,"address":[8153041,8154961,8155921,8152081,8154001],"length":1,"stats":{"Line":15}},{"line":193,"address":[7873022,7873982],"length":1,"stats":{"Line":15}},{"line":194,"address":[1661317],"length":1,"stats":{"Line":15}},{"line":196,"address":[8153132,8154092,8152172,8156012,8155052],"length":1,"stats":{"Line":11}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[3488536,3488573,3489533,3489496],"length":1,"stats":{"Line":22}},{"line":200,"address":[4014941,4014645,4015025],"length":1,"stats":{"Line":33}},{"line":201,"address":[8153613,8156493,8154573,8152653,8155533],"length":1,"stats":{"Line":11}},{"line":204,"address":[4571844,4571881],"length":1,"stats":{"Line":22}},{"line":205,"address":[3489883,3489742,3488782,3488923],"length":1,"stats":{"Line":23}},{"line":206,"address":[2694022],"length":1,"stats":{"Line":11}},{"line":225,"address":[4425104],"length":1,"stats":{"Line":7}},{"line":226,"address":[6787737],"length":1,"stats":{"Line":5}},{"line":227,"address":[15700273],"length":1,"stats":{"Line":6}},{"line":228,"address":[2587208],"length":1,"stats":{"Line":5}},{"line":229,"address":[7981503],"length":1,"stats":{"Line":6}},{"line":230,"address":[13422310],"length":1,"stats":{"Line":6}},{"line":231,"address":[11606302],"length":1,"stats":{"Line":1}},{"line":238,"address":[7975552,7976259,7976265],"length":1,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":242,"address":[2819540],"length":1,"stats":{"Line":2}},{"line":245,"address":[7975751],"length":1,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[7975883],"length":1,"stats":{"Line":3}},{"line":257,"address":[],"length":0,"stats":{"Line":3}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[7975895],"length":1,"stats":{"Line":3}},{"line":260,"address":[2819788],"length":1,"stats":{"Line":3}},{"line":261,"address":[7975905],"length":1,"stats":{"Line":3}},{"line":263,"address":[7975967],"length":1,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[2819933],"length":1,"stats":{"Line":0}},{"line":271,"address":[7976109],"length":1,"stats":{"Line":0}},{"line":272,"address":[2820074],"length":1,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":3}},{"line":282,"address":[7976663],"length":1,"stats":{"Line":1}},{"line":283,"address":[7976705,7976733],"length":1,"stats":{"Line":2}},{"line":285,"address":[7976818],"length":1,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[7976899],"length":1,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[7977295],"length":1,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":366,"address":[2822416],"length":1,"stats":{"Line":0}},{"line":367,"address":[2822440],"length":1,"stats":{"Line":0}},{"line":368,"address":[2822477],"length":1,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[2822592],"length":1,"stats":{"Line":0}},{"line":382,"address":[7980816],"length":1,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[7980875],"length":1,"stats":{"Line":0}},{"line":385,"address":[7980926],"length":1,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[7981001],"length":1,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":1}},{"line":402,"address":[7981944,7981981],"length":1,"stats":{"Line":2}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[7982119],"length":1,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[7982093],"length":1,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[7879168,7879248],"length":1,"stats":{"Line":15}},{"line":516,"address":[4789920],"length":1,"stats":{"Line":15}},{"line":517,"address":[2778196],"length":1,"stats":{"Line":15}},{"line":518,"address":[5218353,5218475],"length":1,"stats":{"Line":15}},{"line":519,"address":[4619821,4619929,4619888,4619687,4619920,4619897],"length":1,"stats":{"Line":45}},{"line":521,"address":[1464626],"length":1,"stats":{"Line":15}},{"line":526,"address":[4016651,4015568,4016576],"length":1,"stats":{"Line":13}},{"line":527,"address":[5219710,5218685],"length":1,"stats":{"Line":14}},{"line":528,"address":[4015679],"length":1,"stats":{"Line":1}},{"line":531,"address":[2694878,2694832,2694751],"length":1,"stats":{"Line":28}},{"line":534,"address":[4790331,4790243],"length":1,"stats":{"Line":28}},{"line":535,"address":[],"length":0,"stats":{"Line":30}},{"line":537,"address":[1662781],"length":1,"stats":{"Line":15}},{"line":539,"address":[2779173],"length":1,"stats":{"Line":3}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[4016067,4016021],"length":1,"stats":{"Line":6}},{"line":542,"address":[8160873,8159665,8160806,8163224,8159732,8164308,8163157,8162083,8162016,8164241],"length":1,"stats":{"Line":6}},{"line":543,"address":[4016345],"length":1,"stats":{"Line":3}},{"line":547,"address":[4573752,4573076],"length":1,"stats":{"Line":28}},{"line":548,"address":[],"length":0,"stats":{"Line":14}},{"line":552,"address":[2779808],"length":1,"stats":{"Line":13}},{"line":553,"address":[],"length":0,"stats":{"Line":13}},{"line":554,"address":[4574243],"length":1,"stats":{"Line":13}},{"line":555,"address":[4574320,4574256,4574329],"length":1,"stats":{"Line":42}},{"line":556,"address":[5221701,5221589],"length":1,"stats":{"Line":15}},{"line":557,"address":[2696210],"length":1,"stats":{"Line":15}},{"line":562,"address":[3490528,3490640],"length":1,"stats":{"Line":15}},{"line":566,"address":[4015315],"length":1,"stats":{"Line":15}},{"line":567,"address":[6097879],"length":1,"stats":{"Line":15}},{"line":568,"address":[1662168],"length":1,"stats":{"Line":13}},{"line":572,"address":[],"length":0,"stats":{"Line":13}},{"line":573,"address":[4622277,4622293],"length":1,"stats":{"Line":14}},{"line":579,"address":[2779440],"length":1,"stats":{"Line":14}},{"line":583,"address":[1465838],"length":1,"stats":{"Line":14}},{"line":584,"address":[4573858],"length":1,"stats":{"Line":14}},{"line":585,"address":[],"length":0,"stats":{"Line":39}},{"line":591,"address":[5221008,5221216],"length":1,"stats":{"Line":15}},{"line":596,"address":[4016817],"length":1,"stats":{"Line":15}},{"line":597,"address":[6099416],"length":1,"stats":{"Line":16}},{"line":599,"address":[7878263,7878676,7878465],"length":1,"stats":{"Line":14}},{"line":600,"address":[4791349],"length":1,"stats":{"Line":14}},{"line":601,"address":[2696048,2696096,2696108],"length":1,"stats":{"Line":41}},{"line":636,"address":[5813456,5813408],"length":1,"stats":{"Line":2}},{"line":642,"address":[4918369,4918321],"length":1,"stats":{"Line":2}},{"line":651,"address":[],"length":0,"stats":{"Line":14}},{"line":652,"address":[3490472,3490504],"length":1,"stats":{"Line":14}}],"covered":102,"coverable":198},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","ops","hash.rs"],"content":"use alloc::string::ToString;\nuse alloc::vec::Vec;\nuse core::iter;\n\nuse p3_field::Field;\n\nuse crate::op::Poseidon2Config;\nuse crate::ops::Poseidon2PermCall;\nuse crate::ops::poseidon2_perm::Poseidon2PermOps;\nuse crate::{CircuitBuilder, CircuitBuilderError, ExprId, NonPrimitiveOpId};\n\npub fn add_hash_slice\u003cF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cF\u003e,\n    poseidon2_config: \u0026Poseidon2Config,\n    inputs: \u0026[ExprId],\n    reset: bool,\n) -\u003e Result\u003cVec\u003cExprId\u003e, CircuitBuilderError\u003e {\n    let chunks = inputs.chunks(poseidon2_config.rate_ext());\n    let last_idx = chunks.len() - 1;\n    let mut outputs = [None, None, None, None];\n    let mut last_op_id = NonPrimitiveOpId(0);\n    for (i, input) in chunks.enumerate() {\n        let is_first = i == 0;\n        let is_last = i == last_idx;\n        let (op_id, maybe_outputs) = builder.add_poseidon2_perm(Poseidon2PermCall {\n            config: *poseidon2_config,\n            new_start: if is_first { reset } else { false },\n            merkle_path: false,\n            mmcs_bit: None,\n            inputs: input\n                .iter()\n                .cloned()\n                .map(Some)\n                .chain(iter::repeat(None))\n                .take(4)\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .try_into()\n                .expect(\"We have already taken 4 elements\"),\n            out_ctl: [is_last, is_last],\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })?;\n        outputs = maybe_outputs;\n        last_op_id = op_id;\n    }\n\n    // Only return outputs 0-1 (rate elements) for hashing\n    [outputs[0], outputs[1]]\n        .into_iter()\n        .map(|o| {\n            o.ok_or_else(|| CircuitBuilderError::MalformedNonPrimitiveOutputs {\n                op_id: last_op_id,\n                details: \"\".to_string(),\n            })\n        })\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec::Vec;\n    use core::iter;\n\n    use itertools::Itertools;\n    use p3_baby_bear::{BabyBear, Poseidon2BabyBear, default_babybear_poseidon2_16};\n    use p3_field::extension::BinomialExtensionField;\n    use p3_field::{BasedVectorSpace, PrimeCharacteristicRing};\n    use p3_symmetric::{CryptographicHasher, PaddingFreeSponge};\n\n    use super::add_hash_slice;\n    use crate::ops::{Poseidon2Config, Poseidon2Params, generate_poseidon2_trace};\n    use crate::{CircuitBuilder, ExprId};\n\n    type F = BabyBear;\n    type CF = BinomialExtensionField\u003cF, 4\u003e;\n    type Perm = Poseidon2BabyBear\u003c16\u003e;\n    type MyHash = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\n\n    struct DummyParams;\n\n    impl Poseidon2Params for DummyParams {\n        type BaseField = F;\n        const CONFIG: Poseidon2Config = Poseidon2Config::BabyBearD4Width16;\n    }\n\n    #[test]\n    fn test_hash_squeeze() {\n        let perm = default_babybear_poseidon2_16();\n        let hasher = MyHash::new(perm.clone());\n\n        // Test only lengths that are multiples of 4 (aligned to extension degree)\n        // Non-aligned lengths (like 9, 10, 11) have different behavior in overwrite-mode\n        // sponge vs zero-padded extension packing - see test_hash_non_aligned for details\n        for len in [4, 8, 12, 16, 32, 64] {\n            let base_inputs = (0..len)\n                .map(|i| F::from_u64(i as u64 + 1))\n                .collect::\u003cVec\u003c_\u003e\u003e();\n            let expected = hasher.hash_iter(base_inputs.clone());\n\n            let mut builder = CircuitBuilder::\u003cCF\u003e::new();\n            builder.enable_poseidon2_perm::\u003cDummyParams, _\u003e(\n                generate_poseidon2_trace::\u003cCF, DummyParams\u003e,\n                perm.clone(),\n            );\n\n            let input_exprs: Vec\u003cExprId\u003e = (0..base_inputs.len())\n                .chunks(\u003cCF as BasedVectorSpace\u003cF\u003e\u003e::DIMENSION)\n                .into_iter()\n                .map(|_| builder.public_input())\n                .collect();\n\n            let outputs = add_hash_slice(\n                \u0026mut builder,\n                \u0026Poseidon2Config::BabyBearD4Width16,\n                \u0026input_exprs,\n                true,\n            )\n            .unwrap();\n\n            let out0_pi = builder.public_input();\n            let out1_pi = builder.public_input();\n            builder.connect(outputs[0], out0_pi);\n            builder.connect(outputs[1], out1_pi);\n\n            let circuit = builder.build().unwrap();\n            let mut runner = circuit.runner();\n            let mut public_inputs = base_inputs // Pad to multiple of 4\n                .chunks(\u003cCF as BasedVectorSpace\u003cF\u003e\u003e::DIMENSION)\n                .map(|chunk| {\n                    let chunk: Vec\u003cF\u003e = chunk\n                        .iter()\n                        .cloned()\n                        .chain(iter::repeat(F::ZERO))\n                        .take(\u003cCF as BasedVectorSpace\u003cF\u003e\u003e::DIMENSION)\n                        .collect();\n                    CF::from_basis_coefficients_slice(\u0026chunk).unwrap()\n                })\n                .collect::\u003cVec\u003c_\u003e\u003e();\n            let expected_limb0 = CF::from_basis_coefficients_slice(\u0026expected[0..4]).unwrap();\n            let expected_limb1 = CF::from_basis_coefficients_slice(\u0026expected[4..8]).unwrap();\n            public_inputs.push(expected_limb0);\n            public_inputs.push(expected_limb1);\n            runner.set_public_inputs(\u0026public_inputs).unwrap();\n\n            runner.run().unwrap();\n        }\n    }\n\n    /// Test that exposes the mismatch between circuit hashing and native PaddingFreeSponge\n    /// for non-aligned input lengths.\n    ///\n    /// Native PaddingFreeSponge uses \"overwrite mode\": when absorbing a partial chunk,\n    /// only the absorbed positions are overwritten; the rest keep their previous values.\n    ///\n    /// The circuit's add_hash_slice + repack_base_to_ext uses zero-padding: partial\n    /// extension elements are padded with zeros, which overwrites all rate positions.\n    ///\n    /// This test demonstrates the mismatch for 9 base field elements (not a multiple of 4).\n    #[test]\n    #[should_panic(expected = \"WitnessConflict\")]\n    fn test_hash_non_aligned_shows_mismatch() {\n        let perm = default_babybear_poseidon2_16();\n        let hasher = MyHash::new(perm.clone());\n\n        // 9 elements: NOT aligned to extension degree (4)\n        // Circuit will pack as 3 extension elements: [[v0,v1,v2,v3], [v4,v5,v6,v7], [v8,0,0,0]]\n        // Native sponge will absorb: [v0..v7], permute, then [v8] (keeping positions 1-7 from permutation)\n        let len = 9;\n        let base_inputs = (0..len)\n            .map(|i| F::from_u64(i as u64 + 1))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let expected = hasher.hash_iter(base_inputs.clone());\n\n        let mut builder = CircuitBuilder::\u003cCF\u003e::new();\n        builder.enable_poseidon2_perm::\u003cDummyParams, _\u003e(\n            generate_poseidon2_trace::\u003cCF, DummyParams\u003e,\n            perm,\n        );\n\n        // Pack base inputs into extension elements (will zero-pad the last one)\n        let input_exprs: Vec\u003cExprId\u003e = base_inputs\n            .chunks(\u003cCF as BasedVectorSpace\u003cF\u003e\u003e::DIMENSION)\n            .map(|_| builder.public_input())\n            .collect();\n\n        let outputs = add_hash_slice(\n            \u0026mut builder,\n            \u0026Poseidon2Config::BabyBearD4Width16,\n            \u0026input_exprs,\n            true,\n        )\n        .unwrap();\n\n        let out0_pi = builder.public_input();\n        let out1_pi = builder.public_input();\n        builder.connect(outputs[0], out0_pi);\n        builder.connect(outputs[1], out1_pi);\n\n        let circuit = builder.build().unwrap();\n        let mut runner = circuit.runner();\n\n        // Pack base inputs with zero-padding for the last chunk\n        let mut public_inputs = base_inputs\n            .chunks(\u003cCF as BasedVectorSpace\u003cF\u003e\u003e::DIMENSION)\n            .map(|chunk| {\n                let chunk: Vec\u003cF\u003e = chunk\n                    .iter()\n                    .cloned()\n                    .chain(iter::repeat(F::ZERO))\n                    .take(\u003cCF as BasedVectorSpace\u003cF\u003e\u003e::DIMENSION)\n                    .collect();\n                CF::from_basis_coefficients_slice(\u0026chunk).unwrap()\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // Native hash expects different result due to overwrite mode\n        let expected_limb0 = CF::from_basis_coefficients_slice(\u0026expected[0..4]).unwrap();\n        let expected_limb1 = CF::from_basis_coefficients_slice(\u0026expected[4..8]).unwrap();\n        public_inputs.push(expected_limb0);\n        public_inputs.push(expected_limb1);\n        runner.set_public_inputs(\u0026public_inputs).unwrap();\n\n        // This will panic with WitnessConflict because circuit hash != native hash\n        runner.run().unwrap();\n    }\n}\n","traces":[{"line":12,"address":[7024256],"length":1,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":1}},{"line":27,"address":[7024992,7024842],"length":1,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[7025097],"length":1,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":25,"coverable":32},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","ops","mmcs.rs"],"content":"use alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::cmp::Reverse;\n\nuse itertools::Itertools;\nuse p3_field::Field;\nuse p3_matrix::Dimensions;\n\nuse crate::builder::{CircuitBuilder, CircuitBuilderError};\nuse crate::op::{NonPrimitiveOpType, Poseidon2Config};\nuse crate::ops::Poseidon2PermCall;\nuse crate::ops::poseidon2_perm::Poseidon2PermOps;\nuse crate::types::ExprId;\nuse crate::{CircuitError, NonPrimitiveOpId};\n\n/// Given a vector with the openings and dimensions it formats the openings\n/// into a vec of size `max_height`, where each entry contains the openings\n/// corresponding to that height. Openings for heights that do not exist in the\n/// input are empty vectors.\npub fn format_openings\u003cT: Clone + alloc::fmt::Debug\u003e(\n    openings: \u0026[Vec\u003cT\u003e],\n    dimensions: \u0026[Dimensions],\n    max_height_log: usize,\n    permutation_config: Poseidon2Config,\n) -\u003e Result\u003cVec\u003cVec\u003cT\u003e\u003e, CircuitError\u003e {\n    if openings.len() \u003e 1 \u003c\u003c max_height_log {\n        return Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n            op: NonPrimitiveOpType::Poseidon2Perm(permutation_config),\n            expected: format!(\"at most {}\", max_height_log),\n            got: openings.len(),\n        });\n    }\n\n    let mut heights_tallest_first = dimensions\n        .iter()\n        .enumerate()\n        .sorted_by_key(|(_, dims)| Reverse(dims.height))\n        .peekable();\n\n    // Matrix heights that round up to the same power of two must be equal\n    if !heights_tallest_first\n        .clone()\n        .map(|(_, dims)| dims.height)\n        .tuple_windows()\n        .all(|(curr, next)| curr == next || curr.next_power_of_two() != next.next_power_of_two())\n    {\n        return Err(CircuitError::InconsistentMatrixHeights {\n            details: \"Heights that round up to the same power of two must be equal\".to_string(),\n        });\n    }\n\n    let mut formatted_openings = vec![vec![]; max_height_log];\n    for (curr_height, opening) in formatted_openings\n        .iter_mut()\n        .enumerate()\n        .map(|(i, leaf)| (1 \u003c\u003c (max_height_log - i), leaf))\n    {\n        // Get the initial height padded to a power of two. As heights_tallest_first is sorted,\n        // the initial height will be the maximum height.\n        // Returns an error if either:\n        //              1. proof.len() != log_max_height\n        //              2. heights_tallest_first is empty.\n        let new_opening = heights_tallest_first\n            .peeking_take_while(|(_, dims)| dims.height.next_power_of_two() == curr_height)\n            .flat_map(|(i, _)| openings[i].clone())\n            .collect();\n        *opening = new_opening;\n    }\n    Ok(formatted_openings)\n}\n\n/// Verify a Merkle path in the circuit.\n///\n/// `openings_expr` contains the row digests at each tree level. When its length equals\n/// `directions_expr.len()`, every entry corresponds to a sibling-compression step.\n/// When its length is `directions_expr.len() + 1`, the extra trailing entry is a\n/// **tail digest**: it is compressed into the running hash *after* the last sibling\n/// step but *before* the root comparison. This mirrors the native MMCS behaviour\n/// where matrices at the cap level are injected after the final proof sibling.\npub fn add_mmcs_verify\u003cF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cF\u003e,\n    permutation_config: Poseidon2Config,\n    openings_expr: \u0026[Vec\u003cExprId\u003e],\n    directions_expr: \u0026[ExprId],\n    root_expr: \u0026[ExprId],\n) -\u003e Result\u003cVec\u003cNonPrimitiveOpId\u003e, CircuitBuilderError\u003e {\n    // We return only the operations that require private data.\n    let mut op_ids = Vec::with_capacity(openings_expr.len());\n    let mut output = [None, None, None, None];\n    let zero = builder.define_const(F::ZERO);\n\n    // Detect a non-empty tail digest (cap-level rows to inject after the main path).\n    let has_tail = openings_expr.len() \u003e directions_expr.len()\n        \u0026\u0026 !openings_expr[directions_expr.len()].is_empty();\n\n    let path_openings = \u0026openings_expr[..directions_expr.len()];\n\n    for (i, (row_digest, direction)) in path_openings.iter().zip(directions_expr).enumerate() {\n        let is_first = i == 0;\n        let is_last_direction = i == directions_expr.len() - 1;\n        // The step is truly final only when there is no tail to inject afterwards.\n        let is_final = is_last_direction \u0026\u0026 !has_tail;\n\n        // Extra row (if any) must be combined before the main sibling step.\n        if !is_first \u0026\u0026 !row_digest.is_empty() {\n            let _ = builder.add_poseidon2_perm(Poseidon2PermCall {\n                config: permutation_config,\n                new_start: false,\n                merkle_path: true,\n                mmcs_bit: Some(zero), // Extra row is always a left child\n                inputs: [None, None, Some(row_digest[0]), Some(row_digest[1])],\n                out_ctl: [false, false],\n                return_all_outputs: false,\n                mmcs_index_sum: None,\n            })?;\n        }\n\n        let (op_id, maybe_output) = builder.add_poseidon2_perm(Poseidon2PermCall {\n            config: permutation_config,\n            new_start: is_first,\n            merkle_path: true,\n            mmcs_bit: Some(*direction),\n            inputs: if is_first {\n                [Some(row_digest[0]), Some(row_digest[1]), None, None]\n            } else {\n                [None, None, None, None]\n            },\n            out_ctl: [is_final, is_final],\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })?;\n        op_ids.push(op_id);\n        output = maybe_output;\n    }\n\n    // Inject tail digest (cap-level rows) after the last sibling step.\n    if has_tail {\n        let tail = \u0026openings_expr[directions_expr.len()];\n        let (_, tail_output) = builder.add_poseidon2_perm(Poseidon2PermCall {\n            config: permutation_config,\n            new_start: false,\n            merkle_path: true,\n            mmcs_bit: Some(zero),\n            inputs: [None, None, Some(tail[0]), Some(tail[1])],\n            out_ctl: [true, true],\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })?;\n        output = tail_output;\n    }\n\n    // Only outputs 0-1 are CTL-exposed for MMCS verification\n    let output = [output[0], output[1]]\n        .into_iter()\n        .map(|x| {\n            x.ok_or_else(|| CircuitBuilderError::MalformedNonPrimitiveOutputs {\n                op_id: *op_ids.last().unwrap(),\n                details: \"Expected output from last Poseidon2Perm call\".to_string(),\n            })\n        })\n        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n    builder.connect(output[0], root_expr[0]);\n    builder.connect(output[1], root_expr[1]);\n    Ok(op_ids)\n}\n","traces":[{"line":21,"address":[6406475,6404864,6406481],"length":1,"stats":{"Line":1}},{"line":27,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[6405286],"length":1,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[6405446,6406736,6406751],"length":1,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[6405614],"length":1,"stats":{"Line":0}},{"line":49,"address":[6405575],"length":1,"stats":{"Line":0}},{"line":53,"address":[6405735],"length":1,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[6405848],"length":1,"stats":{"Line":1}},{"line":56,"address":[6405883],"length":1,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[6406928,6406947,6406143],"length":1,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[2742914,2738768,2741331],"length":1,"stats":{"Line":5}},{"line":89,"address":[6160664],"length":1,"stats":{"Line":6}},{"line":90,"address":[3040797],"length":1,"stats":{"Line":5}},{"line":91,"address":[2739049,2739146],"length":1,"stats":{"Line":10}},{"line":94,"address":[2739153,2739337],"length":1,"stats":{"Line":10}},{"line":95,"address":[4834509,4834432],"length":1,"stats":{"Line":10}},{"line":97,"address":[2739358,2739215],"length":1,"stats":{"Line":10}},{"line":99,"address":[3044696,3041166],"length":1,"stats":{"Line":10}},{"line":100,"address":[6401366],"length":1,"stats":{"Line":5}},{"line":101,"address":[],"length":0,"stats":{"Line":10}},{"line":103,"address":[],"length":0,"stats":{"Line":10}},{"line":106,"address":[2742083,2741523,2741460],"length":1,"stats":{"Line":13}},{"line":107,"address":[3984845,3985223,3985102],"length":1,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[2741537],"length":1,"stats":{"Line":3}},{"line":113,"address":[3043486],"length":1,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[2504246,2504356,2503963,2504621],"length":1,"stats":{"Line":10}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[5599564],"length":1,"stats":{"Line":5}},{"line":124,"address":[5600577,5600229,5599570],"length":1,"stats":{"Line":15}},{"line":125,"address":[4322320,4322095],"length":1,"stats":{"Line":10}},{"line":127,"address":[2503805],"length":1,"stats":{"Line":5}},{"line":129,"address":[3044019],"length":1,"stats":{"Line":5}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[4322753],"length":1,"stats":{"Line":5}},{"line":134,"address":[4838088],"length":1,"stats":{"Line":5}},{"line":138,"address":[],"length":0,"stats":{"Line":6}},{"line":139,"address":[3041612,3041531],"length":1,"stats":{"Line":1}},{"line":140,"address":[4320165,4319908,4321282],"length":1,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[3041643,3041573],"length":1,"stats":{"Line":2}},{"line":146,"address":[2501684],"length":1,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[5598492],"length":1,"stats":{"Line":1}},{"line":154,"address":[5598836,5599401,5598561,5597782,5598726],"length":1,"stats":{"Line":15}},{"line":156,"address":[5598680,5601008],"length":1,"stats":{"Line":10}},{"line":157,"address":[3986291,3986126,3986144],"length":1,"stats":{"Line":5}},{"line":158,"address":[3986248,3986176],"length":1,"stats":{"Line":0}},{"line":159,"address":[6404789],"length":1,"stats":{"Line":0}},{"line":163,"address":[2502637,2502725],"length":1,"stats":{"Line":10}},{"line":164,"address":[6162784],"length":1,"stats":{"Line":5}},{"line":165,"address":[5599285],"length":1,"stats":{"Line":5}}],"covered":52,"coverable":78},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","ops","mod.rs"],"content":"pub mod hash;\npub mod mmcs;\npub mod poseidon2_perm;\n\npub(crate) use poseidon2_perm::Poseidon2PermExecutor;\npub use poseidon2_perm::{\n    // D=1 configurations for base field challenges\n    BabyBearD1Width16,\n    KoalaBearD1Width16,\n    // Prover/AIR (trace access)\n    Poseidon2CircuitRow,\n    Poseidon2Config,\n    Poseidon2Params,\n    // Builder API\n    Poseidon2PermCall,\n    Poseidon2PermCallBase,\n    // Configuration\n    Poseidon2PermExec,\n    Poseidon2PermOps,\n    Poseidon2PermPrivateData,\n    Poseidon2Trace,\n    generate_poseidon2_trace,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","ops","poseidon2_perm.rs"],"content":"//! Poseidon2 permutation non-primitive operation (one Poseidon2 call per row).\n//!\n//! This module contains all Poseidon2 permutation related code:\n//! - Builder API (`Poseidon2PermCall`, `Poseidon2PermOps`)\n//! - Executor (`Poseidon2PermExecutor`)\n//! - Execution state (`Poseidon2ExecutionState`, `Poseidon2PermRowRecord`)\n//! - Private data (`Poseidon2PermPrivateData`)\n//! - Trace generation types (`Poseidon2Params`, `Poseidon2CircuitRow`, `Poseidon2Trace`)\n//!\n//! This operation is designed to support both standard hashing and specific logic required for\n//! Merkle path verification within a circuit. Its features include:\n//!\n//! - **Hashing**: Performs a standard Poseidon2 permutation.\n//! - **Chaining**: Can start a new hash computation or continue from the output of the previous row\n//!   (controlled by `new_start`).\n//! - **Merkle Path Verification**: When `merkle_path` is enabled, it supports logic for verifying\n//!   a path up a Merkle tree. This involves conditionally arranging inputs (sibling vs. computed hash)\n//!   based on a direction bit (`mmcs_bit`).\n//! - **Index Accumulation**: Supports accumulating path indices (`mmcs_index_sum`) to verify the\n//!   leaf's position in the tree.\n//!\n//! Only supports extension degree D=4 for now.\n\nuse alloc::boxed::Box;\nuse alloc::string::ToString;\nuse alloc::sync::Arc;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::any::Any;\nuse core::fmt::Debug;\n\nuse p3_field::{ExtensionField, Field, PrimeCharacteristicRing, PrimeField};\nuse serde::{Deserialize, Serialize};\n\nuse crate::builder::{CircuitBuilder, NonPrimitiveOpParams};\nuse crate::circuit::CircuitField;\nuse crate::op::{\n    ExecutionContext, NonPrimitiveExecutor, NonPrimitiveOpConfig, NonPrimitiveOpPrivateData,\n    NonPrimitiveOpType, OpExecutionState,\n};\nuse crate::tables::NonPrimitiveTrace;\nuse crate::types::{ExprId, NonPrimitiveOpId, WitnessId};\nuse crate::{CircuitError, PreprocessedColumns};\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n/// Poseidon2 configuration used as a stable operation key and parameter source.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd, Serialize, Deserialize)]\npub enum Poseidon2Config {\n    /// BabyBear with extension degree D=1 (base field challenges), width 16.\n    BabyBearD1Width16,\n    BabyBearD4Width16,\n    BabyBearD4Width24,\n    /// KoalaBear with extension degree D=1 (base field challenges), width 16.\n    KoalaBearD1Width16,\n    KoalaBearD4Width16,\n    KoalaBearD4Width24,\n}\n\nimpl Poseidon2Config {\n    pub const fn d(self) -\u003e usize {\n        match self {\n            Self::BabyBearD1Width16 | Self::KoalaBearD1Width16 =\u003e 1,\n            Self::BabyBearD4Width16\n            | Self::BabyBearD4Width24\n            | Self::KoalaBearD4Width16\n            | Self::KoalaBearD4Width24 =\u003e 4,\n        }\n    }\n\n    pub const fn width(self) -\u003e usize {\n        match self {\n            Self::BabyBearD1Width16\n            | Self::BabyBearD4Width16\n            | Self::KoalaBearD1Width16\n            | Self::KoalaBearD4Width16 =\u003e 16,\n            Self::BabyBearD4Width24 | Self::KoalaBearD4Width24 =\u003e 24,\n        }\n    }\n\n    /// Rate in extension field elements (WIDTH / D for D=4, or WIDTH for D=1).\n    pub const fn rate_ext(self) -\u003e usize {\n        match self {\n            Self::BabyBearD1Width16 | Self::KoalaBearD1Width16 =\u003e 8, // 16 base elements, rate = 8 for sponge\n            Self::BabyBearD4Width16 | Self::KoalaBearD4Width16 =\u003e 2,\n            Self::BabyBearD4Width24 | Self::KoalaBearD4Width24 =\u003e 4,\n        }\n    }\n\n    pub const fn rate(self) -\u003e usize {\n        self.rate_ext() * self.d()\n    }\n\n    /// Capacity in extension field elements.\n    pub const fn capacity_ext(self) -\u003e usize {\n        match self {\n            Self::BabyBearD1Width16 | Self::KoalaBearD1Width16 =\u003e 8, // 16 - 8 = 8 capacity\n            Self::BabyBearD4Width16\n            | Self::BabyBearD4Width24\n            | Self::KoalaBearD4Width16\n            | Self::KoalaBearD4Width24 =\u003e 2,\n        }\n    }\n\n    pub const fn sbox_degree(self) -\u003e u64 {\n        match self {\n            Self::BabyBearD1Width16 | Self::BabyBearD4Width16 | Self::BabyBearD4Width24 =\u003e 7,\n            Self::KoalaBearD1Width16 | Self::KoalaBearD4Width16 | Self::KoalaBearD4Width24 =\u003e 3,\n        }\n    }\n\n    pub const fn sbox_registers(self) -\u003e usize {\n        match self {\n            Self::BabyBearD1Width16 | Self::BabyBearD4Width16 | Self::BabyBearD4Width24 =\u003e 1,\n            Self::KoalaBearD1Width16 | Self::KoalaBearD4Width16 | Self::KoalaBearD4Width24 =\u003e 0,\n        }\n    }\n\n    pub const fn half_full_rounds(self) -\u003e usize {\n        match self {\n            Self::BabyBearD1Width16\n            | Self::BabyBearD4Width16\n            | Self::BabyBearD4Width24\n            | Self::KoalaBearD1Width16\n            | Self::KoalaBearD4Width16\n            | Self::KoalaBearD4Width24 =\u003e 4,\n        }\n    }\n\n    pub const fn partial_rounds(self) -\u003e usize {\n        match self {\n            Self::BabyBearD1Width16 | Self::BabyBearD4Width16 =\u003e 13,\n            Self::BabyBearD4Width24 =\u003e 21,\n            Self::KoalaBearD1Width16 | Self::KoalaBearD4Width16 =\u003e 20,\n            Self::KoalaBearD4Width24 =\u003e 23,\n        }\n    }\n\n    pub const fn width_ext(self) -\u003e usize {\n        self.rate_ext() + self.capacity_ext()\n    }\n}\n\n/// Type alias for the Poseidon2 permutation execution closure (D=4).\n///\n/// The closure takes `DIGEST` extension field limbs and returns `DIGEST` output limbs.\npub type Poseidon2PermExec\u003cF, const DIGEST: usize\u003e =\n    Arc\u003cdyn Fn(\u0026[F; DIGEST]) -\u003e [F; DIGEST] + Send + Sync\u003e;\n\n/// Type alias for the Poseidon2 permutation execution closure for D=1 (base field).\n///\n/// The closure takes 16 base field elements and returns 16 base field elements.\npub type Poseidon2PermExecBase\u003cF\u003e = Arc\u003cdyn Fn(\u0026[F; 16]) -\u003e [F; 16] + Send + Sync\u003e;\n\n// ============================================================================\n// Private Data\n// ============================================================================\n\n/// Private data for Poseidon2 permutation.\n/// Only used for Merkle mode operations, contains exactly `SIBLING_LIMBS` extension field limbs.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Poseidon2PermPrivateData\u003cF, const SIBLING_LIMBS: usize\u003e {\n    pub sibling: [F; SIBLING_LIMBS],\n}\n\n// ============================================================================\n// Execution State\n// ============================================================================\n\n/// Execution state for Poseidon2 permutation operations.\n///\n/// Stores:\n/// - Chaining state (output of last permutation for input to next)\n/// - Circuit rows captured during execution (with extension field values)\n///\n/// Note: During execution, `Poseidon2CircuitRow\u003cF\u003e::input_values` contains 4 extension\n/// field limbs. The trace generator converts these to 16 base field elements.\n#[derive(Debug, Default)]\nstruct Poseidon2ExecutionState\u003cF\u003e {\n    /// Output of the last non-merkle Poseidon2 permutation for sponge/challenger chaining.\n    /// Used when `merkle_path=false`. `None` if no such permutation has been executed yet.\n    last_output_normal: Option\u003c[F; 4]\u003e,\n    /// Output of the last merkle-path Poseidon2 permutation for MMCS chaining.\n    /// Used when `merkle_path=true`. `None` if no such permutation has been executed yet.\n    last_output_merkle: Option\u003c[F; 4]\u003e,\n    /// Circuit rows captured during execution.\n    rows: Vec\u003cPoseidon2CircuitRow\u003cF\u003e\u003e,\n}\n\nimpl\u003cF: Send + Sync + Debug + 'static\u003e OpExecutionState for Poseidon2ExecutionState\u003cF\u003e {\n    fn as_any(\u0026self) -\u003e \u0026dyn Any {\n        self\n    }\n    fn as_any_mut(\u0026mut self) -\u003e \u0026mut dyn Any {\n        self\n    }\n}\n\n/// User-facing arguments for adding a Poseidon2 perm row.\npub struct Poseidon2PermCall {\n    /// Poseidon2 configuration for this permutation row.\n    pub config: Poseidon2Config,\n    /// Flag indicating whether a new chain is started.\n    pub new_start: bool,\n    /// Flag indicating whether we are verifying a Merkle path\n    pub merkle_path: bool,\n    /// MMCS direction bit input (base field, boolean).\n    ///\n    /// Required when `merkle_path = true`. When `merkle_path = false`, this may be omitted and\n    /// defaults to 0 (not exposed via CTL).\n    pub mmcs_bit: Option\u003cExprId\u003e,\n    /// Optional CTL exposure for each input limb (one extension element).\n    /// If `None`, the limb is not exposed via CTL (in_ctl = 0).\n    /// Note: For Merkle mode, unexposed limbs are provided via Poseidon2PermPrivateData (the sibling).\n    pub inputs: [Option\u003cExprId\u003e; 4],\n    /// Output exposure flags for limbs 0 and 1 (CTL-verified against witness table).\n    ///\n    /// When `out_ctl[i]` is true, this call allocates an output witness expression for limb `i`\n    /// (returned from `add_poseidon2_perm`) and exposes it via CTL.\n    pub out_ctl: [bool; 2],\n    /// Whether to return all 4 output limbs (for challenger use).\n    ///\n    /// When true, outputs 2-3 are also allocated and returned, but NOT CTL-verified\n    /// (they are capacity elements, constrained only by the Poseidon2 permutation itself).\n    /// This is used by challenger operations that need the full sponge state.\n    pub return_all_outputs: bool,\n    /// Optional MMCS index accumulator value to expose.\n    pub mmcs_index_sum: Option\u003cExprId\u003e,\n}\n\n/// Convenience helpers to build calls with defaults.\nimpl Default for Poseidon2PermCall {\n    fn default() -\u003e Self {\n        Self {\n            config: Poseidon2Config::BabyBearD4Width16,\n            new_start: false,\n            merkle_path: false,\n            mmcs_bit: None,\n            inputs: [None, None, None, None],\n            out_ctl: [false, false],\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        }\n    }\n}\n\n/// User-facing arguments for adding a Poseidon2 perm row with D=1 (base field).\n///\n/// This variant is for D=1 configurations where we have 16 base field elements\n/// instead of 4 extension field limbs.\npub struct Poseidon2PermCallBase {\n    /// Poseidon2 configuration for this permutation row (must be D=1).\n    pub config: Poseidon2Config,\n    /// Flag indicating whether a new chain is started.\n    pub new_start: bool,\n    /// Optional CTL exposure for each of the 16 input elements.\n    /// If `None`, the element is not exposed via CTL.\n    pub inputs: [Option\u003cExprId\u003e; 16],\n    /// Output exposure flags for the rate elements (first RATE=8 elements).\n    /// When `out_ctl[i]` is true for i in 0..8, output[i] is CTL-verified.\n    pub out_ctl: [bool; 8],\n    /// Whether to return all 16 output elements (for challenger use).\n    /// When true, outputs 8-15 are also allocated and returned, but NOT CTL-verified\n    /// (they are capacity elements, constrained only by the Poseidon2 permutation itself).\n    pub return_all_outputs: bool,\n}\n\nimpl Default for Poseidon2PermCallBase {\n    fn default() -\u003e Self {\n        Self {\n            config: Poseidon2Config::BabyBearD1Width16,\n            new_start: false,\n            inputs: [None; 16],\n            out_ctl: [false; 8],\n            return_all_outputs: false,\n        }\n    }\n}\n\npub trait Poseidon2PermOps\u003cF: Clone + PrimeCharacteristicRing + Eq\u003e {\n    /// Add a Poseidon2 perm row (one permutation) for D=4 extension field.\n    ///\n    /// - `new_start`: if true, this row starts a new chain (no chaining from previous row).\n    /// - `merkle_path`: if true, Merkle-path chaining semantics apply (chained digest placement depends on `mmcs_bit`).\n    /// - `mmcs_bit`: Merkle direction bit witness for this row (used when `merkle_path` is true).\n    /// - `inputs`: optional CTL exposure per limb (extension element, length 4 if provided).\n    ///   Base-component inputs are not supported; unexposed limbs in Merkle mode are\n    ///   provided separately via `Poseidon2PermPrivateData`.\n    /// - `out_ctl`: whether to allocate/expose output limbs 0–1 via CTL.\n    /// - `return_all_outputs`: if true, also returns outputs 2-3 (not CTL-exposed, for challenger).\n    /// - `mmcs_index_sum`: optional exposure of the MMCS index accumulator (base field element).\n    ///\n    /// Returns `(op_id, outputs)` where outputs is `[Option\u003cExprId\u003e; 4]`:\n    /// - outputs[0-1]: present if `out_ctl[i]` is true (CTL-verified)\n    /// - outputs[2-3]: present if `return_all_outputs` is true (NOT CTL-verified, capacity elements)\n    fn add_poseidon2_perm(\n        \u0026mut self,\n        call: Poseidon2PermCall,\n    ) -\u003e Result\u003c(NonPrimitiveOpId, [Option\u003cExprId\u003e; 4]), crate::CircuitBuilderError\u003e;\n\n    /// Add a Poseidon2 perm row (one permutation) for D=1 base field.\n    ///\n    /// This variant is for D=1 configurations where the permutation operates on\n    /// 16 base field elements directly (no extension field packing).\n    ///\n    /// - `new_start`: if true, this row starts a new chain (no chaining from previous row).\n    /// - `inputs`: optional CTL exposure for each of the 16 base field elements.\n    /// - `out_ctl`: whether to allocate/expose output elements 0-7 (rate) via CTL.\n    /// - `return_all_outputs`: if true, also returns outputs 8-15 (not CTL-exposed, capacity).\n    ///\n    /// Returns `(op_id, outputs)` where outputs is `[Option\u003cExprId\u003e; 16]`:\n    /// - outputs[0-7]: present if `out_ctl[i]` is true (CTL-verified, rate elements)\n    /// - outputs[8-15]: present if `return_all_outputs` is true (NOT CTL-verified, capacity elements)\n    fn add_poseidon2_perm_base(\n        \u0026mut self,\n        call: Poseidon2PermCallBase,\n    ) -\u003e Result\u003c(NonPrimitiveOpId, [Option\u003cExprId\u003e; 16]), crate::CircuitBuilderError\u003e;\n}\n\nimpl\u003cF: Field\u003e Poseidon2PermOps\u003cF\u003e for CircuitBuilder\u003cF\u003e\nwhere\n    F: Clone + PrimeCharacteristicRing + Eq + core::hash::Hash,\n{\n    fn add_poseidon2_perm(\n        \u0026mut self,\n        call: Poseidon2PermCall,\n    ) -\u003e Result\u003c(NonPrimitiveOpId, [Option\u003cExprId\u003e; 4]), crate::CircuitBuilderError\u003e {\n        let op_type = NonPrimitiveOpType::Poseidon2Perm(call.config);\n        self.ensure_op_enabled(op_type)?;\n        if call.merkle_path \u0026\u0026 call.mmcs_bit.is_none() {\n            return Err(crate::CircuitBuilderError::Poseidon2MerkleMissingMmcsBit);\n        }\n        if !call.merkle_path \u0026\u0026 call.mmcs_bit.is_some() {\n            return Err(crate::CircuitBuilderError::Poseidon2NonMerkleWithMmcsBit);\n        }\n\n        // Build input_exprs layout: [in0, in1, in2, in3, mmcs_index_sum, mmcs_bit]\n        let mut input_exprs: Vec\u003cVec\u003cExprId\u003e\u003e = Vec::with_capacity(6);\n\n        for limb in call.inputs.iter() {\n            if let Some(val) = limb {\n                input_exprs.push(vec![*val]);\n            } else {\n                input_exprs.push(Vec::new());\n            }\n        }\n\n        if let Some(idx_sum) = call.mmcs_index_sum {\n            input_exprs.push(vec![idx_sum]);\n        } else {\n            input_exprs.push(Vec::new());\n        }\n\n        if let Some(bit) = call.mmcs_bit {\n            input_exprs.push(vec![bit]);\n        } else {\n            input_exprs.push(Vec::new());\n        }\n\n        let output_0 = call.out_ctl.first().copied().unwrap_or(false);\n        let output_1 = call.out_ctl.get(1).copied().unwrap_or(false);\n        // Outputs 2-3 are capacity elements: allocated if return_all_outputs is true, but NOT CTL-verified\n        let output_2 = call.return_all_outputs;\n        let output_3 = call.return_all_outputs;\n\n        let (op_id, _call_expr_id, outputs) = self.push_non_primitive_op_with_outputs(\n            op_type,\n            input_exprs,\n            vec![\n                output_0.then_some(\"poseidon2_perm_out0\"),\n                output_1.then_some(\"poseidon2_perm_out1\"),\n                output_2.then_some(\"poseidon2_perm_out2\"),\n                output_3.then_some(\"poseidon2_perm_out3\"),\n            ],\n            Some(NonPrimitiveOpParams::Poseidon2Perm {\n                new_start: call.new_start,\n                merkle_path: call.merkle_path,\n            }),\n            \"poseidon2_perm\",\n        );\n        Ok((op_id, [outputs[0], outputs[1], outputs[2], outputs[3]]))\n    }\n\n    fn add_poseidon2_perm_base(\n        \u0026mut self,\n        call: Poseidon2PermCallBase,\n    ) -\u003e Result\u003c(NonPrimitiveOpId, [Option\u003cExprId\u003e; 16]), crate::CircuitBuilderError\u003e {\n        let op_type = NonPrimitiveOpType::Poseidon2Perm(call.config);\n        self.ensure_op_enabled(op_type)?;\n\n        // Verify this is a D=1 configuration\n        if call.config.d() != 1 {\n            return Err(crate::CircuitBuilderError::Poseidon2ConfigMismatch {\n                expected: \"D=1 configuration\".to_string(),\n                got: format!(\"D={} configuration\", call.config.d()),\n            });\n        }\n\n        // Build input_exprs layout for D=1: [in0, in1, ..., in15]\n        // No mmcs_index_sum or mmcs_bit for base field mode (no merkle path support for D=1)\n        let mut input_exprs: Vec\u003cVec\u003cExprId\u003e\u003e = Vec::with_capacity(16);\n\n        for element in call.inputs.iter() {\n            if let Some(val) = element {\n                input_exprs.push(vec![*val]);\n            } else {\n                input_exprs.push(Vec::new());\n            }\n        }\n\n        // Build output labels: first 8 (rate) can be CTL-exposed, last 8 (capacity) are optional\n        let mut output_labels: Vec\u003cOption\u003c\u0026'static str\u003e\u003e = Vec::with_capacity(16);\n        for i in 0..8 {\n            if call.out_ctl[i] {\n                output_labels.push(Some(\"poseidon2_perm_base_out\"));\n            } else {\n                output_labels.push(None);\n            }\n        }\n        for _ in 8..16 {\n            if call.return_all_outputs {\n                output_labels.push(Some(\"poseidon2_perm_base_out_capacity\"));\n            } else {\n                output_labels.push(None);\n            }\n        }\n\n        let (op_id, _call_expr_id, outputs) = self.push_non_primitive_op_with_outputs(\n            op_type,\n            input_exprs,\n            output_labels,\n            Some(NonPrimitiveOpParams::Poseidon2Perm {\n                new_start: call.new_start,\n                merkle_path: false, // No merkle path for D=1\n            }),\n            \"poseidon2_perm_base\",\n        );\n\n        Ok((\n            op_id,\n            [\n                outputs[0],\n                outputs[1],\n                outputs[2],\n                outputs[3],\n                outputs[4],\n                outputs[5],\n                outputs[6],\n                outputs[7],\n                outputs[8],\n                outputs[9],\n                outputs[10],\n                outputs[11],\n                outputs[12],\n                outputs[13],\n                outputs[14],\n                outputs[15],\n            ],\n        ))\n    }\n}\n\n/// Executor for Poseidon2 perm operations.\n///\n#[derive(Debug, Clone)]\npub(crate) struct Poseidon2PermExecutor {\n    op_type: NonPrimitiveOpType,\n    pub new_start: bool,\n    pub merkle_path: bool,\n}\n\nimpl Poseidon2PermExecutor {\n    pub const fn new(op_type: NonPrimitiveOpType, new_start: bool, merkle_path: bool) -\u003e Self {\n        Self {\n            op_type,\n            new_start,\n            merkle_path,\n        }\n    }\n}\n\nimpl\u003cF: Field + Send + Sync + 'static\u003e NonPrimitiveExecutor\u003cF\u003e for Poseidon2PermExecutor {\n    fn execute(\n        \u0026self,\n        inputs: \u0026[Vec\u003cWitnessId\u003e],\n        outputs: \u0026[Vec\u003cWitnessId\u003e],\n        ctx: \u0026mut ExecutionContext\u003c'_, F\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        // Get the config to determine D value\n        let config = ctx.get_config(\u0026self.op_type)?;\n\n        // Check if this is D=1 (base field) mode\n        match config {\n            NonPrimitiveOpConfig::Poseidon2PermBase { exec, .. } =\u003e {\n                return self.execute_base(inputs, outputs, ctx, \u0026Arc::clone(exec));\n            }\n            NonPrimitiveOpConfig::Poseidon2Perm { .. } | NonPrimitiveOpConfig::None =\u003e {\n                // Continue with D=4 mode below\n            }\n        }\n\n        // D=4 mode: Input layout: [in0, in1, in2, in3, mmcs_index_sum, mmcs_bit]\n        // Output layout: [out0, out1] or [out0, out1, out2, out3]\n        if inputs.len() != 6 {\n            return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                op: self.op_type,\n                expected: \"6 input vectors\".to_string(),\n                got: inputs.len(),\n            });\n        }\n        for limb_inputs in inputs[..4].iter() {\n            if limb_inputs.len() \u003e 1 {\n                return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                    op: self.op_type,\n                    expected: \"0 or 1 witness per input limb (extension-only)\".to_string(),\n                    got: limb_inputs.len(),\n                });\n            }\n        }\n        if inputs[4].len() \u003e 1 {\n            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                op: self.op_type,\n                expected: \"0 or 1 element for mmcs_index_sum\".to_string(),\n                got: inputs[4].len(),\n            });\n        }\n        if inputs[5].len() \u003e 1 {\n            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                op: self.op_type,\n                expected: \"0 or 1 element for mmcs_bit\".to_string(),\n                got: inputs[5].len(),\n            });\n        }\n        // Support 2 outputs (standard) or 4 outputs (challenger mode with capacity elements)\n        if outputs.len() != 2 \u0026\u0026 outputs.len() != 4 {\n            return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                op: self.op_type,\n                expected: \"2 or 4 output vectors\".to_string(),\n                got: outputs.len(),\n            });\n        }\n\n        // Get the exec closure from config\n        let exec = match config {\n            NonPrimitiveOpConfig::Poseidon2Perm { exec, .. } =\u003e Arc::clone(exec),\n            NonPrimitiveOpConfig::Poseidon2PermBase { .. } =\u003e {\n                // Already handled above\n                unreachable!()\n            }\n            NonPrimitiveOpConfig::None =\u003e {\n                return Err(CircuitError::InvalidNonPrimitiveOpConfiguration { op: self.op_type });\n            }\n        };\n\n        // Get private data if available and validate usage rules.\n        let private_inputs: Option\u003c\u0026[F]\u003e = match ctx.get_private_data() {\n            Ok(NonPrimitiveOpPrivateData::Poseidon2Perm(data)) =\u003e {\n                if !self.merkle_path {\n                    return Err(CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                        op: self.op_type,\n                        operation_index: ctx.operation_id(),\n                        expected: \"no private data (only Merkle mode accepts private data)\"\n                            .to_string(),\n                        got: \"private data provided for non-Merkle operation\".to_string(),\n                    });\n                }\n                Some(\u0026data.sibling[..])\n            }\n            Err(_) =\u003e None,\n        };\n\n        // Get mmcs_bit (required when merkle_path=true; defaults to false otherwise).\n        // mmcs_bit is at inputs[5].\n        let mmcs_bit = if let Some(\u0026wid) = inputs[5].first() {\n            let val = ctx.get_witness(wid)?;\n            match val {\n                v if v == F::ZERO =\u003e false,\n                v if v == F::ONE =\u003e true,\n                v =\u003e {\n                    return Err(CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                        op: self.op_type,\n                        operation_index: ctx.operation_id(),\n                        expected: \"boolean mmcs_bit (0 or 1)\".into(),\n                        got: format!(\"{v:?}\"),\n                    });\n                }\n            }\n        } else if self.merkle_path {\n            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                op: self.op_type,\n                operation_index: ctx.operation_id(),\n                expected: \"mmcs_bit must be provided when merkle_path=true\".into(),\n                got: \"missing mmcs_bit\".into(),\n            });\n        } else {\n            false\n        };\n\n        // Get the previous output for chaining (read from state before mutation)\n        // Use separate chaining states for merkle_path vs non-merkle_path operations\n        // to prevent cross-contamination between MMCS and challenger chains.\n        let last_output = ctx\n            .get_op_state::\u003cPoseidon2ExecutionState\u003cF\u003e\u003e(\u0026self.op_type)\n            .and_then(|s| {\n                if self.merkle_path {\n                    s.last_output_merkle\n                } else {\n                    s.last_output_normal\n                }\n            });\n\n        // Resolve input limbs\n        let mut resolved_inputs = [F::ZERO; 4];\n        for (limb, resolved) in resolved_inputs.iter_mut().enumerate() {\n            *resolved =\n                self.resolve_input_limb(limb, inputs, private_inputs, ctx, last_output, mmcs_bit)?;\n        }\n\n        // Execute the permutation\n        let output = exec(\u0026resolved_inputs);\n\n        // Build CTL metadata for row record\n        let (in_ctl, input_indices) = inputs[..4].iter().enumerate().fold(\n            ([false; 4], [0u32; 4]),\n            |(mut in_ctl, mut input_indices), (i, inp)| {\n                if let Some(\u0026wid) = inp.first() {\n                    in_ctl[i] = true;\n                    input_indices[i] = wid.0;\n                }\n                (in_ctl, input_indices)\n            },\n        );\n\n        // Only track CTL for outputs 0-1 (rate elements); outputs 2-3 are capacity (no CTL)\n        let (out_ctl, output_indices) = outputs.iter().take(2).enumerate().fold(\n            ([false; 2], [0u32; 2]),\n            |(mut out_ctl, mut output_indices), (i, out_slot)| {\n                if let Some(\u0026wid) = out_slot.first() {\n                    out_ctl[i] = true;\n                    output_indices[i] = wid.0;\n                }\n                (out_ctl, output_indices)\n            },\n        );\n\n        let (mmcs_index_sum, mmcs_index_sum_idx, mmcs_ctl_enabled) = if inputs[4].len() == 1 {\n            let wid = inputs[4][0];\n            let val = ctx.get_witness(wid)?;\n            (val, wid.0, true)\n        } else {\n            (F::ZERO, 0, false)\n        };\n\n        // Record row for trace generation (input_values contains 4 extension limbs)\n        let input_values = resolved_inputs.to_vec();\n        debug_assert_eq!(\n            input_values.len(),\n            4,\n            \"Execution row must have exactly 4 input limbs\"\n        );\n\n        let row = Poseidon2CircuitRow {\n            new_start: self.new_start,\n            merkle_path: self.merkle_path,\n            mmcs_bit,\n            mmcs_index_sum,\n            input_values,\n            in_ctl,\n            input_indices,\n            out_ctl,\n            output_indices,\n            mmcs_index_sum_idx,\n            mmcs_ctl_enabled,\n        };\n\n        // Update state: chaining and rows\n        // Use separate chaining states for merkle_path vs non-merkle_path operations.\n        let op_id = ctx.operation_id();\n        let state = ctx.get_op_state_mut::\u003cPoseidon2ExecutionState\u003cF\u003e\u003e(\u0026self.op_type);\n        if self.merkle_path {\n            tracing::trace!(\n                \"Poseidon2 op {:?}: updating last_output_merkle from {:?} to {:?}\",\n                op_id,\n                state\n                    .last_output_merkle\n                    .map(|o| format!(\"[{:?}, {:?}]\", o[0], o[1])),\n                format!(\"[{:?}, {:?}]\", output[0], output[1])\n            );\n            state.last_output_merkle = Some(output);\n        } else {\n            tracing::trace!(\n                \"Poseidon2 op {:?}: updating last_output_normal from {:?} to {:?}\",\n                op_id,\n                state\n                    .last_output_normal\n                    .map(|o| format!(\"[{:?}, {:?}]\", o[0], o[1])),\n                format!(\"[{:?}, {:?}]\", output[0], output[1])\n            );\n            state.last_output_normal = Some(output);\n        }\n        state.rows.push(row);\n\n        // Write outputs to witness (outputs 0-1 for CTL, outputs 2-3 for capacity if requested)\n        for (out_idx, out_slot) in outputs.iter().enumerate() {\n            if out_slot.len() == 1 {\n                let wid = out_slot[0];\n                ctx.set_witness(wid, output[out_idx])?;\n            } else if !out_slot.is_empty() {\n                return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                    op: self.op_type,\n                    expected: \"0 or 1 witness per output limb\".to_string(),\n                    got: out_slot.len(),\n                });\n            }\n        }\n\n        Ok(())\n    }\n\n    fn op_type(\u0026self) -\u003e \u0026NonPrimitiveOpType {\n        \u0026self.op_type\n    }\n\n    fn as_any(\u0026self) -\u003e \u0026dyn core::any::Any {\n        self\n    }\n\n    fn preprocess(\n        \u0026self,\n        inputs: \u0026[Vec\u003cWitnessId\u003e],\n        outputs: \u0026[Vec\u003cWitnessId\u003e],\n        preprocessed: \u0026mut PreprocessedColumns\u003cF\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        // We need to populate in_ctl and out_ctl for this operation.\n        // The inputs have shape:\n        // inputs[0..3]: input limbs, inputs[4]: mmcs_index_sum, inputs[5]: mmcs_bit\n        // The outputs have shape:\n        // outputs[0..1]: output limbs exposed via CTL\n        // The shape of one preprocessed row is:\n        // [in_idx0, in_ctl_0, normal_chain_sel[0], merkle_chain_sel[0], in_idx1, in1_ctl, normal_chain_sel[1], merkle_chain_sel[1], ..., out_idx0, out_ctl_0, out_idx1, out_ctl_1, mmcs_index_sum_ctl_idx, new_start, merkle_path]\n\n        // First, let's add the input indices and `in_ctl` values.\n        for (limb_idx, inp) in inputs[0..4].iter().enumerate() {\n            if inp.is_empty() {\n                // Private input\n                preprocessed.register_non_primitive_preprocessed_no_read(\n                    self.op_type,\n                    \u0026[F::ZERO, F::ZERO], // in_idx, in_ctl\n                );\n            } else {\n                // Exposed input\n                // Update witness multiplicities only if NOT merkle_path mode.\n                // In merkle_path mode, input CTL lookups are disabled in the AIR\n                // because the value permutation (based on runtime mmcs_bit) would\n                // require degree-1 conditional logic that exceeds constraint limits.\n                if self.merkle_path {\n                    // Don't update multiplicities - just register the index\n                    preprocessed.register_non_primitive_preprocessed_no_read(\n                        self.op_type,\n                        \u0026[F::from_u32(inp[0].0)],\n                    );\n                } else {\n                    // Register the witness read (updates multiplicities)\n                    preprocessed.register_non_primitive_witness_reads(self.op_type, inp)?;\n                }\n                // Add in_ctl value\n                preprocessed.register_non_primitive_preprocessed_no_read(self.op_type, \u0026[F::ONE]);\n            }\n            let normal_chain_sel =\n                if !self.new_start \u0026\u0026 !self.merkle_path \u0026\u0026 inputs[limb_idx].is_empty() {\n                    F::ONE\n                } else {\n                    F::ZERO\n                };\n\n            preprocessed\n                .register_non_primitive_preprocessed_no_read(self.op_type, \u0026[normal_chain_sel]);\n\n            let merkle_chain_sel =\n                if !self.new_start \u0026\u0026 self.merkle_path \u0026\u0026 inputs[limb_idx].is_empty() {\n                    F::ONE\n                } else {\n                    F::ZERO\n                };\n            preprocessed\n                .register_non_primitive_preprocessed_no_read(self.op_type, \u0026[merkle_chain_sel]);\n        }\n\n        // Process outputs 0-1 (rate elements with CTL exposure)\n        for out in outputs.iter().take(2) {\n            if out.is_empty() {\n                // Private output\n                preprocessed.register_non_primitive_preprocessed_no_read(\n                    self.op_type,\n                    \u0026[F::ZERO, F::ZERO], // out_idx, out_ctl\n                );\n            } else {\n                // Exposed output: register the witness read (updates multiplicities)\n                preprocessed.register_non_primitive_witness_reads(self.op_type, out)?;\n                // Add out_ctl value\n                preprocessed.register_non_primitive_preprocessed_no_read(self.op_type, \u0026[F::ONE]);\n            }\n        }\n        // Index for mmcs_index_sum CTL\n        // **NOTE**: We do NOT update witness multiplicities here because the mmcs_index_sum\n        // lookup has CONDITIONAL multiplicity (mmcs_merkle_flag * next_new_start).\n        // The multiplicity is computed in get_airs_and_degrees_with_prep() which scans\n        // the preprocessed data and updates witness multiplicities accordingly.\n        if inputs[4].is_empty() {\n            preprocessed.register_non_primitive_preprocessed_no_read(self.op_type, \u0026[F::ZERO]);\n        } else {\n            // Just register the index value, do NOT update multiplicities\n            preprocessed.register_non_primitive_preprocessed_no_read(\n                self.op_type,\n                \u0026[F::from_u32(inputs[4][0].0)],\n            );\n        }\n\n        // mmcs_merkle_flag = mmcs_ctl_enabled * merkle_path (precomputed)\n        // This allows the lookup multiplicity to be computed as: mmcs_merkle_flag * next_new_start\n        // which has degree 2 (safe for constraint evaluation)\n        let mmcs_ctl_enabled = !inputs[4].is_empty();\n        let mmcs_merkle_flag = if mmcs_ctl_enabled \u0026\u0026 self.merkle_path {\n            F::ONE\n        } else {\n            F::ZERO\n        };\n        preprocessed.register_non_primitive_preprocessed_no_read(self.op_type, \u0026[mmcs_merkle_flag]);\n\n        // We need to insert `new_start` and `merkle_path` as well.\n        let new_start_val = if self.new_start { F::ONE } else { F::ZERO };\n        let merkle_path_val = if self.merkle_path { F::ONE } else { F::ZERO };\n        preprocessed.register_non_primitive_preprocessed_no_read(\n            self.op_type,\n            \u0026[new_start_val, merkle_path_val],\n        );\n\n        Ok(())\n    }\n\n    fn boxed(\u0026self) -\u003e Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e {\n        Box::new(self.clone())\n    }\n}\n\nimpl Poseidon2PermExecutor {\n    /// Execute D=1 (base field) permutation with 16 input/output elements.\n    fn execute_base\u003cF: Field + Send + Sync + 'static\u003e(\n        \u0026self,\n        inputs: \u0026[Vec\u003cWitnessId\u003e],\n        outputs: \u0026[Vec\u003cWitnessId\u003e],\n        ctx: \u0026mut ExecutionContext\u003c'_, F\u003e,\n        exec: \u0026Poseidon2PermExecBase\u003cF\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        // D=1 mode: Input layout: [in0, in1, ..., in15]\n        // Output layout: [out0, ..., out7] (rate) or [out0, ..., out15] (with capacity)\n        if inputs.len() != 16 {\n            return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                op: self.op_type,\n                expected: \"16 input vectors for D=1 mode\".to_string(),\n                got: inputs.len(),\n            });\n        }\n        for (i, inp) in inputs.iter().enumerate() {\n            if inp.len() \u003e 1 {\n                return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                    op: self.op_type,\n                    expected: format!(\"0 or 1 witness per input element {}\", i),\n                    got: inp.len(),\n                });\n            }\n        }\n        // Support 8 outputs (rate only) or 16 outputs (with capacity)\n        if outputs.len() != 8 \u0026\u0026 outputs.len() != 16 {\n            return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                op: self.op_type,\n                expected: \"8 or 16 output vectors for D=1 mode\".to_string(),\n                got: outputs.len(),\n            });\n        }\n\n        // Resolve input values: use witness value if available, otherwise zero\n        let mut resolved_inputs = [F::ZERO; 16];\n        for (i, inp) in inputs.iter().enumerate() {\n            if inp.len() == 1 {\n                resolved_inputs[i] = ctx.get_witness(inp[0])?;\n            }\n            // If inp is empty, leave as zero (capacity or unused input)\n        }\n\n        // Execute the permutation\n        let output = exec(\u0026resolved_inputs);\n\n        // Build CTL metadata for row record (grouped into 4 limbs of 4 elements each for AIR compatibility)\n        let mut in_ctl = [false; 4];\n        let mut input_indices = [0u32; 4];\n        for limb in 0..4 {\n            // A limb is \"CTL-exposed\" if any of its 4 base elements have a witness\n            for d in 0..4 {\n                let idx = limb * 4 + d;\n                if !inputs[idx].is_empty() {\n                    in_ctl[limb] = true;\n                    // Store first non-empty witness index for the limb\n                    if input_indices[limb] == 0 {\n                        input_indices[limb] = inputs[idx][0].0;\n                    }\n                }\n            }\n        }\n\n        let mut out_ctl = [false; 2];\n        let mut output_indices = [0u32; 2];\n        for limb in 0..2 {\n            // Rate output limbs 0-1 (first 8 elements, in 2 groups of 4)\n            for d in 0..4 {\n                let idx = limb * 4 + d;\n                if idx \u003c outputs.len() \u0026\u0026 !outputs[idx].is_empty() {\n                    out_ctl[limb] = true;\n                    if output_indices[limb] == 0 {\n                        output_indices[limb] = outputs[idx][0].0;\n                    }\n                }\n            }\n        }\n\n        // Convert resolved inputs to Vec for the row record\n        let input_values = resolved_inputs.to_vec();\n\n        let row = Poseidon2CircuitRow {\n            new_start: self.new_start,\n            merkle_path: false, // No merkle path for D=1\n            mmcs_bit: false,\n            mmcs_index_sum: F::ZERO,\n            input_values,\n            in_ctl,\n            input_indices,\n            out_ctl,\n            output_indices,\n            mmcs_index_sum_idx: 0,\n            mmcs_ctl_enabled: false,\n        };\n\n        // Update state: store rows for trace generation\n        // Note: D=1 doesn't use chaining state the same way D=4 does\n        let state = ctx.get_op_state_mut::\u003cPoseidon2ExecutionState\u003cF\u003e\u003e(\u0026self.op_type);\n        state.rows.push(row);\n\n        // Write outputs to witness\n        for (out_idx, out_slot) in outputs.iter().enumerate() {\n            if out_slot.len() == 1 {\n                let wid = out_slot[0];\n                ctx.set_witness(wid, output[out_idx])?;\n            } else if !out_slot.is_empty() {\n                return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                    op: self.op_type,\n                    expected: \"0 or 1 witness per output element\".to_string(),\n                    got: out_slot.len(),\n                });\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Resolve input limb value using a layered priority system:\n    /// 1. Layer 1: Chaining from previous permutation (lowest priority) or zeros if new_start\n    /// 2. Layer 2: Private inputs - sibling placed based on mmcs_bit\n    /// 3. Layer 3: CTL (witness) values (highest priority, overwrites previous layers)\n    fn resolve_input_limb\u003cF: Field\u003e(\n        \u0026self,\n        limb: usize,\n        inputs: \u0026[Vec\u003cWitnessId\u003e],\n        private_inputs: Option\u003c\u0026[F]\u003e,\n        ctx: \u0026ExecutionContext\u003c'_, F\u003e,\n        last_output: Option\u003c[F; 4]\u003e,\n        mmcs_bit: bool,\n    ) -\u003e Result\u003cF, CircuitError\u003e {\n        // Build up the input array with layered priorities\n        let mut resolved = [None; 4];\n\n        // Layer 1: Chaining from previous permutation (lowest priority)\n        if !self.new_start {\n            let prev =\n                last_output.ok_or_else(|| CircuitError::Poseidon2ChainMissingPreviousState {\n                    operation_index: ctx.operation_id(),\n                })?;\n\n            if !self.merkle_path {\n                // Normal chaining: all 4 limbs come from previous output\n                for i in 0..4 {\n                    resolved[i] = Some(prev[i]);\n                }\n            } else {\n                // Merkle path chaining: canonical placement in limbs 0-1.\n                resolved[0] = Some(prev[0]);\n                resolved[1] = Some(prev[1]);\n            }\n        } else if !self.merkle_path {\n            // new_start = true: all limbs default to zero\n            resolved.fill(Some(F::ZERO));\n        }\n\n        // Layer 2: Private inputs (medium priority)\n        // Private inputs are only used in Merkle mode.\n        // Canonical placement: sibling in limbs 2-3.\n        if let Some(private) = private_inputs\n            \u0026\u0026 self.merkle_path\n        {\n            resolved[2] = Some(private[0]);\n            resolved[3] = Some(private[1]);\n        }\n\n        // Layer 3: CTL (witness) values (highest priority)\n        for i in 0..4 {\n            if inputs.len() \u003e i \u0026\u0026 inputs[i].len() == 1 {\n                let wid = inputs[i][0];\n                let val = ctx.get_witness(wid)?;\n                resolved[i] = Some(val);\n            }\n        }\n\n        let permuted_idx = if self.merkle_path \u0026\u0026 mmcs_bit {\n            match limb {\n                0 =\u003e 2,\n                1 =\u003e 3,\n                2 =\u003e 0,\n                3 =\u003e 1,\n                _ =\u003e limb,\n            }\n        } else {\n            limb\n        };\n\n        // Return the resolved value\n        resolved[permuted_idx].ok_or_else(|| {\n            if self.merkle_path \u0026\u0026 matches!(permuted_idx, 2 | 3) {\n                return CircuitError::Poseidon2MerkleMissingSiblingInput {\n                    operation_index: ctx.operation_id(),\n                    limb,\n                };\n            }\n            CircuitError::Poseidon2MissingInput {\n                operation_index: ctx.operation_id(),\n                limb,\n            }\n        })\n    }\n}\n\n// ============================================================================\n// Trace Types\n// ============================================================================\n\n/// Trait to provide Poseidon2 configuration parameters for a field type.\n///\n/// This allows the trace generator and AIR to work with different Poseidon2 configurations\n/// without hardcoding parameters. Implementations should provide the standard\n/// parameters for their field type.\npub trait Poseidon2Params {\n    type BaseField: PrimeField + PrimeCharacteristicRing;\n    /// Poseidon2 configuration key for this parameter set.\n    const CONFIG: Poseidon2Config;\n    /// Extension degree D\n    const D: usize = Self::CONFIG.d();\n    /// Total width in base field elements\n    const WIDTH: usize = Self::CONFIG.width();\n\n    /// Rate in extension elements\n    const RATE_EXT: usize = Self::CONFIG.rate_ext();\n    /// Capacity in extension elements\n    const CAPACITY_EXT: usize = Self::CONFIG.capacity_ext();\n    /// Capacity size in base field elements = CAPACITY_EXT * D\n    const CAPACITY_SIZE: usize = Self::CAPACITY_EXT * Self::D;\n\n    /// S-box degree (polynomial degree for the S-box)\n    const SBOX_DEGREE: u64 = Self::CONFIG.sbox_degree();\n    /// Number of S-box registers\n    const SBOX_REGISTERS: usize = Self::CONFIG.sbox_registers();\n\n    /// Number of half full rounds\n    const HALF_FULL_ROUNDS: usize = Self::CONFIG.half_full_rounds();\n    /// Number of partial rounds\n    const PARTIAL_ROUNDS: usize = Self::CONFIG.partial_rounds();\n\n    /// Width in extension elements = RATE_EXT + CAPACITY_EXT\n    const WIDTH_EXT: usize = Self::RATE_EXT + Self::CAPACITY_EXT;\n}\n\n/// BabyBear D=1 Width=16 configuration for base field challenges.\n///\n/// This is used when the challenge type is the base field itself (no extension).\n/// The Poseidon2 permutation operates directly on 16 base field elements.\npub struct BabyBearD1Width16;\n\nimpl Poseidon2Params for BabyBearD1Width16 {\n    type BaseField = p3_baby_bear::BabyBear;\n    const CONFIG: Poseidon2Config = Poseidon2Config::BabyBearD1Width16;\n}\n\n/// KoalaBear D=1 Width=16 configuration for base field challenges.\n///\n/// This is used when the challenge type is the base field itself (no extension).\n/// The Poseidon2 permutation operates directly on 16 base field elements.\npub struct KoalaBearD1Width16;\n\nimpl Poseidon2Params for KoalaBearD1Width16 {\n    type BaseField = p3_koala_bear::KoalaBear;\n    const CONFIG: Poseidon2Config = Poseidon2Config::KoalaBearD1Width16;\n}\n\n/// Poseidon2 operation table row.\n///\n/// This implements the Poseidon Permutation Table specification.\n/// See: https://github.com/Plonky3/Plonky3-recursion/discussions/186\n///\n/// The table has one row per Poseidon call, implementing:\n/// - Standard chaining (Challenger-style sponge use)\n/// - Merkle-path chaining (MMCS directional hashing)\n/// - Selective limb exposure to the witness via CTL\n/// - Optional MMCS index accumulator\n#[derive(Debug, Clone)]\npub struct Poseidon2CircuitRow\u003cF\u003e {\n    /// Control: If 1, row begins a new independent Poseidon chain.\n    pub new_start: bool,\n    /// Control: 0 → normal sponge/Challenger mode, 1 → Merkle-path mode.\n    pub merkle_path: bool,\n    /// Control: Direction bit for Merkle left/right hashing (only meaningful when merkle_path = 1).\n    pub mmcs_bit: bool,\n    /// Value: Optional MMCS accumulator (base field, encodes a u32-like integer).\n    pub mmcs_index_sum: F,\n    /// Inputs to the Poseidon2 permutation (flattened state).\n    /// For execution rows: 4 extension limbs. For trace rows: WIDTH base field elements.\n    pub input_values: Vec\u003cF\u003e,\n    /// Input exposure flags for CTL lookups: permuted to match the physical trace layout.\n    /// When merkle_path \u0026\u0026 mmcs_bit, these are permuted (swapped 0↔2, 1↔3) so that\n    /// the CTL lookup for physical limb i uses the correct logical limb's metadata.\n    pub in_ctl: [bool; 4],\n    /// Input exposure indices for CTL lookups.\n    pub input_indices: [u32; 4],\n    /// Output exposure flags: for limbs 0-1 only, if 1, out[i] must match witness lookup at output_indices[i].\n    /// Note: limbs 2-3 are never publicly exposed (always private).\n    pub out_ctl: [bool; 2],\n    /// Output exposure indices: index into the witness table for limbs 0-1.\n    pub output_indices: [u32; 2],\n    /// MMCS index exposure: index for CTL exposure of mmcs_index_sum.\n    pub mmcs_index_sum_idx: u32,\n    /// Whether mmcs_index_sum CTL is enabled. When false, the mmcs_index_sum lookup is disabled.\n    pub mmcs_ctl_enabled: bool,\n}\n\n/// Poseidon2 trace for all hash operations in the circuit.\n#[derive(Debug, Clone)]\npub struct Poseidon2Trace\u003cF\u003e {\n    /// Operation type for this Poseidon2 trace.\n    pub op_type: NonPrimitiveOpType,\n    /// All Poseidon2 operations (permutation rows) in this trace.\n    pub operations: Vec\u003cPoseidon2CircuitRow\u003cF\u003e\u003e,\n}\n\nimpl\u003cF\u003e Poseidon2Trace\u003cF\u003e {\n    pub const fn total_rows(\u0026self) -\u003e usize {\n        self.operations.len()\n    }\n}\n\nimpl\u003cTraceF: Clone + Send + Sync + 'static, CF\u003e NonPrimitiveTrace\u003cCF\u003e for Poseidon2Trace\u003cTraceF\u003e {\n    fn op_type(\u0026self) -\u003e NonPrimitiveOpType {\n        self.op_type\n    }\n\n    fn rows(\u0026self) -\u003e usize {\n        self.total_rows()\n    }\n\n    fn as_any(\u0026self) -\u003e \u0026dyn Any {\n        self\n    }\n\n    fn boxed_clone(\u0026self) -\u003e Box\u003cdyn NonPrimitiveTrace\u003cCF\u003e\u003e {\n        Box::new(self.clone())\n    }\n}\n\n// ============================================================================\n// Trace Generation\n// ============================================================================\n\n/// Generate the Poseidon2 trace from execution state.\n///\n/// Converts circuit rows from extension field format (4 limbs) to base field format (16 elements).\n///\n/// # Type Parameters\n/// - `F`: The circuit field type (extension field)\n/// - `Config`: A type implementing `Poseidon2Params` that specifies the Poseidon2 configuration\npub fn generate_poseidon2_trace\u003c\n    F: CircuitField + ExtensionField\u003cConfig::BaseField\u003e,\n    Config: Poseidon2Params,\n\u003e(\n    op_states: \u0026crate::op::OpStateMap,\n) -\u003e Result\u003cOption\u003cBox\u003cdyn NonPrimitiveTrace\u003cF\u003e\u003e\u003e, CircuitError\u003e {\n    let op_type = NonPrimitiveOpType::Poseidon2Perm(Config::CONFIG);\n    let Some(state) = op_states\n        .get(\u0026op_type)\n        .and_then(|s| s.as_any().downcast_ref::\u003cPoseidon2ExecutionState\u003cF\u003e\u003e())\n    else {\n        return Ok(None);\n    };\n\n    if state.rows.is_empty() {\n        return Ok(None);\n    }\n\n    let d = Config::D;\n\n    // Convert extension field rows to base field rows\n    let operations: Vec\u003cPoseidon2CircuitRow\u003cConfig::BaseField\u003e\u003e = state\n        .rows\n        .iter()\n        .enumerate()\n        .map(|(row_index, row)| -\u003e Result\u003c_, CircuitError\u003e {\n            let limb_count = Config::WIDTH / d;\n            // Flatten extension limbs to WIDTH base field elements.\n            assert_eq!(\n                row.input_values.len(),\n                limb_count,\n                \"Source row must have WIDTH/D input limbs\"\n            );\n            let mut input_values = vec![Config::BaseField::ZERO; Config::WIDTH];\n            assert_eq!(\n                input_values.len(),\n                Config::WIDTH,\n                \"Target row must have WIDTH input elements\"\n            );\n            for (limb, ext_val) in row.input_values.iter().enumerate() {\n                let coeffs = ext_val.as_basis_coefficients_slice();\n                input_values[limb * d..(limb + 1) * d].copy_from_slice(coeffs);\n            }\n\n            let mmcs_index_sum = row.mmcs_index_sum.as_base().ok_or_else(|| {\n                CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                    op: op_type,\n                    operation_index: NonPrimitiveOpId(row_index as u32),\n                    expected: \"base field mmcs_index_sum\".to_string(),\n                    got: \"extension value\".to_string(),\n                }\n            })?;\n\n            Ok(Poseidon2CircuitRow {\n                new_start: row.new_start,\n                merkle_path: row.merkle_path,\n                mmcs_bit: row.mmcs_bit,\n                mmcs_index_sum,\n                input_values,\n                in_ctl: row.in_ctl,\n                input_indices: row.input_indices,\n                out_ctl: row.out_ctl,\n                output_indices: row.output_indices,\n                mmcs_index_sum_idx: row.mmcs_index_sum_idx,\n                mmcs_ctl_enabled: row.mmcs_ctl_enabled,\n            })\n        })\n        .collect::\u003cResult\u003cVec\u003c_\u003e, CircuitError\u003e\u003e()?;\n\n    Ok(Some(Box::new(Poseidon2Trace {\n        op_type,\n        operations,\n    })))\n}\n","traces":[{"line":63,"address":[2572144],"length":1,"stats":{"Line":12}},{"line":64,"address":[4410183],"length":1,"stats":{"Line":11}},{"line":65,"address":[3957254],"length":1,"stats":{"Line":1}},{"line":66,"address":[11591393],"length":1,"stats":{"Line":11}},{"line":73,"address":[2572320],"length":1,"stats":{"Line":0}},{"line":74,"address":[11591511],"length":1,"stats":{"Line":0}},{"line":75,"address":[7159735],"length":1,"stats":{"Line":0}},{"line":79,"address":[7159746],"length":1,"stats":{"Line":0}},{"line":84,"address":[2924096],"length":1,"stats":{"Line":8}},{"line":85,"address":[8895687],"length":1,"stats":{"Line":8}},{"line":86,"address":[8895757],"length":1,"stats":{"Line":0}},{"line":87,"address":[15685576],"length":1,"stats":{"Line":8}},{"line":88,"address":[11591699],"length":1,"stats":{"Line":0}},{"line":92,"address":[7159584],"length":1,"stats":{"Line":5}},{"line":93,"address":[15685372,15685311],"length":1,"stats":{"Line":5}},{"line":97,"address":[4409920],"length":1,"stats":{"Line":0}},{"line":98,"address":[2571895],"length":1,"stats":{"Line":0}},{"line":99,"address":[13407030],"length":1,"stats":{"Line":0}},{"line":100,"address":[13407041],"length":1,"stats":{"Line":0}},{"line":107,"address":[3956896],"length":1,"stats":{"Line":0}},{"line":108,"address":[7879335],"length":1,"stats":{"Line":0}},{"line":109,"address":[6772516],"length":1,"stats":{"Line":0}},{"line":110,"address":[15684943],"length":1,"stats":{"Line":0}},{"line":114,"address":[2363328],"length":1,"stats":{"Line":0}},{"line":115,"address":[15685143],"length":1,"stats":{"Line":0}},{"line":116,"address":[2572084],"length":1,"stats":{"Line":0}},{"line":117,"address":[4410127],"length":1,"stats":{"Line":0}},{"line":121,"address":[2572112],"length":1,"stats":{"Line":0}},{"line":122,"address":[8959895],"length":1,"stats":{"Line":0}},{"line":132,"address":[15685040],"length":1,"stats":{"Line":0}},{"line":133,"address":[4874887],"length":1,"stats":{"Line":0}},{"line":134,"address":[2363270],"length":1,"stats":{"Line":0}},{"line":135,"address":[4410049],"length":1,"stats":{"Line":0}},{"line":136,"address":[13407116],"length":1,"stats":{"Line":0}},{"line":137,"address":[4410071],"length":1,"stats":{"Line":0}},{"line":141,"address":[2572544],"length":1,"stats":{"Line":0}},{"line":142,"address":[7880047,7880109],"length":1,"stats":{"Line":0}},{"line":193,"address":[1625504],"length":1,"stats":{"Line":14}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[6598624],"length":1,"stats":{"Line":14}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[6794352],"length":1,"stats":{"Line":0}},{"line":241,"address":[8916963],"length":1,"stats":{"Line":0}},{"line":242,"address":[4896659],"length":1,"stats":{"Line":0}},{"line":271,"address":[2593920],"length":1,"stats":{"Line":0}},{"line":275,"address":[4896849],"length":1,"stats":{"Line":0}},{"line":276,"address":[15707081],"length":1,"stats":{"Line":0}},{"line":326,"address":[5858105,5857843,5855088],"length":1,"stats":{"Line":14}},{"line":330,"address":[],"length":0,"stats":{"Line":12}},{"line":331,"address":[2905713],"length":1,"stats":{"Line":14}},{"line":332,"address":[],"length":0,"stats":{"Line":20}},{"line":333,"address":[5956895],"length":1,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":26}},{"line":336,"address":[4207526],"length":1,"stats":{"Line":0}},{"line":340,"address":[2905964],"length":1,"stats":{"Line":11}},{"line":342,"address":[7210606,7210746],"length":1,"stats":{"Line":28}},{"line":343,"address":[7213019,7210895],"length":1,"stats":{"Line":25}},{"line":344,"address":[5959409,5959452],"length":1,"stats":{"Line":25}},{"line":346,"address":[2908464,2908637],"length":1,"stats":{"Line":14}},{"line":350,"address":[5460202],"length":1,"stats":{"Line":12}},{"line":351,"address":[4978511,4978467],"length":1,"stats":{"Line":0}},{"line":353,"address":[5856031,5855837],"length":1,"stats":{"Line":24}},{"line":356,"address":[],"length":0,"stats":{"Line":17}},{"line":357,"address":[5856070,5856114],"length":1,"stats":{"Line":10}},{"line":359,"address":[4825120,4825326],"length":1,"stats":{"Line":24}},{"line":362,"address":[],"length":0,"stats":{"Line":24}},{"line":363,"address":[2906931],"length":1,"stats":{"Line":12}},{"line":365,"address":[5460925],"length":1,"stats":{"Line":12}},{"line":366,"address":[2907054],"length":1,"stats":{"Line":12}},{"line":368,"address":[],"length":0,"stats":{"Line":24}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[5856527],"length":1,"stats":{"Line":12}},{"line":371,"address":[5856976,5856656,5856713,5856585],"length":1,"stats":{"Line":36}},{"line":372,"address":[4979320],"length":1,"stats":{"Line":12}},{"line":373,"address":[5856781],"length":1,"stats":{"Line":11}},{"line":374,"address":[],"length":0,"stats":{"Line":12}},{"line":375,"address":[2907479],"length":1,"stats":{"Line":12}},{"line":377,"address":[4979867],"length":1,"stats":{"Line":13}},{"line":378,"address":[5958717],"length":1,"stats":{"Line":12}},{"line":379,"address":[7212352],"length":1,"stats":{"Line":13}},{"line":383,"address":[4826508,4826432],"length":1,"stats":{"Line":24}},{"line":386,"address":[4210176,4213557,4213122],"length":1,"stats":{"Line":1}},{"line":390,"address":[6052873],"length":1,"stats":{"Line":1}},{"line":391,"address":[4210269],"length":1,"stats":{"Line":1}},{"line":394,"address":[5462826],"length":1,"stats":{"Line":1}},{"line":395,"address":[6056425],"length":1,"stats":{"Line":0}},{"line":396,"address":[5858486],"length":1,"stats":{"Line":0}},{"line":397,"address":[4981179,4984270],"length":1,"stats":{"Line":0}},{"line":403,"address":[6053085],"length":1,"stats":{"Line":1}},{"line":405,"address":[5462895,5463037],"length":1,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[4830353,4830396],"length":1,"stats":{"Line":2}},{"line":409,"address":[5861352,5861525],"length":1,"stats":{"Line":0}},{"line":414,"address":[5858790],"length":1,"stats":{"Line":1}},{"line":415,"address":[5858797,5858898],"length":1,"stats":{"Line":2}},{"line":416,"address":[4981675,4983836],"length":1,"stats":{"Line":2}},{"line":417,"address":[4830268,4830300],"length":1,"stats":{"Line":2}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":1}},{"line":423,"address":[5859148],"length":1,"stats":{"Line":1}},{"line":424,"address":[4213179,4213147],"length":1,"stats":{"Line":2}},{"line":426,"address":[4830178,4830144],"length":1,"stats":{"Line":0}},{"line":430,"address":[1513990],"length":1,"stats":{"Line":1}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[2909721],"length":1,"stats":{"Line":1}},{"line":433,"address":[2909761],"length":1,"stats":{"Line":1}},{"line":434,"address":[5859275],"length":1,"stats":{"Line":1}},{"line":435,"address":[6053929],"length":1,"stats":{"Line":1}},{"line":441,"address":[5860870],"length":1,"stats":{"Line":1}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[4828484,4828566],"length":1,"stats":{"Line":2}},{"line":445,"address":[6054221],"length":1,"stats":{"Line":1}},{"line":446,"address":[5859623],"length":1,"stats":{"Line":1}},{"line":447,"address":[],"length":0,"stats":{"Line":1}},{"line":448,"address":[],"length":0,"stats":{"Line":1}},{"line":449,"address":[4982465],"length":1,"stats":{"Line":1}},{"line":450,"address":[5464291],"length":1,"stats":{"Line":1}},{"line":451,"address":[5859933],"length":1,"stats":{"Line":1}},{"line":452,"address":[6054655],"length":1,"stats":{"Line":1}},{"line":453,"address":[4829081],"length":1,"stats":{"Line":1}},{"line":454,"address":[2910651],"length":1,"stats":{"Line":1}},{"line":455,"address":[4212201],"length":1,"stats":{"Line":1}},{"line":456,"address":[1514897],"length":1,"stats":{"Line":1}},{"line":457,"address":[5860287],"length":1,"stats":{"Line":1}},{"line":458,"address":[5860337],"length":1,"stats":{"Line":1}},{"line":459,"address":[4829411],"length":1,"stats":{"Line":1}},{"line":475,"address":[6773296],"length":1,"stats":{"Line":15}},{"line":485,"address":[5108336,5110462,5119612],"length":1,"stats":{"Line":13}},{"line":492,"address":[],"length":0,"stats":{"Line":13}},{"line":495,"address":[7922068,7932708],"length":1,"stats":{"Line":12}},{"line":496,"address":[],"length":0,"stats":{"Line":1}},{"line":497,"address":[3707342,3717831],"length":1,"stats":{"Line":1}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[2992331],"length":1,"stats":{"Line":12}},{"line":507,"address":[5108988],"length":1,"stats":{"Line":0}},{"line":508,"address":[5658913,5669953],"length":1,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[2992723,2992493],"length":1,"stats":{"Line":22}},{"line":514,"address":[5659152,5670192],"length":1,"stats":{"Line":12}},{"line":515,"address":[1639250],"length":1,"stats":{"Line":0}},{"line":516,"address":[5120082],"length":1,"stats":{"Line":0}},{"line":517,"address":[3717613],"length":1,"stats":{"Line":0}},{"line":518,"address":[3060334],"length":1,"stats":{"Line":0}},{"line":522,"address":[2003720],"length":1,"stats":{"Line":13}},{"line":523,"address":[4659466,4648870],"length":1,"stats":{"Line":0}},{"line":524,"address":[2003809],"length":1,"stats":{"Line":0}},{"line":525,"address":[1629355],"length":1,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":25}},{"line":530,"address":[7942732,7931744],"length":1,"stats":{"Line":0}},{"line":531,"address":[3790464],"length":1,"stats":{"Line":0}},{"line":532,"address":[3050724],"length":1,"stats":{"Line":0}},{"line":533,"address":[4659129,4648533,4650389,4639445],"length":1,"stats":{"Line":0}},{"line":537,"address":[7922942,7933436,7933582,7922796],"length":1,"stats":{"Line":25}},{"line":538,"address":[4124687,4113743],"length":1,"stats":{"Line":0}},{"line":539,"address":[7487846,7466309,7444773,7455717,7477253],"length":1,"stats":{"Line":0}},{"line":540,"address":[7933606,7922966],"length":1,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[4639472,4650416],"length":1,"stats":{"Line":12}},{"line":547,"address":[2004319],"length":1,"stats":{"Line":13}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[1629799],"length":1,"stats":{"Line":0}},{"line":558,"address":[5670872,5670960,5659832,5659920],"length":1,"stats":{"Line":25}},{"line":559,"address":[3708598],"length":1,"stats":{"Line":5}},{"line":560,"address":[6603222],"length":1,"stats":{"Line":5}},{"line":561,"address":[5110274],"length":1,"stats":{"Line":0}},{"line":562,"address":[4650964,4640020],"length":1,"stats":{"Line":0}},{"line":563,"address":[1630110],"length":1,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[3791189],"length":1,"stats":{"Line":0}},{"line":566,"address":[7923572,7934212],"length":1,"stats":{"Line":0}},{"line":569,"address":[3051764,3051364],"length":1,"stats":{"Line":10}},{"line":571,"address":[7445181,7477661,7466717,7456125,7488255],"length":1,"stats":{"Line":13}},{"line":576,"address":[6604955,6603723],"length":1,"stats":{"Line":26}},{"line":577,"address":[6604942,6603912,6603958],"length":1,"stats":{"Line":12}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[7446239,7457172,7467775,7467882,7478811,7489345,7446346,7489475,7478708,7457275],"length":1,"stats":{"Line":11}},{"line":580,"address":[5661182,5672114,5661244,5672249,5672189,5661085],"length":1,"stats":{"Line":24}},{"line":581,"address":[7935252,7924579],"length":1,"stats":{"Line":0}},{"line":582,"address":[6604756],"length":1,"stats":{"Line":0}},{"line":583,"address":[4126257,4115348],"length":1,"stats":{"Line":0}},{"line":584,"address":[3792251],"length":1,"stats":{"Line":0}},{"line":585,"address":[3792292],"length":1,"stats":{"Line":0}},{"line":586,"address":[1631466,1631399],"length":1,"stats":{"Line":0}},{"line":590,"address":[1630775],"length":1,"stats":{"Line":13}},{"line":591,"address":[5668449,5679141],"length":1,"stats":{"Line":0}},{"line":592,"address":[5661757,5672744],"length":1,"stats":{"Line":0}},{"line":593,"address":[1631852],"length":1,"stats":{"Line":0}},{"line":594,"address":[3059531],"length":1,"stats":{"Line":0}},{"line":595,"address":[3001905],"length":1,"stats":{"Line":0}},{"line":598,"address":[3710335],"length":1,"stats":{"Line":13}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[7457810,7479346,7490128,7446919,7468455],"length":1,"stats":{"Line":13}},{"line":606,"address":[5680544,5661808,5672795,5681312],"length":1,"stats":{"Line":23}},{"line":607,"address":[4134825,4134796,4134110,4134073],"length":1,"stats":{"Line":24}},{"line":608,"address":[5681386,5680612],"length":1,"stats":{"Line":5}},{"line":610,"address":[4134811,4134089],"length":1,"stats":{"Line":10}},{"line":615,"address":[1631900],"length":1,"stats":{"Line":13}},{"line":616,"address":[7931309,7925194,7935984,7942297],"length":1,"stats":{"Line":26}},{"line":617,"address":[4122330,4132947],"length":1,"stats":{"Line":13}},{"line":618,"address":[2006605,2012143,2012410],"length":1,"stats":{"Line":26}},{"line":622,"address":[2006712],"length":1,"stats":{"Line":13}},{"line":625,"address":[3793323,3793504],"length":1,"stats":{"Line":22}},{"line":626,"address":[7925780,7936618],"length":1,"stats":{"Line":13}},{"line":627,"address":[],"length":0,"stats":{"Line":24}},{"line":628,"address":[3060870,3060666],"length":1,"stats":{"Line":26}},{"line":629,"address":[5121378,5121479,5121461],"length":1,"stats":{"Line":26}},{"line":630,"address":[1639954,1639914,1639965],"length":1,"stats":{"Line":26}},{"line":632,"address":[3718116],"length":1,"stats":{"Line":14}},{"line":637,"address":[2996327,2996487],"length":1,"stats":{"Line":24}},{"line":638,"address":[4642761,4653507],"length":1,"stats":{"Line":14}},{"line":639,"address":[3003408,3003458],"length":1,"stats":{"Line":28}},{"line":640,"address":[3800141,3800330],"length":1,"stats":{"Line":26}},{"line":641,"address":[5680789,5682265,5680875,5682197,5680857,5682283],"length":1,"stats":{"Line":24}},{"line":642,"address":[3003681,3003630,3003670],"length":1,"stats":{"Line":24}},{"line":644,"address":[2014503],"length":1,"stats":{"Line":11}},{"line":648,"address":[3054354,3054905,3054332,3054198],"length":1,"stats":{"Line":37}},{"line":649,"address":[3711763,3711654],"length":1,"stats":{"Line":0}},{"line":650,"address":[3794114,3798674],"length":1,"stats":{"Line":0}},{"line":651,"address":[4654267,4643546],"length":1,"stats":{"Line":0}},{"line":653,"address":[3711595],"length":1,"stats":{"Line":11}},{"line":657,"address":[2007435,2007894],"length":1,"stats":{"Line":26}},{"line":658,"address":[3794514,3794879],"length":1,"stats":{"Line":20}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[3712434],"length":1,"stats":{"Line":14}},{"line":666,"address":[6607049],"length":1,"stats":{"Line":12}},{"line":680,"address":[4654717,4644153,4654849,4644021],"length":1,"stats":{"Line":27}},{"line":681,"address":[7938228,7927340],"length":1,"stats":{"Line":13}},{"line":682,"address":[4129489,4129043,4130802,4118347,4118773,4120102],"length":1,"stats":{"Line":29}},{"line":683,"address":[3714727,3714860],"length":1,"stats":{"Line":9}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":5}},{"line":693,"address":[6608077,6607870,6607503,6607445,6608284],"length":1,"stats":{"Line":13}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[7927720,7938600],"length":1,"stats":{"Line":13}},{"line":703,"address":[3714107],"length":1,"stats":{"Line":13}},{"line":706,"address":[7929984,7940910],"length":1,"stats":{"Line":11}},{"line":707,"address":[],"length":0,"stats":{"Line":24}},{"line":708,"address":[4121336,4132278,4121626,4131988],"length":1,"stats":{"Line":24}},{"line":709,"address":[1637650],"length":1,"stats":{"Line":13}},{"line":710,"address":[],"length":0,"stats":{"Line":15}},{"line":711,"address":[7941440,7930508],"length":1,"stats":{"Line":0}},{"line":712,"address":[7463124,7474008,7484660,7495809,7452479],"length":1,"stats":{"Line":0}},{"line":713,"address":[5118343],"length":1,"stats":{"Line":0}},{"line":714,"address":[5118379],"length":1,"stats":{"Line":0}},{"line":719,"address":[6610362],"length":1,"stats":{"Line":11}},{"line":722,"address":[4662208,4662224],"length":1,"stats":{"Line":6}},{"line":723,"address":[3801208],"length":1,"stats":{"Line":6}},{"line":726,"address":[3706928],"length":1,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[7919360,7916608],"length":1,"stats":{"Line":2}},{"line":745,"address":[],"length":0,"stats":{"Line":4}},{"line":746,"address":[3787448],"length":1,"stats":{"Line":2}},{"line":748,"address":[4111308,4108778],"length":1,"stats":{"Line":3}},{"line":749,"address":[4637361,4634989],"length":1,"stats":{"Line":3}},{"line":750,"address":[7920772,7918400],"length":1,"stats":{"Line":3}},{"line":758,"address":[3048519],"length":1,"stats":{"Line":2}},{"line":760,"address":[5107539],"length":1,"stats":{"Line":1}},{"line":761,"address":[2991092],"length":1,"stats":{"Line":1}},{"line":762,"address":[6600667],"length":1,"stats":{"Line":1}},{"line":766,"address":[4637609,4635088,4635306,4637422],"length":1,"stats":{"Line":2}},{"line":769,"address":[2991286],"length":1,"stats":{"Line":3}},{"line":771,"address":[3788925,3788952],"length":1,"stats":{"Line":6}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[2991459],"length":1,"stats":{"Line":2}},{"line":775,"address":[6600929],"length":1,"stats":{"Line":3}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[5657723,5655105],"length":1,"stats":{"Line":3}},{"line":781,"address":[6601160,6601206],"length":1,"stats":{"Line":6}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[3049370],"length":1,"stats":{"Line":1}},{"line":785,"address":[7919128,7921324],"length":1,"stats":{"Line":3}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[3706722],"length":1,"stats":{"Line":3}},{"line":792,"address":[3047098,3047193],"length":1,"stats":{"Line":6}},{"line":793,"address":[3787644],"length":1,"stats":{"Line":3}},{"line":795,"address":[3788360],"length":1,"stats":{"Line":2}},{"line":796,"address":[3705586],"length":1,"stats":{"Line":2}},{"line":797,"address":[3705589],"length":1,"stats":{"Line":2}},{"line":801,"address":[5106862,5107067],"length":1,"stats":{"Line":2}},{"line":803,"address":[5654542,5657015],"length":1,"stats":{"Line":2}},{"line":811,"address":[4109993,4107875],"length":1,"stats":{"Line":2}},{"line":812,"address":[5106088],"length":1,"stats":{"Line":2}},{"line":815,"address":[2001334],"length":1,"stats":{"Line":0}},{"line":816,"address":[3704664],"length":1,"stats":{"Line":0}},{"line":817,"address":[2989781,2989885,2989695],"length":1,"stats":{"Line":0}},{"line":824,"address":[3787946,3787897],"length":1,"stats":{"Line":2}},{"line":825,"address":[5106314,5106373],"length":1,"stats":{"Line":6}},{"line":826,"address":[7917538,7920212],"length":1,"stats":{"Line":0}},{"line":828,"address":[2001452],"length":1,"stats":{"Line":3}},{"line":830,"address":[4636825,4634170],"length":1,"stats":{"Line":3}},{"line":833,"address":[2001540],"length":1,"stats":{"Line":2}},{"line":834,"address":[3705199],"length":1,"stats":{"Line":2}},{"line":835,"address":[5654221,5656656],"length":1,"stats":{"Line":2}},{"line":836,"address":[3705277],"length":1,"stats":{"Line":2}},{"line":837,"address":[3705280],"length":1,"stats":{"Line":2}},{"line":840,"address":[7917978,7920407],"length":1,"stats":{"Line":2}},{"line":843,"address":[7442912,7443024,7443136,7443248,7443360],"length":1,"stats":{"Line":0}},{"line":844,"address":[3706825],"length":1,"stats":{"Line":0}},{"line":850,"address":[4606675,4611646,4608768,4611274,4604096,4607068],"length":1,"stats":{"Line":1}},{"line":859,"address":[5094551],"length":1,"stats":{"Line":1}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[3746988],"length":1,"stats":{"Line":0}},{"line":862,"address":[5640998,5636326],"length":1,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[1611358,1611093],"length":1,"stats":{"Line":2}},{"line":867,"address":[3030754],"length":1,"stats":{"Line":1}},{"line":868,"address":[6575060],"length":1,"stats":{"Line":0}},{"line":869,"address":[7889032,7884353],"length":1,"stats":{"Line":0}},{"line":870,"address":[4092826,4097489],"length":1,"stats":{"Line":0}},{"line":871,"address":[5098907],"length":1,"stats":{"Line":0}},{"line":876,"address":[6571110,6571052],"length":1,"stats":{"Line":2}},{"line":877,"address":[3691901],"length":1,"stats":{"Line":0}},{"line":878,"address":[4093747,4089314],"length":1,"stats":{"Line":0}},{"line":879,"address":[7383757,7388429,7397741,7379324,7393308],"length":1,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[5094978],"length":1,"stats":{"Line":1}},{"line":886,"address":[4609369,4604973,4605063,4609652],"length":1,"stats":{"Line":2}},{"line":887,"address":[4605171,4612948,4608411,4609760],"length":1,"stats":{"Line":2}},{"line":888,"address":[6574543,6574830],"length":1,"stats":{"Line":1}},{"line":894,"address":[5095518],"length":1,"stats":{"Line":1}},{"line":897,"address":[3692346],"length":1,"stats":{"Line":1}},{"line":898,"address":[2961566],"length":1,"stats":{"Line":1}},{"line":899,"address":[],"length":0,"stats":{"Line":2}},{"line":901,"address":[7883567,7888205,7885943,7881316],"length":1,"stats":{"Line":2}},{"line":902,"address":[3033915,3033828],"length":1,"stats":{"Line":1}},{"line":903,"address":[5639738,5644349,5644316,5639771],"length":1,"stats":{"Line":2}},{"line":904,"address":[5098195,5098233],"length":1,"stats":{"Line":1}},{"line":906,"address":[7382293,7386922,7391649,7401106,7391691,7396484,7396277,7400899,7400941,7391856,7382500,7382335,7386964,7387129,7396319],"length":1,"stats":{"Line":3}},{"line":907,"address":[5098437,5098313],"length":1,"stats":{"Line":1}},{"line":913,"address":[4094425,4089814],"length":1,"stats":{"Line":1}},{"line":914,"address":[3031549],"length":1,"stats":{"Line":1}},{"line":915,"address":[3747984,3748015],"length":1,"stats":{"Line":2}},{"line":917,"address":[5643632,5642083,5639054,5637494],"length":1,"stats":{"Line":2}},{"line":918,"address":[3694293,3694383],"length":1,"stats":{"Line":1}},{"line":919,"address":[],"length":0,"stats":{"Line":2}},{"line":920,"address":[4096425,4091803,4096387,4091765],"length":1,"stats":{"Line":1}},{"line":921,"address":[1968858,1968693,1968651],"length":1,"stats":{"Line":3}},{"line":922,"address":[4092007,4091883,4096505,4096629],"length":1,"stats":{"Line":1}},{"line":929,"address":[2961917],"length":1,"stats":{"Line":1}},{"line":932,"address":[6572020],"length":1,"stats":{"Line":1}},{"line":947,"address":[7384929,7389631,7394238,7384861,7380322,7398845,7398913,7380254,7389563,7394306],"length":1,"stats":{"Line":2}},{"line":948,"address":[5096235],"length":1,"stats":{"Line":1}},{"line":951,"address":[1967313],"length":1,"stats":{"Line":1}},{"line":952,"address":[5638253,5638321,5642914,5642846],"length":1,"stats":{"Line":2}},{"line":953,"address":[3693814,3693520],"length":1,"stats":{"Line":2}},{"line":954,"address":[6573113],"length":1,"stats":{"Line":1}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[3693683],"length":1,"stats":{"Line":0}},{"line":957,"address":[7390190,7399456,7380871,7394855,7385479],"length":1,"stats":{"Line":0}},{"line":958,"address":[1967742],"length":1,"stats":{"Line":0}},{"line":959,"address":[5643047,5638448],"length":1,"stats":{"Line":0}},{"line":964,"address":[3748869],"length":1,"stats":{"Line":1}},{"line":971,"address":[4615184,4613296],"length":1,"stats":{"Line":13}},{"line":981,"address":[6575315],"length":1,"stats":{"Line":13}},{"line":984,"address":[5099365],"length":1,"stats":{"Line":13}},{"line":985,"address":[3751697,3753393,3753344,3751537],"length":1,"stats":{"Line":8}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[1972096],"length":1,"stats":{"Line":0}},{"line":990,"address":[2965616,2965900],"length":1,"stats":{"Line":15}},{"line":992,"address":[3035710,3035999,3035430],"length":1,"stats":{"Line":19}},{"line":993,"address":[3751946,3751999,3752078],"length":1,"stats":{"Line":13}},{"line":997,"address":[1970549],"length":1,"stats":{"Line":8}},{"line":998,"address":[5099779],"length":1,"stats":{"Line":8}},{"line":1000,"address":[4613688,4615580],"length":1,"stats":{"Line":13}},{"line":1002,"address":[7412020,7409821,7403028,7405704,7407933],"length":1,"stats":{"Line":13}},{"line":1008,"address":[5099978,5100686,5100309],"length":1,"stats":{"Line":25}},{"line":1009,"address":[1616863],"length":1,"stats":{"Line":5}},{"line":1011,"address":[5100551,5100398],"length":1,"stats":{"Line":7}},{"line":1012,"address":[4616627,4614341,4616792,4614372,4614302,4616669],"length":1,"stats":{"Line":12}},{"line":1016,"address":[1971078,1970912],"length":1,"stats":{"Line":26}},{"line":1017,"address":[2967144,2966784,2967584],"length":1,"stats":{"Line":39}},{"line":1018,"address":[7404106,7404241,7410535,7413012,7413147,7408785,7408647,7406687,7406822,7410673],"length":1,"stats":{"Line":13}},{"line":1019,"address":[5101267,5101363],"length":1,"stats":{"Line":13}},{"line":1020,"address":[],"length":0,"stats":{"Line":13}},{"line":1024,"address":[5648886,5648864,5646444,5646466],"length":1,"stats":{"Line":27}},{"line":1025,"address":[6576914],"length":1,"stats":{"Line":8}},{"line":1026,"address":[],"length":0,"stats":{"Line":8}},{"line":1027,"address":[2966929],"length":1,"stats":{"Line":8}},{"line":1028,"address":[5646588,5649007],"length":1,"stats":{"Line":8}},{"line":1029,"address":[2966957],"length":1,"stats":{"Line":8}},{"line":1030,"address":[1971262],"length":1,"stats":{"Line":0}},{"line":1033,"address":[6576886],"length":1,"stats":{"Line":14}},{"line":1037,"address":[1618208,1617502,1617386],"length":1,"stats":{"Line":26}},{"line":1038,"address":[7893939,7894008,7894200,7894131],"length":1,"stats":{"Line":0}},{"line":1039,"address":[7894271,7894079],"length":1,"stats":{"Line":0}},{"line":1040,"address":[3698627],"length":1,"stats":{"Line":0}},{"line":1041,"address":[1618360],"length":1,"stats":{"Line":0}},{"line":1044,"address":[4617933,4618125],"length":1,"stats":{"Line":0}},{"line":1045,"address":[1971905],"length":1,"stats":{"Line":0}},{"line":1046,"address":[5101670],"length":1,"stats":{"Line":0}},{"line":1163,"address":[3698688],"length":1,"stats":{"Line":3}},{"line":1164,"address":[4102757],"length":1,"stats":{"Line":3}},{"line":1169,"address":[],"length":0,"stats":{"Line":11}},{"line":1170,"address":[],"length":0,"stats":{"Line":13}},{"line":1173,"address":[4662592],"length":1,"stats":{"Line":2}},{"line":1174,"address":[4138181],"length":1,"stats":{"Line":3}},{"line":1177,"address":[],"length":0,"stats":{"Line":2}},{"line":1178,"address":[],"length":0,"stats":{"Line":0}},{"line":1181,"address":[3061872],"length":1,"stats":{"Line":0}},{"line":1182,"address":[5684790],"length":1,"stats":{"Line":0}},{"line":1197,"address":[3037712,3038429,3038404],"length":1,"stats":{"Line":13}},{"line":1203,"address":[7894422],"length":1,"stats":{"Line":13}},{"line":1204,"address":[3698778],"length":1,"stats":{"Line":13}},{"line":1205,"address":[4618323],"length":1,"stats":{"Line":13}},{"line":1206,"address":[4620832,4618336,4620844],"length":1,"stats":{"Line":39}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1208,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[4618392],"length":1,"stats":{"Line":13}},{"line":1212,"address":[3753767],"length":1,"stats":{"Line":0}},{"line":1215,"address":[3698879],"length":1,"stats":{"Line":13}},{"line":1218,"address":[6578168,6578428,6578364,6578252],"length":1,"stats":{"Line":39}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1222,"address":[3756030,3756036,3753656,3754224,3754287],"length":1,"stats":{"Line":39}},{"line":1223,"address":[5102838,5102719],"length":1,"stats":{"Line":13}},{"line":1225,"address":[3038594,3038659],"length":1,"stats":{"Line":13}},{"line":1226,"address":[2968773],"length":1,"stats":{"Line":13}},{"line":1227,"address":[],"length":0,"stats":{"Line":0}},{"line":1228,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[7895416],"length":1,"stats":{"Line":13}},{"line":1231,"address":[1619584,1619710],"length":1,"stats":{"Line":13}},{"line":1232,"address":[5103016,5102949],"length":1,"stats":{"Line":26}},{"line":1233,"address":[],"length":0,"stats":{"Line":0}},{"line":1234,"address":[],"length":0,"stats":{"Line":0}},{"line":1236,"address":[6579277,6579200],"length":1,"stats":{"Line":26}},{"line":1237,"address":[4104293,4105077],"length":1,"stats":{"Line":26}},{"line":1238,"address":[2970229],"length":1,"stats":{"Line":13}},{"line":1241,"address":[7897221,7895937,7896151,7896992,7897215],"length":1,"stats":{"Line":13}},{"line":1242,"address":[5652992],"length":1,"stats":{"Line":0}},{"line":1243,"address":[4620903],"length":1,"stats":{"Line":0}},{"line":1244,"address":[6580622],"length":1,"stats":{"Line":0}},{"line":1245,"address":[6580628],"length":1,"stats":{"Line":0}},{"line":1246,"address":[4620937],"length":1,"stats":{"Line":0}},{"line":1250,"address":[5103930],"length":1,"stats":{"Line":15}},{"line":1251,"address":[],"length":0,"stats":{"Line":13}},{"line":1252,"address":[5103810],"length":1,"stats":{"Line":13}},{"line":1253,"address":[7896294],"length":1,"stats":{"Line":13}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[4620186],"length":1,"stats":{"Line":13}},{"line":1256,"address":[4620234],"length":1,"stats":{"Line":13}},{"line":1257,"address":[1620436],"length":1,"stats":{"Line":13}},{"line":1258,"address":[5652284],"length":1,"stats":{"Line":13}},{"line":1259,"address":[5652296],"length":1,"stats":{"Line":14}},{"line":1260,"address":[7896404],"length":1,"stats":{"Line":15}},{"line":1261,"address":[4620295],"length":1,"stats":{"Line":11}},{"line":1266,"address":[3038250,3038355],"length":1,"stats":{"Line":26}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[2968408],"length":1,"stats":{"Line":11}}],"covered":292,"coverable":461},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","policy.rs"],"content":"use hashbrown::HashSet;\n\nuse crate::op::NonPrimitiveOpType;\n\n/// Policy trait to gate non-primitive ops availability.\npub trait NonPrimPolicy {\n    fn is_allowed(\u0026self, op: NonPrimitiveOpType) -\u003e bool;\n}\n\n/// Default profile: non-primitive ops are not supported.\npub struct DefaultProfile;\n\nimpl NonPrimPolicy for DefaultProfile {\n    #[inline]\n    fn is_allowed(\u0026self, _op: NonPrimitiveOpType) -\u003e bool {\n        false\n    }\n}\n\n/// Allow all non-primitive ops.\npub struct AllowAllProfile;\n\nimpl NonPrimPolicy for AllowAllProfile {\n    #[inline]\n    fn is_allowed(\u0026self, _op: NonPrimitiveOpType) -\u003e bool {\n        true\n    }\n}\n\n/// Runtime policy defining the list of allowed non-primitive ops.\npub struct RuntimeAllowlist {\n    allowed: HashSet\u003cNonPrimitiveOpType\u003e,\n}\n\nimpl RuntimeAllowlist {\n    pub fn from_slice(ops: \u0026[NonPrimitiveOpType]) -\u003e Self {\n        Self {\n            allowed: ops.iter().cloned().collect(),\n        }\n    }\n\n    pub fn insert(\u0026mut self, op: NonPrimitiveOpType) {\n        self.allowed.insert(op);\n    }\n}\n\nimpl NonPrimPolicy for RuntimeAllowlist {\n    #[inline]\n    fn is_allowed(\u0026self, op: NonPrimitiveOpType) -\u003e bool {\n        self.allowed.contains(\u0026op)\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[6793728],"length":1,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[15685776],"length":1,"stats":{"Line":0}},{"line":38,"address":[11591936],"length":1,"stats":{"Line":0}},{"line":42,"address":[7643136],"length":1,"stats":{"Line":0}},{"line":43,"address":[2572832],"length":1,"stats":{"Line":0}},{"line":49,"address":[8916688],"length":1,"stats":{"Line":0}},{"line":50,"address":[2593440],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","alu.rs"],"content":"use alloc::vec::Vec;\n\nuse p3_field::Field;\n\nuse crate::CircuitError;\nuse crate::op::{AluOpKind, Op};\nuse crate::types::WitnessId;\n\n/// Unified ALU operation table.\n///\n/// Records all ALU operations (Add, Mul, BoolCheck, MulAdd) in the circuit.\n/// Each row represents one constraint based on the operation kind:\n/// - Add: a + b = out\n/// - Mul: a * b = out\n/// - BoolCheck: a * (a - 1) = 0, out = a\n/// - MulAdd: a * b + c = out\n#[derive(Debug, Clone)]\npub struct AluTrace\u003cF\u003e {\n    /// Operation kind for each row\n    pub op_kind: Vec\u003cAluOpKind\u003e,\n    /// First operand values (a)\n    pub a_values: Vec\u003cF\u003e,\n    /// First operand indices (references witness bus)\n    pub a_index: Vec\u003cWitnessId\u003e,\n    /// Second operand values (b)\n    pub b_values: Vec\u003cF\u003e,\n    /// Second operand indices (references witness bus)\n    pub b_index: Vec\u003cWitnessId\u003e,\n    /// Third operand values (c) - only used for MulAdd, zero otherwise\n    pub c_values: Vec\u003cF\u003e,\n    /// Third operand indices - only meaningful for MulAdd\n    pub c_index: Vec\u003cWitnessId\u003e,\n    /// Result values\n    pub out_values: Vec\u003cF\u003e,\n    /// Result indices (references witness bus)\n    pub out_index: Vec\u003cWitnessId\u003e,\n}\n\nimpl\u003cF\u003e AluTrace\u003cF\u003e {\n    /// Returns the number of operations in the trace.\n    pub const fn len(\u0026self) -\u003e usize {\n        self.a_values.len()\n    }\n\n    /// Returns true if the trace is empty.\n    pub const fn is_empty(\u0026self) -\u003e bool {\n        self.a_values.is_empty()\n    }\n}\n\n/// Builder for generating ALU traces.\npub struct AluTraceBuilder\u003c'a, F\u003e {\n    primitive_ops: \u0026'a [Op\u003cF\u003e],\n    witness: \u0026'a [Option\u003cF\u003e],\n}\n\nimpl\u003c'a, F: Clone + Field\u003e AluTraceBuilder\u003c'a, F\u003e {\n    /// Creates a new ALU trace builder.\n    pub const fn new(primitive_ops: \u0026'a [Op\u003cF\u003e], witness: \u0026'a [Option\u003cF\u003e]) -\u003e Self {\n        Self {\n            primitive_ops,\n            witness,\n        }\n    }\n\n    /// Builds the ALU trace from circuit operations.\n    pub fn build(self) -\u003e Result\u003cAluTrace\u003cF\u003e, CircuitError\u003e {\n        let mut op_kind = Vec::with_capacity(1 \u003c\u003c 15);\n        let mut a_values = Vec::with_capacity(1 \u003c\u003c 15);\n        let mut a_index = Vec::with_capacity(1 \u003c\u003c 15);\n        let mut b_values = Vec::with_capacity(1 \u003c\u003c 15);\n        let mut b_index = Vec::with_capacity(1 \u003c\u003c 15);\n        let mut c_values = Vec::with_capacity(1 \u003c\u003c 15);\n        let mut c_index = Vec::with_capacity(1 \u003c\u003c 15);\n        let mut out_values = Vec::with_capacity(1 \u003c\u003c 15);\n        let mut out_index = Vec::with_capacity(1 \u003c\u003c 15);\n\n        for prim in self.primitive_ops {\n            if let Op::Alu {\n                kind, a, b, c, out, ..\n            } = prim\n            {\n                let a_val = self.resolve(a)?;\n                let b_val = self.resolve(b)?;\n                let c_val = if let Some(c_id) = c {\n                    self.resolve(c_id)?\n                } else {\n                    F::ZERO\n                };\n                let out_val = self.resolve(out)?;\n\n                op_kind.push(*kind);\n                a_values.push(a_val);\n                a_index.push(*a);\n                b_values.push(b_val);\n                b_index.push(*b);\n                c_values.push(c_val);\n                c_index.push(c.unwrap_or(WitnessId(0)));\n                out_values.push(out_val);\n                out_index.push(*out);\n            }\n        }\n\n        // If trace is empty, add a dummy row: 0 + 0 = 0\n        if a_values.is_empty() {\n            op_kind.push(AluOpKind::Add);\n            a_values.push(F::ZERO);\n            a_index.push(WitnessId(0));\n            b_values.push(F::ZERO);\n            b_index.push(WitnessId(0));\n            c_values.push(F::ZERO);\n            c_index.push(WitnessId(0));\n            out_values.push(F::ZERO);\n            out_index.push(WitnessId(0));\n        }\n\n        Ok(AluTrace {\n            op_kind,\n            a_values,\n            a_index,\n            b_values,\n            b_index,\n            c_values,\n            c_index,\n            out_values,\n            out_index,\n        })\n    }\n\n    /// Resolves a single witness value safely.\n    #[inline]\n    fn resolve(\u0026self, id: \u0026WitnessId) -\u003e Result\u003cF, CircuitError\u003e {\n        self.witness\n            .get(id.0 as usize)\n            .and_then(|opt| opt.as_ref())\n            .cloned()\n            .ok_or(CircuitError::WitnessNotSet { witness_id: *id })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_single_addition() {\n        let a = F::from_u64(5);\n        let b = F::from_u64(3);\n        let out = F::from_u64(8);\n        let witness = vec![Some(a), Some(b), Some(out)];\n\n        let ops = vec![Op::add(WitnessId(0), WitnessId(1), WitnessId(2))];\n\n        let builder = AluTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        assert_eq!(trace.len(), 1);\n        assert_eq!(trace.op_kind[0], AluOpKind::Add);\n        assert_eq!(trace.a_values[0], a);\n        assert_eq!(trace.b_values[0], b);\n        assert_eq!(trace.out_values[0], out);\n    }\n\n    #[test]\n    fn test_single_multiplication() {\n        let a = F::from_u64(5);\n        let b = F::from_u64(3);\n        let out = F::from_u64(15);\n        let witness = vec![Some(a), Some(b), Some(out)];\n\n        let ops = vec![Op::mul(WitnessId(0), WitnessId(1), WitnessId(2))];\n\n        let builder = AluTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        assert_eq!(trace.len(), 1);\n        assert_eq!(trace.op_kind[0], AluOpKind::Mul);\n        assert_eq!(trace.a_values[0], a);\n        assert_eq!(trace.b_values[0], b);\n        assert_eq!(trace.out_values[0], out);\n    }\n\n    #[test]\n    fn test_mul_add() {\n        // a * b + c = out =\u003e 5 * 3 + 2 = 17\n        let a = F::from_u64(5);\n        let b = F::from_u64(3);\n        let c = F::from_u64(2);\n        let out = F::from_u64(17);\n        let witness = vec![Some(a), Some(b), Some(c), Some(out)];\n\n        let ops = vec![Op::mul_add(\n            WitnessId(0),\n            WitnessId(1),\n            WitnessId(2),\n            WitnessId(3),\n        )];\n\n        let builder = AluTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        assert_eq!(trace.len(), 1);\n        assert_eq!(trace.op_kind[0], AluOpKind::MulAdd);\n        assert_eq!(trace.a_values[0], a);\n        assert_eq!(trace.b_values[0], b);\n        assert_eq!(trace.c_values[0], c);\n        assert_eq!(trace.out_values[0], out);\n    }\n\n    #[test]\n    fn test_bool_check() {\n        // BoolCheck: a * (a - 1) = 0, out = a\n        // For a = 1: 1 * 0 = 0 ✓\n        let a = F::ONE;\n        let witness = vec![Some(a), Some(F::ZERO)]; // a and placeholder for b\n\n        let ops = vec![Op::bool_check(WitnessId(0), WitnessId(1), WitnessId(0))];\n\n        let builder = AluTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        assert_eq!(trace.len(), 1);\n        assert_eq!(trace.op_kind[0], AluOpKind::BoolCheck);\n        assert_eq!(trace.a_values[0], a);\n    }\n\n    #[test]\n    fn test_mixed_operations() {\n        let a1 = F::from_u64(10);\n        let b1 = F::from_u64(20);\n        let out1 = F::from_u64(30); // add\n\n        let a2 = F::from_u64(7);\n        let b2 = F::from_u64(3);\n        let out2 = F::from_u64(21); // mul\n\n        let witness = vec![\n            Some(a1),\n            Some(b1),\n            Some(out1),\n            Some(a2),\n            Some(b2),\n            Some(out2),\n        ];\n\n        let ops = vec![\n            Op::add(WitnessId(0), WitnessId(1), WitnessId(2)),\n            Op::mul(WitnessId(3), WitnessId(4), WitnessId(5)),\n        ];\n\n        let builder = AluTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        assert_eq!(trace.len(), 2);\n        assert_eq!(trace.op_kind[0], AluOpKind::Add);\n        assert_eq!(trace.op_kind[1], AluOpKind::Mul);\n    }\n\n    #[test]\n    fn test_empty_operations_creates_dummy_row() {\n        let witness = vec![Some(F::ZERO)];\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![];\n\n        let builder = AluTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        assert_eq!(trace.len(), 1);\n        assert_eq!(trace.op_kind[0], AluOpKind::Add);\n        assert_eq!(trace.a_values[0], F::ZERO);\n        assert_eq!(trace.b_values[0], F::ZERO);\n        assert_eq!(trace.out_values[0], F::ZERO);\n    }\n\n    #[test]\n    fn test_missing_witness_returns_error() {\n        let witness = vec![None, Some(F::from_u64(5)), Some(F::from_u64(5))];\n\n        let ops = vec![Op::add(WitnessId(0), WitnessId(1), WitnessId(2))];\n\n        let builder = AluTraceBuilder::new(\u0026ops, \u0026witness);\n        let result = builder.build();\n\n        assert!(result.is_err());\n        match result {\n            Err(CircuitError::WitnessNotSet { witness_id }) =\u003e {\n                assert_eq!(witness_id, WitnessId(0));\n            }\n            _ =\u003e panic!(\"Expected WitnessNotSet error\"),\n        }\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[7264437],"length":1,"stats":{"Line":1}},{"line":46,"address":[7264448],"length":1,"stats":{"Line":1}},{"line":47,"address":[7264453],"length":1,"stats":{"Line":1}},{"line":59,"address":[4621360,4621312],"length":1,"stats":{"Line":26}},{"line":67,"address":[6022272,6026011],"length":1,"stats":{"Line":26}},{"line":68,"address":[7264598,7268358],"length":1,"stats":{"Line":25}},{"line":69,"address":[7264626,7268389],"length":1,"stats":{"Line":27}},{"line":70,"address":[6022366],"length":1,"stats":{"Line":25}},{"line":71,"address":[2524569],"length":1,"stats":{"Line":27}},{"line":72,"address":[4623732,4627502],"length":1,"stats":{"Line":26}},{"line":73,"address":[1972765],"length":1,"stats":{"Line":26}},{"line":74,"address":[4506664],"length":1,"stats":{"Line":26}},{"line":75,"address":[6168933,6165351],"length":1,"stats":{"Line":26}},{"line":76,"address":[2226032],"length":1,"stats":{"Line":25}},{"line":78,"address":[6022784,6022855],"length":1,"stats":{"Line":52}},{"line":79,"address":[5281893],"length":1,"stats":{"Line":28}},{"line":80,"address":[12375121,12367537,12378844,12382481,12371484],"length":1,"stats":{"Line":23}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[12371589,12369471,12382586,12367642,12373047,12376830,12378949,12380407,12375226,12384190],"length":1,"stats":{"Line":26}},{"line":84,"address":[7266881,7270606,7271762,7268185],"length":1,"stats":{"Line":24}},{"line":85,"address":[6167556,6171224,6167498,6171147],"length":1,"stats":{"Line":44}},{"line":86,"address":[6171245,6171569,6167858,6167538,6167577,6171187],"length":1,"stats":{"Line":44}},{"line":88,"address":[],"length":0,"stats":{"Line":24}},{"line":90,"address":[4626538,4630701,4627124,4630230,4630187,4626581],"length":1,"stats":{"Line":46}},{"line":92,"address":[7267896,7271547],"length":1,"stats":{"Line":22}},{"line":93,"address":[1975721],"length":1,"stats":{"Line":25}},{"line":94,"address":[4509573],"length":1,"stats":{"Line":22}},{"line":95,"address":[12380258,12383972,12376612,12369205,12372898],"length":1,"stats":{"Line":25}},{"line":96,"address":[1422848],"length":1,"stats":{"Line":21}},{"line":97,"address":[7271647,7268033],"length":1,"stats":{"Line":24}},{"line":98,"address":[1975818],"length":1,"stats":{"Line":21}},{"line":99,"address":[6168331,6172082],"length":1,"stats":{"Line":24}},{"line":100,"address":[],"length":0,"stats":{"Line":21}},{"line":105,"address":[],"length":0,"stats":{"Line":26}},{"line":106,"address":[2526082],"length":1,"stats":{"Line":9}},{"line":107,"address":[1974194],"length":1,"stats":{"Line":7}},{"line":108,"address":[4629011,4625237],"length":1,"stats":{"Line":9}},{"line":109,"address":[6166692,6170268],"length":1,"stats":{"Line":7}},{"line":110,"address":[7266344,7270101],"length":1,"stats":{"Line":9}},{"line":111,"address":[5282943],"length":1,"stats":{"Line":7}},{"line":112,"address":[7266395,7270135],"length":1,"stats":{"Line":9}},{"line":113,"address":[12367450,12371432,12375042,12378792,12382402],"length":1,"stats":{"Line":7}},{"line":114,"address":[4626878,4623241],"length":1,"stats":{"Line":9}},{"line":117,"address":[4624724,4628512],"length":1,"stats":{"Line":29}},{"line":118,"address":[6023050],"length":1,"stats":{"Line":24}},{"line":119,"address":[6023092],"length":1,"stats":{"Line":28}},{"line":120,"address":[6165840,6169412],"length":1,"stats":{"Line":24}},{"line":121,"address":[2525332],"length":1,"stats":{"Line":28}},{"line":122,"address":[5282132],"length":1,"stats":{"Line":24}},{"line":123,"address":[7269376,7265588],"length":1,"stats":{"Line":27}},{"line":124,"address":[2525476],"length":1,"stats":{"Line":23}},{"line":125,"address":[4507456],"length":1,"stats":{"Line":29}},{"line":126,"address":[5282324],"length":1,"stats":{"Line":25}},{"line":132,"address":[7271936,7272080],"length":1,"stats":{"Line":23}},{"line":133,"address":[1976108],"length":1,"stats":{"Line":25}},{"line":134,"address":[2528222],"length":1,"stats":{"Line":23}},{"line":135,"address":[6172617,6172362,6172585,6172496,6172576,6172608],"length":1,"stats":{"Line":73}},{"line":137,"address":[1976152],"length":1,"stats":{"Line":23}}],"covered":58,"coverable":59},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","constant.rs"],"content":"use alloc::vec::Vec;\n\nuse crate::CircuitError;\nuse crate::op::Op;\nuse crate::types::WitnessId;\n\n/// Constant values table.\n///\n/// Stores all compile-time known constant values used in the circuit.\n/// Each constant binds to a specific witness ID.\n/// Both prover and verifier know these values in advance.\n#[derive(Debug, Clone)]\npub struct ConstTrace\u003cF\u003e {\n    /// Witness IDs that each constant binds to.\n    ///\n    /// Maps each constant to its location in the witness table.\n    pub index: Vec\u003cWitnessId\u003e,\n    /// Constant field element values.\n    pub values: Vec\u003cF\u003e,\n}\n\n/// Builder for generating constant traces.\npub struct ConstTraceBuilder\u003c'a, F\u003e {\n    primitive_ops: \u0026'a [Op\u003cF\u003e],\n}\n\nimpl\u003c'a, F: Clone\u003e ConstTraceBuilder\u003c'a, F\u003e {\n    /// Creates a new constant trace builder.\n    pub const fn new(primitive_ops: \u0026'a [Op\u003cF\u003e]) -\u003e Self {\n        Self { primitive_ops }\n    }\n\n    /// Builds the constant trace from circuit operations.\n    pub fn build(self) -\u003e Result\u003cConstTrace\u003cF\u003e, CircuitError\u003e {\n        let mut index = Vec::with_capacity(1 \u003c\u003c 9);\n        let mut values = Vec::with_capacity(1 \u003c\u003c 9);\n\n        for prim in self.primitive_ops {\n            if let Op::Const { out, val } = prim {\n                index.push(*out);\n                values.push(val.clone());\n            }\n        }\n\n        Ok(ConstTrace { index, values })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_single_constant() {\n        // Create a single constant operation that loads a value into witness\n        let val = F::from_u64(42);\n        let out = WitnessId(0);\n\n        let ops = vec![Op::Const { out, val }];\n\n        // Build the trace using the builder pattern\n        let builder = ConstTraceBuilder::new(\u0026ops);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace contains exactly one constant\n        assert_eq!(trace.index.len(), 1, \"Should have one constant operation\");\n        assert_eq!(trace.values.len(), 1, \"Should have one constant value\");\n\n        // Verify the constant is correctly recorded\n        assert_eq!(trace.index[0], out);\n        assert_eq!(trace.values[0], val);\n    }\n\n    #[test]\n    fn test_multiple_constants() {\n        // Create multiple constant operations with different values\n        let val1 = F::from_u64(10);\n        let out1 = WitnessId(0);\n\n        let val2 = F::from_u64(20);\n        let out2 = WitnessId(1);\n\n        let val3 = F::from_u64(30);\n        let out3 = WitnessId(2);\n\n        let ops = vec![\n            Op::Const {\n                out: out1,\n                val: val1,\n            },\n            Op::Const {\n                out: out2,\n                val: val2,\n            },\n            Op::Const {\n                out: out3,\n                val: val3,\n            },\n        ];\n\n        // Build the trace\n        let builder = ConstTraceBuilder::new(\u0026ops);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify we have exactly three constants\n        assert_eq!(\n            trace.index.len(),\n            3,\n            \"Should have three constant operations\"\n        );\n        assert_eq!(trace.values.len(), 3, \"Should have three constant values\");\n\n        // Verify first constant\n        assert_eq!(trace.index[0], out1);\n        assert_eq!(trace.values[0], val1);\n\n        // Verify second constant\n        assert_eq!(trace.index[1], out2);\n        assert_eq!(trace.values[1], val2);\n\n        // Verify third constant\n        assert_eq!(trace.index[2], out3);\n        assert_eq!(trace.values[2], val3);\n    }\n\n    #[test]\n    fn test_empty_operations() {\n        // Provide an empty operations list\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![];\n\n        // Build the trace\n        let builder = ConstTraceBuilder::new(\u0026ops);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace is empty\n        assert_eq!(trace.index.len(), 0, \"Should have no constants\");\n        assert_eq!(trace.values.len(), 0, \"Should have no values\");\n    }\n}\n","traces":[{"line":29,"address":[3881888],"length":1,"stats":{"Line":28}},{"line":34,"address":[8839312,8838590,8837896,8838608,8839987,8840016,8840680,8839993,8839289,8838584,8839283,8837920,8840686,8837902,8837232],"length":1,"stats":{"Line":28}},{"line":35,"address":[1669547],"length":1,"stats":{"Line":28}},{"line":36,"address":[5033076,5033780],"length":1,"stats":{"Line":28}},{"line":38,"address":[7988759,7989386,7988698,7989451],"length":1,"stats":{"Line":55}},{"line":39,"address":[7863960,7862966,7863259,7863664],"length":1,"stats":{"Line":52}},{"line":40,"address":[2700989],"length":1,"stats":{"Line":25}},{"line":41,"address":[7864015,7863320],"length":1,"stats":{"Line":27}},{"line":45,"address":[],"length":0,"stats":{"Line":25}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","mod.rs"],"content":"//! Execution trace tables for zkVM circuit operations.\n\nuse alloc::boxed::Box;\nuse alloc::string::String;\nuse alloc::vec::Vec;\nuse core::any::Any;\nuse core::fmt;\n\nuse hashbrown::HashMap;\n\nuse crate::CircuitError;\nuse crate::op::{NonPrimitiveOpType, OpStateMap};\nuse crate::types::WitnessId;\n\nmod alu;\nmod constant;\nmod public;\nmod runner;\nmod witness;\n\npub use alu::{AluTrace, AluTraceBuilder};\npub use constant::{ConstTrace, ConstTraceBuilder};\npub use public::{PublicTrace, PublicTraceBuilder};\npub use runner::CircuitRunner;\npub use witness::{WitnessTrace, WitnessTraceBuilder};\n\n/// Trait implemented by all non-primitive operation traces.\npub trait NonPrimitiveTrace\u003cF\u003e: Send + Sync {\n    /// Operation type for this non-primitive trace.\n    fn op_type(\u0026self) -\u003e NonPrimitiveOpType;\n    /// Number of rows produced by this trace.\n    fn rows(\u0026self) -\u003e usize;\n    /// Type-erased access for downcasting.\n    fn as_any(\u0026self) -\u003e \u0026dyn Any;\n    /// Clone the trace into a boxed trait object.\n    fn boxed_clone(\u0026self) -\u003e Box\u003cdyn NonPrimitiveTrace\u003cF\u003e\u003e;\n}\n\n/// Function pointer for constructing a non-primitive trace from runner state.\n///\n/// The trace generator receives operation execution state (recorded row data, chaining state, etc.).\npub type TraceGeneratorFn\u003cF\u003e =\n    fn(op_states: \u0026OpStateMap) -\u003e Result\u003cOption\u003cBox\u003cdyn NonPrimitiveTrace\u003cF\u003e\u003e\u003e, CircuitError\u003e;\n\n/// Execution traces for all tables.\n///\n/// This structure holds the complete execution trace of a circuit,\n/// containing all the data needed to generate proofs.\npub struct Traces\u003cF\u003e {\n    /// Central witness table (bus) storing all intermediate values.\n    pub witness_trace: WitnessTrace\u003cF\u003e,\n    /// Constant table for compile-time known values.\n    pub const_trace: ConstTrace\u003cF\u003e,\n    /// Public input table for externally provided values.\n    pub public_trace: PublicTrace\u003cF\u003e,\n    /// Unified ALU operation table (Add, Mul, BoolCheck, MulAdd).\n    pub alu_trace: AluTrace\u003cF\u003e,\n    /// Dynamically registered non-primitive traces indexed by operation type.\n    pub non_primitive_traces: HashMap\u003cNonPrimitiveOpType, Box\u003cdyn NonPrimitiveTrace\u003cF\u003e\u003e\u003e,\n    /// Tag to witness index mapping for probing values by name.\n    pub tag_to_witness: HashMap\u003cString, WitnessId\u003e,\n}\n\nimpl\u003cF\u003e Traces\u003cF\u003e {\n    /// Fetch a non-primitive trace by identifier and downcast to a concrete type.\n    pub fn non_primitive_trace\u003cT\u003e(\u0026self, op_type: NonPrimitiveOpType) -\u003e Option\u003c\u0026T\u003e\n    where\n        T: NonPrimitiveTrace\u003cF\u003e + 'static,\n    {\n        self.non_primitive_traces\n            .get(\u0026op_type)\n            .and_then(|trace| trace.as_any().downcast_ref::\u003cT\u003e())\n    }\n\n    /// Probes the value of a tagged wire.\n    ///\n    /// Returns `None` if the tag was not registered during circuit construction.\n    ///\n    /// # Example\n    /// ```ignore\n    /// let value = traces.probe(\"my-tag\").expect(\"tag should exist\");\n    /// ```\n    pub fn probe(\u0026self, tag: \u0026str) -\u003e Option\u003c\u0026F\u003e {\n        let witness_id = self.tag_to_witness.get(tag)?;\n        self.witness_trace.get_value(*witness_id)\n    }\n}\n\nimpl\u003cF: Clone\u003e Clone for Traces\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            witness_trace: self.witness_trace.clone(),\n            const_trace: self.const_trace.clone(),\n            public_trace: self.public_trace.clone(),\n            alu_trace: self.alu_trace.clone(),\n            non_primitive_traces: self\n                .non_primitive_traces\n                .iter()\n                .map(|(\u0026op_type, trace)| (op_type, trace.boxed_clone()))\n                .collect(),\n            tag_to_witness: self.tag_to_witness.clone(),\n        }\n    }\n}\n\nimpl\u003cF\u003e fmt::Debug for Traces\u003cF\u003e\nwhere\n    WitnessTrace\u003cF\u003e: fmt::Debug,\n    ConstTrace\u003cF\u003e: fmt::Debug,\n    PublicTrace\u003cF\u003e: fmt::Debug,\n    AluTrace\u003cF\u003e: fmt::Debug,\n{\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let extra_summary: Vec\u003c_\u003e = self\n            .non_primitive_traces\n            .iter()\n            .map(|(\u0026op_type, trace)| (op_type, trace.rows()))\n            .collect();\n        f.debug_struct(\"Traces\")\n            .field(\"witness_trace\", \u0026self.witness_trace)\n            .field(\"const_trace\", \u0026self.const_trace)\n            .field(\"public_trace\", \u0026self.public_trace)\n            .field(\"alu_trace\", \u0026self.alu_trace)\n            .field(\"non_primitive_traces\", \u0026extra_summary)\n            .finish()\n    }\n}\n\nimpl\u003cF: alloc::fmt::Debug\u003e Traces\u003cF\u003e {\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn dump_primitive_traces_log(\u0026self) {\n        #[cfg(feature = \"debugging\")]\n        {\n            tracing::debug!(\"\\n=== WITNESS TRACE ===\");\n            for (i, (idx, val)) in self\n                .witness_trace\n                .index\n                .iter()\n                .zip(self.witness_trace.values().iter())\n                .enumerate()\n            {\n                tracing::debug!(\"Row {i}: WitnessId({idx}) = {val:?}\");\n            }\n\n            tracing::debug!(\"\\n=== CONST TRACE ===\");\n            for (i, (idx, val)) in self\n                .const_trace\n                .index\n                .iter()\n                .zip(self.const_trace.values.iter())\n                .enumerate()\n            {\n                tracing::debug!(\"Row {i}: WitnessId({idx}) = {val:?}\");\n            }\n\n            tracing::debug!(\"\\n=== PUBLIC TRACE ===\");\n            for (i, (idx, val)) in self\n                .public_trace\n                .index\n                .iter()\n                .zip(self.public_trace.values.iter())\n                .enumerate()\n            {\n                tracing::debug!(\"Row {i}: WitnessId({idx}) = {val:?}\");\n            }\n\n            tracing::debug!(\"\\n=== ALU TRACE ===\");\n            for i in 0..self.alu_trace.a_values.len() {\n                tracing::debug!(\n                    \"Row {}: {:?} WitnessId({}) op WitnessId({}) [c={}] -\u003e WitnessId({}) | {:?} op {:?} [{:?}] -\u003e {:?}\",\n                    i,\n                    self.alu_trace.op_kind[i],\n                    self.alu_trace.a_index[i],\n                    self.alu_trace.b_index[i],\n                    self.alu_trace.c_index[i],\n                    self.alu_trace.out_index[i],\n                    self.alu_trace.a_values[i],\n                    self.alu_trace.b_values[i],\n                    self.alu_trace.c_values[i],\n                    self.alu_trace.out_values[i]\n                );\n            }\n        }\n    }\n}\n","traces":[{"line":66,"address":[4621168,4621120],"length":1,"stats":{"Line":2}},{"line":70,"address":[4621136,4621184],"length":1,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":83,"address":[7264304],"length":1,"stats":{"Line":1}},{"line":84,"address":[7264328],"length":1,"stats":{"Line":1}},{"line":85,"address":[7264408],"length":1,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[7264288],"length":1,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":63},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","public.rs"],"content":"use alloc::vec::Vec;\n\nuse crate::CircuitError;\nuse crate::op::Op;\nuse crate::types::WitnessId;\n\n/// Public input table.\n///\n/// Unlike compile-time `Const` values, these inputs are provided at runtime\n/// and are known to both the prover and the verifier.\n#[derive(Debug, Clone)]\npub struct PublicTrace\u003cF\u003e {\n    /// Witness IDs of each public input.\n    ///\n    /// Identifies which witness slots contain public values.\n    pub index: Vec\u003cWitnessId\u003e,\n\n    /// Public input field element values.\n    ///\n    /// Provided at the start of the execution.\n    /// Serve as the starting point for computation.\n    pub values: Vec\u003cF\u003e,\n}\n\n/// Builder for generating public input traces.\npub struct PublicTraceBuilder\u003c'a, F\u003e {\n    primitive_ops: \u0026'a [Op\u003cF\u003e],\n    witness: \u0026'a [Option\u003cF\u003e],\n}\n\nimpl\u003c'a, F: Clone\u003e PublicTraceBuilder\u003c'a, F\u003e {\n    /// Creates a new public trace builder.\n    pub const fn new(primitive_ops: \u0026'a [Op\u003cF\u003e], witness: \u0026'a [Option\u003cF\u003e]) -\u003e Self {\n        Self {\n            primitive_ops,\n            witness,\n        }\n    }\n\n    /// Builds the public input trace from circuit operations.\n    pub fn build(self) -\u003e Result\u003cPublicTrace\u003cF\u003e, CircuitError\u003e {\n        let mut index = Vec::with_capacity(1 \u003c\u003c 15);\n        let mut values = Vec::with_capacity(1 \u003c\u003c 15);\n\n        for prim in self.primitive_ops {\n            if let Op::Public { out, public_pos: _ } = prim {\n                index.push(*out);\n                let value = self\n                    .witness\n                    .get(out.0 as usize)\n                    .and_then(|opt| opt.as_ref())\n                    .cloned()\n                    .ok_or(CircuitError::WitnessNotSet { witness_id: *out })?;\n                values.push(value);\n            }\n        }\n\n        Ok(PublicTrace { index, values })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_single_public_input() {\n        // Create a single public input operation that reads from witness\n        let out = WitnessId(0);\n        let val = F::from_u64(42);\n\n        let ops = vec![Op::Public { out, public_pos: 0 }];\n\n        // Prepare the witness table with the public input value\n        let witness = vec![Some(val)];\n\n        // Build the trace using the builder pattern\n        let builder = PublicTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace contains exactly one public input\n        assert_eq!(trace.index.len(), 1, \"Should have one public input\");\n        assert_eq!(trace.values.len(), 1, \"Should have one public value\");\n\n        // Verify the public input is correctly recorded\n        assert_eq!(trace.index[0], out);\n        assert_eq!(trace.values[0], val);\n    }\n\n    #[test]\n    fn test_multiple_public_inputs() {\n        // Create multiple public input operations with non-contiguous witness indices\n        let out1 = WitnessId(0);\n        let out2 = WitnessId(2);\n\n        let val1 = F::from_u64(10);\n        let val2 = F::from_u64(30);\n\n        let ops = vec![\n            Op::Public {\n                out: out1,\n                public_pos: 0,\n            },\n            Op::Public {\n                out: out2,\n                public_pos: 1,\n            },\n        ];\n\n        // Prepare witness table with gaps (index 1 is unused)\n        let witness = vec![Some(val1), None, Some(val2)];\n\n        // Build the trace\n        let builder = PublicTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify we have exactly two public inputs\n        assert_eq!(trace.index.len(), 2, \"Should have two public inputs\");\n        assert_eq!(trace.values.len(), 2, \"Should have two public values\");\n\n        // Verify first public input\n        assert_eq!(trace.index[0], out1);\n        assert_eq!(trace.values[0], val1);\n\n        // Verify second public input\n        assert_eq!(trace.index[1], out2);\n        assert_eq!(trace.values[1], val2);\n    }\n\n    #[test]\n    fn test_empty_operations() {\n        // Provide an empty operations list\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![];\n        let witness: Vec\u003cOption\u003cF\u003e\u003e = vec![];\n\n        // Build the trace\n        let builder = PublicTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace is empty\n        assert_eq!(trace.index.len(), 0, \"Should have no public inputs\");\n        assert_eq!(trace.values.len(), 0, \"Should have no values\");\n    }\n\n    #[test]\n    fn test_witness_not_set_error() {\n        // Create a public input operation referencing an unset witness slot\n        let out = WitnessId(0);\n        let ops = vec![Op::Public { out, public_pos: 0 }];\n\n        // Witness table has the slot but value is None (not yet set)\n        let witness: Vec\u003cOption\u003cF\u003e\u003e = vec![None];\n\n        // Attempt to build the trace\n        let builder = PublicTraceBuilder::new(\u0026ops, \u0026witness);\n        let result = builder.build();\n\n        // Verify the build fails with the expected error\n        assert!(result.is_err(), \"Should fail when witness is not set\");\n        assert!(matches!(\n            result,\n            Err(CircuitError::WitnessNotSet { witness_id }) if witness_id == out\n        ));\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":27}},{"line":41,"address":[5193374,5194574,5192240,5193408],"length":1,"stats":{"Line":25}},{"line":42,"address":[3986406],"length":1,"stats":{"Line":26}},{"line":43,"address":[2430087],"length":1,"stats":{"Line":26}},{"line":45,"address":[],"length":0,"stats":{"Line":51}},{"line":46,"address":[],"length":0,"stats":{"Line":72}},{"line":47,"address":[5193997,5192833],"length":1,"stats":{"Line":23}},{"line":48,"address":[6027010,6027143,6026870],"length":1,"stats":{"Line":47}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[6026878],"length":1,"stats":{"Line":23}},{"line":51,"address":[6874339,6874905,6873175,6874896,6874937,6874928],"length":1,"stats":{"Line":69}},{"line":53,"address":[7416999,7418249,7416872,7419415,7418130,7415714,7419288,7420488,7415833,7420615],"length":1,"stats":{"Line":24}},{"line":54,"address":[6714476,6715656],"length":1,"stats":{"Line":23}},{"line":58,"address":[3880990],"length":1,"stats":{"Line":26}}],"covered":13,"coverable":14},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","runner.rs"],"content":"use alloc::boxed::Box;\nuse alloc::collections::BTreeMap;\nuse alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\n\nuse hashbrown::HashMap;\nuse tracing::instrument;\n\nuse super::alu::AluTraceBuilder;\nuse super::constant::ConstTraceBuilder;\nuse super::public::PublicTraceBuilder;\nuse super::witness::WitnessTraceBuilder;\nuse super::{NonPrimitiveTrace, Traces};\nuse crate::circuit::Circuit;\nuse crate::op::{ExecutionContext, NonPrimitiveOpPrivateData, NonPrimitiveOpType, Op, OpStateMap};\nuse crate::types::{NonPrimitiveOpId, WitnessId};\nuse crate::{AluOpKind, CircuitError, CircuitField};\n\n/// Circuit execution engine.\npub struct CircuitRunner\u003cF\u003e {\n    /// Circuit specification.\n    circuit: Circuit\u003cF\u003e,\n    /// Witness values (None = unset, Some = computed).\n    witness: Vec\u003cOption\u003cF\u003e\u003e,\n    /// Private data for non-primitive operations (not on witness bus)\n    non_primitive_op_private_data: Vec\u003cOption\u003cNonPrimitiveOpPrivateData\u003cF\u003e\u003e\u003e,\n    /// Map from NonPrimitiveOpId -\u003e index in `circuit.ops` for type checks.\n    non_primitive_op_index_by_id: Vec\u003cOption\u003cusize\u003e\u003e,\n    /// Operation-specific execution state (e.g., Poseidon chaining, row records).\n    op_states: OpStateMap,\n}\n\nimpl\u003cF: CircuitField\u003e CircuitRunner\u003cF\u003e {\n    /// Creates circuit runner with empty witness storage.\n    pub fn new(circuit: Circuit\u003cF\u003e) -\u003e Self {\n        let witness = vec![None; circuit.witness_count as usize];\n        let mut max_op_id: Option\u003cu32\u003e = None;\n        for op in \u0026circuit.ops {\n            if let Op::NonPrimitiveOpWithExecutor { op_id, .. } = op {\n                max_op_id = Some(max_op_id.map_or(op_id.0, |cur| cur.max(op_id.0)));\n            }\n        }\n        let non_primitive_op_count = max_op_id.map_or(0, |m| m as usize + 1);\n\n        let mut non_primitive_op_index_by_id = vec![None; non_primitive_op_count];\n        for (idx, op) in circuit.ops.iter().enumerate() {\n            if let Op::NonPrimitiveOpWithExecutor { op_id, .. } = op\n                \u0026\u0026 let Some(slot) = non_primitive_op_index_by_id.get_mut(op_id.0 as usize)\n            {\n                #[cfg(debug_assertions)]\n                debug_assert!(\n                    slot.is_none(),\n                    \"duplicate NonPrimitiveOpId({}) in circuit.ops\",\n                    op_id.0\n                );\n                // Keep the first occurrence if duplicates exist (release builds).\n                if slot.is_none() {\n                    *slot = Some(idx);\n                }\n            }\n        }\n\n        let non_primitive_op_private_data = vec![None; non_primitive_op_count];\n        let op_states = BTreeMap::new();\n        Self {\n            circuit,\n            witness,\n            non_primitive_op_private_data,\n            non_primitive_op_index_by_id,\n            op_states,\n        }\n    }\n\n    /// Sets public input values into witness table.\n    pub fn set_public_inputs(\u0026mut self, public_values: \u0026[F]) -\u003e Result\u003c(), CircuitError\u003e {\n        if public_values.len() != self.circuit.public_flat_len {\n            return Err(CircuitError::PublicInputLengthMismatch {\n                expected: self.circuit.public_flat_len,\n                got: public_values.len(),\n            });\n        }\n        if self.circuit.public_rows.len() != self.circuit.public_flat_len {\n            return Err(CircuitError::MissingPublicRowsMapping);\n        }\n\n        for (i, value) in public_values.iter().enumerate() {\n            let widx = self.circuit.public_rows[i];\n            self.set_witness(widx, *value)?;\n        }\n\n        Ok(())\n    }\n\n    /// Sets private data for a non-primitive operation.\n    pub fn set_private_data(\n        \u0026mut self,\n        op_id: NonPrimitiveOpId,\n        private_data: NonPrimitiveOpPrivateData\u003cF\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        // Validate that the op_id exists in the circuit.\n        if op_id.0 as usize \u003e= self.non_primitive_op_private_data.len()\n            || self\n                .non_primitive_op_index_by_id\n                .get(op_id.0 as usize)\n                .and_then(|x| *x)\n                .is_none()\n        {\n            return Err(CircuitError::NonPrimitiveOpIdOutOfRange {\n                op_id: op_id.0,\n                max_ops: self.non_primitive_op_private_data.len(),\n            });\n        }\n\n        // Validate that the private data matches the operation type\n        let op_idx = self\n            .non_primitive_op_index_by_id\n            .get(op_id.0 as usize)\n            .and_then(|x| *x)\n            .ok_or(CircuitError::NonPrimitiveOpIdOutOfRange {\n                op_id: op_id.0,\n                max_ops: self.non_primitive_op_private_data.len(),\n            })?;\n        let Op::NonPrimitiveOpWithExecutor { executor, .. } = \u0026self.circuit.ops[op_idx] else {\n            return Err(CircuitError::NonPrimitiveOpIdOutOfRange {\n                op_id: op_id.0,\n                max_ops: self.non_primitive_op_private_data.len(),\n            });\n        };\n        match (executor.op_type(), \u0026private_data) {\n            (\n                crate::op::NonPrimitiveOpType::Poseidon2Perm(_),\n                NonPrimitiveOpPrivateData::Poseidon2Perm(_),\n            ) =\u003e {\n                // ok\n            }\n            // Unconstrained operations don't need private data.\n            (crate::op::NonPrimitiveOpType::Unconstrained, _) =\u003e return Ok(()),\n        }\n\n        // Disallow double-setting private data\n        if self.non_primitive_op_private_data[op_id.0 as usize].is_some() {\n            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                op: *executor.op_type(),\n                operation_index: op_id,\n                expected: \"private data not previously set\".to_string(),\n                got: \"already set\".to_string(),\n            });\n        }\n\n        // Store private data for this operation\n        self.non_primitive_op_private_data[op_id.0 as usize] = Some(private_data);\n        Ok(())\n    }\n\n    /// Sets private data for a non-primitive operation by its tag.\n    ///\n    /// The tag must have been registered during circuit construction via `builder.tag_op()`.\n    ///\n    /// # Errors\n    /// Returns `CircuitError::UnknownTag` if the tag was not registered.\n    pub fn set_private_data_by_tag(\n        \u0026mut self,\n        tag: \u0026str,\n        private_data: NonPrimitiveOpPrivateData\u003cF\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        let op_id = self.circuit.tag_to_op_id.get(tag).copied().ok_or_else(|| {\n            CircuitError::UnknownTag {\n                tag: tag.to_string(),\n            }\n        })?;\n        self.set_private_data(op_id, private_data)\n    }\n\n    /// Run the circuit and generate traces\n    #[instrument(skip_all)]\n    pub fn run(mut self) -\u003e Result\u003cTraces\u003cF\u003e, CircuitError\u003e {\n        self.execute_all()?;\n\n        if let Some(rewrite) = self.circuit.witness_rewrite.take() {\n            let mut resolved: HashMap\u003cWitnessId, WitnessId\u003e = HashMap::new();\n            let mut root = |canon: WitnessId| {\n                *resolved.entry(canon).or_insert_with(|| {\n                    let mut cur = canon;\n                    while let Some(\u0026next) = rewrite.get(\u0026cur) {\n                        cur = next;\n                    }\n                    cur\n                })\n            };\n            for (dup, canon) in \u0026rewrite {\n                let r = root(*canon);\n                if let Some(ref val) = self.witness[r.0 as usize] {\n                    self.set_witness(*dup, *val)?;\n                }\n            }\n        }\n\n        // Delegate to trace builders for each table\n        let witness_trace = WitnessTraceBuilder::new(\u0026self.witness).build()?;\n        let const_trace = ConstTraceBuilder::new(\u0026self.circuit.ops).build()?;\n        let public_trace = PublicTraceBuilder::new(\u0026self.circuit.ops, \u0026self.witness).build()?;\n        let alu_trace = AluTraceBuilder::new(\u0026self.circuit.ops, \u0026self.witness).build()?;\n\n        let mut non_primitive_traces: HashMap\u003cNonPrimitiveOpType, Box\u003cdyn NonPrimitiveTrace\u003cF\u003e\u003e\u003e =\n            HashMap::new();\n        // Iterate over generators in deterministic order (sorted by key)\n        let _scope = tracing::debug_span!(\"generators\").entered();\n\n        for op_type in \u0026self.circuit.non_primitive_trace_generator_order {\n            let generator = \u0026self.circuit.non_primitive_trace_generators[op_type];\n            if let Some(trace) = generator(\u0026self.op_states)? {\n                let trace_op_type = trace.op_type();\n                non_primitive_traces.insert(trace_op_type, trace);\n            }\n        }\n        _scope.exit();\n\n        Ok(Traces {\n            witness_trace,\n            const_trace,\n            public_trace,\n            alu_trace,\n            tag_to_witness: self.circuit.tag_to_witness,\n            non_primitive_traces,\n        })\n    }\n\n    /// Executes the full circuit operation list to populate witness table.\n    ///\n    /// The circuit is already lowered into a valid execution order, so this function\n    /// can blindly execute from index 0 to end.\n    #[instrument(skip_all, level = \"debug\")]\n    pub fn execute_all(\u0026mut self) -\u003e Result\u003c(), CircuitError\u003e {\n        for i in 0..self.circuit.ops.len() {\n            let op = \u0026self.circuit.ops[i];\n            match op {\n                Op::Const { out, val } =\u003e {\n                    self.set_witness(*out, *val)?;\n                }\n                Op::Public { out, public_pos: _ } =\u003e {\n                    // Public inputs should already be set\n                    if self.witness[out.0 as usize].is_none() {\n                        return Err(CircuitError::PublicInputNotSet { witness_id: *out });\n                    }\n                }\n                Op::Alu {\n                    kind,\n                    a,\n                    b,\n                    c,\n                    out,\n                    intermediate_out,\n                } =\u003e match kind {\n                    AluOpKind::Add =\u003e {\n                        let a_val = self.get_witness(*a)?;\n                        if let Ok(b_val) = self.get_witness(*b) {\n                            let result = a_val + b_val;\n                            self.set_witness(*out, result)?;\n                        } else {\n                            let out_val = self.get_witness(*out)?;\n                            let b_val = out_val - a_val;\n                            self.set_witness(*b, b_val)?;\n                        }\n                    }\n                    AluOpKind::Mul =\u003e {\n                        // Mul is used to represent either `Mul` or `Div` operations.\n                        // We determine which based on which inputs are set.\n                        let a_val = self.get_witness(*a)?;\n                        if let Ok(b_val) = self.get_witness(*b) {\n                            self.set_witness(*out, a_val * b_val)?;\n                        } else {\n                            let result_val = self.get_witness(*out)?;\n                            let a_inv = a_val.try_inverse().ok_or(CircuitError::DivisionByZero)?;\n                            self.set_witness(*b, result_val * a_inv)?;\n                        }\n                    }\n                    AluOpKind::BoolCheck =\u003e {\n                        // BoolCheck constraint is checked in the AIR; here we just ensure out = a\n                        let a_val = self.get_witness(*a)?;\n                        self.set_witness(*out, a_val)?;\n                    }\n                    AluOpKind::MulAdd =\u003e {\n                        // out = a * b + c\n                        let a_val = self.get_witness(*a)?;\n                        let b_val = self.get_witness(*b)?;\n                        let ab_product = a_val * b_val;\n                        let intermediate_out_id = *intermediate_out;\n                        let c_id_opt = *c;\n                        let out_id = *out;\n\n                        // Set intermediate_out if fused from separate operations\n                        if let Some(io) = intermediate_out_id {\n                            self.set_witness(io, ab_product)?;\n                        }\n\n                        let c_val = if let Some(c_id) = c_id_opt {\n                            self.get_witness(c_id)?\n                        } else {\n                            F::ZERO\n                        };\n                        self.set_witness(out_id, ab_product + c_val)?;\n                    }\n                },\n                Op::NonPrimitiveOpWithExecutor {\n                    inputs,\n                    outputs,\n                    executor,\n                    op_id,\n                } =\u003e {\n                    let mut ctx = ExecutionContext::new(\n                        \u0026mut self.witness,\n                        \u0026self.non_primitive_op_private_data,\n                        \u0026self.circuit.enabled_ops,\n                        *op_id,\n                        \u0026mut self.op_states,\n                    );\n\n                    executor.execute(inputs, outputs, \u0026mut ctx)?;\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Gets witness value by ID.\n    #[inline(always)]\n    fn get_witness(\u0026self, widx: WitnessId) -\u003e Result\u003cF, CircuitError\u003e {\n        self.witness\n            .get(widx.0 as usize)\n            .and_then(|opt| opt.as_ref())\n            .cloned()\n            .ok_or(CircuitError::WitnessNotSet { witness_id: widx })\n    }\n\n    /// Sets witness value by ID.\n    #[inline]\n    fn set_witness(\u0026mut self, widx: WitnessId, value: F) -\u003e Result\u003c(), CircuitError\u003e {\n        if widx.0 as usize \u003e= self.witness.len() {\n            return Err(CircuitError::WitnessIdOutOfBounds { witness_id: widx });\n        }\n\n        let slot = \u0026mut self.witness[widx.0 as usize];\n\n        // Check for conflicting reassignment\n        if let Some(existing_value) = slot.as_ref() {\n            if *existing_value == value {\n                return Ok(());\n            }\n            #[cfg(feature = \"debugging\")]\n            let expr_ids = self\n                .circuit\n                .expr_to_widx\n                .iter()\n                .filter_map(|(expr_id, \u0026witness_id)| {\n                    if witness_id == widx {\n                        Some(*expr_id)\n                    } else {\n                        None\n                    }\n                })\n                .collect::\u003cVec\u003c_\u003e\u003e();\n            #[cfg(not(feature = \"debugging\"))]\n            let expr_ids = vec![];\n\n            return Err(CircuitError::WitnessConflict {\n                witness_id: widx,\n                existing: format!(\"{existing_value:?}\"),\n                new: format!(\"{value:?}\"),\n                expr_ids,\n            });\n        }\n\n        *slot = Some(value);\n        Ok(())\n    }\n\n    /// Reference to the witness slice (for benchmarking trace builders after `execute_all`).\n    pub fn witness(\u0026self) -\u003e \u0026[Option\u003cF\u003e] {\n        \u0026self.witness\n    }\n\n    /// Reference to the circuit ops (for benchmarking trace builders after `execute_all`).\n    pub fn ops(\u0026self) -\u003e \u0026[Op\u003cF\u003e] {\n        \u0026self.circuit.ops\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing};\n    use tracing_forest::ForestLayer;\n    use tracing_forest::util::LevelFilter;\n    use tracing_subscriber::layer::SubscriberExt;\n    use tracing_subscriber::util::SubscriberInitExt;\n    use tracing_subscriber::{EnvFilter, Registry};\n\n    use super::*;\n    use crate::NonPrimitiveOpType;\n    use crate::builder::CircuitBuilder;\n    use crate::op::NonPrimitiveExecutor;\n    use crate::types::WitnessId;\n\n    /// Initializes a global logger with default parameters.\n    fn init_logger() {\n        let env_filter = EnvFilter::builder()\n            .with_default_directive(LevelFilter::INFO.into())\n            .from_env_lossy();\n\n        Registry::default()\n            .with(env_filter)\n            .with(ForestLayer::default())\n            .init();\n    }\n\n    #[test]\n    fn test_table_generation_basic() {\n        let mut builder = CircuitBuilder::new();\n\n        // Simple test: x + 5 = result\n        let x = builder.public_input();\n        let c5 = builder.define_const(BabyBear::from_u64(5));\n        let _result = builder.add(x, c5);\n\n        let circuit = builder.build().unwrap();\n        let mut runner = circuit.runner();\n\n        // Set public input: x = 3\n        runner.set_public_inputs(\u0026[BabyBear::from_u64(3)]).unwrap();\n\n        let traces = runner.run().unwrap();\n\n        // Check witness trace\n        assert_eq!(\n            traces.witness_trace.index.len(),\n            traces.witness_trace.num_rows()\n        );\n\n        // Check that we have const trace entries\n        assert!(!traces.const_trace.values.is_empty());\n\n        // Check that we have public trace entries\n        assert!(!traces.public_trace.values.is_empty());\n\n        // Check that we have ALU trace entries\n        assert!(!traces.alu_trace.a_values.is_empty());\n    }\n\n    #[derive(Debug, Clone)]\n    /// The hint defined by x in an equation a*x - b = 0\n    struct XHint {}\n\n    impl XHint {\n        pub fn new() -\u003e Self {\n            Self {}\n        }\n    }\n\n    impl\u003cF: Field\u003e NonPrimitiveExecutor\u003cF\u003e for XHint {\n        fn execute(\n            \u0026self,\n            inputs: \u0026[Vec\u003cWitnessId\u003e],\n            outputs: \u0026[Vec\u003cWitnessId\u003e],\n            ctx: \u0026mut ExecutionContext\u003c'_, F\u003e,\n        ) -\u003e Result\u003c(), CircuitError\u003e {\n            let a = ctx.get_witness(inputs[0][0])?;\n            let b = ctx.get_witness(inputs[0][1])?;\n            let inv_a = a.try_inverse().ok_or(CircuitError::DivisionByZero)?;\n            let x = b * inv_a;\n            ctx.set_witness(outputs[0][0], x)?;\n            Ok(())\n        }\n\n        fn op_type(\u0026self) -\u003e \u0026NonPrimitiveOpType {\n            \u0026NonPrimitiveOpType::Unconstrained\n        }\n\n        fn as_any(\u0026self) -\u003e \u0026dyn core::any::Any {\n            self\n        }\n\n        fn boxed(\u0026self) -\u003e Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e {\n            Box::new(self.clone())\n        }\n    }\n\n    #[test]\n    // Proves that we know x such that 37 * x - 111 = 0\n    fn test_toy_example_37_times_x_minus_111() {\n        init_logger();\n\n        let mut builder = CircuitBuilder::new();\n\n        let c37 = builder.define_const(BabyBear::from_u64(37));\n        let c111 = builder.define_const(BabyBear::from_u64(111));\n        let x_hint = XHint::new();\n        let x = builder\n            .push_unconstrained_op(vec![vec![c37, c111]], 1, x_hint, \"x\")\n            .2[0]\n            .unwrap();\n\n        let mul_result = builder.mul(c37, x);\n        let sub_result = builder.sub(mul_result, c111);\n        builder.assert_zero(sub_result);\n\n        let circuit = builder.build().unwrap();\n\n        let witness_count = circuit.witness_count;\n        let runner = circuit.runner();\n\n        let traces = runner.run().unwrap();\n\n        traces.dump_primitive_traces_log();\n\n        // Verify trace structure\n        assert_eq!(traces.witness_trace.index.len(), witness_count as usize);\n\n        // Should have constants: 0, 37, 111 and -111 (introduced by algebraic rewrite)\n        assert_eq!(traces.const_trace.values.len(), 4);\n\n        // Should have no public input\n        assert!(traces.public_trace.values.is_empty());\n\n        // Should store the value of the hint (3) at `WitnessId(3)``\n        assert_eq!(traces.witness_trace.index[3], WitnessId(3));\n        assert_eq!(\n            traces.witness_trace.get_value(WitnessId(3)).unwrap(),\n            \u0026BabyBear::from_usize(3)\n        );\n\n        // Should have one mul operation: 37 * x\n        // And one add operation for sub: result + rhs = lhs\n        // Total 2 ALU operations\n        assert_eq!(traces.alu_trace.a_values.len(), 2);\n    }\n\n    #[test]\n    fn test_extension_field_support() {\n        type ExtField = BinomialExtensionField\u003cBabyBear, 4\u003e;\n\n        let mut builder = CircuitBuilder::new();\n\n        // Test extension field operations: x + y * z\n        let x = builder.public_input();\n        let y = builder.public_input();\n        let z = builder.public_input();\n\n        let yz = builder.mul(y, z);\n        let _result = builder.add(x, yz);\n\n        let circuit = builder.build().unwrap();\n        let mut runner = circuit.runner();\n\n        // Set public inputs to genuine extension field values with ALL non-zero coefficients\n        let x_val = ExtField::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(1), // a0\n            BabyBear::from_u64(2), // a1\n            BabyBear::from_u64(3), // a2\n            BabyBear::from_u64(4), // a3\n        ])\n        .unwrap();\n        let y_val = ExtField::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(5), // b0\n            BabyBear::from_u64(6), // b1\n            BabyBear::from_u64(7), // b2\n            BabyBear::from_u64(8), // b3\n        ])\n        .unwrap();\n        let z_val = ExtField::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(9),  // c0\n            BabyBear::from_u64(10), // c1\n            BabyBear::from_u64(11), // c2\n            BabyBear::from_u64(12), // c3\n        ])\n        .unwrap();\n\n        runner.set_public_inputs(\u0026[x_val, y_val, z_val]).unwrap();\n        let traces = runner.run().unwrap();\n\n        // Verify extension field traces were generated correctly\n        assert_eq!(traces.public_trace.values.len(), 3);\n        assert_eq!(traces.public_trace.values[0], x_val);\n        assert_eq!(traces.public_trace.values[1], y_val);\n        assert_eq!(traces.public_trace.values[2], z_val);\n\n        // Should have one MulAdd operation (fused from y * z + x)\n        assert_eq!(traces.alu_trace.a_values.len(), 1);\n\n        // Verify MulAdd operation: y * z + x\n        let expected_yz = y_val * z_val;\n        let expected_result = expected_yz + x_val;\n        assert_eq!(traces.alu_trace.a_values[0], y_val);\n        assert_eq!(traces.alu_trace.b_values[0], z_val);\n        assert_eq!(traces.alu_trace.c_values[0], x_val);\n        assert_eq!(traces.alu_trace.out_values[0], expected_result);\n    }\n\n    #[test]\n    fn test_set_private_data_by_unknown_tag_error() {\n        use crate::ops::poseidon2_perm::Poseidon2PermPrivateData;\n\n        let builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let circuit = builder.build().unwrap();\n        let mut runner = circuit.runner();\n\n        let private_data = Poseidon2PermPrivateData {\n            sibling: [BabyBear::ZERO, BabyBear::ZERO],\n        };\n\n        let result = runner.set_private_data_by_tag(\n            \"nonexistent-tag\",\n            crate::op::NonPrimitiveOpPrivateData::Poseidon2Perm(private_data),\n        );\n\n        assert!(matches!(\n            result,\n            Err(CircuitError::UnknownTag { tag }) if tag == \"nonexistent-tag\"\n        ));\n    }\n}\n","traces":[{"line":36,"address":[6903664,6904989,6905414,6906742,6907167,6905440],"length":1,"stats":{"Line":26}},{"line":37,"address":[1476863],"length":1,"stats":{"Line":28}},{"line":38,"address":[5631945,5630184],"length":1,"stats":{"Line":26}},{"line":39,"address":[6421216,6421140],"length":1,"stats":{"Line":54}},{"line":40,"address":[3280497,3280432,3279070],"length":1,"stats":{"Line":59}},{"line":41,"address":[5336016,5336040,5335944],"length":1,"stats":{"Line":43}},{"line":44,"address":[7593510,7596776,7596712,7596768,7595269,7596704],"length":1,"stats":{"Line":55}},{"line":46,"address":[5334690],"length":1,"stats":{"Line":27}},{"line":47,"address":[1793202,1793281],"length":1,"stats":{"Line":53}},{"line":48,"address":[3815041,3814477,3813288,3812724],"length":1,"stats":{"Line":42}},{"line":49,"address":[6422369],"length":1,"stats":{"Line":16}},{"line":51,"address":[4933862],"length":1,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[1794419,1794292,1794389],"length":1,"stats":{"Line":43}},{"line":59,"address":[10974833,10976600,10969560,10971313,10973082],"length":1,"stats":{"Line":15}},{"line":64,"address":[10968740,10972261,10970493,10974013,10975780],"length":1,"stats":{"Line":28}},{"line":65,"address":[3812830,3814583],"length":1,"stats":{"Line":24}},{"line":76,"address":[10967216,10965168,10965872,10964512,10966560],"length":1,"stats":{"Line":23}},{"line":77,"address":[3811352,3810664],"length":1,"stats":{"Line":24}},{"line":78,"address":[7591913,7592569],"length":1,"stats":{"Line":0}},{"line":79,"address":[3754082],"length":1,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[4931766],"length":1,"stats":{"Line":24}},{"line":84,"address":[3754241],"length":1,"stats":{"Line":0}},{"line":87,"address":[5333792,5333930],"length":1,"stats":{"Line":48}},{"line":88,"address":[10967636,10966981,10966292,10965588,10964933],"length":1,"stats":{"Line":24}},{"line":89,"address":[5334075,5334184],"length":1,"stats":{"Line":23}},{"line":92,"address":[2330282],"length":1,"stats":{"Line":25}},{"line":96,"address":[5628683,5627376],"length":1,"stats":{"Line":6}},{"line":102,"address":[2328406],"length":1,"stats":{"Line":6}},{"line":103,"address":[6419095,6419035],"length":1,"stats":{"Line":12}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":106,"address":[6900695,6901840,6901845],"length":1,"stats":{"Line":18}},{"line":107,"address":[6900710],"length":1,"stats":{"Line":6}},{"line":109,"address":[4930503],"length":1,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[7590578],"length":1,"stats":{"Line":0}},{"line":116,"address":[5627829,5627611,5627745],"length":1,"stats":{"Line":12}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[2328609],"length":1,"stats":{"Line":6}},{"line":119,"address":[6901856,6900848,6901861],"length":1,"stats":{"Line":18}},{"line":120,"address":[4930635],"length":1,"stats":{"Line":6}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[2328641],"length":1,"stats":{"Line":6}},{"line":124,"address":[2328882],"length":1,"stats":{"Line":6}},{"line":125,"address":[5628059],"length":1,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[7591078],"length":1,"stats":{"Line":0}},{"line":130,"address":[7591035],"length":1,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[7591160],"length":1,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[6901658],"length":1,"stats":{"Line":0}},{"line":144,"address":[6419959],"length":1,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[4931393],"length":1,"stats":{"Line":0}},{"line":152,"address":[2329176],"length":1,"stats":{"Line":6}},{"line":153,"address":[2329347],"length":1,"stats":{"Line":6}},{"line":162,"address":[6903216],"length":1,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[6903591],"length":1,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[6924205,6907408,6919513,6915212,6916384,6910520],"length":1,"stats":{"Line":26}},{"line":178,"address":[6909334,6918310,6924967,6907684,6916660,6915974],"length":1,"stats":{"Line":56}},{"line":180,"address":[],"length":0,"stats":{"Line":26}},{"line":181,"address":[6424146],"length":1,"stats":{"Line":13}},{"line":182,"address":[6424242,6430336],"length":1,"stats":{"Line":28}},{"line":183,"address":[1802097,1802144],"length":1,"stats":{"Line":27}},{"line":184,"address":[1486179],"length":1,"stats":{"Line":13}},{"line":185,"address":[6925592,6925704,6925646,6925534],"length":1,"stats":{"Line":14}},{"line":186,"address":[7612053,7611941],"length":1,"stats":{"Line":0}},{"line":188,"address":[1802235],"length":1,"stats":{"Line":13}},{"line":191,"address":[1480066,1480110],"length":1,"stats":{"Line":27}},{"line":192,"address":[1480270,1480342],"length":1,"stats":{"Line":27}},{"line":193,"address":[],"length":0,"stats":{"Line":13}},{"line":194,"address":[3824891,3817451],"length":1,"stats":{"Line":14}},{"line":200,"address":[7611325,7606420,7605585,7603902,7598997,7598145],"length":1,"stats":{"Line":54}},{"line":201,"address":[3283288,3287734,3283209],"length":1,"stats":{"Line":55}},{"line":202,"address":[5339244,5343485,5339347],"length":1,"stats":{"Line":52}},{"line":203,"address":[6426486,6429879,6426589],"length":1,"stats":{"Line":52}},{"line":205,"address":[3760690],"length":1,"stats":{"Line":25}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":79}},{"line":210,"address":[3820455,3827878,3820383,3827806],"length":1,"stats":{"Line":54}},{"line":211,"address":[],"length":0,"stats":{"Line":26}},{"line":212,"address":[7603179,7611169,7610602,7603746],"length":1,"stats":{"Line":26}},{"line":213,"address":[1801325,1801398],"length":1,"stats":{"Line":28}},{"line":214,"address":[5343252],"length":1,"stats":{"Line":13}},{"line":217,"address":[5646139,5638716],"length":1,"stats":{"Line":27}},{"line":219,"address":[7602041,7609464],"length":1,"stats":{"Line":30}},{"line":220,"address":[3820686,3828109],"length":1,"stats":{"Line":27}},{"line":221,"address":[4939288],"length":1,"stats":{"Line":27}},{"line":222,"address":[1483713],"length":1,"stats":{"Line":25}},{"line":223,"address":[10982810,11006413,11014285,10998557,10990686],"length":1,"stats":{"Line":27}},{"line":224,"address":[4939374],"length":1,"stats":{"Line":27}},{"line":225,"address":[1483806],"length":1,"stats":{"Line":29}},{"line":234,"address":[7581621,7577568,7587978,7570939,7566880,7577534],"length":1,"stats":{"Line":29}},{"line":235,"address":[3266255,3266992],"length":1,"stats":{"Line":55}},{"line":236,"address":[3743075,3743261],"length":1,"stats":{"Line":55}},{"line":237,"address":[3788309,3798757],"length":1,"stats":{"Line":27}},{"line":238,"address":[4919702],"length":1,"stats":{"Line":27}},{"line":239,"address":[3788833,3798868,3799298,3788420],"length":1,"stats":{"Line":54}},{"line":241,"address":[3267522],"length":1,"stats":{"Line":23}},{"line":243,"address":[3267545,3268162],"length":1,"stats":{"Line":46}},{"line":244,"address":[4920475],"length":1,"stats":{"Line":0}},{"line":247,"address":[5323574],"length":1,"stats":{"Line":22}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[5608689,5619329,5616569,5605898,5617521,5606802],"length":1,"stats":{"Line":44}},{"line":257,"address":[6410601,6410546,6410339],"length":1,"stats":{"Line":67}},{"line":258,"address":[5325673,5325750],"length":1,"stats":{"Line":28}},{"line":259,"address":[3745760],"length":1,"stats":{"Line":23}},{"line":261,"address":[1785756,1785120,1784897],"length":1,"stats":{"Line":29}},{"line":262,"address":[1785377],"length":1,"stats":{"Line":15}},{"line":263,"address":[5619048,5608384],"length":1,"stats":{"Line":15}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[4923350,4925593,4920764],"length":1,"stats":{"Line":40}},{"line":270,"address":[3802982,3803045,3792268,3802775,3792550,3792487],"length":1,"stats":{"Line":57}},{"line":271,"address":[3271801,3271658],"length":1,"stats":{"Line":36}},{"line":273,"address":[3793212,3792977,3794168,3803740,3804724,3803517],"length":1,"stats":{"Line":18}},{"line":274,"address":[2322909,2323615],"length":1,"stats":{"Line":9}},{"line":275,"address":[6413838],"length":1,"stats":{"Line":9}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[2319022,2324219,2323646],"length":1,"stats":{"Line":0}},{"line":281,"address":[6414511],"length":1,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[6895412,6890573,6886011,6878826,6897477,6883818],"length":1,"stats":{"Line":40}},{"line":286,"address":[10957746,10947154,10945360,10912797,10913020,10914899,10945595,10956187,10925734,10924048,10934657,10955952,10923825,10934880,10936566],"length":1,"stats":{"Line":41}},{"line":287,"address":[5330476],"length":1,"stats":{"Line":20}},{"line":288,"address":[1473093],"length":1,"stats":{"Line":20}},{"line":289,"address":[6884677,6896258],"length":1,"stats":{"Line":20}},{"line":290,"address":[6884696,6896277],"length":1,"stats":{"Line":20}},{"line":293,"address":[7575598,7586139],"length":1,"stats":{"Line":20}},{"line":294,"address":[3274872,3274951],"length":1,"stats":{"Line":40}},{"line":297,"address":[5330928,5330641,5331170],"length":1,"stats":{"Line":39}},{"line":298,"address":[6416347,6416712],"length":1,"stats":{"Line":19}},{"line":300,"address":[5623580,5613032],"length":1,"stats":{"Line":0}},{"line":302,"address":[3807260,3807161,3796518,3796568],"length":1,"stats":{"Line":40}},{"line":305,"address":[6408663],"length":1,"stats":{"Line":13}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[3743761],"length":1,"stats":{"Line":12}},{"line":313,"address":[3807570,3796878],"length":1,"stats":{"Line":14}},{"line":314,"address":[3752142],"length":1,"stats":{"Line":13}},{"line":315,"address":[3796945,3807637],"length":1,"stats":{"Line":14}},{"line":316,"address":[7587443,7576999],"length":1,"stats":{"Line":17}},{"line":319,"address":[6897632,6886166],"length":1,"stats":{"Line":14}},{"line":323,"address":[3267193],"length":1,"stats":{"Line":28}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[5606148,5606374,5607849,5625087,5606600,5605922,5618531,5609765,5607099,5612861,5623385,5617069,5624926,5609023,5617307,5620361,5622424,5619652,5616593,5616831,5617823,5611865],"length":1,"stats":{"Line":165}},{"line":330,"address":[3747364,3750206,3744489,3745440,3752789,3744263,3744715,3744941,3751202,3746190,3748106],"length":1,"stats":{"Line":168}},{"line":331,"address":[6415209,6413109,6409266,6416199,6417777,6410443,6412367,6417856,6417865,6411193,6409718,6409492,6409944],"length":1,"stats":{"Line":207}},{"line":333,"address":[10907345,10931964,10930790,10929315,10951004,10929089,10939936,10918709,10907860,10919208,10906667,10932706,10924958,10940928,10943466,10951520,10907119,10910734,10950290,10953349,10954058,10950528,10956121,10958860,10959016,10942757,10959180,10950766,10940412,10930040,10946490,10923974,10939698,10913994,10928863,10957082,10935790,10958700,10918483,10918257,10929541,10945529,10906893,10941636,10940174,10952228,10918031,10958536,10934806,10908674,10919958,10909944,10921874,10912946,10921132],"length":1,"stats":{"Line":168}},{"line":338,"address":[],"length":0,"stats":{"Line":28}},{"line":339,"address":[6898597,6899558],"length":1,"stats":{"Line":26}},{"line":340,"address":[3753101],"length":1,"stats":{"Line":0}},{"line":343,"address":[7588495,7589550],"length":1,"stats":{"Line":29}},{"line":346,"address":[5332789,5332883],"length":1,"stats":{"Line":51}},{"line":347,"address":[4929513],"length":1,"stats":{"Line":26}},{"line":348,"address":[3753368],"length":1,"stats":{"Line":24}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[1792111],"length":1,"stats":{"Line":1}},{"line":366,"address":[1475962],"length":1,"stats":{"Line":1}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[5332985,5333075],"length":1,"stats":{"Line":2}},{"line":369,"address":[6899135,6899068,6900194,6900127],"length":1,"stats":{"Line":2}},{"line":370,"address":[2328093],"length":1,"stats":{"Line":1}},{"line":374,"address":[6418178],"length":1,"stats":{"Line":29}},{"line":375,"address":[3808882,3809941],"length":1,"stats":{"Line":27}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}}],"covered":133,"coverable":196},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","witness.rs"],"content":"use alloc::vec::Vec;\n\nuse crate::CircuitError;\nuse crate::types::WitnessId;\n\n/// Central witness table.\n///\n/// Primary storage for all intermediate values in the circuit.\n/// Acts as the \"bus\" that all operation tables reference.\n/// Witnesses have sequential IDs starting from 0.\n#[derive(Debug, Clone)]\npub struct WitnessTrace\u003cF\u003e {\n    /// Sequential witness IDs: WitnessId(0), WitnessId(1), WitnessId(2), ...\n    ///\n    /// Forms a preprocessed column for lookups from other tables.\n    pub index: Vec\u003cWitnessId\u003e,\n\n    /// Witness field element values.\n    ///\n    /// Each value is one computation result.\n    /// Computed during circuit execution.\n    values: Vec\u003cF\u003e,\n}\n\nimpl\u003cF\u003e WitnessTrace\u003cF\u003e {\n    /// Create a new instance of [`WitnessTrace`].\n    pub fn new(index: Vec\u003cWitnessId\u003e, values: Vec\u003cF\u003e) -\u003e Self {\n        assert_eq!(index.len(), values.len());\n        Self { index, values }\n    }\n\n    /// Output the number of rows in the trace.\n    pub const fn num_rows(\u0026self) -\u003e usize {\n        self.values.len()\n    }\n\n    #[cfg(feature = \"debugging\")]\n    /// Return a reference to the values of the witness trace.\n    pub(crate) fn values(\u0026self) -\u003e \u0026[F] {\n        \u0026self.values\n    }\n\n    /// Return a reference to the value at the given witness id.\n    /// Returns `None` if the target [`WitnessId`] is not set.\n    pub fn get_value(\u0026self, witness_id: WitnessId) -\u003e Option\u003c\u0026F\u003e {\n        self.values.get(witness_id.0 as usize)\n    }\n\n    /// Return the last value in the trace.\n    /// This is useful for padding.\n    pub fn last_value(\u0026self) -\u003e Option\u003c\u0026F\u003e {\n        self.values.last()\n    }\n}\n\n/// Builder for generating witness traces.\npub struct WitnessTraceBuilder\u003c'a, F\u003e {\n    witness: \u0026'a [Option\u003cF\u003e],\n}\n\nimpl\u003c'a, F: Clone\u003e WitnessTraceBuilder\u003c'a, F\u003e {\n    /// Creates a new witness trace builder.\n    pub const fn new(witness: \u0026'a [Option\u003cF\u003e]) -\u003e Self {\n        Self { witness }\n    }\n\n    /// Builds the witness trace from the populated witness table.\n    pub fn build(self) -\u003e Result\u003cWitnessTrace\u003cF\u003e, CircuitError\u003e {\n        let capacity = self.witness.len();\n        let mut index = Vec::with_capacity(capacity);\n        let mut values = Vec::with_capacity(capacity);\n\n        for (i, witness_opt) in self.witness.iter().enumerate() {\n            match witness_opt {\n                Some(value) =\u003e {\n                    index.push(WitnessId(i as u32));\n                    values.push(value.clone());\n                }\n                None =\u003e {\n                    return Err(CircuitError::WitnessNotSetForIndex { index: i });\n                }\n            }\n        }\n\n        Ok(WitnessTrace { index, values })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_single_witness() {\n        // Create a witness table with a single value\n        let val = F::from_u64(42);\n        let witness = vec![Some(val)];\n\n        // Build the trace using the builder pattern\n        let builder = WitnessTraceBuilder::new(\u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace contains exactly one witness\n        assert_eq!(trace.index.len(), 1, \"Should have one witness entry\");\n        assert_eq!(trace.values.len(), 1, \"Should have one witness value\");\n\n        // Verify the witness is correctly recorded with sequential index\n        assert_eq!(trace.index[0], WitnessId(0));\n        assert_eq!(trace.values[0], val);\n    }\n\n    #[test]\n    fn test_multiple_witnesses() {\n        // Create a witness table with multiple values\n        let val1 = F::from_u64(10);\n        let val2 = F::from_u64(20);\n        let val3 = F::from_u64(30);\n\n        let witness = vec![Some(val1), Some(val2), Some(val3)];\n\n        // Build the trace\n        let builder = WitnessTraceBuilder::new(\u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify we have exactly three witnesses\n        assert_eq!(trace.index.len(), 3, \"Should have three witness entries\");\n        assert_eq!(trace.values.len(), 3, \"Should have three witness values\");\n\n        // Verify indices are sequential starting from 0\n        assert_eq!(trace.index[0], WitnessId(0));\n        assert_eq!(trace.index[1], WitnessId(1));\n        assert_eq!(trace.index[2], WitnessId(2));\n\n        // Verify values match the input order\n        assert_eq!(trace.values[0], val1);\n        assert_eq!(trace.values[1], val2);\n        assert_eq!(trace.values[2], val3);\n    }\n\n    #[test]\n    fn test_empty_witness() {\n        // Provide an empty witness table\n        let witness: Vec\u003cOption\u003cF\u003e\u003e = vec![];\n\n        // Build the trace\n        let builder = WitnessTraceBuilder::new(\u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace is empty\n        assert_eq!(trace.index.len(), 0, \"Should have no witness entries\");\n        assert_eq!(trace.values.len(), 0, \"Should have no values\");\n    }\n\n    #[test]\n    fn test_witness_not_set_error() {\n        // Create a witness table with an unset slot in the middle\n        let witness: Vec\u003cOption\u003cF\u003e\u003e = vec![Some(F::from_u64(10)), None, Some(F::from_u64(30))];\n\n        // Attempt to build the trace\n        let builder = WitnessTraceBuilder::new(\u0026witness);\n        let result = builder.build();\n\n        // Verify the build fails with the expected error at index 1\n        assert!(result.is_err(), \"Should fail when witness slot is not set\");\n        assert!(matches!(\n            result,\n            Err(CircuitError::WitnessNotSetForIndex { index: 1 })\n        ));\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[7751536],"length":1,"stats":{"Line":15}},{"line":34,"address":[3329893,3329909],"length":1,"stats":{"Line":13}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[3329920,3329984],"length":1,"stats":{"Line":14}},{"line":46,"address":[3329937,3330001],"length":1,"stats":{"Line":16}},{"line":51,"address":[5813504,5813536],"length":1,"stats":{"Line":11}},{"line":52,"address":[5030981],"length":1,"stats":{"Line":11}},{"line":63,"address":[6792160],"length":1,"stats":{"Line":27}},{"line":68,"address":[5815563,5813792,5814665,5814671,5814688,5815557],"length":1,"stats":{"Line":29}},{"line":69,"address":[1936851],"length":1,"stats":{"Line":27}},{"line":70,"address":[1936864],"length":1,"stats":{"Line":29}},{"line":71,"address":[1936879],"length":1,"stats":{"Line":26}},{"line":73,"address":[5032181,5032254,5031285,5031354],"length":1,"stats":{"Line":54}},{"line":74,"address":[5815092,5814200],"length":1,"stats":{"Line":32}},{"line":75,"address":[],"length":0,"stats":{"Line":28}},{"line":76,"address":[1527152],"length":1,"stats":{"Line":32}},{"line":77,"address":[10453893,10450308,10452997,10451205,10452101],"length":1,"stats":{"Line":29}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[3331720,3330828],"length":1,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":29}}],"covered":20,"coverable":23},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","test_utils.rs"],"content":"use core::borrow::Borrow;\n\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues, BaseAir};\nuse p3_field::PrimeField64;\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\n\npub struct FibonacciAir {}\n\npub const NUM_FIBONACCI_COLS: usize = 2;\n\nimpl\u003cF\u003e BaseAir\u003cF\u003e for FibonacciAir {\n    fn width(\u0026self) -\u003e usize {\n        NUM_FIBONACCI_COLS\n    }\n}\n\nimpl\u003cAB: AirBuilderWithPublicValues\u003e Air\u003cAB\u003e for FibonacciAir {\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n\n        let pis = builder.public_values();\n\n        let a = pis[0];\n        let b = pis[1];\n        let x = pis[2];\n\n        let (local, next) = (\n            main.row_slice(0).expect(\"Matrix is empty?\"),\n            main.row_slice(1).expect(\"Matrix only has 1 row?\"),\n        );\n        let local: \u0026FibonacciRow\u003cAB::Var\u003e = (*local).borrow();\n        let next: \u0026FibonacciRow\u003cAB::Var\u003e = (*next).borrow();\n\n        let mut when_first_row = builder.when_first_row();\n\n        when_first_row.assert_eq(local.left.clone(), a);\n        when_first_row.assert_eq(local.right.clone(), b);\n\n        let mut when_transition = builder.when_transition();\n\n        // a' \u003c- b\n        when_transition.assert_eq(local.right.clone(), next.left.clone());\n\n        // b' \u003c- a + b\n        when_transition.assert_eq(local.left.clone() + local.right.clone(), next.right.clone());\n\n        builder.when_last_row().assert_eq(local.right.clone(), x);\n    }\n}\n\npub fn generate_trace_rows\u003cF: PrimeField64\u003e(a: u64, b: u64, n: usize) -\u003e RowMajorMatrix\u003cF\u003e {\n    assert!(n.is_power_of_two());\n\n    let mut trace = RowMajorMatrix::new(F::zero_vec(n * NUM_FIBONACCI_COLS), NUM_FIBONACCI_COLS);\n\n    let (prefix, rows, suffix) = unsafe { trace.values.align_to_mut::\u003cFibonacciRow\u003cF\u003e\u003e() };\n    assert!(prefix.is_empty(), \"Alignment should match\");\n    assert!(suffix.is_empty(), \"Alignment should match\");\n    assert_eq!(rows.len(), n);\n\n    rows[0] = FibonacciRow::new(F::from_u64(a), F::from_u64(b));\n\n    for i in 1..n {\n        rows[i].left = rows[i - 1].right;\n        rows[i].right = rows[i - 1].left + rows[i - 1].right;\n    }\n\n    trace\n}\n\npub struct FibonacciRow\u003cF\u003e {\n    pub left: F,\n    pub right: F,\n}\n\nimpl\u003cF\u003e FibonacciRow\u003cF\u003e {\n    const fn new(left: F, right: F) -\u003e Self {\n        Self { left, right }\n    }\n}\n\nimpl\u003cF\u003e Borrow\u003cFibonacciRow\u003cF\u003e\u003e for [F] {\n    fn borrow(\u0026self) -\u003e \u0026FibonacciRow\u003cF\u003e {\n        debug_assert_eq!(self.len(), NUM_FIBONACCI_COLS);\n        let (prefix, shorts, suffix) = unsafe { self.align_to::\u003cFibonacciRow\u003cF\u003e\u003e() };\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\n        debug_assert_eq!(shorts.len(), 1);\n        \u0026shorts[0]\n    }\n}\n","traces":[{"line":13,"address":[5488112],"length":1,"stats":{"Line":4}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":12}},{"line":20,"address":[7227724,7229231],"length":1,"stats":{"Line":12}},{"line":22,"address":[7227825,7229355,7227763,7229276],"length":1,"stats":{"Line":24}},{"line":24,"address":[5481168,5482646,5482705,5479275,5475707,5479353,5475785,5477633,5477574,5481121],"length":1,"stats":{"Line":12}},{"line":25,"address":[5481202,5482782,5481233,5475765,5481151,5482685,5479333,5477710,5479393,5482745,5475881,5477673,5477613,5479449,5475825],"length":1,"stats":{"Line":24}},{"line":26,"address":[7229525,7227936,7229576,7228024,7229640,7227981],"length":1,"stats":{"Line":24}},{"line":28,"address":[5352434,5350762,5356002,5357766,5354310],"length":1,"stats":{"Line":12}},{"line":29,"address":[5355823,5354010,5357586,5357627,5350626,5352255,5352188,5350588,5355756,5354083],"length":1,"stats":{"Line":24}},{"line":30,"address":[5476138,5482988,5481424,5476084,5482954,5477996,5481390,5479652,5477930,5479706],"length":1,"stats":{"Line":24}},{"line":32,"address":[5354414,5350952,5357902,5352538,5354468,5350898,5352592,5356106,5357962,5356160],"length":1,"stats":{"Line":24}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":35,"address":[5358055,5351050,5352693,5356261,5354561],"length":1,"stats":{"Line":12}},{"line":37,"address":[7228548,7230137,7230184,7228494],"length":1,"stats":{"Line":24}},{"line":38,"address":[5358173,5352828,5356396,5354679,5351136],"length":1,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":12}},{"line":43,"address":[5480330,5478611,5481911,5481985,5478537,5483535,5476698,5476762,5480266,5482456,5479079,5480353,5480947,5481962,5483586,5483609,5484079,5476785,5477379,5478588],"length":1,"stats":{"Line":24}},{"line":46,"address":[5479069,5480451,5478693,5480490,5480610,5482122,5482446,5476922,5483846,5477364,5482083,5477042,5480932,5478848,5484069,5483738,5483691,5482242,5478740,5476883],"length":1,"stats":{"Line":12}},{"line":48,"address":[5480714,5483934,5478936,5482343,5477146,5483998,5482374,5478999],"length":1,"stats":{"Line":12}},{"line":52,"address":[5393096,5393090,5391472],"length":1,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[5391577,5391700],"length":1,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":4}},{"line":58,"address":[5181928,5182033],"length":1,"stats":{"Line":2}},{"line":59,"address":[5182057,5182170,5182006],"length":1,"stats":{"Line":4}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[5392232,5392363],"length":1,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":6}},{"line":65,"address":[5182624,5182520,5182780],"length":1,"stats":{"Line":4}},{"line":66,"address":[5392731,5392798,5393069],"length":1,"stats":{"Line":4}},{"line":69,"address":[5182556],"length":1,"stats":{"Line":2}},{"line":78,"address":[5393120],"length":1,"stats":{"Line":2}},{"line":84,"address":[4000736],"length":1,"stats":{"Line":8}},{"line":85,"address":[4836142],"length":1,"stats":{"Line":8}},{"line":86,"address":[7745998],"length":1,"stats":{"Line":8}},{"line":87,"address":[7746106],"length":1,"stats":{"Line":8}},{"line":88,"address":[7264097],"length":1,"stats":{"Line":8}},{"line":89,"address":[4001075],"length":1,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":8}}],"covered":39,"coverable":40},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","types.rs"],"content":"use core::fmt;\n\nuse serde::{Deserialize, Serialize};\n\n/// Witness ID type - a unique identifier for extension field values in the global witness bus\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]\npub struct WitnessId(pub u32);\n\nimpl fmt::Display for WitnessId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"w{}\", self.0)\n    }\n}\n\n/// Handle to an expression in the graph\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct ExprId(pub u32);\n\nimpl fmt::Display for ExprId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"e{}\", self.0)\n    }\n}\n\nimpl ExprId {\n    /// The zero expression ID - always points to Const(0)\n    pub const ZERO: Self = Self(0);\n}\n\n/// Handle to a non-primitive operation (for setting private data later)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct NonPrimitiveOpId(pub u32);\n\nimpl fmt::Display for NonPrimitiveOpId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"id{}\", self.0)\n    }\n}\n\n/// Witness allocator for monotonic index assignment\n#[derive(Debug, Clone, Default)]\npub struct WitnessAllocator {\n    next_idx: u32,\n}\n\nimpl WitnessAllocator {\n    pub const fn new() -\u003e Self {\n        Self { next_idx: 0 }\n    }\n\n    pub const fn alloc(\u0026mut self) -\u003e WitnessId {\n        let idx = WitnessId(self.next_idx);\n        self.next_idx += 1;\n        idx\n    }\n\n    pub const fn witness_count(\u0026self) -\u003e u32 {\n        self.next_idx\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::format;\n\n    use super::*;\n\n    #[test]\n    fn test_witness_id_display() {\n        let idx = WitnessId(42);\n        assert_eq!(format!(\"{idx}\"), \"w42\");\n    }\n\n    #[test]\n    fn test_witness_allocator() {\n        let mut allocator = WitnessAllocator::new();\n\n        let w0 = allocator.alloc();\n        let w1 = allocator.alloc();\n        let w2 = allocator.alloc();\n\n        assert_eq!(w0, WitnessId(0));\n        assert_eq!(w1, WitnessId(1));\n        assert_eq!(w2, WitnessId(2));\n        assert_eq!(allocator.witness_count(), 3);\n    }\n\n    #[cfg(test)]\n    mod proptests {\n        use proptest::prelude::*;\n\n        use super::*;\n\n        proptest! {\n            #[test]\n            fn witness_id_ordering(a in 0u32..u32::MAX, b in 0u32..u32::MAX) {\n                let id_a = WitnessId(a);\n                let id_b = WitnessId(b);\n\n                if a \u003c b {\n                    prop_assert!(id_a \u003c id_b, \"ordering should match inner value\");\n                } else if a \u003e b {\n                    prop_assert!(id_a \u003e id_b, \"ordering should match inner value\");\n                } else {\n                    prop_assert_eq!(id_a, id_b, \"equal values should compare equal\");\n                }\n            }\n\n            #[test]\n            fn expr_id_ordering(a in 0u32..u32::MAX, b in 0u32..u32::MAX) {\n                let id_a = ExprId(a);\n                let id_b = ExprId(b);\n\n                if a \u003c b {\n                    prop_assert!(id_a \u003c id_b, \"ordering should match inner value\");\n                } else if a \u003e b {\n                    prop_assert!(id_a \u003e id_b, \"ordering should match inner value\");\n                } else {\n                    prop_assert_eq!(id_a, id_b, \"equal values should compare equal\");\n                }\n            }\n\n            #[test]\n            fn non_primitive_op_id_equality(a in 0u32..u32::MAX, b in 0u32..u32::MAX) {\n                let id_a1 = NonPrimitiveOpId(a);\n                let id_a2 = NonPrimitiveOpId(a);\n                let id_b = NonPrimitiveOpId(b);\n\n                prop_assert_eq!(id_a1, id_a2, \"same value should be equal\");\n                if a != b {\n                    prop_assert_ne!(id_a1, id_b, \"different values should not be equal\");\n                }\n            }\n\n            #[test]\n            fn witness_allocator_unique(count in 1usize..100) {\n                let mut allocator = WitnessAllocator::new();\n                let mut seen = hashbrown::HashSet::new();\n\n                for _ in 0..count {\n                    let id = allocator.alloc();\n                    prop_assert!(seen.insert(id), \"each allocation should be unique\");\n                }\n            }\n\n            #[test]\n            fn witness_allocator_count_accurate(count in 0usize..100) {\n                let mut allocator = WitnessAllocator::new();\n\n                prop_assert_eq!(allocator.witness_count(), 0, \"new allocator should have count 0\");\n\n                for i in 1..=count {\n                    allocator.alloc();\n                    prop_assert_eq!(\n                        allocator.witness_count(),\n                        i as u32,\n                        \"count should increment with each allocation\"\n                    );\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":10,"address":[3007536],"length":1,"stats":{"Line":1}},{"line":11,"address":[2447145],"length":1,"stats":{"Line":1}},{"line":20,"address":[4958464],"length":1,"stats":{"Line":0}},{"line":21,"address":[4493609],"length":1,"stats":{"Line":0}},{"line":35,"address":[3019072],"length":1,"stats":{"Line":0}},{"line":36,"address":[4052473],"length":1,"stats":{"Line":0}},{"line":51,"address":[4031824],"length":1,"stats":{"Line":18}},{"line":52,"address":[6847438],"length":1,"stats":{"Line":17}},{"line":53,"address":[15759864,15759899],"length":1,"stats":{"Line":18}},{"line":57,"address":[8210496],"length":1,"stats":{"Line":21}},{"line":58,"address":[8210501],"length":1,"stats":{"Line":17}}],"covered":7,"coverable":11},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","utils.rs"],"content":"use alloc::vec;\nuse alloc::vec::Vec;\n\nuse hashbrown::HashMap;\nuse p3_field::{ExtensionField, Field};\nuse p3_uni_stark::{Entry, SymbolicExpression};\n\nuse crate::{CircuitBuilder, ExprId};\n\n/// Identifiers for special row selector flags in the circuit.\n#[derive(Clone, Copy, Debug)]\npub struct RowSelectorsTargets {\n    pub is_first_row: ExprId,\n    pub is_last_row: ExprId,\n    pub is_transition: ExprId,\n}\n\n/// Targets for all columns in the circuit.\n#[derive(Clone, Debug)]\npub struct ColumnsTargets\u003c'a\u003e {\n    /// Challenges added to the circuit.\n    pub challenges: \u0026'a [ExprId],\n    /// Public values added to the circuit.\n    pub public_values: \u0026'a [ExprId],\n    /// Targets for the permutation values used in the circuit.\n    pub permutation_local_values: \u0026'a [ExprId],\n    /// Targets for the permutation values evaluated at the next row.\n    pub permutation_next_values: \u0026'a [ExprId],\n    /// Targets for the preprocessed values used in the circuit.\n    pub local_prep_values: \u0026'a [ExprId],\n    /// Targets for the preprocessed values evaluated at the next row.\n    pub next_prep_values: \u0026'a [ExprId],\n    /// Targets for the main trace values.\n    pub local_values: \u0026'a [ExprId],\n    /// Targets for the main trace values evaluated at the next row.\n    pub next_values: \u0026'a [ExprId],\n}\n\n/// Given symbolic constraints, adds the corresponding recursive circuit to `circuit`.\n/// The `public_values`, `local_prep_values`, `next_prep_values`, `local_values`, and `next_values`\n/// are assumed to be in the same order as those used to create the symbolic expressions.\n// Recursive approaches blowup quickly, so this takes an iterative DAG approach with\n// some caching of `SymbolicExpression` nodes.\npub fn symbolic_to_circuit\u003cF: Field\u003e(\n    row_selectors: RowSelectorsTargets,\n    columns: \u0026ColumnsTargets\u003c'_\u003e,\n    symbolic: \u0026SymbolicExpression\u003cF\u003e,\n    circuit: \u0026mut CircuitBuilder\u003cF\u003e,\n) -\u003e ExprId {\n    let mut cache = HashMap::new();\n    symbolic_to_circuit_core(row_selectors, columns, symbolic, circuit, \u0026mut cache, |c| c)\n}\n\n/// Convert base-field symbolic constraints to extension-field circuit operations.\n///\n/// Unlike [`symbolic_to_circuit`], this accepts `SymbolicExpression\u003cF\u003e` (base field)\n/// with a `CircuitBuilder\u003cEF\u003e` (extension field), lifting constants via `EF::from(c)`.\n///\n/// Converting directly the tree SymbolicExpression\u003cF\u003e → SymbolicExpression\u003cEF\u003e\n/// destroys Arc-based sub-expression sharing and causes exponential blowup.\n/// Instead, we lift F → EF constants directly.\n///\n/// Additionally, the `cache` is shared across all constraint calls to reuse circuit\n/// operations for sub-expressions shared between different constraints.\npub fn symbolic_to_circuit_base\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e(\n    row_selectors: RowSelectorsTargets,\n    columns: \u0026ColumnsTargets\u003c'_\u003e,\n    symbolic: \u0026SymbolicExpression\u003cF\u003e,\n    circuit: \u0026mut CircuitBuilder\u003cEF\u003e,\n    cache: \u0026mut HashMap\u003c*const SymbolicExpression\u003cF\u003e, ExprId\u003e,\n) -\u003e ExprId {\n    symbolic_to_circuit_core(row_selectors, columns, symbolic, circuit, cache, EF::from)\n}\n\n/// Convert extension-field symbolic constraints to circuit operations with an external cache.\n///\n/// Same as [`symbolic_to_circuit`] but with an external `cache` to allow sharing across\n/// multiple calls.\npub fn symbolic_to_circuit_ext\u003cF: Field\u003e(\n    row_selectors: RowSelectorsTargets,\n    columns: \u0026ColumnsTargets\u003c'_\u003e,\n    symbolic: \u0026SymbolicExpression\u003cF\u003e,\n    circuit: \u0026mut CircuitBuilder\u003cF\u003e,\n    cache: \u0026mut HashMap\u003c*const SymbolicExpression\u003cF\u003e, ExprId\u003e,\n) -\u003e ExprId {\n    symbolic_to_circuit_core(row_selectors, columns, symbolic, circuit, cache, |c| c)\n}\n\n/// Core implementation of symbolic-to-circuit conversion.\n///\n/// Generic over the expression constant field (`CF`) and circuit field (`F`).\n/// `convert_const` lifts expression constants from `CF` to `F`.\nfn symbolic_to_circuit_core\u003cCF: Field, F: Field\u003e(\n    row_selectors: RowSelectorsTargets,\n    columns: \u0026ColumnsTargets\u003c'_\u003e,\n    symbolic: \u0026SymbolicExpression\u003cCF\u003e,\n    circuit: \u0026mut CircuitBuilder\u003cF\u003e,\n    cache: \u0026mut HashMap\u003c*const SymbolicExpression\u003cCF\u003e, ExprId\u003e,\n    convert_const: impl Fn(CF) -\u003e F,\n) -\u003e ExprId {\n    enum Work\u003c'a, CF: Field\u003e {\n        Eval(\u0026'a SymbolicExpression\u003cCF\u003e),\n        Build(*const SymbolicExpression\u003cCF\u003e, Op, usize),\n    }\n\n    #[derive(Copy, Clone)]\n    enum Op {\n        Add,\n        Sub,\n        Mul,\n        Neg,\n    }\n\n    let RowSelectorsTargets {\n        is_first_row,\n        is_last_row,\n        is_transition,\n    } = row_selectors;\n\n    let ColumnsTargets {\n        challenges,\n        public_values,\n        permutation_local_values,\n        permutation_next_values,\n        local_prep_values,\n        next_prep_values,\n        local_values,\n        next_values,\n    } = columns;\n\n    let mut tasks = vec![Work::Eval(symbolic)];\n    let mut stack = Vec::with_capacity(16);\n\n    while let Some(work) = tasks.pop() {\n        match work {\n            Work::Eval(expr) =\u003e {\n                let key = expr as *const _;\n                if let Some(\u0026cached) = cache.get(\u0026key) {\n                    stack.push(cached);\n                    continue;\n                }\n                match expr {\n                    SymbolicExpression::Constant(c) =\u003e {\n                        let id = circuit.define_const(convert_const(*c));\n                        cache.insert(key, id);\n                        stack.push(id);\n                    }\n                    SymbolicExpression::Variable(v) =\u003e {\n                        let get_val =\n                            |offset: usize,\n                             index: usize,\n                             local_vals: \u0026[ExprId],\n                             next_vals: \u0026[ExprId]| match offset {\n                                0 =\u003e local_vals[index],\n                                1 =\u003e next_vals[index],\n                                _ =\u003e {\n                                    panic!(\"Cannot have expressions involving more than two rows.\")\n                                }\n                            };\n                        let id = match v.entry {\n                            Entry::Preprocessed { offset } =\u003e {\n                                get_val(offset, v.index, local_prep_values, next_prep_values)\n                            }\n                            Entry::Permutation { offset } =\u003e get_val(\n                                offset,\n                                v.index,\n                                permutation_local_values,\n                                permutation_next_values,\n                            ),\n                            Entry::Main { offset } =\u003e {\n                                get_val(offset, v.index, local_values, next_values)\n                            }\n                            Entry::Public =\u003e public_values[v.index],\n                            Entry::Challenge =\u003e challenges[v.index],\n                        };\n                        cache.insert(key, id);\n                        stack.push(id);\n                    }\n                    SymbolicExpression::IsFirstRow =\u003e stack.push(is_first_row),\n                    SymbolicExpression::IsLastRow =\u003e stack.push(is_last_row),\n                    SymbolicExpression::IsTransition =\u003e stack.push(is_transition),\n                    SymbolicExpression::Neg { x, .. } =\u003e {\n                        tasks.push(Work::Build(key, Op::Neg, 1));\n                        tasks.push(Work::Eval(x));\n                    }\n                    SymbolicExpression::Add { x, y, .. } =\u003e {\n                        tasks.push(Work::Build(key, Op::Add, 2));\n                        tasks.push(Work::Eval(y));\n                        tasks.push(Work::Eval(x));\n                    }\n                    SymbolicExpression::Sub { x, y, .. } =\u003e {\n                        tasks.push(Work::Build(key, Op::Sub, 2));\n                        tasks.push(Work::Eval(y));\n                        tasks.push(Work::Eval(x));\n                    }\n                    SymbolicExpression::Mul { x, y, .. } =\u003e {\n                        tasks.push(Work::Build(key, Op::Mul, 2));\n                        tasks.push(Work::Eval(y));\n                        tasks.push(Work::Eval(x));\n                    }\n                }\n            }\n            Work::Build(key, op, arity) =\u003e {\n                let rhs = stack.pop().expect(\"rhs\");\n                let lhs = if arity == 2 {\n                    stack.pop().expect(\"lhs\")\n                } else {\n                    rhs // placeholder; for Neg we overwrite below\n                };\n                let id = match op {\n                    Op::Add =\u003e circuit.add(lhs, rhs),\n                    Op::Sub =\u003e circuit.sub(lhs, rhs),\n                    Op::Mul =\u003e circuit.mul(lhs, rhs),\n                    Op::Neg =\u003e {\n                        let zero = circuit.define_const(F::ZERO);\n                        circuit.sub(zero, rhs)\n                    }\n                };\n                cache.insert(key, id);\n                stack.push(id);\n            }\n        }\n    }\n\n    stack.pop().expect(\"final target\")\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_air::{Air, BaseAir};\n    use p3_baby_bear::{BabyBear, Poseidon2BabyBear};\n    use p3_challenger::DuplexChallenger;\n    use p3_commit::ExtensionMmcs;\n    use p3_dft::Radix2DitParallel;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_field::integers::QuotientMap;\n    use p3_fri::TwoAdicFriPcs;\n    use p3_matrix::dense::RowMajorMatrixView;\n    use p3_matrix::stack::VerticalPair;\n    use p3_merkle_tree::MerkleTreeMmcs;\n    use p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\n    use p3_uni_stark::{\n        StarkConfig, SymbolicExpression, VerifierConstraintFolder, get_symbolic_constraints,\n    };\n    use rand::rngs::SmallRng;\n    use rand::{Rng, SeedableRng};\n\n    use super::*;\n\n    type F = BabyBear;\n    const D: usize = 4;\n    type Challenge = BinomialExtensionField\u003cF, D\u003e;\n    type Dft = Radix2DitParallel\u003cF\u003e;\n    type Perm = Poseidon2BabyBear\u003c16\u003e;\n    type MyHash = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\n    type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\n    type ValMmcs =\n        MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\n    type ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\n    type Challenger = DuplexChallenger\u003cF, Perm, 16, 8\u003e;\n    type MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\n    type MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n    use p3_field::PrimeCharacteristicRing;\n\n    use crate::test_utils::{FibonacciAir, NUM_FIBONACCI_COLS};\n    use crate::utils::{ColumnsTargets, RowSelectorsTargets, symbolic_to_circuit};\n    use crate::{CircuitBuilder, CircuitError};\n\n    #[test]\n    fn test_symbolic_to_circuit() -\u003e Result\u003c(), CircuitError\u003e {\n        let mut rng = SmallRng::seed_from_u64(1);\n        let x = 21;\n\n        let pis = vec![F::ZERO, F::ONE, F::from_u64(x)];\n        let pis_ext = pis\n            .iter()\n            .map(|c| Challenge::from_prime_subfield(*c))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let air = FibonacciAir {};\n\n        let alpha = Challenge::from_u64(rng.next_u64());\n\n        // Let us simulate the constraints folding.\n        // First, get random values for the trace.\n        let width = \u003cFibonacciAir as BaseAir\u003cF\u003e\u003e::width(\u0026air);\n        let mut trace_local = Vec::with_capacity(width);\n        let mut trace_next = Vec::with_capacity(width);\n        for _ in 0..width {\n            trace_local.push(Challenge::from_prime_subfield(F::from_int(rng.next_u64())));\n            trace_next.push(Challenge::from_prime_subfield(F::from_int(rng.next_u64())));\n        }\n        let main = VerticalPair::new(\n            RowMajorMatrixView::new_row(\u0026trace_local),\n            RowMajorMatrixView::new_row(\u0026trace_next),\n        );\n\n        // Get random values for the selectors.\n        let sels = [\n            Challenge::from_u64(rng.next_u64()),\n            Challenge::from_u64(rng.next_u64()),\n            Challenge::from_u64(rng.next_u64()),\n        ];\n\n        // Fold the constraints using random values for the trace and selectors.\n        let mut folder: VerifierConstraintFolder\u003c'_, MyConfig\u003e = VerifierConstraintFolder {\n            main,\n            preprocessed: None,\n            public_values: \u0026pis,\n            is_first_row: sels[0],\n            is_last_row: sels[1],\n            is_transition: sels[2],\n            alpha,\n            accumulator: Challenge::ZERO,\n        };\n        air.eval(\u0026mut folder);\n        let folded_constraints = folder.accumulator;\n\n        // Get the symbolic constraints from `FibonacciAir`.\n        let symbolic_constraints: Vec\u003cp3_uni_stark::SymbolicExpression\u003cChallenge\u003e\u003e =\n            get_symbolic_constraints(\u0026air, 0, pis.len());\n\n        // Fold the symbolic constraints using `alpha`.\n        let folded_symbolic_constraints = {\n            let mut acc = SymbolicExpression::\u003cChallenge\u003e::Constant(Challenge::ZERO);\n            let ch = SymbolicExpression::Constant(alpha);\n            for s_c in symbolic_constraints.iter() {\n                acc = ch.clone() * acc;\n                acc += s_c.clone();\n            }\n            acc\n        };\n\n        // Build a circuit adding public inputs for `sels`, public values, local values and next values.\n        let mut circuit = CircuitBuilder::new();\n        let circuit_sels = [\n            circuit.public_input(),\n            circuit.public_input(),\n            circuit.public_input(),\n        ];\n        let circuit_public_values = [\n            circuit.public_input(),\n            circuit.public_input(),\n            circuit.public_input(),\n        ];\n        let mut circuit_local_values = Vec::with_capacity(NUM_FIBONACCI_COLS);\n        let mut circuit_next_values = Vec::with_capacity(NUM_FIBONACCI_COLS);\n        for _ in 0..NUM_FIBONACCI_COLS {\n            circuit_local_values.push(circuit.public_input());\n            circuit_next_values.push(circuit.public_input());\n        }\n\n        let row_selectors = RowSelectorsTargets {\n            is_first_row: circuit_sels[0],\n            is_last_row: circuit_sels[1],\n            is_transition: circuit_sels[2],\n        };\n\n        let columns = ColumnsTargets {\n            challenges: \u0026[],\n            public_values: \u0026circuit_public_values,\n            permutation_local_values: \u0026[],\n            permutation_next_values: \u0026[],\n            local_prep_values: \u0026[],\n            next_prep_values: \u0026[],\n            local_values: \u0026circuit_local_values,\n            next_values: \u0026circuit_next_values,\n        };\n\n        // Get the circuit for the folded constraints.\n        let sum = symbolic_to_circuit(\n            row_selectors,\n            \u0026columns,\n            \u0026folded_symbolic_constraints,\n            \u0026mut circuit,\n        );\n\n        // Check that the circuit output equals the folded constraints.\n        let final_result_const = circuit.define_const(folded_constraints);\n        circuit.connect(final_result_const, sum);\n\n        let mut all_public_values = sels.to_vec();\n        all_public_values.extend_from_slice(\u0026pis_ext);\n        for i in 0..NUM_FIBONACCI_COLS {\n            all_public_values.push(trace_local[i]);\n            all_public_values.push(trace_next[i]);\n        }\n\n        let builder = circuit.build().unwrap();\n        let mut builder = builder.runner();\n        builder.set_public_inputs(\u0026all_public_values).unwrap();\n        let _ = builder.run()?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":44,"address":[8210780,8210608],"length":1,"stats":{"Line":1}},{"line":50,"address":[8210660],"length":1,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[3778944],"length":1,"stats":{"Line":9}},{"line":72,"address":[1728728],"length":1,"stats":{"Line":8}},{"line":79,"address":[2304672],"length":1,"stats":{"Line":5}},{"line":86,"address":[4001280,4001240,4001288],"length":1,"stats":{"Line":3}},{"line":93,"address":[4005152,4001376,4005464,4008881,4001688,4005138],"length":1,"stats":{"Line":15}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[3779079,3782823],"length":1,"stats":{"Line":12}},{"line":116,"address":[4005239,4001463],"length":1,"stats":{"Line":15}},{"line":117,"address":[3782856,3779112],"length":1,"stats":{"Line":12}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[3782873,3779129],"length":1,"stats":{"Line":15}},{"line":122,"address":[],"length":0,"stats":{"Line":12}},{"line":123,"address":[5445848,5449592],"length":1,"stats":{"Line":16}},{"line":124,"address":[3782927,3779183],"length":1,"stats":{"Line":12}},{"line":125,"address":[1728966,1732694],"length":1,"stats":{"Line":16}},{"line":126,"address":[8211053],"length":1,"stats":{"Line":12}},{"line":127,"address":[1732740,1729012],"length":1,"stats":{"Line":16}},{"line":128,"address":[3837115,3833371],"length":1,"stats":{"Line":12}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[2308971,2305195,2308905,2305129],"length":1,"stats":{"Line":28}},{"line":132,"address":[4918468,4922196,4922149,4918421],"length":1,"stats":{"Line":28}},{"line":134,"address":[3779590,3779638,3783382,3783334],"length":1,"stats":{"Line":28}},{"line":135,"address":[4918609,4922337],"length":1,"stats":{"Line":16}},{"line":136,"address":[8211699],"length":1,"stats":{"Line":12}},{"line":137,"address":[4006047,4002271],"length":1,"stats":{"Line":16}},{"line":138,"address":[3537455,3541199],"length":1,"stats":{"Line":12}},{"line":139,"address":[3834102,3837846,3834151,3837895],"length":1,"stats":{"Line":12}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[4922645,4918917],"length":1,"stats":{"Line":16}},{"line":143,"address":[3783956,3780212],"length":1,"stats":{"Line":9}},{"line":144,"address":[5448328,5450659,5446915,5452105],"length":1,"stats":{"Line":18}},{"line":145,"address":[8213529],"length":1,"stats":{"Line":9}},{"line":146,"address":[3839579,3835802],"length":1,"stats":{"Line":9}},{"line":148,"address":[2305894,2309670],"length":1,"stats":{"Line":12}},{"line":149,"address":[5453216,5453488],"length":1,"stats":{"Line":14}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[5453293,5453565],"length":1,"stats":{"Line":14}},{"line":154,"address":[4009345,4009311,4009039,4009073],"length":1,"stats":{"Line":28}},{"line":155,"address":[],"length":0,"stats":{"Line":28}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[5453313,5453585],"length":1,"stats":{"Line":0}},{"line":160,"address":[2305917,2309693],"length":1,"stats":{"Line":16}},{"line":161,"address":[3838614,3834837],"length":1,"stats":{"Line":12}},{"line":162,"address":[4003154,4007519,4003776,4006897],"length":1,"stats":{"Line":24}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[3542432,3538655],"length":1,"stats":{"Line":5}},{"line":168,"address":[3784903,3781126],"length":1,"stats":{"Line":3}},{"line":170,"address":[1730681,1734409],"length":1,"stats":{"Line":13}},{"line":171,"address":[8212787,8213275],"length":1,"stats":{"Line":27}},{"line":173,"address":[2310876,2307133,2307320,2311063],"length":1,"stats":{"Line":13}},{"line":174,"address":[3835626,3839403,3839203,3835426],"length":1,"stats":{"Line":8}},{"line":176,"address":[3538926,3542703],"length":1,"stats":{"Line":15}},{"line":177,"address":[4007726,4003983],"length":1,"stats":{"Line":13}},{"line":179,"address":[4006288,4002512,4004010,4007753],"length":1,"stats":{"Line":26}},{"line":180,"address":[4002537,4004015,4006313,4007758],"length":1,"stats":{"Line":14}},{"line":181,"address":[3835715,3838034,3839492,3834290],"length":1,"stats":{"Line":28}},{"line":182,"address":[1730265,1733993],"length":1,"stats":{"Line":5}},{"line":183,"address":[3538062,3541839],"length":1,"stats":{"Line":3}},{"line":184,"address":[5452457,5448680],"length":1,"stats":{"Line":4}},{"line":186,"address":[8212117],"length":1,"stats":{"Line":13}},{"line":187,"address":[8212160],"length":1,"stats":{"Line":15}},{"line":188,"address":[3543039,3539262],"length":1,"stats":{"Line":13}},{"line":189,"address":[3785567,3781790],"length":1,"stats":{"Line":14}},{"line":191,"address":[2309985,2306242],"length":1,"stats":{"Line":13}},{"line":192,"address":[3834524,3838301],"length":1,"stats":{"Line":15}},{"line":193,"address":[],"length":0,"stats":{"Line":13}},{"line":194,"address":[3539459,3543236],"length":1,"stats":{"Line":15}},{"line":196,"address":[4919499,4923227],"length":1,"stats":{"Line":12}},{"line":197,"address":[1734134,1730406],"length":1,"stats":{"Line":16}},{"line":198,"address":[1731819,1735547],"length":1,"stats":{"Line":12}},{"line":199,"address":[4008269,4004526],"length":1,"stats":{"Line":16}},{"line":203,"address":[8211590],"length":1,"stats":{"Line":15}},{"line":204,"address":[2305671,2311800,2308057,2309447],"length":1,"stats":{"Line":28}},{"line":205,"address":[2308123,2311849,2311866,2308106],"length":1,"stats":{"Line":17}},{"line":206,"address":[8214129,8214188],"length":1,"stats":{"Line":28}},{"line":208,"address":[8214112],"length":1,"stats":{"Line":4}},{"line":210,"address":[1735784,1732056],"length":1,"stats":{"Line":15}},{"line":211,"address":[4008654,4008534,4004911,4004791],"length":1,"stats":{"Line":28}},{"line":212,"address":[2312020,2308408,2308277,2312151],"length":1,"stats":{"Line":28}},{"line":213,"address":[3786341,3782564,3782450,3786227],"length":1,"stats":{"Line":28}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[8214329,8214442],"length":1,"stats":{"Line":8}},{"line":216,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[3840406,3836629],"length":1,"stats":{"Line":13}},{"line":220,"address":[8214473],"length":1,"stats":{"Line":15}},{"line":225,"address":[2312261,2305570,2308518,2309346],"length":1,"stats":{"Line":28}}],"covered":81,"coverable":93},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","benches","prover.rs"],"content":"//! Benchmarks: trace-to-matrix conversion and full proving.\n//!\n//! Instance shape and size are parameterized so results are comparable and\n//! scaling is visible.\n\nuse criterion::{BenchmarkId, Criterion, black_box, criterion_group, criterion_main};\nuse p3_baby_bear::BabyBear;\nuse p3_batch_stark::ProverData;\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit_prover::air::{AluAir, ConstAir, PublicAir, WitnessAir};\nuse p3_circuit_prover::common::get_airs_and_degrees_with_prep;\nuse p3_circuit_prover::config::BabyBearConfig;\nuse p3_circuit_prover::{\n    BatchStarkProver, CircuitProverData, ConstraintProfile, TablePacking, config,\n};\nuse p3_field::PrimeCharacteristicRing;\n\ntype F = BabyBear;\n\nfn fib_circuit(n: usize) -\u003e (p3_circuit::Circuit\u003cF\u003e, F) {\n    let mut builder = CircuitBuilder::new();\n    let expected_result = builder.alloc_public_input(\"expected_result\");\n    let mut a = builder.alloc_const(F::ZERO, \"F(0)\");\n    let mut b = builder.alloc_const(F::ONE, \"F(1)\");\n    for _ in 2..=n {\n        let next = builder.add(a, b);\n        a = b;\n        b = next;\n    }\n    builder.connect(b, expected_result);\n    let circuit = builder.build().unwrap();\n    let expected_fib = fib_classical(n);\n    (circuit, expected_fib)\n}\n\nfn fib_classical(n: usize) -\u003e F {\n    if n == 0 {\n        return F::ZERO;\n    }\n    if n == 1 {\n        return F::ONE;\n    }\n    let mut a = F::ZERO;\n    let mut b = F::ONE;\n    for _ in 2..=n {\n        let next = a + b;\n        a = b;\n        b = next;\n    }\n    b\n}\n\nfn bench_trace_to_matrix(c: \u0026mut Criterion) {\n    let table_packing = TablePacking::new(4, 1, 4);\n    let lanes_w = table_packing.witness_lanes();\n    let lanes_p = table_packing.public_lanes();\n    let lanes_a = table_packing.alu_lanes();\n\n    let mut group = c.benchmark_group(\"trace_to_matrix\");\n    for n in [100, 500, 2000] {\n        group.bench_with_input(BenchmarkId::new(\"fibonacci\", n), \u0026n, |b, \u0026n| {\n            b.iter(|| {\n                let (circuit, expected_fib) = fib_circuit(n);\n                let mut runner = circuit.runner();\n                runner.set_public_inputs(\u0026[expected_fib]).unwrap();\n                let traces = runner.run().unwrap();\n                let _ = black_box(WitnessAir::\u003cF, 1\u003e::trace_to_matrix(\n                    \u0026traces.witness_trace,\n                    lanes_w,\n                ));\n                let _ = black_box(ConstAir::\u003cF, 1\u003e::trace_to_matrix(\u0026traces.const_trace));\n                let _ = black_box(PublicAir::\u003cF, 1\u003e::trace_to_matrix(\n                    \u0026traces.public_trace,\n                    lanes_p,\n                ));\n                let _ = black_box(AluAir::\u003cF, 1\u003e::trace_to_matrix(\u0026traces.alu_trace, lanes_a));\n            });\n        });\n    }\n    group.finish();\n}\n\nfn bench_prove_all_tables(c: \u0026mut Criterion) {\n    let table_packing = TablePacking::new(4, 1, 4);\n\n    let mut group = c.benchmark_group(\"prove_all_tables\");\n    for n in [100, 500, 2000] {\n        group.bench_with_input(BenchmarkId::new(\"fibonacci\", n), \u0026n, |b, \u0026n| {\n            b.iter(|| {\n                let config = config::baby_bear().build();\n                let (circuit, expected_fib) = fib_circuit(n);\n                let (airs_degrees, preprocessed_columns) =\n                    get_airs_and_degrees_with_prep::\u003cBabyBearConfig, _, 1\u003e(\n                        \u0026circuit,\n                        table_packing,\n                        None,\n                        ConstraintProfile::Standard,\n                    )\n                    .unwrap();\n                let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n                let mut runner = circuit.runner();\n                runner.set_public_inputs(\u0026[expected_fib]).unwrap();\n                let traces = runner.run().unwrap();\n                let prover_data = ProverData::from_airs_and_degrees(\u0026config, \u0026mut airs, \u0026degrees);\n                let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n                let prover = BatchStarkProver::new(config).with_table_packing(table_packing);\n                black_box(\n                    prover\n                        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n                        .unwrap(),\n                )\n            });\n        });\n    }\n    group.finish();\n}\n\ncriterion_group!(benches, bench_trace_to_matrix, bench_prove_all_tables);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","examples","fibonacci.rs"],"content":"use std::env;\nuse std::error::Error;\n\n/// Fibonacci circuit: Compute F(n) and prove correctness\n/// Public input: expected_result (F(n))\nuse p3_baby_bear::BabyBear;\nuse p3_batch_stark::ProverData;\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit_prover::common::get_airs_and_degrees_with_prep;\nuse p3_circuit_prover::config::BabyBearConfig;\nuse p3_circuit_prover::{\n    BatchStarkProver, CircuitProverData, ConstraintProfile, TablePacking, config,\n};\nuse p3_field::PrimeCharacteristicRing;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n/// Initializes a global logger with default parameters.\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\ntype F = BabyBear;\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    init_logger();\n\n    let config = config::baby_bear().build();\n\n    let n = env::args()\n        .nth(1)\n        .and_then(|s| s.parse().ok())\n        .unwrap_or(100);\n\n    let mut builder = CircuitBuilder::new();\n\n    // Public input: expected F(n)\n    let expected_result = builder.alloc_public_input(\"expected_result\");\n\n    // Compute F(n) iteratively\n    let mut a = builder.alloc_const(F::ZERO, \"F(0)\");\n    let mut b = builder.alloc_const(F::ONE, \"F(1)\");\n\n    for _i in 2..=n {\n        let next = builder.add(a, b);\n        a = b;\n        b = next;\n    }\n\n    // Assert computed F(n) equals expected result\n    builder.connect(b, expected_result);\n\n    builder.dump_allocation_log();\n\n    let circuit = builder.build()?;\n    let table_packing = TablePacking::new(4, 4, 4);\n\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cBabyBearConfig, _, 1\u003e(\n            \u0026circuit,\n            table_packing,\n            None,\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    // Set public input\n    let expected_fib = compute_fibonacci_classical(n);\n    runner.set_public_inputs(\u0026[expected_fib])?;\n\n    let traces = runner.run()?;\n    let prover_data = ProverData::from_airs_and_degrees(\u0026config, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n    let prover = BatchStarkProver::new(config).with_table_packing(table_packing);\n\n    let proof = prover.prove_all_tables(\u0026traces, \u0026circuit_prover_data)?;\n    prover.verify_all_tables(\u0026proof, circuit_prover_data.common_data())?;\n    Ok(())\n}\n\nfn compute_fibonacci_classical(n: usize) -\u003e F {\n    if n == 0 {\n        return F::ZERO;\n    }\n    if n == 1 {\n        return F::ONE;\n    }\n\n    let mut a = F::ZERO;\n    let mut b = F::ONE;\n\n    for _i in 2..=n {\n        let next = a + b;\n        a = b;\n        b = next;\n    }\n\n    b\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","examples","poseidon2_perm_chain.rs"],"content":"use std::env;\nuse std::error::Error;\n\n/// Poseidon2 permutation chain example using the Poseidon2Perm op.\n///\n/// Builds a chain of Poseidon2 permutations and verifies the final output against a native\n/// computation.\nuse p3_baby_bear::{BabyBear, default_babybear_poseidon2_16};\nuse p3_batch_stark::ProverData;\nuse p3_circuit::op::NonPrimitiveOpType;\nuse p3_circuit::ops::{Poseidon2PermCall, Poseidon2PermOps, generate_poseidon2_trace};\nuse p3_circuit::{CircuitBuilder, ExprId};\nuse p3_circuit_prover::common::{NonPrimitiveConfig, get_airs_and_degrees_with_prep};\nuse p3_circuit_prover::config::BabyBearConfig;\nuse p3_circuit_prover::{\n    BatchStarkProver, CircuitProverData, ConstraintProfile, Poseidon2Config, TablePacking, config,\n};\nuse p3_field::extension::BinomialExtensionField;\nuse p3_field::{BasedVectorSpace, PrimeCharacteristicRing};\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\nuse p3_symmetric::Permutation;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n/// Initializes a global logger with default parameters.\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\ntype Base = BabyBear;\ntype Ext4 = BinomialExtensionField\u003cBase, 4\u003e;\n\nconst WIDTH: usize = 16;\nconst LIMB_SIZE: usize = 4; // D=4\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    init_logger();\n\n    // Parse chain length from CLI (default: 3 permutations).\n    let chain_length: usize = env::args().nth(1).and_then(|s| s.parse().ok()).unwrap_or(3);\n    assert!(chain_length \u003e= 1, \"chain length must be at least 1\");\n\n    // Build an initial state of 4 extension limbs with distinct coefficients.\n    let mut ext_limbs = [Ext4::ZERO; 4];\n    for (limb, ext_limb) in ext_limbs.iter_mut().enumerate() {\n        let coeffs: [Base; LIMB_SIZE] =\n            core::array::from_fn(|j| Base::from_u64((limb * LIMB_SIZE + j + 1) as u64));\n        *ext_limb = Ext4::from_basis_coefficients_slice(\u0026coeffs).unwrap();\n    }\n\n    // Compute native permutation chain over the base field (flattened coefficients).\n    let perm = default_babybear_poseidon2_16();\n    let mut state_base = flatten_ext_limbs(\u0026ext_limbs);\n    for _ in 0..chain_length {\n        state_base = perm.permute(state_base);\n    }\n    let final_state = state_base;\n    let final_limbs_ext = collect_ext_limbs(\u0026final_state);\n\n    // Build the circuit.\n    let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n    builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cExt4, BabyBearD4Width16\u003e,\n        perm,\n    );\n\n    // Allocate initial input limbs (constants for this example).\n    let first_inputs_expr: [ExprId; 4] =\n        core::array::from_fn(|i| builder.alloc_const(ext_limbs[i], \"poseidon2_perm_input\"));\n\n    // Allocate expected outputs for limbs 0 and 1 of the final row (for checking).\n    let expected_final_output_exprs: [ExprId; 2] = core::array::from_fn(|i| {\n        builder.alloc_const(final_limbs_ext[i], \"poseidon2_perm_expected_output\")\n    });\n\n    // Add permutation rows.\n    let mut last_outputs: [Option\u003cExprId\u003e; 4] = [None, None, None, None];\n\n    for row in 0..chain_length {\n        let is_first = row == 0;\n        let is_last = row + 1 == chain_length;\n\n        let mut inputs: [Option\u003cExprId\u003e; 4] = [None, None, None, None];\n        if is_first {\n            for limb in 0..4 {\n                inputs[limb] = Some(first_inputs_expr[limb]);\n            }\n        }\n\n        let (_op_id, outputs) = builder.add_poseidon2_perm(Poseidon2PermCall {\n            config: Poseidon2Config::BabyBearD4Width16,\n            new_start: is_first,\n            merkle_path: false,\n            mmcs_bit: None, // Must be None when merkle_path=false\n            inputs,\n            out_ctl: [is_last, is_last],\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })?;\n\n        if is_last {\n            last_outputs = outputs;\n\n            let out0 = outputs[0].ok_or(\"missing out0 expr\")?;\n            let out1 = outputs[1].ok_or(\"missing out1 expr\")?;\n            builder.connect(out0, expected_final_output_exprs[0]);\n            builder.connect(out1, expected_final_output_exprs[1]);\n        }\n    }\n\n    let out0 = last_outputs[0].ok_or(\"missing out0 expr\")?;\n    let out1 = last_outputs[1].ok_or(\"missing out1 expr\")?;\n\n    // Build + run.\n    let circuit = builder.build()?;\n    let expr_to_widx = circuit.expr_to_widx.clone();\n\n    let stark_config = config::baby_bear().build();\n    let table_packing = TablePacking::new(2, 2, 2);\n    let poseidon2_config = Poseidon2Config::BabyBearD4Width16;\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cBabyBearConfig, _, 4\u003e(\n            \u0026circuit,\n            table_packing,\n            Some(\u0026[NonPrimitiveConfig::Poseidon2(poseidon2_config)]),\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n\n    let runner = circuit.runner();\n    let traces = runner.run()?;\n\n    // Sanity-check exposed outputs against the native computation.\n    let observed_out0 = {\n        let wid = expr_to_widx\n            .get(\u0026out0)\n            .ok_or(\"missing witness id for out0\")?;\n        *traces\n            .witness_trace\n            .get_value(*wid)\n            .ok_or(\"missing witness value for out0\")?\n    };\n    let observed_out1 = {\n        let wid = expr_to_widx\n            .get(\u0026out1)\n            .ok_or(\"missing witness id for out1\")?;\n        *traces\n            .witness_trace\n            .get_value(*wid)\n            .ok_or(\"missing witness value for out1\")?\n    };\n\n    assert_eq!(\n        [observed_out0, observed_out1],\n        [final_limbs_ext[0], final_limbs_ext[1]]\n    );\n\n    assert!(\n        traces\n            .non_primitive_traces\n            .get(\u0026NonPrimitiveOpType::Poseidon2Perm(\n                Poseidon2Config::BabyBearD4Width16\n            ))\n            .is_some_and(|t| t.rows() == chain_length),\n        \"Poseidon2 trace should contain one row per perm op\"\n    );\n\n    // Prove and verify the circuit.\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let prover_data = ProverData::from_airs_and_degrees(\u0026stark_config, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    assert!(\n        !circuit_prover_data.common_data().lookups[4].is_empty(),\n        \"Poseidon2 table should have lookups\"\n    );\n\n    let mut prover = BatchStarkProver::new(stark_config).with_table_packing(table_packing);\n    prover.register_poseidon2_table(poseidon2_config);\n\n    let proof = prover.prove_all_tables(\u0026traces, \u0026circuit_prover_data)?;\n    prover.verify_all_tables(\u0026proof, circuit_prover_data.common_data())?;\n\n    Ok(())\n}\n\nfn flatten_ext_limbs(limbs: \u0026[Ext4; 4]) -\u003e [Base; WIDTH] {\n    let mut out = [Base::ZERO; WIDTH];\n    for (i, limb) in limbs.iter().enumerate() {\n        let coeffs = limb.as_basis_coefficients_slice();\n        out[i * LIMB_SIZE..(i + 1) * LIMB_SIZE].copy_from_slice(coeffs);\n    }\n    out\n}\n\nfn collect_ext_limbs(state: \u0026[Base; WIDTH]) -\u003e [Ext4; 4] {\n    let mut limbs = [Ext4::ZERO; 4];\n    for i in 0..4 {\n        let chunk = \u0026state[i * LIMB_SIZE..(i + 1) * LIMB_SIZE];\n        limbs[i] = Ext4::from_basis_coefficients_slice(chunk).unwrap();\n    }\n    limbs\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","examples","poseidon2_perm_merkle.rs"],"content":"use std::error::Error;\n\nuse p3_baby_bear::{BabyBear, default_babybear_poseidon2_16};\nuse p3_batch_stark::ProverData;\nuse p3_circuit::op::{NonPrimitiveOpPrivateData, NonPrimitiveOpType};\nuse p3_circuit::ops::{Poseidon2PermPrivateData, generate_poseidon2_trace};\nuse p3_circuit::{CircuitBuilder, ExprId, Poseidon2PermOps};\nuse p3_circuit_prover::common::{NonPrimitiveConfig, get_airs_and_degrees_with_prep};\nuse p3_circuit_prover::config::BabyBearConfig;\nuse p3_circuit_prover::{\n    BatchStarkProver, CircuitProverData, ConstraintProfile, Poseidon2Config, TablePacking, config,\n};\nuse p3_field::extension::BinomialExtensionField;\nuse p3_field::{BasedVectorSpace, PrimeCharacteristicRing};\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\nuse p3_symmetric::Permutation;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n/// Initializes a global logger with default parameters.\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\ntype Base = BabyBear;\ntype Ext4 = BinomialExtensionField\u003cBase, 4\u003e;\n\nconst LIMB_SIZE: usize = 4;\nconst WIDTH: usize = 16;\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    init_logger();\n\n    // Three-row Merkle path example (2 levels):\n    // Row 0: permutation input is leaf || sibling0. merkle_path = true, new_start = true, mmcs_bit = 0\n    // Row 1: merkle_path = true, new_start = false, mmcs_bit = 1 (previous hash becomes right child),\n    //        input limbs 2-3 get prev row's output limbs 0-1; input limbs 0-1 take sibling1 as private inputs.\n    // Row 2: merkle_path = true, new_start = false, mmcs_bit = 0 (previous hash becomes left child),\n    //        input limbs 0-1 get prev row's output limbs 0-1; input limbs 2-3 take sibling2 as private inputs.\n    //\n    // Tree shape (limb ranges = base-field coeff slices of Ext4):\n    //          root (row2 out)\n    //         /                 \\\n    //   row2 left (row1 out)   sibling2 [25..32]\n    //      /          \\\n    // sibling1 [17..24]  row0 out\n    //                     /     \\\n    //               leaf [1..8]  sibling0 [9..16]\n    //\n    // We expose final digest limbs 0-1 as public inputs and the mmcs_index_sum (should be binary 010 = 2).\n\n    let perm = default_babybear_poseidon2_16();\n\n    // Build leaf and siblings as extension limbs.\n    let leaf_limb0 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(1),\n        Base::from_u64(2),\n        Base::from_u64(3),\n        Base::from_u64(4),\n    ])\n    .expect(\"extension from coeffs\");\n    let leaf_limb1 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(5),\n        Base::from_u64(6),\n        Base::from_u64(7),\n        Base::from_u64(8),\n    ])\n    .expect(\"extension from coeffs\");\n    let sibling0_limb2 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(9),\n        Base::from_u64(10),\n        Base::from_u64(11),\n        Base::from_u64(12),\n    ])\n    .expect(\"extension from coeffs\");\n    let sibling0_limb3 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(13),\n        Base::from_u64(14),\n        Base::from_u64(15),\n        Base::from_u64(16),\n    ])\n    .expect(\"extension from coeffs\");\n\n    let sibling1_limb2 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(17),\n        Base::from_u64(18),\n        Base::from_u64(19),\n        Base::from_u64(20),\n    ])\n    .expect(\"extension from coeffs\");\n    let sibling1_limb3 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(21),\n        Base::from_u64(22),\n        Base::from_u64(23),\n        Base::from_u64(24),\n    ])\n    .expect(\"extension from coeffs\");\n    let sibling2_limb2 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(25),\n        Base::from_u64(26),\n        Base::from_u64(27),\n        Base::from_u64(28),\n    ])\n    .expect(\"extension from coeffs\");\n    let sibling2_limb3 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(29),\n        Base::from_u64(30),\n        Base::from_u64(31),\n        Base::from_u64(32),\n    ])\n    .expect(\"extension from coeffs\");\n\n    // Native row 0 permutation: hash(leaf limbs, sibling0 limbs)\n    let row0_state = [leaf_limb0, leaf_limb1, sibling0_limb2, sibling0_limb3];\n    let row0_state_base = flatten_ext_limbs(\u0026row0_state);\n    let row0_out_base = perm.permute(row0_state_base);\n\n    // Row 1 chaining: mmcs_bit = 1, so previous hash becomes right child.\n    // Previous digest (out[0..1]) chains into limbs 2-3; sibling1 provides limbs 0-1.\n    let mut row1_state_base = [Base::ZERO; WIDTH];\n    // limbs 0-1 from sibling1\n    let sibling1_flat: [Base; 2 * LIMB_SIZE] = flatten_ext_limbs(\u0026[sibling1_limb2, sibling1_limb3]);\n    row1_state_base[0..2 * LIMB_SIZE].copy_from_slice(\u0026sibling1_flat);\n    // limbs 2-3 from row0 output limbs 0-1\n    row1_state_base[2 * LIMB_SIZE..4 * LIMB_SIZE].copy_from_slice(\u0026row0_out_base[0..2 * LIMB_SIZE]);\n\n    let row1_out_base = perm.permute(row1_state_base);\n\n    // Row 2 chaining: mmcs_bit = 0, so previous hash becomes left child (limbs 0-1 get prev_out[0..2])\n    // limbs 2-3 from sibling2\n    let mut row2_state_base = [Base::ZERO; WIDTH];\n    row2_state_base[0..2 * LIMB_SIZE].copy_from_slice(\u0026row1_out_base[0..2 * LIMB_SIZE]);\n    let sibling2_flat: [Base; 2 * LIMB_SIZE] = flatten_ext_limbs(\u0026[sibling2_limb2, sibling2_limb3]);\n    row2_state_base[2 * LIMB_SIZE..4 * LIMB_SIZE].copy_from_slice(\u0026sibling2_flat);\n\n    let row2_out_base = perm.permute(row2_state_base);\n    let row2_out_limbs = collect_ext_limbs(\u0026row2_out_base);\n\n    // mmcs_index_sum should be 2 (bits: row1=1, row2=0)\n    let mmcs_index_sum_row2 = Base::from_u64(2);\n\n    // Build circuit\n    let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n    builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cExt4, BabyBearD4Width16\u003e,\n        perm,\n    );\n\n    // Row 0: expose all inputs\n    let mmcs_bit_row0 = builder.alloc_const(Ext4::from_prime_subfield(Base::ZERO), \"mmcs_bit_row0\");\n    let inputs_row0: [ExprId; 4] = [\n        builder.alloc_const(row0_state[0], \"leaf0\"),\n        builder.alloc_const(row0_state[1], \"leaf1\"),\n        builder.alloc_const(row0_state[2], \"sibling0_2\"),\n        builder.alloc_const(row0_state[3], \"sibling0_3\"),\n    ];\n\n    let (_row0_op_id, _row0_outputs) =\n        builder.add_poseidon2_perm(p3_circuit::ops::Poseidon2PermCall {\n            config: Poseidon2Config::BabyBearD4Width16,\n            new_start: true,\n            merkle_path: true,\n            mmcs_bit: Some(mmcs_bit_row0),\n            inputs: inputs_row0.map(Some),\n            out_ctl: [false, false],\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })?;\n\n    // Row 1: Merkle right. Chain previous digest into limbs 2-3 and provide sibling1 in limbs 0-1.\n    // All inputs are private (chained from row 0 or provided via private data)\n    let sibling1_inputs: [Option\u003cExprId\u003e; 4] = [None, None, None, None];\n    // Public root limbs\n    let out0 = builder.public_input();\n    let out1 = builder.public_input();\n    let mmcs_idx_sum_expr = builder.public_input();\n\n    let mmcs_bit_row1 = builder.alloc_const(Ext4::from_prime_subfield(Base::ONE), \"mmcs_bit_row1\");\n    let (row1_op_id, _row1_outputs) =\n        builder.add_poseidon2_perm(p3_circuit::ops::Poseidon2PermCall {\n            config: Poseidon2Config::BabyBearD4Width16,\n            new_start: false,\n            merkle_path: true,\n            mmcs_bit: Some(mmcs_bit_row1),\n            inputs: sibling1_inputs,\n            out_ctl: [false, false],\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })?;\n\n    // Row 2: merkle left - all inputs private (chained from row 1 or provided via private data)\n    let mmcs_bit_row2 = builder.alloc_const(Ext4::from_prime_subfield(Base::ZERO), \"mmcs_bit_row2\");\n    let sibling2_inputs: [Option\u003cExprId\u003e; 4] = [None, None, None, None];\n    let (row2_op_id, row2_outputs) =\n        builder.add_poseidon2_perm(p3_circuit::ops::Poseidon2PermCall {\n            config: Poseidon2Config::BabyBearD4Width16,\n            new_start: false,\n            merkle_path: true,\n            mmcs_bit: Some(mmcs_bit_row2),\n            inputs: sibling2_inputs,\n            out_ctl: [true, true],\n            return_all_outputs: false,\n            mmcs_index_sum: Some(mmcs_idx_sum_expr),\n        })?;\n    let row2_out0 = row2_outputs[0].ok_or(\"missing row2 out0\")?;\n    let row2_out1 = row2_outputs[1].ok_or(\"missing row2 out1\")?;\n    builder.connect(row2_out0, out0);\n    builder.connect(row2_out1, out1);\n\n    let circuit = builder.build()?;\n    let table_packing = TablePacking::new(4, 4, 4);\n    let poseidon2_config = Poseidon2Config::BabyBearD4Width16;\n    let stark_config = config::baby_bear().build();\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cBabyBearConfig, _, 4\u003e(\n            \u0026circuit,\n            table_packing,\n            Some(\u0026[NonPrimitiveConfig::Poseidon2(poseidon2_config)]),\n            ConstraintProfile::Standard,\n        )?;\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n\n    let mut runner = circuit.runner();\n    runner.set_public_inputs(\u0026[\n        row2_out_limbs[0],\n        row2_out_limbs[1],\n        Ext4::from_prime_subfield(mmcs_index_sum_row2),\n    ])?;\n\n    // Set private inputs for Row 1\n    // Row 1: mmcs_bit = 1 (Right Child). Previous digest chains from previous row.\n    // For Merkle mode, provide the sibling (2 limbs). Internal logic handles placement.\n    runner.set_private_data(\n        row1_op_id,\n        NonPrimitiveOpPrivateData::Poseidon2Perm(Poseidon2PermPrivateData {\n            sibling: [sibling1_limb2, sibling1_limb3],\n        }),\n    )?;\n\n    // Set private inputs for Row 2\n    // Row 2: mmcs_bit = 0 (Left Child). Previous digest chains from previous row.\n    // For Merkle mode, provide the sibling (2 limbs). Internal logic handles placement.\n    runner.set_private_data(\n        row2_op_id,\n        NonPrimitiveOpPrivateData::Poseidon2Perm(Poseidon2PermPrivateData {\n            sibling: [sibling2_limb2, sibling2_limb3],\n        }),\n    )?;\n\n    let traces = runner.run()?;\n\n    // Check Poseidon2 trace rows and mmcs_index_sum exposure\n    let poseidon2_trace = traces\n        .non_primitive_trace::\u003cp3_circuit::ops::Poseidon2Trace\u003cBase\u003e\u003e(\n            NonPrimitiveOpType::Poseidon2Perm(Poseidon2Config::BabyBearD4Width16),\n        )\n        .expect(\"poseidon2 trace missing\");\n    assert_eq!(poseidon2_trace.total_rows(), 3, \"expected three perm rows\");\n\n    let prover_data = ProverData::from_airs_and_degrees(\u0026stark_config, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    assert!(\n        !circuit_prover_data.common_data().lookups[4].is_empty(),\n        \"Poseidon2 table should have lookups\"\n    );\n\n    let mut prover = BatchStarkProver::new(stark_config).with_table_packing(table_packing);\n    prover.register_poseidon2_table(poseidon2_config);\n\n    let proof = prover.prove_all_tables(\u0026traces, \u0026circuit_prover_data)?;\n    prover.verify_all_tables(\u0026proof, circuit_prover_data.common_data())?;\n\n    Ok(())\n}\n\nfn flatten_ext_limbs\u003cconst N: usize, const M: usize\u003e(limbs: \u0026[Ext4; N]) -\u003e [Base; M] {\n    let mut out = [Base::ZERO; M];\n    for (i, limb) in limbs.iter().enumerate() {\n        let coeffs = limb.as_basis_coefficients_slice();\n        let start = i * LIMB_SIZE;\n        let end = (start + LIMB_SIZE).min(M);\n        out[start..end].copy_from_slice(\u0026coeffs[0..(end - start)]);\n    }\n    out\n}\n\nfn collect_ext_limbs(state: \u0026[Base; WIDTH]) -\u003e [Ext4; 4] {\n    let mut limbs = [Ext4::ZERO; 4];\n    for i in 0..4 {\n        let chunk = \u0026state[i * LIMB_SIZE..(i + 1) * LIMB_SIZE];\n        limbs[i] = Ext4::from_basis_coefficients_slice(chunk).unwrap();\n    }\n    limbs\n}\n","traces":[{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","alu_air.rs"],"content":"//! [`AluAir`] defines the unified AIR for proving arithmetic operations over both base and extension fields.\n//!\n//! This AIR combines addition, multiplication, boolean checks, and fused multiply-add operations\n//! into a single table, reducing the number of table commitments in the proof.\n//!\n//! Conceptually, each row of the trace encodes one or more arithmetic constraints based on\n//! preprocessed operation selectors:\n//!\n//! - **ADD**: `a + b = out`\n//! - **MUL**: `a * b = out`\n//! - **BOOL_CHECK**: `a * (a - 1) = 0`, `out = a`\n//! - **MUL_ADD**: `a * b + c = out`\n//!\n//! # Column layout\n//!\n//! For each logical operation (lane) we allocate `4 * D` main columns:\n//!\n//! - `D` columns for operand `a` (basis coefficients),\n//! - `D` columns for operand `b` (basis coefficients),\n//! - `D` columns for operand `c` (basis coefficients, only used for MulAdd),\n//! - `D` columns for output `out` (basis coefficients).\n//!\n//! Preprocessed columns per lane:\n//!\n//! - 1 column for multiplicity (1 for real ops, 0 for padding),\n//! - 3 columns for operation selectors:\n//!   - `sel_add_vs_mul` (1 = Add, 0 = Mul when `sel_bool = sel_muladd = 0`)\n//!   - `sel_bool` (1 = BoolCheck),\n//!   - `sel_muladd` (1 = MulAdd),\n//! - 4 columns for operand indices (a_idx, b_idx, c_idx, out_idx).\n//!\n//! # Constraints (degree ≤ 3)\n//!\n//! All constraint degrees are within the limit for `log_blowup = 1`:\n//!\n//! - ADD: `a + b - out = 0` (degree 1)\n//! - MUL: `a * b - out = 0` (degree 2)\n//! - BOOL_CHECK: `a * (a - 1) = 0` (degree 2)\n//! - MUL_ADD: `a * b + c - out = 0` (degree 2)\n\nuse alloc::string::ToString;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::marker::PhantomData;\n\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues, BaseAir, PermutationAirBuilder};\nuse p3_circuit::op::AluOpKind;\nuse p3_circuit::tables::AluTrace;\nuse p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing};\nuse p3_lookup::lookup_traits::{Direction, Kind, Lookup};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\n\nuse crate::air::utils::{\n    create_chunked_preprocessed_trace, create_symbolic_variables, get_alu_index_lookups,\n};\n\n/// AIR for proving unified arithmetic operations.\n///\n/// Supports ADD, MUL, BOOL_CHECK, and MUL_ADD operations with preprocessed selectors.\n#[derive(Debug, Clone)]\npub struct AluAir\u003cF, const D: usize = 1\u003e {\n    /// Total number of logical ALU operations in the trace.\n    pub num_ops: usize,\n    /// Number of independent operations packed per trace row.\n    pub lanes: usize,\n    /// For binomial extensions x^D = W (D \u003e 1).\n    pub w_binomial: Option\u003cF\u003e,\n    /// Flattened preprocessed values (selectors + indices).\n    pub preprocessed: Vec\u003cF\u003e,\n    /// Number of lookup columns registered so far.\n    pub num_lookup_columns: usize,\n    /// Minimum trace height (for FRI compatibility with higher log_final_poly_len).\n    pub min_height: usize,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field + PrimeCharacteristicRing, const D: usize\u003e AluAir\u003cF, D\u003e {\n    /// Construct a new `AluAir` for base-field operations (D=1).\n    pub const fn new(num_ops: usize, lanes: usize) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        assert!(D == 1, \"Use new_binomial for D \u003e 1\");\n        Self {\n            num_ops,\n            lanes,\n            w_binomial: None,\n            preprocessed: Vec::new(),\n            num_lookup_columns: 0,\n            min_height: 1,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Construct a new `AluAir` for base-field operations with preprocessed data.\n    pub const fn new_with_preprocessed(num_ops: usize, lanes: usize, preprocessed: Vec\u003cF\u003e) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        assert!(D == 1, \"Use new_binomial_with_preprocessed for D \u003e 1\");\n        Self {\n            num_ops,\n            lanes,\n            w_binomial: None,\n            preprocessed,\n            num_lookup_columns: 0,\n            min_height: 1,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Construct a new `AluAir` for binomial extension-field operations (D \u003e 1).\n    pub const fn new_binomial(num_ops: usize, lanes: usize, w: F) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        assert!(D \u003e= 2, \"Binomial constructor requires D \u003e= 2\");\n        Self {\n            num_ops,\n            lanes,\n            w_binomial: Some(w),\n            preprocessed: Vec::new(),\n            num_lookup_columns: 0,\n            min_height: 1,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Construct a new `AluAir` for binomial extension-field operations with preprocessed data.\n    pub const fn new_binomial_with_preprocessed(\n        num_ops: usize,\n        lanes: usize,\n        w: F,\n        preprocessed: Vec\u003cF\u003e,\n    ) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        assert!(D \u003e= 2, \"Binomial constructor requires D \u003e= 2\");\n        Self {\n            num_ops,\n            lanes,\n            w_binomial: Some(w),\n            preprocessed,\n            num_lookup_columns: 0,\n            min_height: 1,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Set the minimum trace height for FRI compatibility.\n    ///\n    /// FRI requires: `log_trace_height \u003e log_final_poly_len + log_blowup`\n    /// So `min_height` should be \u003e= `2^(log_final_poly_len + log_blowup + 1)`.\n    pub const fn with_min_height(mut self, min_height: usize) -\u003e Self {\n        self.min_height = min_height;\n        self\n    }\n\n    /// Number of main columns per lane: a[D], b[D], c[D], out[D]\n    pub const fn lane_width() -\u003e usize {\n        4 * D\n    }\n\n    /// Total main trace width for this AIR instance.\n    pub const fn total_width(\u0026self) -\u003e usize {\n        self.lanes * Self::lane_width()\n    }\n\n    /// Number of preprocessed columns per lane:\n    /// - 1 multiplicity\n    /// - 3 selectors:\n    ///   - 1 bit for Add vs Mul (when Bool/MulAdd are 0)\n    ///   - 1 for BoolCheck\n    ///   - 1 for MulAdd\n    /// - 4 indices (a, b, c, out)\n    pub const fn preprocessed_lane_width() -\u003e usize {\n        8\n    }\n\n    /// Total preprocessed width for this AIR instance.\n    pub const fn preprocessed_width(\u0026self) -\u003e usize {\n        self.lanes * Self::preprocessed_lane_width()\n    }\n\n    /// Number of preprocessed columns excluding multiplicity.\n    pub const fn preprocessed_width_without_multiplicity(\u0026self) -\u003e usize {\n        self.lanes * (Self::preprocessed_lane_width() - 1)\n    }\n\n    /// Convert an `AluTrace` into a `RowMajorMatrix` suitable for the STARK prover.\n    pub fn trace_to_matrix\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(\n        trace: \u0026AluTrace\u003cExtF\u003e,\n        lanes: usize,\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n\n        let lane_width = Self::lane_width();\n        let width = lane_width * lanes;\n        let op_count = trace.a_values.len();\n        let row_count = op_count.div_ceil(lanes);\n\n        let mut values = F::zero_vec(width * row_count.max(1));\n\n        for (op_idx, (((a_val, b_val), c_val), out_val)) in trace\n            .a_values\n            .iter()\n            .zip(trace.b_values.iter())\n            .zip(trace.c_values.iter())\n            .zip(trace.out_values.iter())\n            .enumerate()\n        {\n            let row = op_idx / lanes;\n            let lane = op_idx % lanes;\n            let mut cursor = (row * width) + (lane * lane_width);\n\n            // Write a[D]\n            let a_coeffs = a_val.as_basis_coefficients_slice();\n            assert_eq!(a_coeffs.len(), D, \"Extension field degree mismatch for a\");\n            values[cursor..cursor + D].copy_from_slice(a_coeffs);\n            cursor += D;\n\n            // Write b[D]\n            let b_coeffs = b_val.as_basis_coefficients_slice();\n            assert_eq!(b_coeffs.len(), D, \"Extension field degree mismatch for b\");\n            values[cursor..cursor + D].copy_from_slice(b_coeffs);\n            cursor += D;\n\n            // Write c[D]\n            let c_coeffs = c_val.as_basis_coefficients_slice();\n            assert_eq!(c_coeffs.len(), D, \"Extension field degree mismatch for c\");\n            values[cursor..cursor + D].copy_from_slice(c_coeffs);\n            cursor += D;\n\n            // Write out[D]\n            let out_coeffs = out_val.as_basis_coefficients_slice();\n            assert_eq!(\n                out_coeffs.len(),\n                D,\n                \"Extension field degree mismatch for out\"\n            );\n            values[cursor..cursor + D].copy_from_slice(out_coeffs);\n        }\n\n        let mut mat = RowMajorMatrix::new(values, width);\n        mat.pad_to_power_of_two_height(F::ZERO);\n        mat\n    }\n\n    /// Convert an `AluTrace` to preprocessed values.\n    /// Layout per op (without multiplicity):\n    /// [sel_add_vs_mul, sel_bool, sel_muladd, a_idx, b_idx, c_idx, out_idx]\n    pub fn trace_to_preprocessed\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(trace: \u0026AluTrace\u003cExtF\u003e) -\u003e Vec\u003cF\u003e {\n        let total_len = trace.a_index.len() * (Self::preprocessed_lane_width() - 1);\n        let mut preprocessed_values = Vec::with_capacity(total_len);\n\n        for (i, kind) in trace.op_kind.iter().enumerate() {\n            // Selectors encoded as:\n            // - sel_add_vs_mul: 1 for Add, 0 for Mul (when Bool/MulAdd are 0)\n            // - sel_bool: 1 for BoolCheck\n            // - sel_muladd: 1 for MulAdd\n            let (sel_add_vs_mul, sel_bool, sel_muladd) = match kind {\n                AluOpKind::Add =\u003e (F::ONE, F::ZERO, F::ZERO),\n                AluOpKind::Mul =\u003e (F::ZERO, F::ZERO, F::ZERO),\n                AluOpKind::BoolCheck =\u003e (F::ZERO, F::ONE, F::ZERO),\n                AluOpKind::MulAdd =\u003e (F::ZERO, F::ZERO, F::ONE),\n            };\n\n            preprocessed_values.extend(\u0026[\n                sel_add_vs_mul,\n                sel_bool,\n                sel_muladd,\n                F::from_u32(trace.a_index[i].0),\n                F::from_u32(trace.b_index[i].0),\n                F::from_u32(trace.c_index[i].0),\n                F::from_u32(trace.out_index[i].0),\n            ]);\n        }\n\n        preprocessed_values\n    }\n}\n\nimpl\u003cF: Field, const D: usize\u003e BaseAir\u003cF\u003e for AluAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        self.total_width()\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\n        if self.num_ops \u003e 0 {\n            assert!(!self.preprocessed.is_empty());\n        }\n\n        Some(create_chunked_preprocessed_trace(\n            \u0026self.preprocessed,\n            Self::preprocessed_lane_width(),\n            self.lanes,\n            self.min_height,\n        ))\n    }\n}\n\nimpl\u003cAB: AirBuilder, const D: usize\u003e Air\u003cAB\u003e for AluAir\u003cAB::F, D\u003e\nwhere\n    AB::F: Field,\n{\n    #[allow(clippy::needless_range_loop)]\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n        debug_assert_eq!(main.width(), self.total_width(), \"column width mismatch\");\n\n        let local = main.row_slice(0).expect(\"matrix must be non-empty\");\n        let lane_width = Self::lane_width();\n\n        // Get preprocessed columns\n        let preprocessed = builder\n            .preprocessed()\n            .expect(\"AluAir requires preprocessed trace\");\n        let preprocessed_local = preprocessed\n            .row_slice(0)\n            .expect(\"preprocessed must be non-empty\");\n        let preprocessed_lane_width = Self::preprocessed_lane_width();\n\n        // D=1 specialization\n        if D == 1 {\n            debug_assert_eq!(lane_width, 4);\n\n            for lane in 0..self.lanes {\n                let main_offset = lane * lane_width;\n                let prep_offset = lane * preprocessed_lane_width;\n\n                let a = local[main_offset].clone();\n                let b = local[main_offset + 1].clone();\n                let c = local[main_offset + 2].clone();\n                let out = local[main_offset + 3].clone();\n\n                // Multiplicity and selectors from preprocessed:\n                // layout per lane: [m, sel_add_vs_mul, sel_bool, sel_muladd, a_idx, b_idx, c_idx, out_idx]\n                let multiplicity = preprocessed_local[prep_offset].clone();\n                let sel_add_vs_mul = preprocessed_local[prep_offset + 1].clone();\n                let sel_bool = preprocessed_local[prep_offset + 2].clone();\n                let sel_muladd = preprocessed_local[prep_offset + 3].clone();\n\n                // Derive MUL selector linearly:\n                // sel_mul = m - sel_bool - sel_muladd - sel_add_vs_mul\n                let sel_mul = multiplicity.clone()\n                    - sel_bool.clone()\n                    - sel_muladd.clone()\n                    - sel_add_vs_mul.clone();\n\n                // ADD constraint: sel_add_vs_mul * (a + b - out) = 0\n                builder.assert_zero(sel_add_vs_mul.clone() * (a.clone() + b.clone() - out.clone()));\n\n                // MUL constraint: sel_mul * (a * b - out) = 0\n                builder.assert_zero(sel_mul.clone() * (a.clone() * b.clone() - out.clone()));\n\n                // BOOL_CHECK constraint: sel_bool * a * (a - 1) = 0\n                let one = AB::Expr::ONE;\n                builder.assert_zero(sel_bool.clone() * a.clone() * (a.clone() - one.clone()));\n\n                // MUL_ADD constraint: sel_muladd * (a * b + c - out) = 0\n                builder.assert_zero(\n                    sel_muladd.clone() * (a.clone() * b.clone() + c.clone() - out.clone()),\n                );\n            }\n        } else {\n            // Extension field case (D \u003e 1)\n            let w = self\n                .w_binomial\n                .as_ref()\n                .map(|w| AB::Expr::from(*w))\n                .expect(\"AluAir with D\u003e1 requires binomial parameter W\");\n\n            for lane in 0..self.lanes {\n                let main_offset = lane * lane_width;\n                let prep_offset = lane * preprocessed_lane_width;\n\n                let a_slice = \u0026local[main_offset..main_offset + D];\n                let b_slice = \u0026local[main_offset + D..main_offset + 2 * D];\n                let c_slice = \u0026local[main_offset + 2 * D..main_offset + 3 * D];\n                let out_slice = \u0026local[main_offset + 3 * D..main_offset + 4 * D];\n\n                // Multiplicity and selectors from preprocessed:\n                // layout per lane: [m, sel_add_vs_mul, sel_bool, sel_muladd, a_idx, b_idx, c_idx, out_idx]\n                let multiplicity = preprocessed_local[prep_offset].clone();\n                let sel_add_vs_mul = preprocessed_local[prep_offset + 1].clone();\n                let sel_bool = preprocessed_local[prep_offset + 2].clone();\n                let sel_muladd = preprocessed_local[prep_offset + 3].clone();\n\n                // Derive MUL selector linearly:\n                // sel_mul = m - sel_bool - sel_muladd - sel_add_vs_mul\n                let sel_mul = multiplicity.clone()\n                    - sel_bool.clone()\n                    - sel_muladd.clone()\n                    - sel_add_vs_mul.clone();\n\n                // ADD constraints: sel_add_vs_mul * (a[i] + b[i] - out[i]) = 0\n                for i in 0..D {\n                    builder.assert_zero(\n                        sel_add_vs_mul.clone()\n                            * (a_slice[i].clone() + b_slice[i].clone() - out_slice[i].clone()),\n                    );\n                }\n\n                // MUL constraints: extension field multiplication\n                let mut mul_acc = vec![AB::Expr::ZERO; D];\n                for i in 0..D {\n                    for j in 0..D {\n                        let term = a_slice[i].clone() * b_slice[j].clone();\n                        let k = i + j;\n                        if k \u003c D {\n                            mul_acc[k] = mul_acc[k].clone() + term;\n                        } else {\n                            mul_acc[k - D] = mul_acc[k - D].clone() + w.clone() * term;\n                        }\n                    }\n                }\n                for i in 0..D {\n                    builder\n                        .assert_zero(sel_mul.clone() * (mul_acc[i].clone() - out_slice[i].clone()));\n                }\n\n                // BOOL_CHECK constraints: sel_bool * a[i] * (a[i] - 1) = 0 for i=0 only (base component)\n                // For extension fields, boolean check only makes sense on the base component\n                let one = AB::Expr::ONE;\n                builder.assert_zero(\n                    sel_bool.clone() * a_slice[0].clone() * (a_slice[0].clone() - one.clone()),\n                );\n\n                // MUL_ADD constraints: a * b + c = out (extension field)\n                let mut muladd_acc = vec![AB::Expr::ZERO; D];\n                for i in 0..D {\n                    for j in 0..D {\n                        let term = a_slice[i].clone() * b_slice[j].clone();\n                        let k = i + j;\n                        if k \u003c D {\n                            muladd_acc[k] = muladd_acc[k].clone() + term;\n                        } else {\n                            muladd_acc[k - D] = muladd_acc[k - D].clone() + w.clone() * term;\n                        }\n                    }\n                }\n                // Add c component-wise\n                for i in 0..D {\n                    muladd_acc[i] = muladd_acc[i].clone() + c_slice[i].clone();\n                }\n                for i in 0..D {\n                    builder.assert_zero(\n                        sel_muladd.clone() * (muladd_acc[i].clone() - out_slice[i].clone()),\n                    );\n                }\n            }\n        }\n    }\n\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        let new_idx = self.num_lookup_columns;\n        self.num_lookup_columns += 1;\n        vec![new_idx]\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cAB\u003e::F\u003e\u003e\n    where\n        AB: PermutationAirBuilder + AirBuilderWithPublicValues,\n    {\n        let mut lookups = Vec::new();\n        self.num_lookup_columns = 0;\n\n        let (symbolic_main_local, preprocessed_local) = create_symbolic_variables::\u003cAB::F\u003e(\n            self.preprocessed_width(),\n            BaseAir::\u003cAB::F\u003e::width(self),\n            0,\n            0,\n        );\n\n        for lane in 0..self.lanes {\n            let lane_offset = lane * Self::lane_width();\n            let preprocessed_lane_offset = lane * Self::preprocessed_lane_width();\n\n            // 4 lookups per lane: a, b, c, out\n            let lane_lookup_inputs = get_alu_index_lookups::\u003cAB, D\u003e(\n                lane_offset,\n                preprocessed_lane_offset,\n                \u0026symbolic_main_local,\n                \u0026preprocessed_local,\n                Direction::Send,\n            );\n            lookups.extend(lane_lookup_inputs.into_iter().map(|inps| {\n                \u003cSelf as Air\u003cAB\u003e\u003e::register_lookup(\n                    self,\n                    Kind::Global(\"WitnessChecks\".to_string()),\n                    \u0026[inps],\n                )\n            }));\n        }\n        lookups\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n    use alloc::vec::Vec;\n\n    use p3_baby_bear::BabyBear as Val;\n    use p3_circuit::WitnessId;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_uni_stark::{prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed};\n    use p3_util::log2_ceil_usize;\n\n    use super::*;\n    use crate::air::test_utils::build_test_config;\n\n    #[test]\n    fn prove_verify_alu_add_base_field() {\n        let n = 8;\n        let a_values = vec![Val::from_u64(3); n];\n        let b_values = vec![Val::from_u64(5); n];\n        let c_values = vec![Val::ZERO; n];\n        let out_values = vec![Val::from_u64(8); n];\n        let op_kind = vec![AluOpKind::Add; n];\n        let a_index = vec![WitnessId(1); n];\n        let b_index = vec![WitnessId(2); n];\n        let c_index = vec![WitnessId(0); n];\n        let out_index = vec![WitnessId(3); n];\n\n        let trace = AluTrace {\n            op_kind,\n            a_values,\n            a_index,\n            b_values,\n            b_index,\n            c_values,\n            c_index,\n            out_values,\n            out_index,\n        };\n\n        let preprocessed_values = AluAir::\u003cVal, 1\u003e::trace_to_preprocessed(\u0026trace);\n        let matrix: RowMajorMatrix\u003cVal\u003e = AluAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n        assert_eq!(matrix.width(), 4);\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let air = AluAir::\u003cVal, 1\u003e::new_with_preprocessed(n, 1, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"verification failed\");\n    }\n\n    #[test]\n    fn prove_verify_alu_mul_base_field() {\n        let n = 8;\n        let a_values = vec![Val::from_u64(3); n];\n        let b_values = vec![Val::from_u64(5); n];\n        let c_values = vec![Val::ZERO; n];\n        let out_values = vec![Val::from_u64(15); n];\n        let op_kind = vec![AluOpKind::Mul; n];\n        let a_index = vec![WitnessId(1); n];\n        let b_index = vec![WitnessId(2); n];\n        let c_index = vec![WitnessId(0); n];\n        let out_index = vec![WitnessId(3); n];\n\n        let trace = AluTrace {\n            op_kind,\n            a_values,\n            a_index,\n            b_values,\n            b_index,\n            c_values,\n            c_index,\n            out_values,\n            out_index,\n        };\n\n        let preprocessed_values = AluAir::\u003cVal, 1\u003e::trace_to_preprocessed(\u0026trace);\n        let matrix: RowMajorMatrix\u003cVal\u003e = AluAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let air = AluAir::\u003cVal, 1\u003e::new_with_preprocessed(n, 1, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"verification failed\");\n    }\n\n    #[test]\n    fn prove_verify_alu_bool_check() {\n        let n = 8;\n        // Test with valid boolean values (0 and 1)\n        let a_values: Vec\u003cVal\u003e = (0..n).map(|i| Val::from_u64(i as u64 % 2)).collect();\n        let b_values = vec![Val::ZERO; n]; // unused for bool check\n        let c_values = vec![Val::ZERO; n];\n        let out_values = a_values.clone(); // out = a for bool check\n        let op_kind = vec![AluOpKind::BoolCheck; n];\n        let a_index = vec![WitnessId(1); n];\n        let b_index = vec![WitnessId(0); n];\n        let c_index = vec![WitnessId(0); n];\n        let out_index = vec![WitnessId(1); n]; // out points to same as a\n\n        let trace = AluTrace {\n            op_kind,\n            a_values,\n            a_index,\n            b_values,\n            b_index,\n            c_values,\n            c_index,\n            out_values,\n            out_index,\n        };\n\n        let preprocessed_values = AluAir::\u003cVal, 1\u003e::trace_to_preprocessed(\u0026trace);\n        let matrix: RowMajorMatrix\u003cVal\u003e = AluAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let air = AluAir::\u003cVal, 1\u003e::new_with_preprocessed(n, 1, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"verification failed\");\n    }\n\n    #[test]\n    fn prove_verify_alu_muladd() {\n        let n = 8;\n        // a * b + c = out =\u003e 3 * 5 + 2 = 17\n        let a_values = vec![Val::from_u64(3); n];\n        let b_values = vec![Val::from_u64(5); n];\n        let c_values = vec![Val::from_u64(2); n];\n        let out_values = vec![Val::from_u64(17); n];\n        let op_kind = vec![AluOpKind::MulAdd; n];\n        let a_index = vec![WitnessId(1); n];\n        let b_index = vec![WitnessId(2); n];\n        let c_index = vec![WitnessId(3); n];\n        let out_index = vec![WitnessId(4); n];\n\n        let trace = AluTrace {\n            op_kind,\n            a_values,\n            a_index,\n            b_values,\n            b_index,\n            c_values,\n            c_index,\n            out_values,\n            out_index,\n        };\n\n        let preprocessed_values = AluAir::\u003cVal, 1\u003e::trace_to_preprocessed(\u0026trace);\n        let matrix: RowMajorMatrix\u003cVal\u003e = AluAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let air = AluAir::\u003cVal, 1\u003e::new_with_preprocessed(n, 1, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"verification failed\");\n    }\n\n    #[test]\n    fn prove_verify_alu_mixed_ops() {\n        // Mix of ADD and MUL operations\n        let a_vals = vec![Val::from_u64(3), Val::from_u64(4)];\n        let b_vals = vec![Val::from_u64(5), Val::from_u64(6)];\n        let c_vals = vec![Val::ZERO, Val::ZERO];\n        let out_vals = vec![Val::from_u64(8), Val::from_u64(24)]; // 3+5=8, 4*6=24\n        let ops = vec![AluOpKind::Add, AluOpKind::Mul];\n\n        let trace = AluTrace {\n            op_kind: ops,\n            a_values: a_vals,\n            a_index: vec![WitnessId(0), WitnessId(1)],\n            b_values: b_vals,\n            b_index: vec![WitnessId(2), WitnessId(3)],\n            c_values: c_vals,\n            c_index: vec![WitnessId(0), WitnessId(0)],\n            out_values: out_vals,\n            out_index: vec![WitnessId(4), WitnessId(5)],\n        };\n\n        let preprocessed_values = AluAir::\u003cVal, 1\u003e::trace_to_preprocessed(\u0026trace);\n        let matrix: RowMajorMatrix\u003cVal\u003e = AluAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let air = AluAir::\u003cVal, 1\u003e::new_with_preprocessed(2, 1, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"verification failed\");\n    }\n\n    #[test]\n    fn prove_verify_alu_extension_field_d4() {\n        type ExtField = BinomialExtensionField\u003cVal, 4\u003e;\n        let n = 4;\n\n        let a = ExtField::from_basis_coefficients_slice(\u0026[\n            Val::from_u64(7),\n            Val::from_u64(3),\n            Val::from_u64(4),\n            Val::from_u64(5),\n        ])\n        .unwrap();\n\n        let b = ExtField::from_basis_coefficients_slice(\u0026[\n            Val::from_u64(11),\n            Val::from_u64(2),\n            Val::from_u64(9),\n            Val::from_u64(6),\n        ])\n        .unwrap();\n\n        let c = ExtField::ZERO;\n        let out = a * b; // multiplication result\n\n        let trace = AluTrace {\n            op_kind: vec![AluOpKind::Mul; n],\n            a_values: vec![a; n],\n            a_index: vec![WitnessId(1); n],\n            b_values: vec![b; n],\n            b_index: vec![WitnessId(2); n],\n            c_values: vec![c; n],\n            c_index: vec![WitnessId(0); n],\n            out_values: vec![out; n],\n            out_index: vec![WitnessId(3); n],\n        };\n\n        let preprocessed_values = AluAir::\u003cVal, 4\u003e::trace_to_preprocessed(\u0026trace);\n        let matrix: RowMajorMatrix\u003cVal\u003e = AluAir::\u003cVal, 4\u003e::trace_to_matrix(\u0026trace, 1);\n        assert_eq!(matrix.width(), AluAir::\u003cVal, 4\u003e::lane_width());\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        // Get w from the extension field\n        let w = Val::from_u64(11); // BabyBear's binomial extension uses w=11\n\n        let air = AluAir::\u003cVal, 4\u003e::new_binomial_with_preprocessed(n, 1, w, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"extension field verification failed\");\n    }\n\n    #[test]\n    fn test_alu_air_constraint_degree() {\n        let preprocessed = vec![Val::ZERO; 8 * 7]; // 8 ops * 7 preprocessed values per op\n        let air = AluAir::\u003cVal, 1\u003e::new_with_preprocessed(8, 2, preprocessed);\n        p3_test_utils::assert_air_constraint_degree!(air, \"AluAir\");\n    }\n}\n","traces":[{"line":80,"address":[6121776,6121312,6121584,6121488,6121680],"length":1,"stats":{"Line":5}},{"line":81,"address":[5672158,5671870,5671966,5672062,5671713],"length":1,"stats":{"Line":5}},{"line":82,"address":[],"length":0,"stats":{"Line":5}},{"line":87,"address":[6372109],"length":1,"stats":{"Line":5}},{"line":95,"address":[],"length":0,"stats":{"Line":9}},{"line":96,"address":[5571939,5572018,5571058,5571191,5570979,5571273,5571671,5571459,5571538,5571753],"length":1,"stats":{"Line":9}},{"line":97,"address":[1789562],"length":1,"stats":{"Line":9}},{"line":110,"address":[],"length":0,"stats":{"Line":5}},{"line":111,"address":[5552506,5551243,5553274,5552370,5552698,5553082,5552203,5551627,5550938,5551106,5551818,5552891,5552010,5550803,5551434],"length":1,"stats":{"Line":5}},{"line":112,"address":[6117084,6116724,6116532,6116340,6116916],"length":1,"stats":{"Line":5}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[6116342,6116726,6116918,6116534],"length":1,"stats":{"Line":5}},{"line":125,"address":[6121104,6121281],"length":1,"stats":{"Line":6}},{"line":131,"address":[6371238,6371394,6371159,6371479],"length":1,"stats":{"Line":6}},{"line":132,"address":[6121162,6121226],"length":1,"stats":{"Line":6}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[5670304,5670352,5670208,5670400,5670256],"length":1,"stats":{"Line":11}},{"line":149,"address":[6370337,6370241,6370193,6370289,6370385],"length":1,"stats":{"Line":11}},{"line":150,"address":[6120581,6120629,6120533,6120437,6120485],"length":1,"stats":{"Line":11}},{"line":154,"address":[5549488,5549008,5549440,5549296,5549152,5549104,5548864,5549200,5548960,5549248,5549344,5549392,5548912,5549536,5549056],"length":1,"stats":{"Line":14}},{"line":155,"address":[5548989,5549037,5549201,5549105,5549133,5549469,5549345,5549153,5549229,5549179,5549421,5549563,5548865,5549009,5549393,5548941,5549325,5549441,5549057,5549297,5549515,5548913,5549373,5548893,5549277,5549085,5548961,5549249,5549489,5549537],"length":1,"stats":{"Line":14}},{"line":159,"address":[5550064,5549664,5549904,5549984,5550304,5550384,5549824,5549744,5550144,5549584,5550464,5550224,5550544,5550624,5550704],"length":1,"stats":{"Line":12}},{"line":160,"address":[6362468,6362505,6362388,6362425,6362548,6362628,6362345,6362665,6362708,6362585],"length":1,"stats":{"Line":13}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[1789408],"length":1,"stats":{"Line":13}},{"line":176,"address":[1789417,1789460],"length":1,"stats":{"Line":13}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[5666891,5663648,5668225,5666928,5664945,5670171],"length":1,"stats":{"Line":12}},{"line":189,"address":[6117191],"length":1,"stats":{"Line":14}},{"line":191,"address":[5667033,5663753],"length":1,"stats":{"Line":12}},{"line":192,"address":[5663913,5667193,5667062,5663782],"length":1,"stats":{"Line":14}},{"line":193,"address":[6117310],"length":1,"stats":{"Line":12}},{"line":194,"address":[6117338],"length":1,"stats":{"Line":14}},{"line":196,"address":[],"length":0,"stats":{"Line":26}},{"line":198,"address":[5557576,5560315,5554280,5553739,5560856,5567416,5564136,5557035,5563595,5566875],"length":1,"stats":{"Line":25}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[5664060,5667340],"length":1,"stats":{"Line":14}},{"line":201,"address":[],"length":0,"stats":{"Line":12}},{"line":202,"address":[6364212,6367492],"length":1,"stats":{"Line":13}},{"line":203,"address":[5557429,5554133,5563989,5567269,5560709],"length":1,"stats":{"Line":13}},{"line":204,"address":[6364449,6367729],"length":1,"stats":{"Line":13}},{"line":206,"address":[6368215,6364935,6364975,6364691,6367971,6368255],"length":1,"stats":{"Line":26}},{"line":207,"address":[6118586,6118539,6118487],"length":1,"stats":{"Line":26}},{"line":208,"address":[],"length":0,"stats":{"Line":26}},{"line":211,"address":[5558325,5568225,5564885,5568165,5564945,5561665,5555039,5561605,5555099,5558385],"length":1,"stats":{"Line":26}},{"line":212,"address":[6365297,6368577,6368738,6365458],"length":1,"stats":{"Line":13}},{"line":213,"address":[5665544,5665428,5668708,5668824],"length":1,"stats":{"Line":26}},{"line":214,"address":[6119137,6119212],"length":1,"stats":{"Line":13}},{"line":217,"address":[6119249,6119189],"length":1,"stats":{"Line":26}},{"line":218,"address":[],"length":0,"stats":{"Line":13}},{"line":219,"address":[6365844,6365960,6369240,6369124],"length":1,"stats":{"Line":26}},{"line":220,"address":[5565801,5569009,5569081,5555883,5555955,5559241,5565729,5559169,5562521,5562449],"length":1,"stats":{"Line":12}},{"line":223,"address":[],"length":0,"stats":{"Line":25}},{"line":224,"address":[5666219,5669499,5669642,5666362],"length":1,"stats":{"Line":12}},{"line":225,"address":[],"length":0,"stats":{"Line":23}},{"line":226,"address":[5569475,5562915,5556286,5566195,5569412,5556349,5562852,5566132,5559635,5559572],"length":1,"stats":{"Line":11}},{"line":229,"address":[],"length":0,"stats":{"Line":23}},{"line":230,"address":[],"length":0,"stats":{"Line":12}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":23}},{"line":238,"address":[6118234],"length":1,"stats":{"Line":11}},{"line":239,"address":[5664819,5668099],"length":1,"stats":{"Line":12}},{"line":240,"address":[5664882,5668162],"length":1,"stats":{"Line":11}},{"line":246,"address":[],"length":0,"stats":{"Line":4}},{"line":247,"address":[],"length":0,"stats":{"Line":4}},{"line":248,"address":[5573428,5572276],"length":1,"stats":{"Line":4}},{"line":250,"address":[5573441,5572385,5572289,5573537],"length":1,"stats":{"Line":8}},{"line":255,"address":[5573769,5574010,5572617,5572858],"length":1,"stats":{"Line":8}},{"line":256,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":4}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[5572912,5574064],"length":1,"stats":{"Line":4}},{"line":267,"address":[],"length":0,"stats":{"Line":4}},{"line":268,"address":[],"length":0,"stats":{"Line":4}},{"line":269,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":3}},{"line":278,"address":[5385568,5385584,5385600,5385616,5385632],"length":1,"stats":{"Line":13}},{"line":279,"address":[5385637,5385589,5385621,5385573,5385605],"length":1,"stats":{"Line":12}},{"line":282,"address":[],"length":0,"stats":{"Line":14}},{"line":283,"address":[5385400,5385208],"length":1,"stats":{"Line":11}},{"line":284,"address":[],"length":0,"stats":{"Line":12}},{"line":287,"address":[],"length":0,"stats":{"Line":11}},{"line":288,"address":[6152612,6152420],"length":1,"stats":{"Line":11}},{"line":289,"address":[5060131,5059939,5059544,5060323,5059747],"length":1,"stats":{"Line":12}},{"line":290,"address":[5059962,5059567,5060154,5060346,5059770],"length":1,"stats":{"Line":11}},{"line":291,"address":[5059571,5060158,5059966,5060350,5059774],"length":1,"stats":{"Line":12}},{"line":301,"address":[],"length":0,"stats":{"Line":62}},{"line":302,"address":[5433174,5423047,5471287,5491415,5454662,5481399,5513047,5444519,5466007,5412903,5507959,5523190,5534550,5496614],"length":1,"stats":{"Line":60}},{"line":303,"address":[1776830,1777005,1771394,1771323,1776764,1771577],"length":1,"stats":{"Line":124}},{"line":305,"address":[5497186,5508534,5445155,5523762,5523855,5413563,5466667,5481974,5535122,5492051,5497279,5535215,5423622,5423683,5413470,5455234,5471862,5433839,5508595,5513683,5513622,5455327,5466574,5433746,5482035,5491990,5445094,5471923],"length":1,"stats":{"Line":121}},{"line":306,"address":[5976953,5961495,5993383,6013971,6036671,6025331,5956057,5993325,6003639,5945725,6013913,5956115,6003581,5961437,6041913,5988237,6025273,5971751,6041971,6036613,5971693,5977011,5945783,5988295],"length":1,"stats":{"Line":123}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":31}},{"line":315,"address":[5434251,5513944,5535577,5467016,5524217,5445463,5472231,5497691,5423991,5434201,5455689,5455739,5492359,5482296,5508856,5467066,5472184,5524267,5413962,5535627,5513991,5445416,5423944,5492312,5508903,5482343,5413912,5497641],"length":1,"stats":{"Line":120}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[5296514,5110304,5344880,5360271,5360326,5328278,5365510,5135750,5417599,5417654,5089634,5296569,5094799,5323190,5135695,5433043,5433104,5323135,5382112,5365455,5140994,5344819,5382051,5328223,5110243,5089689,5094854,5141049],"length":1,"stats":{"Line":32}},{"line":321,"address":[6204590,6287230,6209928,6292433],"length":1,"stats":{"Line":35}},{"line":322,"address":[6204766,6204825,6287491,6292609,6204851,6287406,6210189,6210215,6287465,6210104,6292668,6292694],"length":1,"stats":{"Line":68}},{"line":323,"address":[5095153,5110676,5141348,5136135,5360711,5433476,5090074,5345205,5328577,5360625,5095200,5296954,5110715,5110629,5328624,5141395,5418000,5433429,5090035,5296915,5417953,5365856,5418039,5382523,5360672,5323489,5433515,5089988,5141434,5095239,5382437,5136096,5136049,5323575,5345252,5365895,5323536,5345291,5382484,5328663,5365809,5296868],"length":1,"stats":{"Line":69}},{"line":325,"address":[],"length":0,"stats":{"Line":70}},{"line":326,"address":[6037525,5957059,6037583,5957001,5989134,5972546,5989076,5972604],"length":1,"stats":{"Line":70}},{"line":327,"address":[6287889,6205335,6210670,6205277,6293178,6287947,6210615,6293120],"length":1,"stats":{"Line":70}},{"line":328,"address":[5468091,5536624,5536676,5493384,5509874,5509926,5468149,5493442],"length":1,"stats":{"Line":67}},{"line":332,"address":[6205781,6293558,6288260,6288317,6210979,6211036,6205715,6293624],"length":1,"stats":{"Line":67}},{"line":333,"address":[],"length":0,"stats":{"Line":69}},{"line":334,"address":[5990021,5973590,5957890,5989969,5973648,6038627,5957942,6038569],"length":1,"stats":{"Line":65}},{"line":335,"address":[5510547,5468974,5510599,5494267,5468916,5537353,5494209,5537301],"length":1,"stats":{"Line":63}},{"line":339,"address":[1774122,1774241,1773900,1779412,1779670,1779465,1773934,1779551,1779789,1774003],"length":1,"stats":{"Line":160}},{"line":340,"address":[6289083,6206693,6214099,6288999,6211725,6211802,6208657,6289006,6294436,6294536,6296486,6206593,6294462,6291209,6211718,6206619],"length":1,"stats":{"Line":62}},{"line":341,"address":[5510914,5537665,5469407,5469304,5510994,5471233,5510907,5494597,5537658,5469330,5537745,5539913,5494700,5512996,5496540,5494623],"length":1,"stats":{"Line":68}},{"line":342,"address":[6206828,6211960,6212040,6294694,6294776,6208647,6289241,6289321,6291199,6206945,6296476,6206854,6294671,6211953,6289234,6214071],"length":1,"stats":{"Line":62}},{"line":345,"address":[],"length":0,"stats":{"Line":66}},{"line":348,"address":[5959093,5959131,5991387,5974879,5960594,5975055,6039918,6040022,5959319,5991161,5991199,6039846,5959203,6041070,5991271,5974825,5974951,5976105,5992561,6039792],"length":1,"stats":{"Line":33}},{"line":351,"address":[6207697,6295528,6212885,6290153],"length":1,"stats":{"Line":30}},{"line":352,"address":[6296431,6213125,6290365,6290184,6207965,6290218,6207893,6208602,6213009,6212931,6207708,6212978,6213197,6213966,6207789,6295539,6295589,6295620,6290249,6207758,6290437,6295724,6295796,6291154],"length":1,"stats":{"Line":66}},{"line":355,"address":[5471133,5512896,5539688,5496440],"length":1,"stats":{"Line":31}},{"line":356,"address":[5437160,5385953,5369289,5093361,5421198,5364374,5331822,5436710,5348721,5364221,5348486,5348414,5326850,5144825,5093723,5331938,5139645,5332238,5364114,5363884,5139308,5145083,5368982,5436826,5386168,5348376,5421126,5139538,5113838,5369470,5436600,5369170,5385834,5326734,5114360,5144649,5364010,5385718,5421614,5113800,5300603,5093235,5300115,5114145,5093465,5327150,5326969,5332057,5369054,5436945,5098902,5139798,5098412,5113910,5093572,5144595,5326662,5098466,5326624,5331712,5348936,5098749,5098538,5144932,5300241,5368944,5421088,5144721,5114026,5098642,5385608,5139362,5300345,5093289,5421314,5139434,5348602,5300169,5300452,5331750,5363938,5385646,5421433,5436638],"length":1,"stats":{"Line":35}},{"line":361,"address":[],"length":0,"stats":{"Line":37}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[6308096,6308185,6307961,6308032,6308240,6277050,6297678,6308144,6308249,6235434,6307920,6308016,6215162,6308112,6308208,6181950,6193310,6307936,6308128,6308153,6308272,6307952,6266938,6307984,6308176,6308224,6245710,6308048,6308064,6307888,6256914,6307904,6307872,6308288,6308080,6225397,6308000,6307856],"length":1,"stats":{"Line":78}},{"line":367,"address":[5146259,5189426,5407587,5458819,5470175,5490385,5500670,5189335,5350367,5423012,5333650,5222019,5312035,5232295,5370791,5125745,5255106,5276442,5156606,5200786,5387562,5125667,5243655,5500579,5167841,5397549,5422934,5458910,5167763,5333559,5480257,5512018,5243746,5407665,5156515,5222097,5286495,5480179,5232386,5115676,5448563,5178066,5255015,5470253,5301853,5177975,5397471,5511927,5350445,5200695,5100161,5312126,5286573,5266301,5115754,5438451,5438529,5266223,5370882,5387484,5146337,5100083,5490307,5301775,5211903,5276364,5448641,5211981],"length":1,"stats":{"Line":54}},{"line":368,"address":[6225766,6235690,6245979,6182219,6193646,6182312,6246072,6267248,6215498,6298014,6193672,6215418,6246046,6277386,6257257,6297947,6225686,6193579,6267194,6257283,6182286,6257203,6277306,6225740,6277360,6215472,6298040,6267274,6235770,6235744],"length":1,"stats":{"Line":57}},{"line":369,"address":[5302122,5500952,5438712,5371078,5125928,5156849,5222366,5255302,5286756,5156888,5448824,5200982,5232629,5178262,5302083,5470483,5480487,5512261,5255349,5448871,5146567,5115984,5312369,5100344,5255388,5266484,5201029,5286842,5146520,5222280,5397818,5178309,5266531,5286803,5302036,5333893,5459153,5201068,5178348,5397732,5387831,5168110,5350675,5371164,5350628,5333846,5126014,5312322,5189708,5500913,5387745,5189622,5350714,5407934,5212164,5168071,5212211,5407895,5244028,5116023,5232582,5423242,5438759,5387792,5470436,5125975,5480440,5490615,5480526,5156802,5168024,5276625,5423195,5243989,5459106,5243942,5512300,5115937,5276672,5222327,5470522,5500866,5212250,5397779,5459192,5146606,5276711,5438798,5266570,5490568,5189669,5512214,5100430,5407848,5448910,5232668,5371125,5490654,5423281,5100391,5312408,5333932],"length":1,"stats":{"Line":58}},{"line":371,"address":[6235867,6246117,6267371,6277431,6235815,6182409,6298085,6215543,6225811,6257328,6193717,6267319,6182357,6277483,6193769,6246169,6225863,6298137,6257380,6215595],"length":1,"stats":{"Line":56}},{"line":372,"address":[6193934,6215760,6246334,6267536,6257545,6226028,6277648,6298302,6182574,6236032],"length":1,"stats":{"Line":28}},{"line":373,"address":[5501447,5147101,5157385,5371661,5244525,5267067,5201563,5178845,5439295,5408429,5398313,5491151,5388328,5126511,5222863,5212747,5287339,5100927,5255883,5423776,5459689,5512797,5190205,5302619,5449407,5481023,5471019,5168605,5351211,5334429,5116520,5233165,5312905,5277208],"length":1,"stats":{"Line":27}},{"line":374,"address":[5302978,5213106,5101286,5126870,5471378,5388687,5256240,5201920,5244884,5334788,5233524,5439654,5501804,5277567,5491510,5190564,5449766,5398670,5460048,5168962,5223222,5481382,5116879,5267426,5424133,5513156,5157744,5372020,5313264,5408786,5287698,5179204,5351570,5147458],"length":1,"stats":{"Line":27}},{"line":378,"address":[6278665,6237053,6194955,6268555,6183595,6227047,6299321,6247351,6258564,6216781],"length":1,"stats":{"Line":27}},{"line":379,"address":[5515788,5425784,5526149,5415796,5474084,5499511,5484235,5415854,5484177,5457621,5526091,5447318,5425842,5447260,5515846,5436073,5436131,5457563,5474026,5499569],"length":1,"stats":{"Line":54}},{"line":380,"address":[5963899,6044277,6044335,6016339,5979377,6027641,6016281,6005981,5963841,5995785,5948187,5979319,6006039,6027699,5995727,5948129],"length":1,"stats":{"Line":54}},{"line":381,"address":[6237648,6195553,6237590,6299861,6227626,6217376,6247891,6227684,6269150,6299919,6259143,6184135,6195495,6184193,6217318,6247949,6259201,6269092,6279202,6279260],"length":1,"stats":{"Line":54}},{"line":385,"address":[6238144,6259493,6217634,6184571,6195709,6259354,6184383,6184690,6248208,6279518,6228095,6259612,6269646,6279415,6269527,6217872,6248327,6217531,6279637,6195812,6196050,6279449,6259731,6237906,6238025,6269408,6300297,6237803,6184349,6248139,6259407,6300075,6184452,6217565,6248105,6248446,6300178,6217753,6269339,6279756,6300416,6269305,6300109,6195743,6227890,6195931,6228214,6227976,6227837,6237837],"length":1,"stats":{"Line":135}},{"line":386,"address":[5246137,5231025,5440826,5220909,5450938,5447455,5188030,5472686,5410037,5472586,5304227,5166570,5158999,5425344,5102458,5314440,5257418,5234777,5285242,5425359,5489185,5502982,5224389,5409960,5514411,5461303,5499313,5128121,5203098,5461226,5257495,5472612,5295388,5450931,5492761,5278803,5288906,5304143,5396360,5492677,5158915,5268600,5503059,5180459,5148709,5440903,5416589,5265066,5170188,5128037,5155261,5203175,5180382,5176715,5180375,5234700,5482633,5304150,5399844,5224473,5278777,5373191,5102535,5399837,5482556,5373275,5482549,5210746,5118187,5406473,5468874,5314433,5214273,5278877,5314517,5359262,5514327,5457567,5268593,5102451,5399921,5322088,5242348,5521982,5431878,5335959,5510630,5336043,5191733,5389895,5275229,5109087,5352780,5214357,5158922,5389921,5199388,5191817,5124552,5461219,5118113,5170173,5118087,5128044,5203091,5246060,5253708,5492684,5352880,5335966,5389995,5170265,5246053,5310779,5257411,5234693,5191740,5289006,5479068,5224396,5148625,5148632,5514334,5343614,5268677,5380846,5409953,5352806,5214280,5502975,5288932,5134673,5440819,5425436,5373198,5451015],"length":1,"stats":{"Line":52}},{"line":387,"address":[5987442,6006580,6044878,6016882,6052400,5955236,5979920,5996326,6006660,5964440,6024404,6035764,5996406,6044958,5964520,5948728,5980000,5948808,5970948,6002834,6044871,6006573,6028235,5964433,5979913,5948721,5996319,6028322,6028242,6013088,6016962,6016875],"length":1,"stats":{"Line":54}},{"line":388,"address":[6300455,6203394,6248398,6259676,6269605,6279715,6279795,6265870,6269685,6269598,6286099,6217911,6248405,6244487,6196009,6228133,6184642,6217831,6184729,6184649,6192034,6228159,6228250,6238103,6248485,6275989,6300368,6300375,6196089,6224215,6238096,6238183,6259650,6279708,6196002,6307760,6234370,6217824,6259767,6255790],"length":1,"stats":{"Line":57}},{"line":391,"address":[5980127,6017181,5949014,5964726,6045085,5996533,6028449,6006866,5996612,6017089,6006787,6045177,5980219,5948935,6028541,5964647],"length":1,"stats":{"Line":57}},{"line":392,"address":[6234343,6255742,6191986,6224188,6203346,6265843,6286072,6244460,6307712,6275962],"length":1,"stats":{"Line":27}},{"line":393,"address":[6265806,6243884,6286009,6218135,6255163,6300692,6223612,6269909,6191923,6259975,6224125,6202767,6265319,6196326,6244397,6191407,6234304,6280019,6275899,6228458,6255679,6203283,6184966,6248722,6275386,6285496,6307649,6307133,6238407,6233817],"length":1,"stats":{"Line":85}},{"line":394,"address":[5465336,5480738,5443765,5444320,5422963,5534203,5465810,5491018,5491195,5507203,5481155,5523080,5433048,5433076,5422652,5465482,5491307,5454552,5533783,5465675,5507430,5522725,5480963,5444185,5490799,5422510,5443846,5507623,5443992,5522500,5454389,5453972,5534338,5507284,5481318,5432913,5507794,5534374,5480818,5491327,5432496,5422829,5522580,5444356,5534010,5432576,5432721,5481290,5422433,5454197,5465846,5523052,5533864,5522917,5465255,5507758,5454524,5454052,5422943,5490876],"length":1,"stats":{"Line":56}},{"line":399,"address":[5517025,5527344,5500764,5485491,5458816,5475263,5427021,5448497,5417110,5437326],"length":1,"stats":{"Line":27}},{"line":400,"address":[5996798,6007144,5980516,6017386,6045382,5964912,6007052,5996890,6045474,5965004,5980424,5949200,6028746,5949292,6028838,6017478],"length":1,"stats":{"Line":54}},{"line":401,"address":[5417334,5453715,5475515,5464808,5459087,5427273,5501035,5522243,5490587,5506756,5505625,5532205,5479490,5443318,5463677,5431248,5432239,5422221,5448749,5452724,5517277,5521252,5527615,5485715,5442187,5421267,5489648,5480481,5533336,5437597],"length":1,"stats":{"Line":83}},{"line":402,"address":[5185931,5197289,5123970,5134039,5293986,5378924,5404921,5208824,5283676,5430238,5198712,5175067,5176126,5229473,5175245,5446821,5466775,5488551,5240249,5253032,5415955,5456015,5477488,5341692,5164648,5497586,5404746,5521306,5122986,5394963,5197466,5445728,5445903,5509954,5220275,5283845,5153534,5310145,5394794,5208647,5455840,5229298,5378747,5153709,5309052,5468198,5519883,5498679,5264390,5414862,5154627,5273677,5219182,5133121,5508708,5284660,5108453,5186108,5430416,5274595,5395778,5431291,5293808,5357860,5251609,5132946,5273502,5341515,5466952,5508531,5520060,5357682,5319989,5187354,5210070,5294804,5321412,5165894,5251786,5342938,5358678,5405839,5415037,5164471,5456933,5477666,5123155,5487633,5487458,5230391,5263144,5262967,5107360,5309227,5219357,5497761,5107535,5241672,5320166,5478484,5380170,5240426],"length":1,"stats":{"Line":30}},{"line":403,"address":[5521662,5521699,5532617,5506074,5532654,5464126,5453171,5464089,5442636,5421697,5421734,5490063,5442599,5431658,5479937,5453134,5431695,5490100,5479900,5506037],"length":1,"stats":{"Line":30}},{"line":404,"address":[6050626,6002190,6012444,6023697,5969539,5953827,5986735,5985668,6011679,6051693,6022630,6033990,6035057,5954592,5970304,6001425],"length":1,"stats":{"Line":60}},{"line":405,"address":[],"length":0,"stats":{"Line":60}},{"line":407,"address":[5477941,5379296,5294201,5395600,5107748,5274276,5175657,5379597,5198081,5431102,5284057,5498034,5241267,5175937,5294626,5342533,5379765,5358234,5309500,5342365,5284216,5497974,5309440,5395175,5405194,5165321,5379539,5165020,5252459,5133493,5229686,5415250,5430729,5430822,5240798,5431021,5395235,5252158,5456387,5405520,5467625,5252401,5509323,5263817,5509080,5273890,5241099,5133394,5154308,5123367,5175558,5209497,5133720,5107808,5230072,5415732,5186480,5415409,5165263,5446176,5446598,5309826,5478306,5219729,5509381,5446275,5509549,5165489,5498456,5520733,5294547,5342064,5487906,5108230,5487846,5320781,5446116,5467793,5284117,5309599,5175856,5467567,5164861,5284482,5241041,5430657,5520333,5415636,5467225,5498133,5240639,5154081,5456614,5456710,5508921,5467324,5153922,5209196,5154404,5219570,5240699,5107907,5488328,5284403,5133816,5230168,5186949,5219630,5252059,5273950,5186381,5274049,5123713,5123792,5186781,5252627,5379197,5198307,5358075,5123427,5320538,5456288,5478040,5209439,5488232,5405134,5229845,5108134,5153982,5263417,5498360,5508981,5123526,5309922,5175486,5415310,5467165,5197679,5341965,5209037,5320839,5133334,5456228,5342307,5379137,5263985,5405616,5520273,5520901,5395334,5251999,5294261,5186723,5358500,5186321,5197739,5197838,5209665,5229746,5446502,5477881,5478227,5164921,5520675,5219956,5198139,5220052,5321007,5520432,5209097,5395521,5320439,5263516,5341905,5358421,5274372,5320379,5488005,5294360,5405293,5263357,5263759,5358135],"length":1,"stats":{"Line":56}},{"line":411,"address":[],"length":0,"stats":{"Line":27}},{"line":412,"address":[5466592,5319806,5341332,5357510,5122817,5229141,5240066,5262784,5185748,5487301,5414705,5508348,5132789,5477316,5107203,5219025,5394625,5283507,5174895,5430066,5445571,5273345,5308895,5153377,5208464,5293636,5197106,5251426,5378564,5404589,5455683,5519700,5497429,5164288],"length":1,"stats":{"Line":27}},{"line":413,"address":[6021773,6011051,6000632,5949641,6049970,5980865,6033133,6049804,5965353,6022145,6000597,5953034,5953199,5984846,5997239,6045823,5953362,5985012,6021808,6010886,6033334,6007493,6033168,6017827,6021974,6050141,6049769,5968911,5952999,5984811,5985183,6000797,5968746,6010851,6000960,6029187,6033505,6011214,5969074,5968711],"length":1,"stats":{"Line":56}},{"line":418,"address":[5337037,5119156,5400883,5374269,5247131,5269639,5515405,5426403,5289975,5225435,5473655,5390964,5159993,5171232,5149671,5204169,5181453,5129083,5410999,5235771,5483595,5279846,5504053,5103497,5493723,5192811,5305189,5315511,5353849,5451977,5441865,5258489,5215319,5462297],"length":1,"stats":{"Line":26}},{"line":419,"address":[6301770,6219163,6239435,6186044,6261010,6229493,6281047,6197404,6270937,6249800],"length":1,"stats":{"Line":26}},{"line":420,"address":[5981047,5949959,6000574,6018176,5997557,6029536,6010828,6017938,5949682,5980976,6018248,6029243,5965394,6033097,6007576,5965743,5984775,6021737,6017883,5965507,5980921,6045934,6046005,6046244,6049733,5952976,6029608,6007534,6029298,5997393,5997322,6045879,6046172,5950031,5949724,5965671,5997629,6007811,5949795,5981214,6018009,6029369,5997280,6007883,5981286,5968688,6007647,5965436],"length":1,"stats":{"Line":52}},{"line":424,"address":[5501839,5528419,5418123,5518050,5459891,5438401,5428046,5449522,5476288,5486504],"length":1,"stats":{"Line":27}},{"line":425,"address":[5129749,5337753,5182169,5247755,5193527,5280401,5411665,5215985,5104163,5442439,5462921,5270305,5452551,5494297,5442531,5504769,5463013,5226101,5484169,5484261,5391519,5427055,5474306,5150245,5504677,5204793,5354500,5270213,5452643,5193435,5316135,5259113,5374893,5182077,5204885,5290626,5160709,5401457,5516121,5259205,5426959,5119807,5494389,5474210,5290530,5160617,5280497,5354404,5305763,5337661,5226009,5374985,5316227,5119711,5516029,5171884,5129657,5305855,5247847,5411573,5391615,5171788,5401549,5150337,5236395,5215893,5236487,5104071],"length":1,"stats":{"Line":52}},{"line":426,"address":[6032668,5983164,5999287,6020126,5984346,5966150,5981712,5951689,5950438,6000329,5968443,6008290,5952731,6010583,6018674,6031486,6046670,6048122,5998036,5967401,6009541,6021308,6030034,6049304],"length":1,"stats":{"Line":78}},{"line":427,"address":[5452301,5461941,5519694,5478116,5530283,5419916,5420842,5477932,5451166,5463220,5519878,5461755,5441730,5488113,5531748,5520829,5429690,5503703,5440265,5489223,5479067,5451350,5488297,5430825,5505168,5429874,5419732,5530469,5503889,5440451],"length":1,"stats":{"Line":26}},{"line":428,"address":[6303982,6188213,6221153,6221110,6199573,6199616,6241382,6272927,6251969,6241425,6231431,6231474,6262948,6188256,6272884,6282994,6303939,6252012,6262991,6283037],"length":1,"stats":{"Line":26}},{"line":429,"address":[6232219,6272919,6252004,6200699,6221145,6221934,6199608,6273708,6188248,6283029,6283818,6189339,6263736,6262983,6241417,6231466,6242206,6253095,6305065,6303974],"length":1,"stats":{"Line":52}},{"line":430,"address":[6021544,6032846,6021704,6048705,6010614,6010719,5967982,5968579,5952762,6010807,6021365,6021486,6032069,6032904,5952955,6000553,6049700,6032725,5984582,5999868,6020709,5983747,5984742,6010122,6033064,5952270,6049540,5968474,6000465,6000360,6049361,6049482,5968667,5984403,5984524,5952867],"length":1,"stats":{"Line":54}},{"line":432,"address":[6304695,6231616,6272997,6273069,6283107,6283508,6273398,6304124,6200161,6252253,6283278,6221720,6241567,6231944,6188801,6188969,6221624,6188326,6241495,6221295,6241666,6241896,6252499,6252557,6263461,6263546,6221223,6188743,6199857,6232029,6252725,6263244,6273494,6200103,6188398,6221394,6200329,6231727,6241992,6199758,6263061,6263133,6283179,6304527,6252082,6304052,6304223,6304469,6188497,6231544,6252154,6273168,6283604,6199686],"length":1,"stats":{"Line":51}},{"line":437,"address":[5411825,5475640,5205045,5281831,5104323,5317743,5376501,5216145,5260721,5427215,5413006,5182329,5428386,5442691,5183685,5151678,5517637,5339269,5337913,5226261,5484421,5516281,5375145,5494549,5249363,5392949,5173215,5193687,5316387,5452803,5227442,5453984,5206401,5150497,5195043,5259365,5391775,5291960,5248007,5129909,5238003,5131090,5217326,5354660,5443872,5463173,5270465,5290786,5271646,5474466,5504929,5355834,5236647,5307196,5119967,5485602,5464529,5121141,5172044,5306015,5402890,5506285,5105504,5162225,5401709,5280657,5160869,5495730],"length":1,"stats":{"Line":51}},{"line":438,"address":[5227111,5475437,5249213,5162075,5291888,5464542,5151592,5248903,5428312,5131095,5173007,5401882,5271651,5248180,5517177,5506135,5120140,5412786,5494722,5194695,5206053,5183471,5281759,5354833,5195056,5355509,5150670,5391948,5151347,5249376,5506071,5173220,5217331,5495644,5121146,5495735,5376153,5338086,5428062,5464315,5485607,5339282,5226434,5505825,5517289,5402895,5317529,5376351,5484594,5376041,5130082,5151683,5290959,5317283,5495510,5271560,5260571,5281628,5317593,5443877,5205218,5485271,5338809,5427388,5517650,5182502,5375318,5130759,5194893,5260261,5161877,5227222,5392746,5205941,5474639,5475568,5485516,5306188,5402559,5453653,5260734,5306865,5217240,5206187,5281506,5443786,5291965,5206414,5172217,5105418,5355762,5505937,5227447,5259538,5260507,5121069,5193860,5402670,5271426,5485382,5516454,5376287,5120938,5291757,5453898,5506298,5260373,5183698,5194583,5306976,5411998,5162238,5428178,5317395,5464181,5206251,5413011,5355839,5376514,5392954,5464069,5355631,5105173,5216995,5270638,5249015,5307110,5237543,5402804,5475645,5131004,5183535,5217106,5412675,5495399,5237789,5291635,5517487,5316560,5236820,5452976,5428391,5271315,5338921,5173141,5317756,5392877,5453764,5464379,5105284,5172891,5216318,5392624,5412920,5162011,5194829,5237853,5105509,5307201,5475315,5443652,5280830,5151458,5339055,5249149,5120816,5130870,5161765,5237655,5442864,5453989,5183337,5161042,5227356,5281836,5339119,5104496,5183225,5443541,5463346,5505102,5238016,5517423],"length":1,"stats":{"Line":51}},{"line":440,"address":[6046915,5950683,5981957,6030279,5998281,6008535,6018919,5966395],"length":1,"stats":{"Line":28}},{"line":441,"address":[5477391,5487586,5450625,5419205,5429149,5439550,5502988,5529568,5519153,5461040],"length":1,"stats":{"Line":27}},{"line":442,"address":[6047568,5966682,5998470,6019588,5966584,5982146,6030592,6047190,6030468,5998899,5966850,5950872,5982232,5951138,5982626,6009153,6030554,6047104,6008784,5982270,6047397,6019108,6047584,5998530,6030761,6008822,5951301,6008990,6019401,5967013,5966644,6008724,6030932,6019232,5982439,5998568,5950970,6030948,6047228,5998736,5950932,5982610,6019572,6019194],"length":1,"stats":{"Line":55}},{"line":449,"address":[5944784],"length":1,"stats":{"Line":13}},{"line":450,"address":[6180344,6180568],"length":1,"stats":{"Line":13}},{"line":451,"address":[5412519,5412454,5412743,5412678],"length":1,"stats":{"Line":13}},{"line":452,"address":[5944857,5944905,5944983],"length":1,"stats":{"Line":28}},{"line":455,"address":[5080743,5078736,5079725,5080784,5081773,5082791,5081808,5083856,5081767,5083821,5082797,5079760,5080749,5084845,5079719,5083815,5082832,5084839],"length":1,"stats":{"Line":13}},{"line":459,"address":[5409639,5410663],"length":1,"stats":{"Line":13}},{"line":460,"address":[6177580,6178604],"length":1,"stats":{"Line":13}},{"line":463,"address":[],"length":0,"stats":{"Line":13}},{"line":464,"address":[5943524],"length":1,"stats":{"Line":13}},{"line":469,"address":[5943650,5943741],"length":1,"stats":{"Line":25}},{"line":470,"address":[5943847,5944043,5944005],"length":1,"stats":{"Line":24}},{"line":471,"address":[],"length":0,"stats":{"Line":24}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[6178235,6179259],"length":1,"stats":{"Line":12}},{"line":478,"address":[6178298,6179322],"length":1,"stats":{"Line":12}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":24}},{"line":482,"address":[6180218,6179834],"length":1,"stats":{"Line":13}},{"line":483,"address":[5944429],"length":1,"stats":{"Line":12}},{"line":484,"address":[5412164,5411701,5412085,5411780],"length":1,"stats":{"Line":26}},{"line":485,"address":[],"length":0,"stats":{"Line":13}},{"line":489,"address":[],"length":0,"stats":{"Line":14}}],"covered":179,"coverable":198},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","const_air.rs"],"content":"//! [`ConstAir`] stores constants either in the base field or the extension field (of extension degree `D`).\n//!\n//! # Column layout\n//!\n//! The AIR is generic over an extension degree `D`.\n//! For each constant entry, we allocate `D + 1` base-field columns.\n//!\n//! - `D` columns for the constant value (basis coefficients),\n//! - `1` column for the `index`: the witness-bus index of the constant.\n//!\n//! The layout for a single row is:\n//!\n//! ```text\n//!     [value[0], value[1], ..., value[D-1], index]\n//! ```\n//!\n//! # Constraints\n//!\n//! The AIR has no constraints.\n//!\n//! # Global Interactions\n//!\n//! There is one interaction with the global witness bus:\n//!\n//! - send (index, value)\n\nuse alloc::string::ToString;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::marker::PhantomData;\n\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues, BaseAir, PermutationAirBuilder};\nuse p3_circuit::tables::ConstTrace;\nuse p3_field::{BasedVectorSpace, Field};\nuse p3_lookup::lookup_traits::{Direction, Kind, Lookup};\nuse p3_matrix::dense::RowMajorMatrix;\n\nuse crate::air::utils::{\n    create_simple_preprocessed_trace, create_symbolic_variables, get_index_lookups,\n};\n\n/// ConstAir: vector-valued constant binding with generic extension degree D.\n///\n/// This chip exposes preprocessed constants that don't need to be committed during proving.\n/// It serves as the source of truth for constant values in the system, with each row\n/// representing a (value, index) pair where the index corresponds to a WitnessId.\n///\n/// Layout per row: [value[0..D-1], index] → width = D + 1\n/// - value[0..D-1]: Extension field value represented as D base field coefficients\n/// - index: Preprocessed WitnessId that this constant binds to\n#[derive(Debug, Clone)]\npub struct ConstAir\u003cF, const D: usize = 1\u003e {\n    /// Total number of constants defined in this trace.\n    pub height: usize,\n    /// Preprocessed values, corresponding to the indices in the trace.\n    pub preprocessed: Vec\u003cF\u003e,\n    /// Minimum trace height (for FRI compatibility with higher log_final_poly_len).\n    pub min_height: usize,\n    /// Marker tying this AIR to its base field.\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field, const D: usize\u003e ConstAir\u003cF, D\u003e {\n    /// Construct a new `ConstAir` instance.\n    ///\n    /// - `height`: The number of constant values to be exposed.\n    pub const fn new(height: usize) -\u003e Self {\n        Self {\n            height,\n            preprocessed: Vec::new(),\n            min_height: 1,\n            _phantom: PhantomData,\n        }\n    }\n\n    pub const fn new_with_preprocessed(height: usize, preprocessed: Vec\u003cF\u003e) -\u003e Self {\n        Self {\n            height,\n            preprocessed,\n            min_height: 1,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Set the minimum trace height for FRI compatibility.\n    ///\n    /// FRI requires: `log_trace_height \u003e log_final_poly_len + log_blowup`\n    /// So `min_height` should be \u003e= `2^(log_final_poly_len + log_blowup + 1)`.\n    pub const fn with_min_height(mut self, min_height: usize) -\u003e Self {\n        self.min_height = min_height;\n        self\n    }\n\n    /// Number of preprocessed columns: multiplicity + index\n    pub const fn preprocessed_width() -\u003e usize {\n        2 // One column for multiplicity, one for index\n    }\n    /// Convert a `ConstTrace` into a `RowMajorMatrix` suitable for the STARK prover.\n    ///\n    /// This function is responsible for:\n    ///\n    /// 1. Decomposing each extension element in the trace into `D` basis coordinates.\n    /// 2. Padding the trace to have a power-of-two number of rows.\n    #[inline]\n    pub fn trace_to_matrix\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(\n        trace: \u0026ConstTrace\u003cExtF\u003e,\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\n        let height = trace.values.len();\n        assert_eq!(\n            height,\n            trace.index.len(),\n            \"ConstTrace column length mismatch: values vs indices\"\n        );\n        let width = D;\n\n        let mut values = Vec::with_capacity(height * width);\n\n        // Iterate over values and indices, populating the flat vector.\n        for i in 0..height {\n            // Extract basis coefficients.\n            let coeffs = trace.values[i].as_basis_coefficients_slice();\n            assert_eq!(\n                coeffs.len(),\n                D,\n                \"extension degree mismatch for ConstTrace value\"\n            );\n            // Copy coefficients into the first D columns.\n            values.extend_from_slice(coeffs);\n        }\n\n        // Pad to power of two by repeating last row\n        let mut mat = RowMajorMatrix::new(values, width);\n        mat.pad_to_power_of_two_height(F::ZERO);\n\n        mat\n    }\n\n    pub fn trace_to_preprocessed\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(trace: \u0026ConstTrace\u003cExtF\u003e) -\u003e Vec\u003cF\u003e {\n        trace\n            .index\n            .iter()\n            .map(|widx| F::from_u64(widx.0 as u64))\n            .collect()\n    }\n}\n\nimpl\u003cF: Field, const D: usize\u003e BaseAir\u003cF\u003e for ConstAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        D\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\n        Some(create_simple_preprocessed_trace(\n            \u0026self.preprocessed,\n            Self::preprocessed_width(),\n            self.min_height,\n        ))\n    }\n}\n\nimpl\u003cAB: AirBuilder, const D: usize\u003e Air\u003cAB\u003e for ConstAir\u003cAB::F, D\u003e\nwhere\n    AB::F: Field,\n{\n    fn eval(\u0026self, _builder: \u0026mut AB) {\n        // No constraints for constants in Stage 1\n    }\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        // There is only one lookup to register in this AIR.\n        vec![0]\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cAB\u003e::F\u003e\u003e\n    where\n        AB: PermutationAirBuilder + AirBuilderWithPublicValues,\n    {\n        let (symbolic_main_local, preprocessed_local) = create_symbolic_variables::\u003cAB::F\u003e(\n            Self::preprocessed_width(),\n            BaseAir::\u003cAB::F\u003e::width(self),\n            1,\n            0,\n        );\n\n        let lookup_inps = get_index_lookups::\u003cAB, D\u003e(\n            0,\n            0,\n            1,\n            \u0026symbolic_main_local,\n            \u0026preprocessed_local,\n            Direction::Send,\n        );\n\n        assert!(lookup_inps.len() == 1);\n        let lookup = \u003cSelf as Air\u003cAB\u003e\u003e::register_lookup(\n            self,\n            Kind::Global(\"WitnessChecks\".to_string()),\n            \u0026lookup_inps,\n        );\n\n        vec![lookup]\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_circuit::WitnessId;\n    use p3_field::PrimeCharacteristicRing;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_matrix::Matrix;\n    use p3_uni_stark::{prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed};\n    use p3_util::log2_ceil_usize;\n\n    use super::*;\n    use crate::air::test_utils::build_test_config;\n\n    type F = BabyBear;\n    type EF = BinomialExtensionField\u003cF, 4\u003e;\n\n    #[test]\n    fn test_const_air_base_field() {\n        // Create a CONST trace with several constant values\n        // Toy example used: assert(37 * x - 111 = 0)\n        let const_values = vec![\n            F::from_u64(37),  // CONST 1 37\n            F::from_u64(111), // CONST 3 111\n            F::from_u64(0),   // CONST 4 0\n        ];\n        // Witness IDs these constants bind to\n        let const_indices = vec![WitnessId(1), WitnessId(3), WitnessId(4)];\n\n        let preprocessed_values = const_indices\n            .iter()\n            .map(|idx| F::from_u64(idx.0 as u64))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let trace = ConstTrace {\n            index: const_indices.clone(),\n            values: const_values,\n        };\n\n        // Convert to matrix using the ConstAir\n        let matrix = ConstAir::\u003cF, 1\u003e::trace_to_matrix(\u0026trace);\n\n        // Verify matrix dimensions\n        //\n        // D + 1 = 1 + 1 = 2 (value + index)\n        assert_eq!(matrix.width(), 1);\n\n        // Height should be next power of two \u003e= 3\n        let height = matrix.height();\n        assert_eq!(height, 4);\n\n        // Verify the data layout: [value, index] per row\n        let data = \u0026matrix.values;\n\n        // First row: value=37, index=1\n        assert_eq!(data[0], F::from_u64(37));\n\n        // Second row: value=111, index=3\n        assert_eq!(data[1], F::from_u64(111));\n\n        // Third row: value=0, index=4\n        assert_eq!(data[2], F::from_u64(0));\n\n        // Test that we can prove and verify (should succeed since no constraints)\n        let config = build_test_config();\n        // No public inputs for CONST chip\n        let pis: Vec\u003cF\u003e = vec![];\n\n        let air = ConstAir::\u003cF, 1\u003e::new_with_preprocessed(height, preprocessed_values);\n\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_matrix.height(), height);\n\n        // Assert the preprocessed values were properly created.\n        const_indices.iter().enumerate().for_each(|(i, const_idx)| {\n            let row = preprocessed_matrix.row_slice(i).unwrap();\n            // The multiplicity should be 1 for all active rows.\n            assert_eq!(row[0], F::ONE);\n            // Check the witness index.\n            assert_eq!(row[1], F::from_u32(const_idx.0));\n        });\n        // Check the padding row\n        let last_row = preprocessed_matrix.row_slice(height - 1).unwrap();\n        assert_eq!(last_row[0], F::ZERO);\n        assert_eq!(last_row[1], F::ZERO);\n\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(height)).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"CONST chip verification failed\");\n    }\n\n    #[test]\n    fn test_const_air_extension_field() {\n        // Create extension field constants with all non-zero coefficients\n        let const1 = EF::from_basis_coefficients_slice(\u0026[\n            F::from_u64(1), // a0\n            F::from_u64(2), // a1\n            F::from_u64(3), // a2\n            F::from_u64(4), // a3\n        ])\n        .unwrap();\n\n        let const2 = EF::from_basis_coefficients_slice(\u0026[\n            F::from_u64(5), // b0\n            F::from_u64(6), // b1\n            F::from_u64(7), // b2\n            F::from_u64(8), // b3\n        ])\n        .unwrap();\n\n        let const_values = vec![const1, const2];\n        let const_indices = vec![WitnessId(10), WitnessId(20)];\n        let preprocessed_values = const_indices\n            .iter()\n            .map(|idx| F::from_u64(idx.0 as u64))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let trace = ConstTrace {\n            index: const_indices,\n            values: const_values,\n        };\n\n        // Convert to matrix for D=4 extension field\n        let matrix: RowMajorMatrix\u003cF\u003e = ConstAir::\u003cF, 4\u003e::trace_to_matrix(\u0026trace);\n\n        // Verify matrix dimensions: D = 4 (4 value coefficients)\n        assert_eq!(matrix.width(), 4);\n        let height = matrix.height();\n        assert_eq!(height, 2);\n\n        let data = \u0026matrix.values;\n\n        // First row: [a0, a1, a2, a3] = [1, 2, 3, 4]\n        assert_eq!(data[0], F::from_u64(1));\n        assert_eq!(data[1], F::from_u64(2));\n        assert_eq!(data[2], F::from_u64(3));\n        assert_eq!(data[3], F::from_u64(4));\n\n        // Second row: [b0, b1, b2, b3] = [5, 6, 7, 8]\n        assert_eq!(data[4], F::from_u64(5));\n        assert_eq!(data[5], F::from_u64(6));\n        assert_eq!(data[6], F::from_u64(7));\n        assert_eq!(data[7], F::from_u64(8));\n\n        // Test proving and verification for extension field\n        let config = build_test_config();\n        let pis: Vec\u003cF\u003e = vec![];\n\n        let air = ConstAir::\u003cF, 4\u003e::new_with_preprocessed(height, preprocessed_values);\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        let row0 = preprocessed_matrix.row_slice(0).unwrap();\n        // Assert that the multipliticy is 1 since the furst row is active\n        assert_eq!(row0[0], F::ONE);\n        // Assert that the witness index is correct.\n        assert_eq!(row0[1], F::from_u64(10));\n        let last_row = preprocessed_matrix.row_slice(height - 1).unwrap();\n        // Assert that the multipliticy is 1 since the furst row is active\n        assert_eq!(last_row[0], F::ONE);\n        // Assert that the witness index is correct.\n        assert_eq!(last_row[1], F::from_u64(20));\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(height)).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"Extension field CONST verification failed\");\n    }\n\n    #[test]\n    fn test_air_constraint_degree() {\n        let air = ConstAir::\u003cF, 1\u003e::new_with_preprocessed(8, vec![F::ZERO; 8]);\n        p3_test_utils::assert_air_constraint_degree!(air, \"ConstAir\");\n    }\n}\n","traces":[{"line":67,"address":[5040064,5039872,5040160,5039968,5039776],"length":1,"stats":{"Line":10}},{"line":70,"address":[],"length":0,"stats":{"Line":10}},{"line":76,"address":[6783888,6783936],"length":1,"stats":{"Line":12}},{"line":89,"address":[5582384,5582912,5582864,5582816,5582528,5582432,5582288,5582480,5582768,5582336,5582576,5582624,5582672,5582240,5582720],"length":1,"stats":{"Line":11}},{"line":90,"address":[],"length":0,"stats":{"Line":11}},{"line":91,"address":[5582933,5582597,5582789,5582645,5582357,5582837,5582885,5582693,5582405,5582309,5582501,5582261,5582741,5582453,5582549],"length":1,"stats":{"Line":11}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[5579230,5578542,5578318,5580152,5581294,5580416,5578576,5579488,5579454,5580376,5582206,5581070,5581328,5577664,5581982],"length":1,"stats":{"Line":12}},{"line":108,"address":[5581366,5577702,5578614,5579526,5580454],"length":1,"stats":{"Line":10}},{"line":109,"address":[5038635],"length":1,"stats":{"Line":12}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":10}},{"line":116,"address":[5038820,5038741],"length":1,"stats":{"Line":12}},{"line":119,"address":[5038884,5038790],"length":1,"stats":{"Line":22}},{"line":121,"address":[],"length":0,"stats":{"Line":22}},{"line":122,"address":[],"length":0,"stats":{"Line":10}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[5766179,5767091,5766233,5767145],"length":1,"stats":{"Line":22}},{"line":132,"address":[6783160,6782248],"length":1,"stats":{"Line":12}},{"line":133,"address":[5039094],"length":1,"stats":{"Line":10}},{"line":135,"address":[],"length":0,"stats":{"Line":12}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[1837344],"length":1,"stats":{"Line":12}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[6713136,6712992],"length":1,"stats":{"Line":10}},{"line":153,"address":[],"length":0,"stats":{"Line":10}},{"line":154,"address":[5070416,5069840,5070272,5069984,5070128],"length":1,"stats":{"Line":12}},{"line":155,"address":[5703983,5703839],"length":1,"stats":{"Line":10}},{"line":156,"address":[5069878,5070310,5070166,5070022,5070455],"length":1,"stats":{"Line":12}},{"line":165,"address":[1840128,1840144],"length":1,"stats":{"Line":55}},{"line":168,"address":[5038224],"length":1,"stats":{"Line":13}},{"line":170,"address":[],"length":0,"stats":{"Line":13}},{"line":173,"address":[5038207,5037152,5038179],"length":1,"stats":{"Line":12}},{"line":178,"address":[6777694,6778766],"length":1,"stats":{"Line":12}},{"line":179,"address":[5037213],"length":1,"stats":{"Line":12}},{"line":188,"address":[],"length":0,"stats":{"Line":12}},{"line":189,"address":[],"length":0,"stats":{"Line":12}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[6778003,6779132,6779075,6778060],"length":1,"stats":{"Line":26}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[5528480,5529552,5526336,5527408,5525264,5524192],"length":1,"stats":{"Line":13}},{"line":197,"address":[],"length":0,"stats":{"Line":13}},{"line":200,"address":[],"length":0,"stats":{"Line":26}}],"covered":36,"coverable":50},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","mod.rs"],"content":"pub mod alu_air;\npub mod const_air;\npub mod public_air;\npub mod utils;\npub mod witness_air;\n\n#[cfg(test)]\npub mod test_utils;\n\npub use alu_air::AluAir;\npub use const_air::ConstAir;\npub use public_air::PublicAir;\npub use witness_air::WitnessAir;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","public_air.rs"],"content":"//! [`PublicAir`] stores public inputs either in the base field or the extension field (of extension degree `D`).\n//!\n//! # Column Layout\n//!\n//! For each logical public input (lane) we allocate `D` base-field columns for the value.\n//! The runtime parameter `lanes` controls how many independent public inputs are packed\n//! side-by-side in a single row of the trace.\n//!\n//! We also allocate 2 preprocessed base-field columns per lane:\n//! - 1 column for the multiplicity (1 for active rows, 0 for padding),\n//! - 1 column for the witness index.\n//!\n//! # Constraints\n//!\n//! The AIR has no constraints.\n//!\n//! # Global Interactions\n//!\n//! For each lane, there is one interaction with the witness bus:\n//! - send (index, value)\n\nuse alloc::string::ToString;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::marker::PhantomData;\n\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues, BaseAir, PermutationAirBuilder};\nuse p3_circuit::tables::PublicTrace;\nuse p3_field::{BasedVectorSpace, Field};\nuse p3_lookup::lookup_traits::{Direction, Kind, Lookup};\nuse p3_matrix::dense::RowMajorMatrix;\n\nuse crate::air::utils::{\n    create_preprocessed_trace_with_multiplicity, create_symbolic_variables, get_index_lookups,\n};\n\n/// PublicAir: vector-valued public input binding with generic extension degree D.\n/// Layout per row: [value[0..D)] repeated `lanes` times.\n#[derive(Debug, Clone)]\npub struct PublicAir\u003cF, const D: usize = 1\u003e {\n    /// Total number of logical public input operations in the trace.\n    pub num_ops: usize,\n    /// Number of independent public inputs packed per trace row.\n    pub lanes: usize,\n    /// Preprocessed witness indices for the public inputs.\n    pub preprocessed: Vec\u003cF\u003e,\n    /// Number of lookup columns registered by this AIR so far.\n    pub num_lookup_columns: usize,\n    /// Minimum trace height (for FRI compatibility with higher log_final_poly_len).\n    pub min_height: usize,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field, const D: usize\u003e PublicAir\u003cF, D\u003e {\n    /// Construct a new `PublicAir` instance.\n    ///\n    /// - `num_ops`: total number of public input operations to be proven,\n    /// - `lanes`: how many operations are packed side-by-side in each row.\n    ///\n    /// Panics if `lanes == 0` because we always need at least one lane per row.\n    pub const fn new(num_ops: usize, lanes: usize) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        Self {\n            num_ops,\n            lanes,\n            preprocessed: Vec::new(),\n            num_lookup_columns: 0,\n            min_height: 1,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Construct a new `PublicAir` instance with preprocessed data.\n    ///\n    /// - `num_ops`: total number of public input operations to be proven,\n    /// - `lanes`: how many operations are packed side-by-side in each row.\n    /// - `preprocessed`: flattened preprocessed values (indices without multiplicities).\n    ///\n    /// Panics if `lanes == 0` because we always need at least one lane per row.\n    pub const fn new_with_preprocessed(num_ops: usize, lanes: usize, preprocessed: Vec\u003cF\u003e) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        Self {\n            num_ops,\n            lanes,\n            preprocessed,\n            num_lookup_columns: 0,\n            min_height: 1,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Set the minimum trace height for FRI compatibility.\n    ///\n    /// FRI requires: `log_trace_height \u003e log_final_poly_len + log_blowup`\n    /// So `min_height` should be \u003e= `2^(log_final_poly_len + log_blowup + 1)`.\n    pub const fn with_min_height(mut self, min_height: usize) -\u003e Self {\n        self.min_height = min_height;\n        self\n    }\n\n    /// Number of base-field columns occupied by a single lane.\n    /// Each lane stores D coordinates for the value.\n    pub const fn lane_width() -\u003e usize {\n        D\n    }\n\n    /// Total number of columns in the main trace for this AIR instance.\n    pub const fn total_width(\u0026self) -\u003e usize {\n        self.lanes * Self::lane_width()\n    }\n\n    /// Number of preprocessed base-field columns occupied by a single lane.\n    /// Each lane stores multiplicity + index = 2 columns.\n    pub const fn preprocessed_lane_width() -\u003e usize {\n        2\n    }\n\n    /// Total number of preprocessed columns for this AIR instance.\n    pub const fn preprocessed_width(\u0026self) -\u003e usize {\n        self.lanes * Self::preprocessed_lane_width()\n    }\n\n    /// Flatten a PublicTrace over an extension into a base-field matrix with lanes packing.\n    #[inline]\n    pub fn trace_to_matrix\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(\n        trace: \u0026PublicTrace\u003cExtF\u003e,\n        lanes: usize,\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\n        let num_ops = trace.values.len();\n        assert_eq!(\n            num_ops,\n            trace.index.len(),\n            \"PublicTrace column length mismatch\"\n        );\n\n        let lane_width = Self::lane_width();\n        let row_width = lanes * lane_width;\n        let num_rows = num_ops.div_ceil(lanes);\n\n        let mut values = Vec::with_capacity(num_rows * row_width);\n        for row_idx in 0..num_rows {\n            for lane in 0..lanes {\n                let op_idx = row_idx * lanes + lane;\n                if op_idx \u003c num_ops {\n                    let coeffs = trace.values[op_idx].as_basis_coefficients_slice();\n                    assert_eq!(\n                        coeffs.len(),\n                        D,\n                        \"extension degree mismatch for PublicTrace value\"\n                    );\n                    values.extend_from_slice(coeffs);\n                } else {\n                    // Padding: fill with zeros\n                    values.extend(core::iter::repeat_n(F::ZERO, lane_width));\n                }\n            }\n        }\n\n        let mut mat = RowMajorMatrix::new(values, row_width);\n        mat.pad_to_power_of_two_height(F::ZERO);\n        mat\n    }\n\n    /// Extract preprocessed indices from a PublicTrace (without multiplicities).\n    pub fn trace_to_preprocessed\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(trace: \u0026PublicTrace\u003cExtF\u003e) -\u003e Vec\u003cF\u003e {\n        trace\n            .index\n            .iter()\n            .map(|widx| F::from_u64(widx.0 as u64))\n            .collect()\n    }\n}\n\nimpl\u003cF: Field, const D: usize\u003e BaseAir\u003cF\u003e for PublicAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        self.total_width()\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\n        Some(create_preprocessed_trace_with_multiplicity(\n            \u0026self.preprocessed,\n            Self::preprocessed_lane_width(),\n            self.lanes,\n            self.min_height,\n            |op_idx| {\n                if op_idx \u003c self.preprocessed.len() {\n                    F::ONE\n                } else {\n                    F::ZERO\n                }\n            },\n        ))\n    }\n}\n\nimpl\u003cAB: AirBuilder, const D: usize\u003e Air\u003cAB\u003e for PublicAir\u003cAB::F, D\u003e\nwhere\n    AB::F: Field,\n{\n    fn eval(\u0026self, _builder: \u0026mut AB) {\n        // No constraints for public inputs in Stage 1\n    }\n\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        let new_idx = self.num_lookup_columns;\n        self.num_lookup_columns += 1;\n        vec![new_idx]\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cAB\u003e::F\u003e\u003e\n    where\n        AB: PermutationAirBuilder + AirBuilderWithPublicValues,\n    {\n        let mut lookups = Vec::new();\n        self.num_lookup_columns = 0;\n\n        let (symbolic_main_local, preprocessed_local) = create_symbolic_variables::\u003cAB::F\u003e(\n            self.preprocessed_width(),\n            BaseAir::\u003cAB::F\u003e::width(self),\n            self.lanes,\n            0,\n        );\n\n        for lane in 0..self.lanes {\n            let lane_offset = lane * Self::lane_width();\n            let preprocessed_lane_offset = lane * Self::preprocessed_lane_width();\n\n            let lane_lookup_inputs = get_index_lookups::\u003cAB, D\u003e(\n                lane_offset,\n                preprocessed_lane_offset,\n                1,\n                \u0026symbolic_main_local,\n                \u0026preprocessed_local,\n                Direction::Send,\n            );\n\n            lookups.extend(lane_lookup_inputs.into_iter().map(|inps| {\n                \u003cSelf as Air\u003cAB\u003e\u003e::register_lookup(\n                    self,\n                    Kind::Global(\"WitnessChecks\".to_string()),\n                    \u0026[inps],\n                )\n            }));\n        }\n        lookups\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_circuit::WitnessId;\n    use p3_field::PrimeCharacteristicRing;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_matrix::Matrix;\n    use p3_uni_stark::{prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed};\n    use p3_util::log2_ceil_usize;\n\n    use super::*;\n    use crate::air::test_utils::build_test_config;\n\n    type F = BabyBear;\n    type EF = BinomialExtensionField\u003cF, 4\u003e;\n\n    #[test]\n    fn test_public_air_base_field() {\n        let n = 8usize;\n        let lanes = 1usize;\n        let values: Vec\u003cF\u003e = (1..=n as u64).map(F::from_u64).collect();\n        let indices: Vec\u003cWitnessId\u003e = (0..n as u32).map(WitnessId).collect();\n\n        // Get preprocessed index values.\n        let preprocessed_values = indices\n            .iter()\n            .map(|idx| F::from_u64(idx.0 as u64))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let trace = PublicTrace {\n            values,\n            index: indices,\n        };\n\n        let matrix = PublicAir::\u003cF, 1\u003e::trace_to_matrix(\u0026trace, lanes);\n\n        // Verify matrix dimensions\n        assert_eq!(matrix.width(), 1); // D = 1, lanes = 1\n\n        // Check first row (scope the borrow)\n        {\n            let row0 = matrix.row_slice(0).unwrap();\n            assert_eq!(row0[0], F::from_u64(1)); // value\n        }\n\n        // Check last original row (scope the borrow)\n        {\n            let last_original_row = n - 1;\n            let row_last = matrix.row_slice(last_original_row).unwrap();\n            assert_eq!(row_last[0], F::from_u64(n as u64)); // value\n        }\n\n        let config = build_test_config();\n        let air = PublicAir::\u003cF, 1\u003e::new_with_preprocessed(n, lanes, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        // Check the correctness of preprocessed values.\n        let preprocessed = air.preprocessed_trace().unwrap();\n        let row0 = preprocessed.row_slice(0).unwrap();\n        let last_row = preprocessed.row_slice(n - 1).unwrap();\n        // The multiplicity is 1 for active rows.\n        assert_eq!(row0[0], F::from_u64(1)); // first index\n        assert_eq!(last_row[0], F::from_u64(1)); // last index\n        // Check the witness indices.\n        assert_eq!(row0[1], F::from_u64(0)); // first index\n        assert_eq!(last_row[1], F::from_u64((n - 1) as u64)); // last index\n\n        let pis: Vec\u003cF\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"PublicAir base field verification failed\");\n    }\n\n    #[test]\n    fn test_public_air_padding() {\n        let n = 5usize;\n        let lanes = 1usize;\n        let values: Vec\u003cF\u003e = (1..=n as u64).map(F::from_u64).collect();\n        let indices: Vec\u003cWitnessId\u003e = (0..n as u32).map(WitnessId).collect();\n\n        // Get preprocessed index values.\n        let preprocessed_values = indices\n            .iter()\n            .map(|idx| F::from_u64(idx.0 as u64))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let trace = PublicTrace {\n            values,\n            index: indices,\n        };\n\n        let matrix = PublicAir::\u003cF, 1\u003e::trace_to_matrix(\u0026trace, lanes);\n\n        // Verify matrix dimensions\n        assert_eq!(matrix.width(), 1); // D = 1, lanes = 1\n        assert_eq!(matrix.height(), 8); // Padded to next power of two\n\n        // Check first row (scope the borrow)\n        {\n            let row0 = matrix.row_slice(0).unwrap();\n            assert_eq!(row0[0], F::from_u64(1)); // value\n        }\n\n        // Check last original row (scope the borrow)\n        {\n            let last_original_row = n - 1;\n            let row_last = matrix.row_slice(last_original_row).unwrap();\n            assert_eq!(row_last[0], F::from_u64(n as u64)); // value\n        }\n        // Check padded rows (scope the borrow)\n        {\n            for i in n..matrix.height() {\n                let row = matrix.row_slice(i).unwrap();\n                assert_eq!(row[0], F::ZERO); // value\n            }\n        }\n\n        let config = build_test_config();\n        let air = PublicAir::\u003cF, 1\u003e::new_with_preprocessed(n, lanes, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        // Check the correctness of preprocessed values.\n        let preprocessed = air.preprocessed_trace().unwrap();\n        assert!(preprocessed.height() == 8);\n        for i in 0..n {\n            let row = preprocessed.row_slice(i).unwrap();\n            // The multiplicity is 1 for active rows.\n            assert_eq!(row[0], F::from_u64(1)); // first index\n            // Check the witness indices.\n            assert_eq!(row[1], F::from_u64(i as u64)); // first index\n        }\n        for i in n..preprocessed.height() {\n            let row = preprocessed.row_slice(i).unwrap();\n            // The multiplicity is 0 for padded rows.\n            assert_eq!(row[0], F::ZERO); // first index\n            // Check the witness indices.\n            assert_eq!(row[1], F::ZERO); // last original index\n        }\n\n        let pis: Vec\u003cF\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"PublicAir base field verification failed\");\n    }\n\n    #[test]\n    fn test_public_air_extension_field() {\n        let lanes = 1usize;\n        let a = EF::from_basis_coefficients_slice(\u0026[\n            F::from_u64(1),\n            F::from_u64(2),\n            F::from_u64(3),\n            F::from_u64(4),\n        ])\n        .unwrap();\n\n        let b = EF::from_basis_coefficients_slice(\u0026[\n            F::from_u64(5),\n            F::from_u64(6),\n            F::from_u64(7),\n            F::from_u64(8),\n        ])\n        .unwrap();\n\n        let values = vec![a, b];\n        let indices = vec![WitnessId(10), WitnessId(20)];\n        let preprocessed_values = indices\n            .iter()\n            .map(|idx| F::from_u64(idx.0 as u64))\n            .collect();\n\n        let trace = PublicTrace {\n            values,\n            index: indices,\n        };\n        let matrix = PublicAir::\u003cF, 4\u003e::trace_to_matrix(\u0026trace, lanes);\n\n        // Verify matrix dimensions\n        assert_eq!(matrix.width(), 4); // D = 4, lanes = 1\n\n        // Check first row - extension field coefficients (scope the borrow)\n        {\n            let row0 = matrix.row_slice(0).unwrap();\n            let a_coeffs = a.as_basis_coefficients_slice();\n            assert_eq!(\u0026row0[0..4], a_coeffs);\n        }\n\n        // Check second row (scope the borrow)\n        {\n            let row1 = matrix.row_slice(1).unwrap();\n            let b_coeffs = b.as_basis_coefficients_slice();\n            assert_eq!(\u0026row1[0..4], b_coeffs);\n        }\n\n        let config = build_test_config();\n        let air = PublicAir::\u003cF, 4\u003e::new_with_preprocessed(2, lanes, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        let prep = air.preprocessed_trace().unwrap();\n        // Check the correctness of preprocessed values.\n        let row0 = prep.row_slice(0).unwrap();\n        let last_row = prep.row_slice(1).unwrap();\n        // The multiplicity is 1 for active rows.\n        assert_eq!(row0[0], F::from_u64(1)); // first index\n        assert_eq!(last_row[0], F::from_u64(1)); // last index\n        // Check the witness indices.\n        assert_eq!(row0[1], F::from_u64(10)); // first index\n        assert_eq!(last_row[1], F::from_u64(20)); // last index\n\n        let pis: Vec\u003cF\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"PublicAir extension field verification failed\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_public_air_mismatched_lengths() {\n        let values = vec![F::from_u64(1), F::from_u64(2)];\n        let indices = vec![WitnessId(0)]; // Wrong length\n\n        let trace = PublicTrace {\n            values,\n            index: indices,\n        };\n        PublicAir::\u003cF, 1\u003e::trace_to_matrix(\u0026trace, 1);\n    }\n\n    #[test]\n    fn test_air_constraint_degree() {\n        let air = PublicAir::\u003cF, 1\u003e::new_with_preprocessed(8, 1, vec![F::ZERO; 8]);\n        p3_test_utils::assert_air_constraint_degree!(air, \"PublicAir\");\n    }\n}\n","traces":[{"line":61,"address":[5196112,5196272,5196432,5196592,5196752],"length":1,"stats":{"Line":11}},{"line":62,"address":[5196465,5196785,5196625,5196305,5196145],"length":1,"stats":{"Line":11}},{"line":66,"address":[],"length":0,"stats":{"Line":11}},{"line":80,"address":[10761237,10762080,10761781,10761264,10761509,10760992,10762053,10761808,10762325,10761536],"length":1,"stats":{"Line":12}},{"line":81,"address":[1737201,1737015],"length":1,"stats":{"Line":12}},{"line":96,"address":[7175392,7175488,7175440,7175296,7175344],"length":1,"stats":{"Line":11}},{"line":97,"address":[6094257,6094113,6094305,6094161,6094209],"length":1,"stats":{"Line":11}},{"line":98,"address":[6094165,6094261,6094213,6094309,6094117],"length":1,"stats":{"Line":11}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[6090784,6090944,6091024,6091104,6090864],"length":1,"stats":{"Line":12}},{"line":109,"address":[10751785,10751428,10751748,10751828,10752425,10751588,10751988,10752548,10751668,10751865,10751945,10752148,10752505,10751625,10752105,10752345,10751385,10751705,10752308,10752265,10751545,10752025,10752468,10752228,10751465,10751908,10752185,10752068,10751508,10752388],"length":1,"stats":{"Line":12}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[6094336,6094416],"length":1,"stats":{"Line":13}},{"line":120,"address":[7175545,7175625,7175588,7175668],"length":1,"stats":{"Line":12}},{"line":125,"address":[6093510,6092607,6094063,6091184,6092054,6092640],"length":1,"stats":{"Line":11}},{"line":129,"address":[10758482,10754098,10755570,10752642,10757026],"length":1,"stats":{"Line":11}},{"line":130,"address":[7173939,7172483],"length":1,"stats":{"Line":11}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[10757184,10754256,10758640,10755728,10752800],"length":1,"stats":{"Line":11}},{"line":137,"address":[],"length":0,"stats":{"Line":11}},{"line":138,"address":[7172680,7174136],"length":1,"stats":{"Line":11}},{"line":140,"address":[5194388,5194427,5194487],"length":1,"stats":{"Line":22}},{"line":141,"address":[6091592,6093149,6093048,6091693],"length":1,"stats":{"Line":22}},{"line":142,"address":[5194683,5194934],"length":1,"stats":{"Line":22}},{"line":143,"address":[5195057,5195143],"length":1,"stats":{"Line":11}},{"line":144,"address":[],"length":0,"stats":{"Line":11}},{"line":145,"address":[],"length":0,"stats":{"Line":22}},{"line":146,"address":[],"length":0,"stats":{"Line":11}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[7173802,7173747,7175258,7175203],"length":1,"stats":{"Line":22}},{"line":154,"address":[5195171,5195240],"length":1,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":11}},{"line":160,"address":[],"length":0,"stats":{"Line":11}},{"line":161,"address":[10754849,10753383,10759223,10757767,10756311],"length":1,"stats":{"Line":11}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[6014752,6014736,6014768,6014784,6014720],"length":1,"stats":{"Line":12}},{"line":176,"address":[5180229,5180293,5180245,5180261,5180277],"length":1,"stats":{"Line":12}},{"line":179,"address":[],"length":0,"stats":{"Line":10}},{"line":180,"address":[6014526,6014382],"length":1,"stats":{"Line":12}},{"line":181,"address":[10447184,10446896,10447040,10447328,10446752],"length":1,"stats":{"Line":12}},{"line":182,"address":[10447056,10446911,10446767,10447343,10447199],"length":1,"stats":{"Line":10}},{"line":183,"address":[7052438,7052294],"length":1,"stats":{"Line":12}},{"line":184,"address":[],"length":0,"stats":{"Line":10}},{"line":185,"address":[10447712,10447440,10447504,10447584,10447648],"length":1,"stats":{"Line":10}},{"line":186,"address":[7052557,7052531,7052595,7052621],"length":1,"stats":{"Line":12}},{"line":187,"address":[10447487,10447759,10447695,10447553,10447631],"length":1,"stats":{"Line":10}},{"line":189,"address":[5180197],"length":1,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":57}},{"line":204,"address":[],"length":0,"stats":{"Line":14}},{"line":205,"address":[7170856,7171080],"length":1,"stats":{"Line":14}},{"line":206,"address":[10748615,10749222,10748998,10748839,10748774,10748391,10748102,10748550,10749287,10748326,10748167,10749063],"length":1,"stats":{"Line":14}},{"line":207,"address":[7171129,7171031,7170953,7171255,7171177,7170905],"length":1,"stats":{"Line":27}},{"line":210,"address":[5189913,5189919,5188912],"length":1,"stats":{"Line":13}},{"line":214,"address":[5188951],"length":1,"stats":{"Line":13}},{"line":215,"address":[],"length":0,"stats":{"Line":13}},{"line":218,"address":[7169108,7168068],"length":1,"stats":{"Line":13}},{"line":219,"address":[7168132,7169172],"length":1,"stats":{"Line":12}},{"line":220,"address":[10743867,10740747,10741787,10744907,10742827,10739707],"length":1,"stats":{"Line":12}},{"line":224,"address":[5189195,5189286],"length":1,"stats":{"Line":24}},{"line":225,"address":[5189392,5189588,5189550],"length":1,"stats":{"Line":24}},{"line":226,"address":[5189576,5189618,5189669],"length":1,"stats":{"Line":24}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":12}},{"line":233,"address":[5189715],"length":1,"stats":{"Line":12}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[5189799,5190299,5189952],"length":1,"stats":{"Line":25}},{"line":238,"address":[5190230],"length":1,"stats":{"Line":14}},{"line":239,"address":[7170093,7170477],"length":1,"stats":{"Line":14}},{"line":240,"address":[6083637,6083716,6083332,6083253],"length":1,"stats":{"Line":28}},{"line":241,"address":[],"length":0,"stats":{"Line":14}},{"line":245,"address":[],"length":0,"stats":{"Line":13}}],"covered":62,"coverable":81},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","test_utils.rs"],"content":"#![allow(clippy::type_complexity)]\n\nuse p3_baby_bear::{BabyBear as Val, Poseidon2BabyBear as Perm};\nuse p3_challenger::DuplexChallenger as Challenger;\nuse p3_commit::ExtensionMmcs;\nuse p3_dft::Radix2DitParallel as Dft;\nuse p3_field::extension::BinomialExtensionField;\nuse p3_fri::{TwoAdicFriPcs as Pcs, create_test_fri_params};\nuse p3_merkle_tree::MerkleTreeMmcs;\nuse p3_symmetric::{PaddingFreeSponge as MyHash, TruncatedPermutation as MyCompress};\nuse p3_uni_stark::StarkConfig;\n\npub type Challenge = BinomialExtensionField\u003cVal, 4\u003e;\npub type ValMmcs = MerkleTreeMmcs\u003c\n    \u003cVal as p3_field::Field\u003e::Packing,\n    \u003cVal as p3_field::Field\u003e::Packing,\n    MyHash\u003cPerm\u003c16\u003e, 16, 8, 8\u003e,\n    MyCompress\u003cPerm\u003c16\u003e, 2, 8, 16\u003e,\n    8,\n\u003e;\npub type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\n\n/// Build a test STARK config following the standard pattern from Plonky3 examples\npub fn build_test_config() -\u003e StarkConfig\u003c\n    Pcs\u003cVal, Dft\u003cVal\u003e, ValMmcs, ChallengeMmcs\u003e,\n    Challenge,\n    Challenger\u003cVal, Perm\u003c16\u003e, 16, 8\u003e,\n\u003e {\n    use rand::SeedableRng;\n    use rand::rngs::SmallRng;\n\n    let mut rng = SmallRng::seed_from_u64(1);\n    let perm = Perm::\u003c16\u003e::new_from_rng_128(\u0026mut rng);\n    let hash = MyHash::\u003cPerm\u003c16\u003e, 16, 8, 8\u003e::new(perm.clone());\n    let compress = MyCompress::\u003cPerm\u003c16\u003e, 2, 8, 16\u003e::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress, 0);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::\u003cVal\u003e::default();\n    let fri_params = create_test_fri_params::\u003cChallengeMmcs\u003e(challenge_mmcs, 0);\n    let pcs = Pcs::new(dft, val_mmcs, fri_params);\n    let challenger = Challenger::\u003cVal, Perm\u003c16\u003e, 16, 8\u003e::new(perm);\n\n    StarkConfig::new(pcs, challenger)\n}\n","traces":[{"line":24,"address":[11447903,11446640,11447981],"length":1,"stats":{"Line":1}},{"line":32,"address":[11446657],"length":1,"stats":{"Line":2}},{"line":33,"address":[11446730],"length":1,"stats":{"Line":1}},{"line":34,"address":[11446769,11446833],"length":1,"stats":{"Line":3}},{"line":35,"address":[11446925,11446864],"length":1,"stats":{"Line":3}},{"line":36,"address":[11446932],"length":1,"stats":{"Line":1}},{"line":37,"address":[11447223,11447159],"length":1,"stats":{"Line":5}},{"line":38,"address":[11447246],"length":1,"stats":{"Line":3}},{"line":39,"address":[11447291],"length":1,"stats":{"Line":3}},{"line":40,"address":[11447407],"length":1,"stats":{"Line":1}},{"line":41,"address":[11447569],"length":1,"stats":{"Line":3}},{"line":43,"address":[11447721],"length":1,"stats":{"Line":1}}],"covered":12,"coverable":12},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","utils.rs"],"content":"use alloc::vec;\nuse alloc::vec::Vec;\nuse core::iter;\n\nuse itertools::Itertools;\nuse p3_air::lookup::LookupEvaluator;\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues, PermutationAirBuilder};\nuse p3_field::Field;\nuse p3_lookup::lookup_traits::{Direction, Lookup, LookupData, LookupInput};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_uni_stark::{SymbolicAirBuilder, SymbolicExpression, SymbolicVariable};\n\npub fn get_index_lookups\u003cAB: PermutationAirBuilder + AirBuilderWithPublicValues, const D: usize\u003e(\n    main_start: usize,\n    preprocessed_start: usize,\n    num_lookups: usize,\n    main: \u0026[SymbolicVariable\u003c\u003cAB as AirBuilder\u003e::F\u003e],\n    preprocessed: \u0026[SymbolicVariable\u003c\u003cAB as AirBuilder\u003e::F\u003e],\n    direction: Direction,\n) -\u003e Vec\u003cLookupInput\u003cAB::F\u003e\u003e {\n    (0..num_lookups)\n        .map(|i| {\n            let idx = SymbolicExpression::from(preprocessed[1 + preprocessed_start + i]);\n\n            let multiplicity = SymbolicExpression::from(preprocessed[preprocessed_start]);\n\n            let values = (0..D).map(|j| SymbolicExpression::from(main[main_start + i * D + j]));\n            let inps = iter::once(idx).chain(values).collect::\u003cVec\u003c_\u003e\u003e();\n\n            (inps, multiplicity, direction)\n        })\n        .collect()\n}\n\n/// Get ALU lookups for the 4 operands (a, b, c, out).\n///\n/// ALU preprocessed layout per lane:\n/// - 0: multiplicity\n/// - 1-3: selectors (add_vs_mul, bool, muladd)\n/// - 4-7: indices (a_idx, b_idx, c_idx, out_idx)\n///\n/// Main layout per lane: a[D], b[D], c[D], out[D]\npub fn get_alu_index_lookups\u003c\n    AB: PermutationAirBuilder + AirBuilderWithPublicValues,\n    const D: usize,\n\u003e(\n    main_start: usize,\n    preprocessed_start: usize,\n    main: \u0026[SymbolicVariable\u003c\u003cAB as AirBuilder\u003e::F\u003e],\n    preprocessed: \u0026[SymbolicVariable\u003c\u003cAB as AirBuilder\u003e::F\u003e],\n    direction: Direction,\n) -\u003e Vec\u003cLookupInput\u003cAB::F\u003e\u003e {\n    let multiplicity = SymbolicExpression::from(preprocessed[preprocessed_start]);\n\n    // Indices are at positions 4, 5, 6, 7 (after multiplicity + 3 selectors)\n    let idx_offset = 4;\n\n    (0..4)\n        .map(|i| {\n            let idx = SymbolicExpression::from(preprocessed[preprocessed_start + idx_offset + i]);\n\n            let values = (0..D).map(|j| SymbolicExpression::from(main[main_start + i * D + j]));\n            let inps = iter::once(idx).chain(values).collect::\u003cVec\u003c_\u003e\u003e();\n\n            (inps, multiplicity.clone(), direction)\n        })\n        .collect()\n}\n\n/// Object‑safe gadget shim.\npub trait LookupEvaluatorDyn\u003cAB: PermutationAirBuilder + AirBuilderWithPublicValues\u003e {\n    fn num_aux_cols(\u0026self) -\u003e usize;\n    fn num_challenges(\u0026self) -\u003e usize;\n    fn eval_with_lookups_dyn(\n        \u0026self,\n        builder: \u0026mut AB,\n        contexts: \u0026[Lookup\u003cAB::F\u003e],\n        lookup_data: \u0026[LookupData\u003cAB::ExprEF\u003e],\n    );\n}\n\n/// Blanket: any concrete `LookupEvaluator` becomes object‑safe.\nimpl\u003cAB, LE\u003e LookupEvaluatorDyn\u003cAB\u003e for LE\nwhere\n    AB: PermutationAirBuilder + AirBuilderWithPublicValues,\n    LE: LookupEvaluator,\n{\n    fn num_aux_cols(\u0026self) -\u003e usize {\n        LE::num_aux_cols(self)\n    }\n    fn num_challenges(\u0026self) -\u003e usize {\n        LE::num_challenges(self)\n    }\n    fn eval_with_lookups_dyn(\n        \u0026self,\n        builder: \u0026mut AB,\n        contexts: \u0026[Lookup\u003cAB::F\u003e],\n        lookup_data: \u0026[LookupData\u003cAB::ExprEF\u003e],\n    ) {\n        // forward to the generic method on the concrete handler\n        LE::eval_lookups(self, builder, contexts, lookup_data);\n    }\n}\n\n/// Object‑safe AIR shim.\npub trait AirDyn\u003cAB\u003e\nwhere\n    AB: PermutationAirBuilder + AirBuilderWithPublicValues,\n{\n    fn add_lookup_columns_dyn(\u0026mut self) -\u003e Vec\u003cusize\u003e;\n    fn get_lookups_dyn(\u0026mut self) -\u003e Vec\u003cLookup\u003cAB::F\u003e\u003e;\n    fn eval_with_lookups_dyn\u003cLE: LookupEvaluator\u003e(\n        \u0026self,\n        builder: \u0026mut AB,\n        contexts: \u0026[Lookup\u003cAB::F\u003e],\n        lookup_data: \u0026[LookupData\u003cAB::ExprEF\u003e],\n        lookup_evaluator: \u0026LE,\n    );\n}\n\n/// Blanket: any existing `Air` now satisfies the object‑safe shim.\nimpl\u003cAB, T\u003e AirDyn\u003cAB\u003e for T\nwhere\n    AB: PermutationAirBuilder + AirBuilderWithPublicValues,\n    T: Air\u003cAB\u003e,\n{\n    fn add_lookup_columns_dyn(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        self.add_lookup_columns()\n    }\n    fn get_lookups_dyn(\u0026mut self) -\u003e Vec\u003cLookup\u003cAB::F\u003e\u003e {\n        self.get_lookups()\n    }\n    fn eval_with_lookups_dyn\u003cLE: LookupEvaluator\u003e(\n        \u0026self,\n        builder: \u0026mut AB,\n        contexts: \u0026[Lookup\u003cAB::F\u003e],\n        lookup_data: \u0026[LookupData\u003cAB::ExprEF\u003e],\n        lookup_evaluator: \u0026LE,\n    ) {\n        Air::\u003cAB\u003e::eval_with_lookups(self, builder, contexts, lookup_data, lookup_evaluator);\n    }\n}\n\n/// Helper to create symbolic air builder and extract symbolic variables for lookup generation.\n///\n/// Returns `(symbolic_main_local, preprocessed_local)` slices for use in lookup generation.\npub fn create_symbolic_variables\u003cF: Field\u003e(\n    preprocessed_width: usize,\n    main_width: usize,\n    num_public_values: usize,\n    num_permutation_cols: usize,\n) -\u003e (Vec\u003cSymbolicVariable\u003cF\u003e\u003e, Vec\u003cSymbolicVariable\u003cF\u003e\u003e) {\n    let symbolic_air_builder = SymbolicAirBuilder::\u003cF\u003e::new(\n        preprocessed_width,\n        main_width,\n        0,\n        num_public_values,\n        num_permutation_cols,\n    );\n\n    let symbolic_main = symbolic_air_builder.main();\n    let symbolic_main_local = symbolic_main.row_slice(0).unwrap().to_vec();\n\n    let preprocessed = symbolic_air_builder\n        .preprocessed()\n        .expect(\"Expected preprocessed columns\");\n    let preprocessed_local = preprocessed.row_slice(0).unwrap().to_vec();\n\n    (symbolic_main_local, preprocessed_local)\n}\n\n/// Helper to pad a matrix to power-of-two height and then to min_height if needed.\npub fn pad_matrix_with_min_height\u003cF: Field\u003e(\n    mut mat: RowMajorMatrix\u003cF\u003e,\n    min_height: usize,\n) -\u003e RowMajorMatrix\u003cF\u003e {\n    mat.pad_to_power_of_two_height(F::ZERO);\n\n    let min_rows = min_height.next_power_of_two();\n    if mat.height() \u003c min_rows {\n        let width = mat.width();\n        let padding_rows = min_rows - mat.height();\n        mat.values\n            .extend(core::iter::repeat_n(F::ZERO, padding_rows * width));\n    }\n\n    mat\n}\n\n/// Helper to create preprocessed trace with multiplicity insertion and padding.\n///\n/// Takes preprocessed values (one per op, without multiplicities) and inserts multiplicities\n/// at the start of each lane, then pads to power-of-two and min_height.\n/// This version assumes each op has exactly one preprocessed value (like PublicAir).\npub fn create_preprocessed_trace_with_multiplicity\u003cF: Field\u003e(\n    preprocessed_values: \u0026[F],\n    preprocessed_lane_width: usize,\n    num_lanes: usize,\n    min_height: usize,\n    get_multiplicity: impl Fn(usize) -\u003e F,\n) -\u003e RowMajorMatrix\u003cF\u003e {\n    let num_ops = preprocessed_values.len();\n    let num_rows = num_ops.div_ceil(num_lanes);\n    let row_width = num_lanes * preprocessed_lane_width;\n\n    let mut values = Vec::with_capacity(num_rows * row_width);\n    for row_idx in 0..num_rows {\n        for lane in 0..num_lanes {\n            let op_idx = row_idx * num_lanes + lane;\n            if op_idx \u003c num_ops {\n                values.push(get_multiplicity(op_idx));\n                values.push(preprocessed_values[op_idx]);\n                // Add remaining columns if preprocessed_lane_width \u003e 2\n                if preprocessed_lane_width \u003e 2 {\n                    values.extend(core::iter::repeat_n(F::ZERO, preprocessed_lane_width - 2));\n                }\n            } else {\n                values.extend(core::iter::repeat_n(F::ZERO, preprocessed_lane_width));\n            }\n        }\n    }\n\n    let mat = RowMajorMatrix::new(values, row_width);\n    pad_matrix_with_min_height(mat, min_height)\n}\n\n/// Helper to create preprocessed trace for single-row-per-op AIRs (like ConstAir).\n///\n/// Inserts multiplicity before each preprocessed value, then pads.\npub fn create_simple_preprocessed_trace\u003cF: Field\u003e(\n    preprocessed_values: \u0026[F],\n    preprocessed_width: usize,\n    min_height: usize,\n) -\u003e RowMajorMatrix\u003cF\u003e {\n    let preprocessed_with_multiplicity: Vec\u003cF\u003e = preprocessed_values\n        .iter()\n        .flat_map(|v| [F::ONE, *v])\n        .collect();\n\n    let mat = RowMajorMatrix::new(preprocessed_with_multiplicity, preprocessed_width);\n    pad_matrix_with_min_height(mat, min_height)\n}\n\n/// Helper to create preprocessed trace for AIRs with chunked preprocessed values (like AluAir).\n///\n/// Takes preprocessed values grouped in chunks of (preprocessed_lane_width - 1) per op,\n/// inserts multiplicity at the start of each chunk, then pads.\npub fn create_chunked_preprocessed_trace\u003cF: Field\u003e(\n    preprocessed_values: \u0026[F],\n    preprocessed_lane_width: usize,\n    num_lanes: usize,\n    min_height: usize,\n) -\u003e RowMajorMatrix\u003cF\u003e {\n    // Add multiplicity to preprocessed values\n    let mut preprocessed_with_multiplicity: Vec\u003cF\u003e = preprocessed_values\n        .iter()\n        .chunks(preprocessed_lane_width - 1)\n        .into_iter()\n        .flat_map(|chunk| iter::once(F::ONE).chain(chunk.into_iter().cloned()))\n        .collect();\n\n    debug_assert!(\n        preprocessed_with_multiplicity\n            .len()\n            .is_multiple_of(preprocessed_lane_width),\n        \"Preprocessed trace length mismatch\"\n    );\n\n    let preprocessed_width = num_lanes * preprocessed_lane_width;\n    let padding_len =\n        preprocessed_width - preprocessed_with_multiplicity.len() % preprocessed_width;\n    if padding_len != preprocessed_width {\n        preprocessed_with_multiplicity.extend(vec![F::ZERO; padding_len]);\n    }\n\n    let mat = RowMajorMatrix::new(preprocessed_with_multiplicity, preprocessed_width);\n    pad_matrix_with_min_height(mat, min_height)\n}\n","traces":[{"line":14,"address":[3371504],"length":1,"stats":{"Line":13}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[7921470,7915393,7917822,7918768,7916910,7917816,7920552,7917856,7914625,7919640,7920558,7920592,7916032,7916944,7918728,7919646,7915649,7921464,7916904,7914881,7915905,7915137,7919680,7918734],"length":1,"stats":{"Line":24}},{"line":24,"address":[4660154,4659242,4659939,4659027],"length":1,"stats":{"Line":12}},{"line":26,"address":[7920864,7918128,7918981,7919040,7916245,7919893,7917216,7919952,7917157,7918069,7916304,7920805],"length":1,"stats":{"Line":24}},{"line":28,"address":[],"length":0,"stats":{"Line":36}},{"line":29,"address":[3372283],"length":1,"stats":{"Line":12}},{"line":31,"address":[3372457],"length":1,"stats":{"Line":12}},{"line":44,"address":[4661854,4662350,4661888,4661860,4662356,4661392],"length":1,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":12}},{"line":57,"address":[3373183],"length":1,"stats":{"Line":12}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[3374190,3373456,3373195,3374196],"length":1,"stats":{"Line":24}},{"line":61,"address":[],"length":0,"stats":{"Line":12}},{"line":63,"address":[7930262,7927958,7927190,7930850,7932002,7931104,7932256,7932290,7931138,7931680,7931714,7926422,7930816,7929494,7931426,7928726,7931968,7931392],"length":1,"stats":{"Line":36}},{"line":64,"address":[7926564,7927332,7929636,7930404,7928100,7928868],"length":1,"stats":{"Line":12}},{"line":66,"address":[3553045,3553813],"length":1,"stats":{"Line":12}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[3375303,3374512,3375279],"length":1,"stats":{"Line":7}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[3374610],"length":1,"stats":{"Line":7}},{"line":163,"address":[],"length":0,"stats":{"Line":14}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":14}},{"line":170,"address":[7933160,7934792,7933976],"length":1,"stats":{"Line":7}},{"line":174,"address":[3375716,3375328],"length":1,"stats":{"Line":6}},{"line":178,"address":[7935034,7935450,7935868],"length":1,"stats":{"Line":10}},{"line":180,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[7935523,7935945,7935107],"length":1,"stats":{"Line":8}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[4665613,4665542],"length":1,"stats":{"Line":1}},{"line":184,"address":[3375711],"length":1,"stats":{"Line":1}},{"line":185,"address":[3375656,3375614],"length":1,"stats":{"Line":2}},{"line":188,"address":[7935565,7935991,7935149],"length":1,"stats":{"Line":8}},{"line":196,"address":[3377403,3378551,3377232],"length":1,"stats":{"Line":10}},{"line":203,"address":[7942213,7944901,7946229,7940885,7943541],"length":1,"stats":{"Line":12}},{"line":204,"address":[4668774,4667365,4668693,4667446],"length":1,"stats":{"Line":22}},{"line":205,"address":[4667454,4668782,4668840,4667512],"length":1,"stats":{"Line":10}},{"line":207,"address":[3559020,3558966,3557692,3557638],"length":1,"stats":{"Line":23}},{"line":208,"address":[7942535,7943781,7946469,7946551,7945141,7941125,7941207,7942453,7943869,7945223],"length":1,"stats":{"Line":22}},{"line":209,"address":[3377997,3377801],"length":1,"stats":{"Line":22}},{"line":210,"address":[7941640,7943058,7945746,7944402,7941730,7944312,7945656,7942968,7947074,7946984],"length":1,"stats":{"Line":12}},{"line":211,"address":[7944395,7941723,7943051,7945739,7947067],"length":1,"stats":{"Line":10}},{"line":212,"address":[3378270,3378322],"length":1,"stats":{"Line":24}},{"line":213,"address":[3378342],"length":1,"stats":{"Line":10}},{"line":215,"address":[3378420],"length":1,"stats":{"Line":12}},{"line":216,"address":[7941958,7947302,7944637,7943286,7945974],"length":1,"stats":{"Line":0}},{"line":219,"address":[3558369,3558426,3559754,3559697],"length":1,"stats":{"Line":0}},{"line":224,"address":[3557965,3559293],"length":1,"stats":{"Line":10}},{"line":225,"address":[],"length":0,"stats":{"Line":12}},{"line":231,"address":[3375744],"length":1,"stats":{"Line":8}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":20}},{"line":241,"address":[],"length":0,"stats":{"Line":8}},{"line":242,"address":[3556065],"length":1,"stats":{"Line":6}},{"line":249,"address":[3376957,3376064,3376925],"length":1,"stats":{"Line":8}},{"line":256,"address":[7938226,7937314,7939138],"length":1,"stats":{"Line":7}},{"line":258,"address":[7938260,7939253,7937348,7939173,7937428,7938340],"length":1,"stats":{"Line":8}},{"line":260,"address":[],"length":0,"stats":{"Line":22}},{"line":263,"address":[7938508,7937596,7939413],"length":1,"stats":{"Line":7}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[3556704,3556654,3556732],"length":1,"stats":{"Line":14}},{"line":271,"address":[],"length":0,"stats":{"Line":16}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":8}},{"line":274,"address":[3556943],"length":1,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":8}},{"line":278,"address":[],"length":0,"stats":{"Line":8}}],"covered":58,"coverable":83},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","witness_air.rs"],"content":"//! [`WitnessAir`] defines the AIR for the global witness bus used by all other circuit tables.\n//!\n//! Each logical witness element is stored once in this table together with its witness index.\n//! The generic parameter `D` allows the AIR to handle values from an extension field of degree\n//! `D` over the base field, while the runtime parameter `lanes` controls how many witness\n//! elements are packed side-by-side in every row of the trace.\n//!\n//! # Column layout\n//!\n//! For each witness element (lane) we allocate `D` base-field columns, corresponding to:\n//!\n//! - `D` columns to store the value, where `D` is the degree extension of the used field compared to the current field\n//!\n//! We also allocate two preprocessing columns:\n//!\n//! - 1 column for the indices of the witness elements\n//! - 1 column for the multiplicity at which each witness element appears in the circuit\n//!\n//! A single row can pack several of these lanes side-by-side, so the full row layout is\n//! this pattern repeated `lanes` times:\n//!\n//! ```text\n//!     [value[0..D), index] repeated `lanes` times.\n//! ```\n//!\n//! The logical ordering of witnesses matches the physical ordering of lanes: lane `ℓ + 1`\n//! always stores the witness with index `index_lane_ℓ + 1`, and the first lane of the next row\n//! continues the same sequence. When the final row is not completely filled, unused lanes are\n//! padded by repeating the last witness value and extending the index sequence.\n//!\n//! # Constraints\n//!\n//!  - In the first row, lane 0: `index = 0`.\n//!  - Within a row: for every adjacent pair of lanes, `index_next - index_current - 1 = 0`.\n//!  - Across rows: the index in the first lane of row `r + 1` must equal that of the last lane of row `r` plus 1.\n//!\n//! # Global Interactions\n//!\n//! This table acts as the canonical bus that other chips read from. The registers of all the other circuit\n//! tables receive interactions of the form `(index, value)`, guaranteeing that they fetch\n//! a value consistent with the witness bus maintained by this AIR.\n\nuse alloc::string::ToString;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::marker::PhantomData;\n\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues, BaseAir, PermutationAirBuilder};\nuse p3_circuit::WitnessId;\nuse p3_circuit::tables::WitnessTrace;\nuse p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing};\nuse p3_lookup::lookup_traits::{Direction, Kind, Lookup};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\n\nuse crate::air::utils::{create_symbolic_variables, get_index_lookups, pad_matrix_with_min_height};\n\n/// AIR enforcing a monotonically increasing witness index column for the global bus.\n/// Layout per row: `[value[0..D), index]` repeated `lanes` times.\n///\n/// Constraints:\n///  - first index (lane 0, row 0) equals 0.\n///  - indices increase by 1 between consecutive lanes.\n///  - index of last lane of row *r* plus 1 equals index of first lane of row *r + 1*.\n#[derive(Debug, Clone)]\npub struct WitnessAir\u003cF, const D: usize = 1\u003e {\n    /// Total number of logical witness entries (before packing into lanes).\n    pub num_witnesses: usize,\n    /// Number of witness entries packed side-by-side in every row.\n    pub lanes: usize,\n    /// Multiplicities: number of times each witness index is used in the circuit.\n    pub multiplicities: Vec\u003cF\u003e,\n    /// Number of currently registered lookup columns.\n    pub num_lookup_columns: usize,\n    /// Minimum trace height (for FRI compatibility with higher log_final_poly_len).\n    pub min_height: usize,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field, const D: usize\u003e WitnessAir\u003cF, D\u003e {\n    /// Construct a new `WitnessAir`.\n    ///\n    /// - `num_witnesses`: total number of logical witness entries.\n    /// - `lanes`: how many witness entries are packed side-by-side in each trace row.\n    /// - `multiplicities`: vector of multiplicities for each witness index. It is only used by the prover.\n    pub const fn new(num_witnesses: usize, lanes: usize) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n\n        Self {\n            num_witnesses,\n            lanes,\n            multiplicities: Vec::new(),\n            num_lookup_columns: 0,\n            min_height: 1,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Construct a new `WitnessAir` with given multiplicities.\n    ///\n    /// - `num_witnesses`: total number of logical witness entries.\n    /// - `lanes`: how many witness entries are packed side-by-side in each trace row.\n    /// - `multiplicities`: vector of multiplicities for each witness index. It is only used by the prover.\n    pub const fn new_with_preprocessed(\n        num_witnesses: usize,\n        lanes: usize,\n        multiplicities: Vec\u003cF\u003e,\n    ) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n\n        Self {\n            num_witnesses,\n            lanes,\n            multiplicities,\n            num_lookup_columns: 0,\n            min_height: 1,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Set the minimum trace height for FRI compatibility.\n    ///\n    /// FRI requires: `log_trace_height \u003e log_final_poly_len + log_blowup`\n    /// So `min_height` should be \u003e= `2^(log_final_poly_len + log_blowup + 1)`.\n    pub const fn with_min_height(mut self, min_height: usize) -\u003e Self {\n        self.min_height = min_height;\n        self\n    }\n\n    #[inline]\n    pub const fn lane_width() -\u003e usize {\n        D\n    }\n\n    #[inline]\n    pub const fn total_width(\u0026self) -\u003e usize {\n        self.lanes * Self::lane_width()\n    }\n\n    #[inline]\n    pub const fn preprocessed_lane_width() -\u003e usize {\n        2\n    }\n\n    #[inline]\n    pub const fn preprocessed_width(\u0026self) -\u003e usize {\n        self.lanes * Self::preprocessed_lane_width()\n    }\n\n    /// Convert a [`WitnessTrace`] into a [`RowMajorMatrix`] suitable for the STARK prover.\n    ///\n    /// This function is responsible for:\n    ///\n    /// 1. Decomposing each witness value into its `D` base-field coordinates,\n    /// 2. Packing `lanes` witnesses side-by-side per row, maintaining the natural witness order,\n    /// 3. Padding the trace to have a power-of-two number of rows for FFT-friendly\n    ///    execution by the STARK prover.\n    ///\n    /// The resulting matrix has:\n    ///\n    /// - width `= lanes * LANE_WIDTH`,\n    /// - height equal to the number of rows after packing and padding.\n    ///\n    /// The layout within a row is:\n    ///\n    /// ```text\n    ///     [value[0..D), index] repeated `lanes` times.\n    #[inline]\n    pub fn trace_to_matrix\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(\n        trace: \u0026WitnessTrace\u003cExtF\u003e,\n        lanes: usize,\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n\n        let witness_count = trace.num_rows();\n        assert_eq!(\n            witness_count,\n            trace.index.len(),\n            \"WitnessTrace column length mismatch\"\n        );\n        assert!(\n            witness_count \u003e 0,\n            \"WitnessTrace must contain at least one witness entry\"\n        );\n\n        let lane_width = Self::lane_width();\n        let width = lane_width * lanes;\n        let logical_rows = witness_count.div_ceil(lanes).max(1);\n        let padded_rows = logical_rows.next_power_of_two();\n        let total_slots = padded_rows * lanes;\n\n        let mut values = F::zero_vec(width * padded_rows);\n\n        // Prepare last value coefficients for padding lanes/rows.\n        let last_coeffs = trace\n            .last_value()\n            .expect(\"non-empty trace\")\n            .as_basis_coefficients_slice();\n        assert_eq!(\n            last_coeffs.len(),\n            D,\n            \"Extension field degree mismatch for witness value\"\n        );\n        let last_coeffs = last_coeffs.to_vec();\n\n        let mut next_virtual_index = trace\n            .index\n            .last()\n            .expect(\"non-empty trace\")\n            .0\n            .checked_add(1)\n            .expect(\"witness index overflow\");\n\n        for slot in 0..total_slots {\n            let row = slot / lanes;\n            let lane = slot % lanes;\n            let cursor = row * width + lane * lane_width;\n\n            if slot \u003c witness_count {\n                let coeffs = trace\n                    .get_value(WitnessId(slot as u32))\n                    .unwrap()\n                    .as_basis_coefficients_slice();\n                assert_eq!(\n                    coeffs.len(),\n                    D,\n                    \"Extension field degree mismatch for witness value\"\n                );\n                values[cursor..cursor + D].copy_from_slice(coeffs);\n            } else {\n                // padding: copy last value coefficients and increment virtual index\n                values[cursor..cursor + D].copy_from_slice(\u0026last_coeffs);\n                next_virtual_index = next_virtual_index\n                    .checked_add(1)\n                    .expect(\"witness index overflow\");\n            }\n        }\n\n        RowMajorMatrix::new(values, width)\n    }\n}\n\nimpl\u003cF: Field, const D: usize\u003e BaseAir\u003cF\u003e for WitnessAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        self.total_width()\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\n        debug_assert!(\n            self.num_witnesses == self.multiplicities.len(),\n            \"Mismatch between the number of witnesses ({}) and the length of the provided multiplicities ({})\",\n            self.num_witnesses,\n            self.multiplicities.len()\n        );\n        // Calculate natural height and respect min_height for FRI compatibility\n        let natural_rows = self.num_witnesses.div_ceil(self.lanes).next_power_of_two();\n        let min_rows = self.min_height.next_power_of_two();\n        let num_rows = natural_rows.max(min_rows);\n        let height = num_rows * self.lanes;\n\n        let all_vals = (0..height)\n            .flat_map(|i| {\n                if i \u003e= self.multiplicities.len() {\n                    // Padding rows have zero multiplicity\n                    return vec![F::ZERO, F::from_u32(i as u32)];\n                }\n                vec![self.multiplicities[i], F::from_u32(i as u32)]\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let mat = RowMajorMatrix::new(all_vals, self.lanes * Self::preprocessed_lane_width());\n        Some(pad_matrix_with_min_height(mat, self.min_height))\n    }\n}\n\nimpl\u003cAB: AirBuilder, const D: usize\u003e Air\u003cAB\u003e for WitnessAir\u003cAB::F, D\u003e\nwhere\n    AB::F: Field,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let lanes = self.lanes;\n\n        // First row: index == 0\n        {\n            let preprocessed = builder\n                .preprocessed()\n                .expect(\"Expected preprocessed columns\");\n            let local_prep = preprocessed\n                .row_slice(0)\n                .expect(\"Preprocessed matrix should be non-empty\");\n            // The index is in the first preprocessed column.\n            let index0 = local_prep[1].clone();\n            builder.when_first_row().assert_zero(index0);\n        }\n\n        // Enforce sequential indices within each row (lanes) and across rows.\n        {\n            let mut b = builder.when_transition();\n            let preprocessed = b.preprocessed().expect(\"Expected preprocessed columns\");\n            let cur_prep = preprocessed.row_slice(0).expect(\"non-empty\");\n\n            let nxt_prep = preprocessed.row_slice(1).expect(\"has next row\");\n            let mut prev_idx = cur_prep[1].clone();\n            for lane in 1..lanes {\n                // The index is in the second column of each lane's preprocessed data.\n                let idx = cur_prep[lane * Self::preprocessed_lane_width() + 1].clone();\n                // between consecutive lanes in the same row: index_next - index_current - 1\n                b.assert_zero(idx.clone() - prev_idx.clone() - AB::Expr::ONE);\n                prev_idx = idx;\n            }\n            let next_first_idx = nxt_prep[1].clone();\n            // between the last lane of a row and the first lane of the next row: index_next - index_current - 1\n            b.assert_zero(next_first_idx - prev_idx - AB::Expr::ONE);\n        }\n\n        if self.lanes \u003e 1 {\n            let mut b = builder.when_last_row();\n            let preprocessed = b.preprocessed().expect(\"Expected preprocessed columns\");\n            let last_prep = preprocessed.row_slice(0).expect(\"non-empty\");\n            let mut prev_idx = last_prep[1].clone();\n            for lane in 1..lanes {\n                let idx = last_prep[lane * Self::preprocessed_lane_width() + 1].clone();\n                // between consecutive lanes in the same row: index_next - index_current - 1\n                b.assert_zero(idx.clone() - prev_idx.clone() - AB::Expr::ONE);\n                prev_idx = idx;\n            }\n        }\n    }\n\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        let new_idx = self.num_lookup_columns;\n        self.num_lookup_columns += 1;\n        vec![new_idx]\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cAB\u003e::F\u003e\u003e\n    where\n        AB: PermutationAirBuilder + AirBuilderWithPublicValues,\n    {\n        let mut lookups = Vec::new();\n        self.num_lookup_columns = 0;\n\n        let (symbolic_main_local, preprocessed_local) = create_symbolic_variables::\u003cAB::F\u003e(\n            self.preprocessed_width(),\n            BaseAir::\u003cAB::F\u003e::width(self),\n            0,\n            0,\n        );\n\n        for lane in 0..self.lanes {\n            let lane_offset = lane * Self::lane_width();\n            let preprocessed_lane_offset = lane * Self::preprocessed_lane_width();\n\n            // There is only 1 lookup per lane: the witness index and its value.\n            let lane_lookup_inputs = get_index_lookups::\u003cAB, D\u003e(\n                lane_offset,\n                preprocessed_lane_offset,\n                1,\n                \u0026symbolic_main_local,\n                \u0026preprocessed_local,\n                Direction::Receive,\n            );\n\n            lookups.push(\u003cSelf as Air\u003cAB\u003e\u003e::register_lookup(\n                self,\n                Kind::Global(\"WitnessChecks\".to_string()),\n                \u0026lane_lookup_inputs,\n            ));\n        }\n\n        lookups\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n    use alloc::vec::Vec;\n\n    use p3_baby_bear::BabyBear as Val;\n    use p3_circuit::WitnessId;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_uni_stark::{prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed};\n    use p3_util::log2_ceil_usize;\n\n    use super::*;\n    use crate::air::test_utils::build_test_config;\n\n    #[test]\n    fn prove_verify_witness_index_monotone() {\n        let n = 8usize;\n        // Use D=1; values can be arbitrary (unused by constraints)\n        let values: Vec\u003cVal\u003e = vec![Val::from_u64(123); n];\n        let indices: Vec\u003cWitnessId\u003e = (0..n as u32).map(WitnessId).collect();\n        let multiplicities: Vec\u003cVal\u003e = vec![Val::ONE; n];\n\n        let trace = WitnessTrace::new(indices, values);\n        let matrix = WitnessAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n        assert_eq!(matrix.height(), n);\n        assert_eq!(matrix.width(), 1);\n\n        let config = build_test_config();\n        let air = WitnessAir::\u003cVal, 1\u003e::new_with_preprocessed(n, 1, multiplicities);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"verification failed\");\n    }\n\n    #[test]\n    fn test_witness_air_extension_field() {\n        type Ext4 = BinomialExtensionField\u003cVal, 4\u003e;\n\n        let a = Ext4::from_basis_coefficients_slice(\u0026[\n            Val::from_u64(1),\n            Val::from_u64(2),\n            Val::from_u64(3),\n            Val::from_u64(4),\n        ])\n        .unwrap();\n\n        let b = Ext4::from_basis_coefficients_slice(\u0026[\n            Val::from_u64(5),\n            Val::from_u64(6),\n            Val::from_u64(7),\n            Val::from_u64(8),\n        ])\n        .unwrap();\n\n        let values = vec![a, b];\n        let indices = vec![WitnessId(0), WitnessId(1)];\n        let multiplicities = vec![Val::from_u64(1); indices.len()];\n\n        let trace = WitnessTrace::new(indices, values);\n        let matrix = WitnessAir::\u003cVal, 4\u003e::trace_to_matrix(\u0026trace, 1);\n\n        // Verify dimensions: D = 4 columns\n        assert_eq!(matrix.width(), 4);\n        assert_eq!(matrix.height(), 2);\n\n        // Check first row layout: [a_coeffs[0..3], index]\n        {\n            let row0 = matrix.row_slice(0).unwrap();\n            let a_coeffs = a.as_basis_coefficients_slice();\n            assert_eq!(\u0026row0[0..4], a_coeffs);\n        }\n\n        let config = build_test_config();\n        let air = WitnessAir::\u003cVal, 4\u003e::new_with_preprocessed(2, 1, multiplicities);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        // Check the correctness of preprocessed values.\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_matrix.height(), 2);\n        let row0 = preprocessed_matrix.row_slice(0).unwrap();\n        let row_last = preprocessed_matrix.row_slice(1).unwrap();\n        // The first column corresponds to the multiplicity (1 for actuve rows).\n        assert_eq!(row0[0], Val::from_u64(1));\n        assert_eq!(row_last[0], Val::from_u64(1));\n        // Check the witness indices.\n        assert_eq!(row0[1], Val::from_u64(0)); // index\n        assert_eq!(row_last[1], Val::from_u64(1)); // index\n\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"Extension field verification failed\");\n    }\n\n    #[test]\n    fn test_witness_air_single_element() {\n        let values = vec![Val::from_u64(42)];\n        let indices = vec![WitnessId(0)];\n\n        let trace = WitnessTrace::new(indices, values);\n        let matrix = WitnessAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n        let multiplicity = vec![Val::ONE; 1];\n\n        // Should be padded to power of two\n        assert!(matrix.height().is_power_of_two());\n        assert_eq!(matrix.width(), 1);\n\n        // Check the single element\n        {\n            let row0 = matrix.row_slice(0).unwrap();\n            assert_eq!(row0[0], Val::from_u64(42)); // value\n        }\n\n        let config = build_test_config();\n        let air = WitnessAir::\u003cVal, 1\u003e::new_with_preprocessed(1, 1, multiplicity);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_matrix.height(), matrix.height());\n        for i in 0..matrix.height() {\n            let row = preprocessed_matrix.row_slice(i).unwrap();\n            assert_eq!(row[0], Val::ONE);\n            assert_eq!(row[1], Val::from_u64(i as u64)); // index\n        }\n\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"Single element verification failed\");\n    }\n\n    #[test]\n    fn test_witness_air_matrix_padding() {\n        let n = 3; // Not a power of two\n        let values: Vec\u003cVal\u003e = (1..=n as u64).map(Val::from_u64).collect();\n        let indices: Vec\u003cWitnessId\u003e = (0..n as u32).map(WitnessId).collect();\n        let multiplicities: Vec\u003cVal\u003e = vec![Val::ONE; n];\n\n        let trace = WitnessTrace::new(indices, values);\n        let matrix = WitnessAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n\n        // Should be padded to next power of two (4)\n        assert_eq!(matrix.height(), 4);\n        assert!(matrix.height().is_power_of_two());\n\n        // Original rows should be preserved\n        for i in 0..n {\n            let row = matrix.row_slice(i).unwrap();\n            assert_eq!(row[0], Val::from_u64((i + 1) as u64)); // value\n        }\n\n        // Padded row should continue monotonic sequence\n        {\n            let last_row = matrix.row_slice(3).unwrap();\n            assert_eq!(last_row[0], Val::from_u64(3)); // last value repeated\n        }\n\n        let config = build_test_config();\n        let air = WitnessAir::\u003cVal, 1\u003e::new_with_preprocessed(3, 1, multiplicities);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_matrix.height(), matrix.height());\n        for i in 0..n {\n            let row = preprocessed_matrix.row_slice(i).unwrap();\n            // The multiplicity is 1 for active rows.\n            assert_eq!(row[0], Val::ONE);\n            // Check the witness index.\n            assert_eq!(row[1], Val::from_u64(i as u64)); // index\n        }\n        for i in n..matrix.height() {\n            let row = preprocessed_matrix.row_slice(i).unwrap();\n            // The multiplicity is 0 for padding rows.\n            assert_eq!(row[0], Val::ZERO);\n            // Check the witness index.\n            assert_eq!(row[1], Val::from_u64(i as u64));\n        }\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"Padding verification failed\");\n    }\n\n    #[test]\n    fn witness_air_multi_lane_packs_sequential_indices() {\n        let values: Vec\u003cVal\u003e = vec![\n            Val::from_u64(10),\n            Val::from_u64(20),\n            Val::from_u64(30),\n            Val::from_u64(40),\n            Val::from_u64(50),\n        ];\n        let multiplicities = vec![\n            Val::from_u64(3),\n            Val::from_u64(4),\n            Val::from_u64(5),\n            Val::from_u64(6),\n            Val::from_u64(7),\n        ];\n        let indices: Vec\u003cWitnessId\u003e = (0..values.len() as u32).map(WitnessId).collect();\n        let trace = WitnessTrace::new(indices, values.clone());\n\n        let lanes = 2;\n        let matrix = WitnessAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, lanes);\n\n        // Width doubles because each row now contains two lanes.\n        assert_eq!(matrix.width(), lanes * WitnessAir::\u003cVal, 1\u003e::lane_width());\n        // 5 witnesses -\u003e ceil(5 / 2) = 3 logical rows -\u003e padded to 4.\n        assert_eq!(matrix.height(), 4);\n\n        // Row 0 holds witnesses 0 and 1.\n        let row0 = matrix.row_slice(0).unwrap();\n        assert_eq!(row0[0], values[0]);\n        assert_eq!(row0[1], values[1]);\n\n        // Row 1 holds witnesses 2 and 3.\n        let row1 = matrix.row_slice(1).unwrap();\n        assert_eq!(row1[0], values[2]);\n        assert_eq!(row1[1], values[3]);\n\n        // Row 2 holds witness 4 and a virtual filler lane continuing the sequence.\n        let row2 = matrix.row_slice(2).unwrap();\n        assert_eq!(row2[0], values[4]);\n        assert_eq!(row2[1], values[4]);\n\n        let air = WitnessAir::\u003cVal, 1\u003e::new_with_preprocessed(\n            values.len(),\n            lanes,\n            multiplicities.clone(),\n        );\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_matrix.height(), matrix.height());\n\n        // Check that the indices and multiplicities in the preprocessed matrix are correct.\n        let preprocessed_width = WitnessAir::\u003cVal, 1\u003e::preprocessed_lane_width();\n        for i in 0..matrix.height() {\n            let row = preprocessed_matrix.row_slice(i).unwrap();\n            for j in 0..lanes {\n                assert_eq!(\n                    row[j * preprocessed_width],\n                    if i * lanes + j \u003c values.len() {\n                        multiplicities[i * lanes + j]\n                    } else {\n                        Val::ZERO\n                    }\n                );\n                assert_eq!(\n                    row[j * preprocessed_width + 1],\n                    Val::from_u64((i * lanes + j) as u64)\n                );\n            }\n        }\n\n        assert_eq!(air.total_width(), matrix.width());\n    }\n\n    #[test]\n    fn test_air_constraint_degree() {\n        let air = WitnessAir::\u003cVal, 1\u003e::new_with_preprocessed(8, 2, vec![Val::ONE; 8]);\n        p3_test_utils::assert_air_constraint_degree!(air, \"WitnessAir\");\n    }\n}\n","traces":[{"line":86,"address":[11466256,11465456,11466736,11465936,11465136,11465296,11466416,11465616,11464816,11465776,11466576,11467056,11464976,11466096,11466896],"length":1,"stats":{"Line":12}},{"line":87,"address":[4445425,4445105,4445585,4445745,4445265],"length":1,"stats":{"Line":12}},{"line":92,"address":[4445467,4445627,4445307,4445787,4445147],"length":1,"stats":{"Line":12}},{"line":104,"address":[5088016,5087989,5088261,5087744],"length":1,"stats":{"Line":12}},{"line":109,"address":[5088055,5087783,5088241,5087969],"length":1,"stats":{"Line":10}},{"line":125,"address":[],"length":0,"stats":{"Line":10}},{"line":126,"address":[5087457,5087553,5087361,5087409,5087505],"length":1,"stats":{"Line":12}},{"line":127,"address":[3918837,3918981,3918933,3918789,3918885],"length":1,"stats":{"Line":10}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[5082208,5082048,5081888,5081968,5082128],"length":1,"stats":{"Line":12}},{"line":137,"address":[],"length":0,"stats":{"Line":12}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[3919008],"length":1,"stats":{"Line":13}},{"line":147,"address":[11463145,11462825,11463108,11462905,11462868,11463065,11462948,11462985,11463188,11463028],"length":1,"stats":{"Line":13}},{"line":169,"address":[4441520,4441474,4443996,4444002,4441468,4438992],"length":1,"stats":{"Line":12}},{"line":173,"address":[4439047,4441575],"length":1,"stats":{"Line":10}},{"line":175,"address":[4439105,4441633],"length":1,"stats":{"Line":12}},{"line":176,"address":[],"length":0,"stats":{"Line":10}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[3916499],"length":1,"stats":{"Line":8}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[3916546],"length":1,"stats":{"Line":12}},{"line":187,"address":[3916707,3916575],"length":1,"stats":{"Line":10}},{"line":188,"address":[5085191,5082663],"length":1,"stats":{"Line":12}},{"line":189,"address":[11457460,11459988,11454932,11449876,11452404],"length":1,"stats":{"Line":10}},{"line":190,"address":[3916689,3916770,3916744],"length":1,"stats":{"Line":22}},{"line":192,"address":[4439543,4442032,4442071,4442115,4439587,4439504],"length":1,"stats":{"Line":22}},{"line":195,"address":[3916978],"length":1,"stats":{"Line":11}},{"line":199,"address":[4442274,4439746],"length":1,"stats":{"Line":11}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[5083157,5085685],"length":1,"stats":{"Line":11}},{"line":206,"address":[5086003,5083237,5083385,5085765,5083475,5085913],"length":1,"stats":{"Line":33}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[5083320,5085848],"length":1,"stats":{"Line":11}},{"line":209,"address":[],"length":0,"stats":{"Line":11}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[4442714,4440186],"length":1,"stats":{"Line":11}},{"line":215,"address":[4443072,4443032,4440544,4440362,4440504,4442890],"length":1,"stats":{"Line":22}},{"line":216,"address":[4440536,4443064,4443117,4443164,4440636,4440589],"length":1,"stats":{"Line":22}},{"line":217,"address":[],"length":0,"stats":{"Line":22}},{"line":219,"address":[5084090,5084413,5086618,5086941],"length":1,"stats":{"Line":22}},{"line":220,"address":[11451645,11456701,11461765,11454173,11459229],"length":1,"stats":{"Line":11}},{"line":221,"address":[4440873,4443401],"length":1,"stats":{"Line":11}},{"line":224,"address":[],"length":0,"stats":{"Line":11}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":22}},{"line":232,"address":[],"length":0,"stats":{"Line":22}},{"line":233,"address":[4443638,4441110,4443569,4441041],"length":1,"stats":{"Line":22}},{"line":234,"address":[],"length":0,"stats":{"Line":11}},{"line":235,"address":[11461660,11451540,11456596,11454068,11459124],"length":1,"stats":{"Line":11}},{"line":239,"address":[11455910,11453382,11458438,11450854,11460966],"length":1,"stats":{"Line":11}},{"line":244,"address":[3842560,3842576,3842528,3842544,3842512],"length":1,"stats":{"Line":12}},{"line":245,"address":[],"length":0,"stats":{"Line":12}},{"line":248,"address":[],"length":0,"stats":{"Line":10}},{"line":249,"address":[4967725,4968486,4967654,4967698,4968530,4968557],"length":1,"stats":{"Line":7}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[4968704,4967872],"length":1,"stats":{"Line":12}},{"line":257,"address":[4968753,4967921],"length":1,"stats":{"Line":10}},{"line":258,"address":[4967946,4968778],"length":1,"stats":{"Line":12}},{"line":259,"address":[],"length":0,"stats":{"Line":10}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[4335568,4336419,4336080,4334302,4335907,4335134,4336425,4335913],"length":1,"stats":{"Line":22}},{"line":263,"address":[],"length":0,"stats":{"Line":12}},{"line":265,"address":[4969397,4969909,4969640,4970152],"length":1,"stats":{"Line":12}},{"line":267,"address":[11022286,11023310,11022892,11023916,11023822,11021845,11022380,11023404,11022798,11021746],"length":1,"stats":{"Line":10}},{"line":271,"address":[11018318,11019610,11021350,11019982,11018020,11020814,11018852,11020516,11018778,11019684,11021652,11019150,11020442,11017946,11021276],"length":1,"stats":{"Line":10}},{"line":272,"address":[11018151,11020647,11021485,11018983,11019815],"length":1,"stats":{"Line":12}},{"line":280,"address":[4351609,4361545,4358356,4376172,4390944,4369164,4355472,4362144,4352208,4383858,4390424,4376178,4380672,4372992,4372472,4354873,4358880,4383852,4394208,4365324,4376832,4369824,4387177,4365984,4348944,4384512,4387776,4397092,4393609,4380018,4365330,4380012,4369170],"length":1,"stats":{"Line":61}},{"line":281,"address":[4358919,4373031,4380711,4387815,4348983,4355511,4369863,4366023,4384551,4376871,4390983,4362183,4394247,4352247],"length":1,"stats":{"Line":62}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[5009509,5029861,4999141,4995301,5013336,4985029,5016744],"length":1,"stats":{"Line":33}},{"line":292,"address":[],"length":0,"stats":{"Line":125}},{"line":293,"address":[4995525,5020401,4989021,5023437,5026749,5026796,5009685,5013606,4985253,5013644,4999365,5003133,4988973,5030037,5020363,4992369,4992246,5023532,5017052,5006444,5006349,5016929,4989068,5023485,5017014,5020278,5026701,5003180,5009733,4995477,4992331,4999317,5003085,5013521,4985205,5030085,5006397],"length":1,"stats":{"Line":123}},{"line":298,"address":[11166773,11212150,11247430,11288070,11170566,11250779,11253947,11274438,11208437,11299141,11177734,11240246,11284357,11264102,11174021,11204597,11184859,11194534,11236533,11312934,11277702,11316198,11191270,11226134,11229419,11160235,11295301,11232693,11181125,11260955,11257221,11243637,11156501,11280966,11188006,11222806,11291461,11267390,11219013,11163382,11306198,11152661,11302854,11309606,11215497,11197798,11201142,11270725],"length":1,"stats":{"Line":61}},{"line":299,"address":[],"length":0,"stats":{"Line":121}},{"line":300,"address":[4362975,4359579,4377742,4381503,4385211,4359610,4363054,4385242,4388511,4388542,4391643,4377663,4394994,4395057,4370590,4349643,4356258,4373823,4366894,4391674,4356321,4352907,4366815,4352938,4349674,4370559,4373902,4381582],"length":1,"stats":{"Line":119}},{"line":302,"address":[4989368,4999879,5003449,5006713,5023801,4989337,5023832,4999813,4985767,5006744,5017434,5010247,5020669,5003480,5027065,5027096,5030533,5014026,5030599,4995973,4992637,5013960,5017368,4996039,5010181,4985701,4992668,5020700],"length":1,"stats":{"Line":119}},{"line":303,"address":[],"length":0,"stats":{"Line":120}},{"line":304,"address":[4356718,4370893,4349960,4350049,4356807,4362109,4363434,4353313,4382051,4395454,4370982,4367363,4378122,4387741,4352173,4359896,4385617,4388934,4374282,4394173,4372962,4353224,4384474,4397582,4385528,4363523,4392049,4359985,4367274,4381962,4358846,4390914,4374371,4376794,4365946,4388845,4355437,4378211,4391960,4395543,4369786,4380634],"length":1,"stats":{"Line":123}},{"line":306,"address":[11316850,11318320,11212802,11249691,11176537,11153460,11226786,11209236,11231503,11233492,11256031,11297817,11290192,11244436,11259737,11246153,11293977,11248232,11240898,11285156,11268074,11308459,11179856,11281618,11169289,11263039,11190128,11199920,11286873,11214272,11171368,11159017,11252863,11223608,11261639,11157300,11164034,11275090,11219812,11167572,11276560,11264754,11235209,11273241,11178386,11181924,11186943,11292260,11283088,11313586,11193392,11288722,11271524,11183641,11196656,11210953,11205396,11216299,11239049,11188658,11266224,11254631,11296100,11304976,11160919,11185543,11299940,11165504,11310408,11311867,11242368,11203403,11221529,11172827,11228256,11251463,11225067,11237332,11201944,11279824,11195186,11207113,11303506,11155177,11162319,11191922,11278354,11301657,11315056,11198450,11307000,11230103,11258020,11269526,11174820,11217810],"length":1,"stats":{"Line":10}},{"line":308,"address":[1785129,1788599,1785423,1788438,1785098,1785050,1788343,1788407],"length":1,"stats":{"Line":10}},{"line":309,"address":[5002498,5009061,5005797,5022934,5029413,5033218,5012866,5016354,5019762,4994902,4991685,5026149,4998658,4988386],"length":1,"stats":{"Line":5}},{"line":311,"address":[4385780,4389097,4392212,4395706,4353476,4378374,4350212,4360148,4356970,4382214,4363686,4371145,4374534,4367526],"length":1,"stats":{"Line":55}},{"line":313,"address":[3912122,3876828,3890364,3898017,3908556,3873290,3883728,3880394,3894204,3905018,3901452,3886826],"length":1,"stats":{"Line":59}},{"line":316,"address":[3901685,3908789,3880554,3912282,3894437,3890597,3877061,3883825,3905178,3873450,3886986,3898114],"length":1,"stats":{"Line":55}},{"line":317,"address":[4395945,4392513,4382588,4357209,4353777,4364060,4371384,4374908,4378748,4350513,4360449,4386081,4389336,4367900],"length":1,"stats":{"Line":5}},{"line":318,"address":[3880648,3905238,3898207,3912376,3901792,3894497,3908849,3877121,3890704,3898173,3873510,3912342,3890657,3877168,3905272,3883884,3873544,3880614,3887046,3883918,3901745,3908896,3887080,3894544],"length":1,"stats":{"Line":10}},{"line":319,"address":[3909029,3887173,3884011,3890837,3894677,3894598,3901846,3873637,3908950,3912438,3880710,3880741,3883980,3887142,3873606,3877301,3890758,3898261,3898324,3901925,3905334,3905365,3877222,3912469],"length":1,"stats":{"Line":10}},{"line":320,"address":[4392711,4364343,4350766,4368241,4371597,4382929,4375249,4364401,4389604,4379031,4379089,4392766,4389549,4350711,4386279,4368183,4357478,4386334,4396214,4357536,4371652,4360647,4360702,4353975,4375191,4354030,4396272,4382871],"length":1,"stats":{"Line":10}},{"line":321,"address":[],"length":0,"stats":{"Line":15}},{"line":322,"address":[11255532,11186384,11220829,11265652,11196036,11175837,11252364,11227684,11272541,11272615,11286247,11301031,11311368,11259037,11217203,11183015,11199348,11186444,11275988,11158317,11279252,11172328,11210253,11293277,11317748,11307900,11217269,11210327,11304356,11168663,11192772,11172268,11213700,11241748,11182941,11282516,11297117,11175911,11293351,11279204,11189508,11179284,11317700,11161820,11154551,11234509,11164884,11179236,11213652,11202904,11314484,11249132,11314436,11249192,11206487,11227636,11245453,11282468,11161760,11238349,11164932,11238423,11262480,11286173,11241796,11199300,11307960,11192820,11220903,11311308,11224568,11231004,11252304,11289572,11304404,11259111,11189556,11196084,11289620,11158391,11202844,11206413,11230944,11245527,11268919,11268985,11154477,11275940,11265604,11300957,11262540,11297191,11224508,11234583,11168589,11255472],"length":1,"stats":{"Line":10}},{"line":324,"address":[4375797,4372307,4375845,4354545,4379637,4379716,4383842,4351599,4383556,4354593,4387167,4380002,4383525,4358160,4372462,4390164,4368868,4383477,4390228,4390414,4354624,4364997,4393360,4393599,4396832,4396896,4364949,4396927,4368837,4372212,4361296,4358096,4386849,4386928,4393329,4376162,4379685,4397082,4361535,4375876,4358191,4369154,4390259,4361217,4368789,4354863,4358346,4351360,4386897,4393281,4351329,4372276,4361265,4365314,4365028,4351281],"length":1,"stats":{"Line":10}},{"line":325,"address":[3902861,3881594,3874490,3888026,3878237,3884883,3891773,3895613,3906218,3909965,3913322,3899231],"length":1,"stats":{"Line":5}},{"line":330,"address":[11151056,11150832,11151504,11151280,11151728,11150608],"length":1,"stats":{"Line":12}},{"line":331,"address":[11151528,11150856,11150632,11151752,11151080,11151304],"length":1,"stats":{"Line":12}},{"line":332,"address":[11150711,11150870,11151607,11150646,11151318,11151094,11151159,11151831,11151542,11150935,11151766,11151383],"length":1,"stats":{"Line":12}},{"line":333,"address":[4348569,4348841,4348919,4348617,4348695,4348793],"length":1,"stats":{"Line":24}},{"line":336,"address":[11148096,11150560,11145680,11145638,11144448,11149376,11146870,11148144,11144400,11148102,11146864,11144406,11145632,11146912,11143216,11149328,11149334,11150566],"length":1,"stats":{"Line":12}},{"line":340,"address":[11146951,11143255,11148183,11144487,11145719,11149415],"length":1,"stats":{"Line":13}},{"line":341,"address":[4983108,4981876],"length":1,"stats":{"Line":13}},{"line":344,"address":[4981884,4983116],"length":1,"stats":{"Line":13}},{"line":345,"address":[4346188,4347420],"length":1,"stats":{"Line":13}},{"line":350,"address":[3870746,3870837],"length":1,"stats":{"Line":26}},{"line":351,"address":[3870955,3871151,3871113],"length":1,"stats":{"Line":26}},{"line":352,"address":[4347981,4348032,4346749,4346800,4347939,4346707],"length":1,"stats":{"Line":26}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[3871215],"length":1,"stats":{"Line":13}},{"line":360,"address":[],"length":0,"stats":{"Line":13}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[11144298,11145530,11147994,11145585,11144353,11149281,11146762,11150513,11148049,11149226,11150458,11146817],"length":1,"stats":{"Line":24}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[11144114,11147877,11149109,11147810,11146578,11146645,11149042,11145413,11145346,11144181,11150274,11150341],"length":1,"stats":{"Line":24}},{"line":367,"address":[],"length":0,"stats":{"Line":12}},{"line":371,"address":[],"length":0,"stats":{"Line":12}}],"covered":100,"coverable":127},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","batch_stark_prover","dynamic_air.rs"],"content":"use alloc::boxed::Box;\nuse alloc::string::String;\nuse alloc::vec::Vec;\n\nuse p3_air::{Air, AirBuilder, BaseAir};\n#[cfg(debug_assertions)]\nuse p3_batch_stark::DebugConstraintBuilderWithLookups;\nuse p3_batch_stark::{StarkGenericConfig, Val};\nuse p3_circuit::op::NonPrimitiveOpType;\nuse p3_circuit::tables::Traces;\nuse p3_field::PrimeField;\nuse p3_field::extension::BinomialExtensionField;\nuse p3_lookup::folder::{ProverConstraintFolderWithLookups, VerifierConstraintFolderWithLookups};\nuse p3_lookup::lookup_traits::Lookup;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_uni_stark::{SymbolicAirBuilder, SymbolicExpression};\n\nuse super::TablePacking;\n\n/// Type-erased AIR implementation for dynamically registered non-primitive tables.\n///\n/// This allows the batch prover to mix primitive AIRs with plugin AIRs in a single heterogeneous\n/// batch.\n/// Internally,`DynamicAirEntry` wraps the boxed plugin AIR and exposes a shared accessor\n/// so that both prover and verifier can operate without knowing the concrete underlying type.\npub struct DynamicAirEntry\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    air: Box\u003cdyn CloneableBatchAir\u003cSC\u003e\u003e,\n}\n\nimpl\u003cSC\u003e DynamicAirEntry\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    pub fn new(inner: Box\u003cdyn CloneableBatchAir\u003cSC\u003e\u003e) -\u003e Self {\n        Self { air: inner }\n    }\n\n    pub fn air(\u0026self) -\u003e \u0026dyn CloneableBatchAir\u003cSC\u003e {\n        \u0026*self.air\n    }\n\n    pub fn air_mut(\u0026mut self) -\u003e \u0026mut dyn CloneableBatchAir\u003cSC\u003e {\n        \u0026mut *self.air\n    }\n}\n\nimpl\u003cSC\u003e Clone for DynamicAirEntry\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            air: self.air.clone_box(),\n        }\n    }\n}\n\nimpl\u003cSC\u003e BaseAir\u003cVal\u003cSC\u003e\u003e for DynamicAirEntry\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        \u003cdyn CloneableBatchAir\u003cSC\u003e as BaseAir\u003cVal\u003cSC\u003e\u003e\u003e::width(self.air())\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e {\n        \u003cdyn CloneableBatchAir\u003cSC\u003e as BaseAir\u003cVal\u003cSC\u003e\u003e\u003e::preprocessed_trace(self.air())\n    }\n}\n\nmacro_rules! impl_air_for_dynamic_entry {\n    (\n        $(#[$cfg:meta])?\n        $lt:lifetime,\n        $builder:ty,\n        $eval_method:ident,\n        $add_lookup_method:ident,\n        $get_lookup_method:ident\n    ) =\u003e {\n        $(#[$cfg])?\n        impl\u003c$lt, SC\u003e Air\u003c$builder\u003e for DynamicAirEntry\u003cSC\u003e\n        where\n            SC: StarkGenericConfig,\n            Val\u003cSC\u003e: PrimeField,\n            SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n        {\n            fn eval(\u0026self, builder: \u0026mut $builder) {\n                self.air().$eval_method(builder);\n            }\n\n            fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n                self.air_mut().$add_lookup_method()\n            }\n\n            fn get_lookups(\n                \u0026mut self,\n            ) -\u003e Vec\u003cLookup\u003c\u003c$builder as AirBuilder\u003e::F\u003e\u003e {\n                self.air_mut().$get_lookup_method()\n            }\n        }\n    };\n    (\n        $(#[$cfg:meta])?\n        $builder:ty,\n        $eval_method:ident,\n        $add_lookup_method:ident,\n        $get_lookup_method:ident\n    ) =\u003e {\n        $(#[$cfg])?\n        impl\u003cSC\u003e Air\u003c$builder\u003e for DynamicAirEntry\u003cSC\u003e\n        where\n            SC: StarkGenericConfig,\n            Val\u003cSC\u003e: PrimeField,\n            SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n        {\n            fn eval(\u0026self, builder: \u0026mut $builder) {\n                self.air().$eval_method(builder);\n            }\n\n            fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n                self.air_mut().$add_lookup_method()\n            }\n\n            fn get_lookups(\n                \u0026mut self,\n            ) -\u003e Vec\u003cLookup\u003c\u003c$builder as AirBuilder\u003e::F\u003e\u003e {\n                self.air_mut().$get_lookup_method()\n            }\n        }\n    };\n}\n\nimpl_air_for_dynamic_entry!(\n    SymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e,\n    eval_symbolic,\n    add_lookup_columns_symbolic,\n    get_lookups_symbolic\n);\n\n#[cfg(debug_assertions)]\nimpl_air_for_dynamic_entry!(\n    'a,\n    DebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e,\n    eval_debug,\n    add_lookup_columns_debug,\n    get_lookups_debug\n);\n\nimpl_air_for_dynamic_entry!(\n    'a,\n    ProverConstraintFolderWithLookups\u003c'a, SC\u003e,\n    eval_prover,\n    add_lookup_columns_prover,\n    get_lookups_prover\n);\n\nimpl_air_for_dynamic_entry!(\n    'a,\n    VerifierConstraintFolderWithLookups\u003c'a, SC\u003e,\n    eval_verifier,\n    add_lookup_columns_verifier,\n    get_lookups_verifier\n);\n\n/// Simple super trait of [`Air`] describing the behaviour of a non-primitive\n/// dynamically dispatched AIR used in batched proofs.\n#[cfg(debug_assertions)]\npub trait BatchAir\u003cSC\u003e:\n    BaseAir\u003cVal\u003cSC\u003e\u003e\n    + Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e\u003e\n    + for\u003c'a\u003e Air\u003cDebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e\u003e\n    + for\u003c'a\u003e Air\u003cProverConstraintFolderWithLookups\u003c'a, SC\u003e\u003e\n    + for\u003c'a\u003e Air\u003cVerifierConstraintFolderWithLookups\u003c'a, SC\u003e\u003e\n    + Send\n    + Sync\nwhere\n    SC: StarkGenericConfig,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n}\n\n#[cfg(not(debug_assertions))]\npub trait BatchAir\u003cSC\u003e:\n    BaseAir\u003cVal\u003cSC\u003e\u003e\n    + Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e\u003e\n    + for\u003c'a\u003e Air\u003cProverConstraintFolderWithLookups\u003c'a, SC\u003e\u003e\n    + for\u003c'a\u003e Air\u003cVerifierConstraintFolderWithLookups\u003c'a, SC\u003e\u003e\n    + Send\n    + Sync\nwhere\n    SC: StarkGenericConfig,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n}\n\nmacro_rules! impl_cloneable_batch_air_forwarding {\n    (\n        $(#[$cfg:meta])?\n        $lt:lifetime,\n        $builder:ty,\n        $eval_method:ident,\n        $add_lookup_method:ident,\n        $get_lookup_method:ident\n    ) =\u003e {\n        $(#[$cfg])?\n        fn $eval_method\u003c$lt\u003e(\u0026self, builder: \u0026mut $builder) {\n            \u003cT as Air\u003c$builder\u003e\u003e::eval(self, builder);\n        }\n\n        $(#[$cfg])?\n        fn $add_lookup_method\u003c$lt\u003e(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n            \u003cT as Air\u003c$builder\u003e\u003e::add_lookup_columns(self)\n        }\n\n        $(#[$cfg])?\n        fn $get_lookup_method\u003c$lt\u003e(\u0026mut self) -\u003e Vec\u003cLookup\u003cVal\u003cSC\u003e\u003e\u003e {\n            \u003cT as Air\u003c$builder\u003e\u003e::get_lookups(self)\n        }\n    };\n    (\n        $(#[$cfg:meta])?\n        $builder:ty,\n        $eval_method:ident,\n        $add_lookup_method:ident,\n        $get_lookup_method:ident\n    ) =\u003e {\n        $(#[$cfg])?\n        fn $eval_method(\u0026self, builder: \u0026mut $builder) {\n            \u003cT as Air\u003c$builder\u003e\u003e::eval(self, builder);\n        }\n\n        $(#[$cfg])?\n        fn $add_lookup_method(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n            \u003cT as Air\u003c$builder\u003e\u003e::add_lookup_columns(self)\n        }\n\n        $(#[$cfg])?\n        fn $get_lookup_method(\u0026mut self) -\u003e Vec\u003cLookup\u003cVal\u003cSC\u003e\u003e\u003e {\n            \u003cT as Air\u003c$builder\u003e\u003e::get_lookups(self)\n        }\n    };\n}\n\npub trait CloneableBatchAir\u003cSC\u003e: BaseAir\u003cVal\u003cSC\u003e\u003e + Send + Sync\nwhere\n    SC: StarkGenericConfig,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    fn clone_box(\u0026self) -\u003e Box\u003cdyn CloneableBatchAir\u003cSC\u003e\u003e;\n\n    #[cfg(debug_assertions)]\n    fn eval_debug\u003c'a\u003e(\n        \u0026self,\n        builder: \u0026mut DebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e,\n    );\n    fn eval_symbolic(\u0026self, builder: \u0026mut SymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e);\n    fn eval_prover\u003c'a\u003e(\u0026self, builder: \u0026mut ProverConstraintFolderWithLookups\u003c'a, SC\u003e);\n    fn eval_verifier\u003c'a\u003e(\u0026self, builder: \u0026mut VerifierConstraintFolderWithLookups\u003c'a, SC\u003e);\n\n    #[cfg(debug_assertions)]\n    fn add_lookup_columns_debug(\u0026mut self) -\u003e Vec\u003cusize\u003e;\n    fn add_lookup_columns_symbolic(\u0026mut self) -\u003e Vec\u003cusize\u003e;\n    fn add_lookup_columns_prover(\u0026mut self) -\u003e Vec\u003cusize\u003e;\n    fn add_lookup_columns_verifier(\u0026mut self) -\u003e Vec\u003cusize\u003e;\n\n    #[cfg(debug_assertions)]\n    fn get_lookups_debug(\u0026mut self) -\u003e Vec\u003cLookup\u003cVal\u003cSC\u003e\u003e\u003e;\n    fn get_lookups_symbolic(\u0026mut self) -\u003e Vec\u003cLookup\u003cVal\u003cSC\u003e\u003e\u003e;\n    fn get_lookups_prover(\u0026mut self) -\u003e Vec\u003cLookup\u003cVal\u003cSC\u003e\u003e\u003e;\n    fn get_lookups_verifier(\u0026mut self) -\u003e Vec\u003cLookup\u003cVal\u003cSC\u003e\u003e\u003e;\n}\n\nimpl\u003cSC, T\u003e CloneableBatchAir\u003cSC\u003e for T\nwhere\n    SC: StarkGenericConfig,\n    T: BatchAir\u003cSC\u003e + Clone + 'static,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    fn clone_box(\u0026self) -\u003e Box\u003cdyn CloneableBatchAir\u003cSC\u003e\u003e {\n        Box::new(self.clone())\n    }\n\n    impl_cloneable_batch_air_forwarding!(\n        SymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e,\n        eval_symbolic,\n        add_lookup_columns_symbolic,\n        get_lookups_symbolic\n    );\n\n    #[cfg(debug_assertions)]\n    impl_cloneable_batch_air_forwarding!(\n        'a,\n        DebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e,\n        eval_debug,\n        add_lookup_columns_debug,\n        get_lookups_debug\n    );\n\n    impl_cloneable_batch_air_forwarding!(\n        'a,\n        ProverConstraintFolderWithLookups\u003c'a, SC\u003e,\n        eval_prover,\n        add_lookup_columns_prover,\n        get_lookups_prover\n    );\n\n    impl_cloneable_batch_air_forwarding!(\n        'a,\n        VerifierConstraintFolderWithLookups\u003c'a, SC\u003e,\n        eval_verifier,\n        add_lookup_columns_verifier,\n        get_lookups_verifier\n    );\n}\n\n/// Data needed to insert a dynamic table instance into the batched prover.\n///\n/// A `BatchTableInstance` bundles everything the batch prover needs from a\n/// non-primitive table plugin: the AIR, its populated trace matrix, any\n/// public values it exposes, and the number of rows it produces.\npub struct BatchTableInstance\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    /// Operation type (it should match `TableProver::op_type`).\n    pub op_type: NonPrimitiveOpType,\n    /// The AIR implementation for this table.\n    pub air: DynamicAirEntry\u003cSC\u003e,\n    /// The populated trace matrix for this table.\n    pub trace: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e,\n    /// Public values exposed by this table.\n    pub public_values: Vec\u003cVal\u003cSC\u003e\u003e,\n    /// Number of rows produced for this table.\n    pub rows: usize,\n}\n\n#[inline(always)]\n/// # Safety\n///\n/// Caller must ensure that both `Traces\u003cFromEF\u003e` and `Traces\u003cToEF\u003e` share an\n/// identical in-memory representation.\npub(crate) unsafe fn transmute_traces\u003cFromEF, ToEF\u003e(t: \u0026Traces\u003cFromEF\u003e) -\u003e \u0026Traces\u003cToEF\u003e {\n    debug_assert_eq!(\n        core::mem::size_of::\u003cTraces\u003cFromEF\u003e\u003e(),\n        core::mem::size_of::\u003cTraces\u003cToEF\u003e\u003e()\n    );\n    debug_assert_eq!(\n        core::mem::align_of::\u003cTraces\u003cFromEF\u003e\u003e(),\n        core::mem::align_of::\u003cTraces\u003cToEF\u003e\u003e()\n    );\n\n    unsafe { \u0026*(t as *const _ as *const Traces\u003cToEF\u003e) }\n}\n\n/// Trait implemented by all non-primitive table plugins used by the batch prover.\n///\n/// Implementors would typically delegate to an existing AIR type, define a base case\n/// for base-field traces, and then use the [`impl_table_prover_batch_instances_from_base!`]\n/// macro to generate the degree-specific implementations.\npub trait TableProver\u003cSC\u003e: Send + Sync\nwhere\n    SC: StarkGenericConfig + 'static,\n{\n    /// Operation type for this prover.\n    fn op_type(\u0026self) -\u003e NonPrimitiveOpType;\n\n    /// Produce a batched table instance for base-field traces.\n    fn batch_instance_d1(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cVal\u003cSC\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e;\n\n    /// Produce a batched table instance for degree-2 extension traces.\n    fn batch_instance_d2(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 2\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e;\n\n    /// Produce a batched table instance for degree-4 extension traces.\n    fn batch_instance_d4(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 4\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e;\n\n    /// Produce a batched table instance for degree-6 extension traces.\n    fn batch_instance_d6(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 6\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e;\n\n    /// Produce a batched table instance for degree-8 extension traces.\n    fn batch_instance_d8(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 8\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e;\n\n    /// Rebuild the AIR for verification from the recorded non-primitive table entry.\n    fn batch_air_from_table_entry(\n        \u0026self,\n        config: \u0026SC,\n        degree: usize,\n        table_entry: \u0026super::NonPrimitiveTableEntry\u003cSC\u003e,\n    ) -\u003e Result\u003cDynamicAirEntry\u003cSC\u003e, String\u003e;\n}\n","traces":[{"line":37,"address":[4130512],"length":1,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[5193552],"length":1,"stats":{"Line":3}},{"line":46,"address":[5036069],"length":1,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[6086112,5943248,5943152,5943056,5943104,6086064,6086160,5943008,5943200],"length":1,"stats":{"Line":7}},{"line":93,"address":[5196930,5343330,5196978],"length":1,"stats":{"Line":7}},{"line":121,"address":[4282512],"length":1,"stats":{"Line":2}},{"line":122,"address":[5156306],"length":1,"stats":{"Line":2}},{"line":129,"address":[5156224],"length":1,"stats":{"Line":3}},{"line":132,"address":[5156256],"length":1,"stats":{"Line":3}},{"line":211,"address":[8820624,8820720,8820912,8820688,8820560,8820592,8820656,8820848,8820880],"length":1,"stats":{"Line":7}},{"line":212,"address":[6151182,6151118,6151086],"length":1,"stats":{"Line":8}},{"line":216,"address":[6151424,6151328,6151360],"length":1,"stats":{"Line":0}},{"line":217,"address":[5372881,5372977,5372913],"length":1,"stats":{"Line":0}},{"line":221,"address":[4330000,4330032,4330096],"length":1,"stats":{"Line":0}},{"line":222,"address":[6151217,6151249,6151313],"length":1,"stats":{"Line":0}},{"line":233,"address":[6151136],"length":1,"stats":{"Line":2}},{"line":234,"address":[5372686],"length":1,"stats":{"Line":2}},{"line":238,"address":[6151392],"length":1,"stats":{"Line":0}},{"line":239,"address":[6151409],"length":1,"stats":{"Line":0}},{"line":243,"address":[6151264],"length":1,"stats":{"Line":3}},{"line":244,"address":[4330081],"length":1,"stats":{"Line":3}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[8821829,8821733,8821781],"length":1,"stats":{"Line":0}},{"line":347,"address":[5941776,5939472,5940496,5941264,5939216,5936400,5940752,5938960,5936912,5937168,5938192,5939984,5935888,5937680,5936144,5940240,5941008,5942032,5941520,5936656,5937424,5937936,5938448,5938704,5939728],"length":1,"stats":{"Line":12}},{"line":348,"address":[5192238,5193006,5192494,5193262,5192750],"length":1,"stats":{"Line":12}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[5192568,5193336,5192312,5192824,5193080],"length":1,"stats":{"Line":14}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":12}}],"covered":21,"coverable":39},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","batch_stark_prover","packing.rs"],"content":"use alloc::vec::Vec;\n\nuse p3_circuit::op::NonPrimitiveOpType;\nuse p3_circuit::tables::Traces;\nuse p3_field::Field;\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse serde::{Deserialize, Serialize};\n\n/// Pad a trace matrix to at least `min_height` rows.\n/// The height is always rounded up to a power of two.\npub(crate) fn pad_matrix_to_min_height\u003cF: Field\u003e(\n    mut matrix: RowMajorMatrix\u003cF\u003e,\n    min_height: usize,\n) -\u003e RowMajorMatrix\u003cF\u003e {\n    let current_height = matrix.height();\n    // Target height is max of current power-of-two and min_height\n    let target_height = current_height\n        .next_power_of_two()\n        .max(min_height.next_power_of_two());\n\n    if current_height \u003c target_height {\n        // Pad with zeros to reach target height\n        let width = matrix.width();\n        let padding_rows = target_height - current_height;\n        matrix\n            .values\n            .extend(core::iter::repeat_n(F::ZERO, padding_rows * width));\n    }\n    matrix\n}\n\n/// Configuration for packing multiple primitive operations into a single AIR row.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub struct TablePacking {\n    witness_lanes: usize,\n    public_lanes: usize,\n    alu_lanes: usize,\n    /// Minimum trace height for all tables (must be power of two).\n    /// This is required for FRI with higher `log_final_poly_len`.\n    /// FRI requires: log_trace_height \u003e log_final_poly_len + log_blowup\n    /// So min_trace_height should be \u003e= 2^(log_final_poly_len + log_blowup + 1)\n    min_trace_height: usize,\n}\n\nimpl TablePacking {\n    pub fn new(witness_lanes: usize, public_lanes: usize, alu_lanes: usize) -\u003e Self {\n        Self {\n            witness_lanes: witness_lanes.max(1),\n            public_lanes: public_lanes.max(1),\n            alu_lanes: alu_lanes.max(1),\n            min_trace_height: 1,\n        }\n    }\n\n    /// Create TablePacking with a minimum trace height requirement.\n    ///\n    /// Use this when FRI parameters have `log_final_poly_len \u003e 0`.\n    /// The minimum trace height must satisfy: `min_trace_height \u003e 2^(log_final_poly_len + log_blowup)`\n    ///\n    /// For example, with `log_final_poly_len = 3` and `log_blowup = 1`:\n    /// - Required: `min_trace_height \u003e 2^(3+1) = 16`\n    /// - So use `min_trace_height = 32` (next power of two)\n    pub fn with_min_trace_height(mut self, min_trace_height: usize) -\u003e Self {\n        // Ensure min_trace_height is a power of two and at least 1\n        self.min_trace_height = min_trace_height.next_power_of_two().max(1);\n        self\n    }\n\n    /// Create TablePacking with minimum height derived from FRI parameters.\n    ///\n    /// This automatically calculates the minimum trace height from `log_final_poly_len` and `log_blowup`.\n    pub const fn with_fri_params(mut self, log_final_poly_len: usize, log_blowup: usize) -\u003e Self {\n        // FRI requires: log_min_height \u003e log_final_poly_len + log_blowup\n        // So min_height must be \u003e= 2^(log_final_poly_len + log_blowup + 1)\n        let min_log_height = log_final_poly_len + log_blowup + 1;\n        self.min_trace_height = 1usize \u003c\u003c min_log_height;\n        self\n    }\n\n    pub const fn witness_lanes(self) -\u003e usize {\n        self.witness_lanes\n    }\n\n    pub const fn public_lanes(self) -\u003e usize {\n        self.public_lanes\n    }\n\n    pub const fn alu_lanes(self) -\u003e usize {\n        self.alu_lanes\n    }\n\n    pub const fn min_trace_height(self) -\u003e usize {\n        self.min_trace_height\n    }\n}\n\nimpl Default for TablePacking {\n    fn default() -\u003e Self {\n        Self::new(1, 1, 1)\n    }\n}\n\n/// Summary of trace lengths for all circuit tables.\n#[derive(Debug, Clone)]\npub struct TraceLengths {\n    pub witness: usize,\n    pub const_: usize,\n    pub public: usize,\n    pub alu: usize,\n    pub witness_lanes: usize,\n    pub public_lanes: usize,\n    pub alu_lanes: usize,\n    pub non_primitive: Vec\u003c(NonPrimitiveOpType, usize)\u003e,\n}\n\nimpl TraceLengths {\n    /// Compute trace lengths from traces and packing configuration.\n    pub fn from_traces\u003cF\u003e(traces: \u0026Traces\u003cF\u003e, packing: TablePacking) -\u003e Self {\n        Self {\n            witness: traces.witness_trace.num_rows() / packing.witness_lanes(),\n            const_: traces.const_trace.values.len(),\n            public: traces.public_trace.values.len() / packing.public_lanes(),\n            alu: traces.alu_trace.op_kind.len() / packing.alu_lanes(),\n            witness_lanes: packing.witness_lanes(),\n            public_lanes: packing.public_lanes(),\n            alu_lanes: packing.alu_lanes(),\n            non_primitive: traces\n                .non_primitive_traces\n                .iter()\n                .map(|(\u0026op, t)| (op, t.rows()))\n                .collect(),\n        }\n    }\n\n    /// Log all trace lengths at info level.\n    pub fn log(\u0026self) {\n        tracing::info!(\n            witness = %self.witness,\n            witness_lanes = %self.witness_lanes,\n            const_ = %self.const_,\n            const_lanes = 1usize,\n            public = %self.public,\n            public_lanes = %self.public_lanes,\n            alu = %self.alu,\n            alu_lanes = %self.alu_lanes,\n            \"Primitive trace lengths\"\n        );\n        for (op, rows) in \u0026self.non_primitive {\n            tracing::info!(?op, rows, \"Non-primitive trace length\");\n        }\n    }\n}\n","traces":[{"line":12,"address":[5244784,5245190],"length":1,"stats":{"Line":8}},{"line":16,"address":[3915368,3915419],"length":1,"stats":{"Line":16}},{"line":18,"address":[3915492],"length":1,"stats":{"Line":8}},{"line":20,"address":[6361172,6360300,6360740],"length":1,"stats":{"Line":8}},{"line":22,"address":[5244956],"length":1,"stats":{"Line":8}},{"line":24,"address":[6361291,6360859,6360419],"length":1,"stats":{"Line":1}},{"line":25,"address":[],"length":0,"stats":{"Line":1}},{"line":26,"address":[5245185],"length":1,"stats":{"Line":1}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[3915674,3915632],"length":1,"stats":{"Line":2}},{"line":30,"address":[5464544],"length":1,"stats":{"Line":8}},{"line":47,"address":[2130944],"length":1,"stats":{"Line":5}},{"line":49,"address":[11357844],"length":1,"stats":{"Line":5}},{"line":50,"address":[2338681],"length":1,"stats":{"Line":5}},{"line":51,"address":[6926062],"length":1,"stats":{"Line":4}},{"line":64,"address":[3724624],"length":1,"stats":{"Line":6}},{"line":66,"address":[11357715],"length":1,"stats":{"Line":4}},{"line":67,"address":[6539228],"length":1,"stats":{"Line":6}},{"line":73,"address":[3724400],"length":1,"stats":{"Line":1}},{"line":76,"address":[8726080,8726151],"length":1,"stats":{"Line":1}},{"line":77,"address":[6353615,6353651,6353707],"length":1,"stats":{"Line":2}},{"line":78,"address":[3724552],"length":1,"stats":{"Line":1}},{"line":82,"address":[6925616],"length":1,"stats":{"Line":4}},{"line":86,"address":[8726016],"length":1,"stats":{"Line":5}},{"line":90,"address":[7112112],"length":1,"stats":{"Line":4}},{"line":94,"address":[7111824],"length":1,"stats":{"Line":5}},{"line":99,"address":[4166000],"length":1,"stats":{"Line":5}},{"line":100,"address":[4630888],"length":1,"stats":{"Line":5}},{"line":119,"address":[6354912,6355792,6354032,6356672,6357552],"length":1,"stats":{"Line":12}},{"line":121,"address":[5462724,5462475,5463371,5463620],"length":1,"stats":{"Line":12}},{"line":122,"address":[5462597,5463493],"length":1,"stats":{"Line":12}},{"line":123,"address":[5243297,5243052,5243948,5244080,5244193,5243184],"length":1,"stats":{"Line":24}},{"line":124,"address":[3914698,3915237,3914824],"length":1,"stats":{"Line":24}},{"line":125,"address":[5243337,5244233],"length":1,"stats":{"Line":12}},{"line":126,"address":[3914915],"length":1,"stats":{"Line":12}},{"line":127,"address":[5243485,5244381],"length":1,"stats":{"Line":13}},{"line":128,"address":[6357358,6358238,6354718,6356478,6355598],"length":1,"stats":{"Line":13}},{"line":137,"address":[6926144],"length":1,"stats":{"Line":6}},{"line":138,"address":[3725484,3725564,3725013,3725415,3725295],"length":1,"stats":{"Line":15}},{"line":149,"address":[3725515,3726141],"length":1,"stats":{"Line":12}},{"line":150,"address":[6359606,6359639],"length":1,"stats":{"Line":13}}],"covered":40,"coverable":41},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","batch_stark_prover","poseidon2.rs"],"content":"use alloc::boxed::Box;\nuse alloc::string::String;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::borrow::Borrow;\nuse core::mem::transmute;\n\nuse p3_air::{Air, AirBuilder, BaseAir};\nuse p3_baby_bear::{BabyBear, GenericPoseidon2LinearLayersBabyBear};\n#[cfg(debug_assertions)]\nuse p3_batch_stark::DebugConstraintBuilderWithLookups;\nuse p3_batch_stark::{StarkGenericConfig, Val};\nuse p3_circuit::op::{NonPrimitiveOpType, Poseidon2Config};\nuse p3_circuit::ops::{Poseidon2CircuitRow, Poseidon2Params, Poseidon2Trace};\nuse p3_circuit::tables::Traces;\nuse p3_field::extension::{BinomialExtensionField, BinomiallyExtendable};\nuse p3_field::{ExtensionField, Field, PrimeCharacteristicRing, PrimeField, PrimeField64};\nuse p3_koala_bear::{GenericPoseidon2LinearLayersKoalaBear, KoalaBear};\nuse p3_lookup::folder::{ProverConstraintFolderWithLookups, VerifierConstraintFolderWithLookups};\nuse p3_lookup::lookup_traits::Lookup;\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_poseidon2_air::RoundConstants;\nuse p3_poseidon2_circuit_air::{\n    BabyBearD4Width16, BabyBearD4Width24, KoalaBearD4Width16, KoalaBearD4Width24,\n    Poseidon2CircuitAirBabyBearD4Width16, Poseidon2CircuitAirBabyBearD4Width24,\n    Poseidon2CircuitAirKoalaBearD4Width16, Poseidon2CircuitAirKoalaBearD4Width24, eval_unchecked,\n    extract_preprocessed_from_operations,\n};\nuse p3_uni_stark::{\n    ProverConstraintFolder, SymbolicAirBuilder, SymbolicExpression, VerifierConstraintFolder,\n};\n\nuse super::dynamic_air::{BatchAir, BatchTableInstance, DynamicAirEntry, TableProver};\nuse crate::batch_stark_prover::{\n    BABY_BEAR_MODULUS, KOALA_BEAR_MODULUS, NonPrimitiveTableEntry, TablePacking,\n};\nuse crate::config::StarkField;\n\n/// Wrapper for Poseidon2CircuitAir that implements BatchAir\u003cSC\u003e\n/// We need this because `BatchAir` requires `BaseAir\u003cVal\u003cSC\u003e\u003e`.\n/// but `Poseidon2CircuitAir` works over a specific field.\n///\n/// Shared between the circuit-prover and the recursion verifier so Poseidon2\n/// dispatch (config → concrete AIR, eval/lookups) is defined in one place.\npub enum Poseidon2AirWrapperInner {\n    BabyBearD4Width16(Box\u003cPoseidon2CircuitAirBabyBearD4Width16\u003e),\n    BabyBearD4Width24(Box\u003cPoseidon2CircuitAirBabyBearD4Width24\u003e),\n    KoalaBearD4Width16(Box\u003cPoseidon2CircuitAirKoalaBearD4Width16\u003e),\n    KoalaBearD4Width24(Box\u003cPoseidon2CircuitAirKoalaBearD4Width24\u003e),\n}\n\nimpl Poseidon2AirWrapperInner {\n    pub fn width(\u0026self) -\u003e usize {\n        match self {\n            Self::BabyBearD4Width16(air) =\u003e air.width(),\n            Self::BabyBearD4Width24(air) =\u003e air.width(),\n            Self::KoalaBearD4Width16(air) =\u003e air.width(),\n            Self::KoalaBearD4Width24(air) =\u003e air.width(),\n        }\n    }\n}\n\nimpl Clone for Poseidon2AirWrapperInner {\n    fn clone(\u0026self) -\u003e Self {\n        match self {\n            Self::BabyBearD4Width16(air) =\u003e Self::BabyBearD4Width16(air.clone()),\n            Self::BabyBearD4Width24(air) =\u003e Self::BabyBearD4Width24(air.clone()),\n            Self::KoalaBearD4Width16(air) =\u003e Self::KoalaBearD4Width16(air.clone()),\n            Self::KoalaBearD4Width24(air) =\u003e Self::KoalaBearD4Width24(air.clone()),\n        }\n    }\n}\n\npub(crate) struct Poseidon2AirWrapper\u003cSC: StarkGenericConfig\u003e {\n    pub(crate) inner: Poseidon2AirWrapperInner,\n    pub(crate) width: usize,\n    _phantom: core::marker::PhantomData\u003cSC\u003e,\n}\n\nimpl\u003cSC\u003e BatchAir\u003cSC\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n}\n\nimpl\u003cSC: StarkGenericConfig\u003e Clone for Poseidon2AirWrapper\u003cSC\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            inner: self.inner.clone(),\n            width: self.width,\n            _phantom: core::marker::PhantomData,\n        }\n    }\n}\n\nimpl\u003cSC\u003e BaseAir\u003cVal\u003cSC\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField,\n{\n    fn width(\u0026self) -\u003e usize {\n        self.width\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e {\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let preprocessed = BaseAir::\u003cBabyBear\u003e::preprocessed_trace(air.as_ref())?;\n                Some(unsafe {\n                    transmute::\u003cRowMajorMatrix\u003cBabyBear\u003e, RowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e(preprocessed)\n                })\n            }\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let preprocessed = BaseAir::\u003cBabyBear\u003e::preprocessed_trace(air.as_ref())?;\n                Some(unsafe {\n                    transmute::\u003cRowMajorMatrix\u003cBabyBear\u003e, RowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e(preprocessed)\n                })\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let preprocessed = BaseAir::\u003cKoalaBear\u003e::preprocessed_trace(air.as_ref())?;\n                Some(unsafe {\n                    transmute::\u003cRowMajorMatrix\u003cKoalaBear\u003e, RowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e(preprocessed)\n                })\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let preprocessed = BaseAir::\u003cKoalaBear\u003e::preprocessed_trace(air.as_ref())?;\n                Some(unsafe {\n                    transmute::\u003cRowMajorMatrix\u003cKoalaBear\u003e, RowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e(preprocessed)\n                })\n            }\n        }\n    }\n}\n\nimpl\u003cSC\u003e Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField,\n{\n    fn eval(\u0026self, builder: \u0026mut SymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e) {\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                unsafe {\n                    let builder_bb: \u0026mut SymbolicAirBuilder\u003cBabyBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_bb);\n                }\n            }\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                unsafe {\n                    let builder_bb: \u0026mut SymbolicAirBuilder\u003cBabyBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_bb);\n                }\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                unsafe {\n                    let builder_kb: \u0026mut SymbolicAirBuilder\u003cKoalaBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_kb);\n                }\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                unsafe {\n                    let builder_kb: \u0026mut SymbolicAirBuilder\u003cKoalaBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_kb);\n                }\n            }\n        }\n    }\n\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n        }\n    }\n\n    #[allow(clippy::missing_transmute_annotations)]\n    fn get_lookups(\n        \u0026mut self,\n    ) -\u003e Vec\u003cLookup\u003c\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e as AirBuilder\u003e::F\u003e\u003e {\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n        }\n    }\n}\n\nimpl\u003cF: Field\u003e BaseAir\u003cF\u003e for Poseidon2AirWrapperInner {\n    fn width(\u0026self) -\u003e usize {\n        match self {\n            Self::BabyBearD4Width16(a) =\u003e BaseAir::\u003cBabyBear\u003e::width(a.as_ref()),\n            Self::BabyBearD4Width24(a) =\u003e BaseAir::\u003cBabyBear\u003e::width(a.as_ref()),\n            Self::KoalaBearD4Width16(a) =\u003e BaseAir::\u003cKoalaBear\u003e::width(a.as_ref()),\n            Self::KoalaBearD4Width24(a) =\u003e BaseAir::\u003cKoalaBear\u003e::width(a.as_ref()),\n        }\n    }\n}\n\nimpl\u003cF, EF\u003e Air\u003cSymbolicAirBuilder\u003cF, EF\u003e\u003e for Poseidon2AirWrapperInner\nwhere\n    F: Field + PrimeField64,\n    EF: ExtensionField\u003cF\u003e,\n    SymbolicExpression\u003cEF\u003e: From\u003cSymbolicExpression\u003cF\u003e\u003e,\n{\n    fn eval(\u0026self, builder: \u0026mut SymbolicAirBuilder\u003cF, EF\u003e) {\n        match self {\n            Self::BabyBearD4Width16(air) =\u003e {\n                assert_eq!(F::from_u64(BABY_BEAR_MODULUS), F::ZERO);\n                unsafe {\n                    let builder_bb: \u0026mut SymbolicAirBuilder\u003cBabyBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_bb);\n                }\n            }\n            Self::BabyBearD4Width24(air) =\u003e {\n                assert_eq!(F::from_u64(BABY_BEAR_MODULUS), F::ZERO);\n                unsafe {\n                    let builder_bb: \u0026mut SymbolicAirBuilder\u003cBabyBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_bb);\n                }\n            }\n            Self::KoalaBearD4Width16(air) =\u003e {\n                assert_eq!(F::from_u64(KOALA_BEAR_MODULUS), F::ZERO);\n                unsafe {\n                    let builder_kb: \u0026mut SymbolicAirBuilder\u003cKoalaBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_kb);\n                }\n            }\n            Self::KoalaBearD4Width24(air) =\u003e {\n                assert_eq!(F::from_u64(KOALA_BEAR_MODULUS), F::ZERO);\n                unsafe {\n                    let builder_kb: \u0026mut SymbolicAirBuilder\u003cKoalaBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_kb);\n                }\n            }\n        }\n    }\n\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        match self {\n            Self::BabyBearD4Width16(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Self::BabyBearD4Width24(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Self::KoalaBearD4Width16(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n            Self::KoalaBearD4Width24(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n        }\n    }\n\n    #[allow(clippy::missing_transmute_annotations)]\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cSymbolicAirBuilder\u003cF, EF\u003e as AirBuilder\u003e::F\u003e\u003e {\n        match self {\n            Self::BabyBearD4Width16(air) =\u003e unsafe {\n                assert_eq!(F::from_u64(BABY_BEAR_MODULUS), F::ZERO);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Self::BabyBearD4Width24(air) =\u003e unsafe {\n                assert_eq!(F::from_u64(BABY_BEAR_MODULUS), F::ZERO);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Self::KoalaBearD4Width16(air) =\u003e unsafe {\n                assert_eq!(F::from_u64(KOALA_BEAR_MODULUS), F::ZERO);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n            Self::KoalaBearD4Width24(air) =\u003e unsafe {\n                assert_eq!(F::from_u64(KOALA_BEAR_MODULUS), F::ZERO);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n        }\n    }\n}\n\n/// Builds a Poseidon2 AIR wrapper from config for use in the recursive verifier\n/// (no preprocessed data). Single source of truth for config → AIR so prover\n/// and verifier stay in sync.\npub fn poseidon2_verifier_air_from_config(config: Poseidon2Config) -\u003e Poseidon2AirWrapperInner {\n    Poseidon2Prover::air_wrapper_for_config(config)\n}\n\n/// Helper function to evaluate a Poseidon2 variant with a given builder.\n/// This encapsulates the common pattern of transmuting slices and calling eval_unchecked.\npub(crate) unsafe fn eval_poseidon2_variant\u003c\n    SC,\n    F: PrimeField,\n    AB: AirBuilder,\n    LinearLayers,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e(\n    air: \u0026p3_poseidon2_circuit_air::Poseidon2CircuitAir\u003c\n        F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e,\n    builder: \u0026mut AB,\n    local_slice: \u0026[\u003cAB as AirBuilder\u003e::Var],\n    next_slice: \u0026[\u003cAB as AirBuilder\u003e::Var],\n    next_preprocessed_slice: \u0026[\u003cAB as AirBuilder\u003e::Var],\n) where\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n    AB::F: PrimeField,\n    LinearLayers: p3_poseidon2::GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n{\n    unsafe {\n        let local_slice_ptr = local_slice.as_ptr() as *const \u003cF as p3_field::Field\u003e::Packing;\n        let local_slice_f = core::slice::from_raw_parts(local_slice_ptr, local_slice.len());\n        let local_f: \u0026p3_poseidon2_circuit_air::Poseidon2CircuitCols\u003c\n            \u003cF as p3_field::Field\u003e::Packing,\n            p3_poseidon2_air::Poseidon2Cols\u003c\n                \u003cF as p3_field::Field\u003e::Packing,\n                WIDTH,\n                SBOX_DEGREE,\n                SBOX_REGISTERS,\n                HALF_FULL_ROUNDS,\n                PARTIAL_ROUNDS,\n            \u003e,\n        \u003e = (*local_slice_f).borrow();\n\n        let next_slice_ptr = next_slice.as_ptr() as *const \u003cF as p3_field::Field\u003e::Packing;\n        let next_slice_f = core::slice::from_raw_parts(next_slice_ptr, next_slice.len());\n        let next_f: \u0026p3_poseidon2_circuit_air::Poseidon2CircuitCols\u003c\n            \u003cF as p3_field::Field\u003e::Packing,\n            p3_poseidon2_air::Poseidon2Cols\u003c\n                \u003cF as p3_field::Field\u003e::Packing,\n                WIDTH,\n                SBOX_DEGREE,\n                SBOX_REGISTERS,\n                HALF_FULL_ROUNDS,\n                PARTIAL_ROUNDS,\n            \u003e,\n        \u003e = (*next_slice_f).borrow();\n\n        let next_preprocessed_ptr =\n            next_preprocessed_slice.as_ptr() as *const \u003cF as p3_field::Field\u003e::Packing;\n        let next_preprocessed_f =\n            core::slice::from_raw_parts(next_preprocessed_ptr, next_preprocessed_slice.len());\n\n        let local_var: \u0026p3_poseidon2_circuit_air::Poseidon2CircuitCols\u003c\n            AB::Var,\n            p3_poseidon2_air::Poseidon2Cols\u003c\n                AB::Var,\n                WIDTH,\n                SBOX_DEGREE,\n                SBOX_REGISTERS,\n                HALF_FULL_ROUNDS,\n                PARTIAL_ROUNDS,\n            \u003e,\n        \u003e = core::mem::transmute(local_f);\n\n        let next_var: \u0026p3_poseidon2_circuit_air::Poseidon2CircuitCols\u003c\n            AB::Var,\n            p3_poseidon2_air::Poseidon2Cols\u003c\n                AB::Var,\n                WIDTH,\n                SBOX_DEGREE,\n                SBOX_REGISTERS,\n                HALF_FULL_ROUNDS,\n                PARTIAL_ROUNDS,\n            \u003e,\n        \u003e = core::mem::transmute(next_f);\n\n        let next_preprocessed_var: \u0026[AB::Var] = core::mem::transmute(next_preprocessed_f);\n\n        eval_unchecked::\u003c\n            F,\n            AB,\n            LinearLayers,\n            D,\n            WIDTH,\n            WIDTH_EXT,\n            RATE_EXT,\n            CAPACITY_EXT,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e(air, builder, local_var, next_var, next_preprocessed_var);\n    }\n}\n\nimpl\u003c'a, SC\u003e Air\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut ProverConstraintFolder\u003c'a, SC\u003e) {\n        let main = builder.main();\n        let local_slice = main.row_slice(0).expect(\"The matrix is empty?\");\n        let next_slice = main.row_slice(1).expect(\"The matrix has only one row?\");\n        let preprocessed = builder\n            .preprocessed()\n            .expect(\"Expected preprocessed columns\");\n        let next_preprocessed_slice = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    ProverConstraintFolder\u003c'a, SC\u003e,\n                    p3_baby_bear::GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width16::D },\n                    { BabyBearD4Width16::WIDTH },\n                    { BabyBearD4Width16::WIDTH_EXT },\n                    { BabyBearD4Width16::RATE_EXT },\n                    { BabyBearD4Width16::CAPACITY_EXT },\n                    { BabyBearD4Width16::SBOX_DEGREE },\n                    { BabyBearD4Width16::SBOX_REGISTERS },\n                    { BabyBearD4Width16::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    ProverConstraintFolder\u003c'a, SC\u003e,\n                    p3_baby_bear::GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width24::D },\n                    { BabyBearD4Width24::WIDTH },\n                    { BabyBearD4Width24::WIDTH_EXT },\n                    { BabyBearD4Width24::RATE_EXT },\n                    { BabyBearD4Width24::CAPACITY_EXT },\n                    { BabyBearD4Width24::SBOX_DEGREE },\n                    { BabyBearD4Width24::SBOX_REGISTERS },\n                    { BabyBearD4Width24::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    ProverConstraintFolder\u003c'a, SC\u003e,\n                    p3_koala_bear::GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width16::D },\n                    { KoalaBearD4Width16::WIDTH },\n                    { KoalaBearD4Width16::WIDTH_EXT },\n                    { KoalaBearD4Width16::RATE_EXT },\n                    { KoalaBearD4Width16::CAPACITY_EXT },\n                    { KoalaBearD4Width16::SBOX_DEGREE },\n                    { KoalaBearD4Width16::SBOX_REGISTERS },\n                    { KoalaBearD4Width16::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    ProverConstraintFolder\u003c'a, SC\u003e,\n                    p3_koala_bear::GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width24::D },\n                    { KoalaBearD4Width24::WIDTH },\n                    { KoalaBearD4Width24::WIDTH_EXT },\n                    { KoalaBearD4Width24::RATE_EXT },\n                    { KoalaBearD4Width24::CAPACITY_EXT },\n                    { KoalaBearD4Width24::SBOX_DEGREE },\n                    { KoalaBearD4Width24::SBOX_REGISTERS },\n                    { KoalaBearD4Width24::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n        }\n    }\n\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n        }\n    }\n\n    #[allow(clippy::missing_transmute_annotations)]\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cProverConstraintFolder\u003c'a, SC\u003e as AirBuilder\u003e::F\u003e\u003e {\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n        }\n    }\n}\n\nimpl\u003c'a, SC\u003e Air\u003cProverConstraintFolderWithLookups\u003c'a, SC\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut ProverConstraintFolderWithLookups\u003c'a, SC\u003e) {\n        let main = builder.main();\n        let local_slice = main.row_slice(0).expect(\"The matrix is empty?\");\n        let next_slice = main.row_slice(1).expect(\"The matrix has only one row?\");\n        let preprocessed = builder\n            .preprocessed()\n            .expect(\"Expected preprocessed columns\");\n        let next_preprocessed_slice = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    ProverConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    p3_baby_bear::GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width16::D },\n                    { BabyBearD4Width16::WIDTH },\n                    { BabyBearD4Width16::WIDTH_EXT },\n                    { BabyBearD4Width16::RATE_EXT },\n                    { BabyBearD4Width16::CAPACITY_EXT },\n                    { BabyBearD4Width16::SBOX_DEGREE },\n                    { BabyBearD4Width16::SBOX_REGISTERS },\n                    { BabyBearD4Width16::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    ProverConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    p3_baby_bear::GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width24::D },\n                    { BabyBearD4Width24::WIDTH },\n                    { BabyBearD4Width24::WIDTH_EXT },\n                    { BabyBearD4Width24::RATE_EXT },\n                    { BabyBearD4Width24::CAPACITY_EXT },\n                    { BabyBearD4Width24::SBOX_DEGREE },\n                    { BabyBearD4Width24::SBOX_REGISTERS },\n                    { BabyBearD4Width24::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    ProverConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    p3_koala_bear::GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width16::D },\n                    { KoalaBearD4Width16::WIDTH },\n                    { KoalaBearD4Width16::WIDTH_EXT },\n                    { KoalaBearD4Width16::RATE_EXT },\n                    { KoalaBearD4Width16::CAPACITY_EXT },\n                    { KoalaBearD4Width16::SBOX_DEGREE },\n                    { KoalaBearD4Width16::SBOX_REGISTERS },\n                    { KoalaBearD4Width16::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    ProverConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    p3_koala_bear::GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width24::D },\n                    { KoalaBearD4Width24::WIDTH },\n                    { KoalaBearD4Width24::WIDTH_EXT },\n                    { KoalaBearD4Width24::RATE_EXT },\n                    { KoalaBearD4Width24::CAPACITY_EXT },\n                    { KoalaBearD4Width24::SBOX_DEGREE },\n                    { KoalaBearD4Width24::SBOX_REGISTERS },\n                    { KoalaBearD4Width24::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n        }\n    }\n\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n        }\n    }\n\n    #[allow(clippy::missing_transmute_annotations)]\n    fn get_lookups(\n        \u0026mut self,\n    ) -\u003e Vec\u003cLookup\u003c\u003cProverConstraintFolderWithLookups\u003c'a, SC\u003e as AirBuilder\u003e::F\u003e\u003e {\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n        }\n    }\n}\n\nimpl\u003c'a, SC\u003e Air\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut VerifierConstraintFolder\u003c'a, SC\u003e) {\n        let main = builder.main();\n        let local_slice = main.row_slice(0).expect(\"The matrix is empty?\");\n        let next_slice = main.row_slice(1).expect(\"The matrix has only one row?\");\n        let preprocessed = builder\n            .preprocessed()\n            .expect(\"Expected preprocessed columns\");\n        let next_preprocessed_slice = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    VerifierConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width16::D },\n                    { BabyBearD4Width16::WIDTH },\n                    { BabyBearD4Width16::WIDTH_EXT },\n                    { BabyBearD4Width16::RATE_EXT },\n                    { BabyBearD4Width16::CAPACITY_EXT },\n                    { BabyBearD4Width16::SBOX_DEGREE },\n                    { BabyBearD4Width16::SBOX_REGISTERS },\n                    { BabyBearD4Width16::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    VerifierConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width24::D },\n                    { BabyBearD4Width24::WIDTH },\n                    { BabyBearD4Width24::WIDTH_EXT },\n                    { BabyBearD4Width24::RATE_EXT },\n                    { BabyBearD4Width24::CAPACITY_EXT },\n                    { BabyBearD4Width24::SBOX_DEGREE },\n                    { BabyBearD4Width24::SBOX_REGISTERS },\n                    { BabyBearD4Width24::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    VerifierConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width16::D },\n                    { KoalaBearD4Width16::WIDTH },\n                    { KoalaBearD4Width16::WIDTH_EXT },\n                    { KoalaBearD4Width16::RATE_EXT },\n                    { KoalaBearD4Width16::CAPACITY_EXT },\n                    { KoalaBearD4Width16::SBOX_DEGREE },\n                    { KoalaBearD4Width16::SBOX_REGISTERS },\n                    { KoalaBearD4Width16::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    VerifierConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width24::D },\n                    { KoalaBearD4Width24::WIDTH },\n                    { KoalaBearD4Width24::WIDTH_EXT },\n                    { KoalaBearD4Width24::RATE_EXT },\n                    { KoalaBearD4Width24::CAPACITY_EXT },\n                    { KoalaBearD4Width24::SBOX_DEGREE },\n                    { KoalaBearD4Width24::SBOX_REGISTERS },\n                    { KoalaBearD4Width24::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n        }\n    }\n}\n\nimpl\u003c'a, SC\u003e Air\u003cVerifierConstraintFolderWithLookups\u003c'a, SC\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut VerifierConstraintFolderWithLookups\u003c'a, SC\u003e) {\n        let main = builder.main();\n        let local_slice = main.row_slice(0).expect(\"The matrix is empty?\");\n        let next_slice = main.row_slice(1).expect(\"The matrix has only one row?\");\n        let preprocessed = builder\n            .preprocessed()\n            .expect(\"Expected preprocessed columns\");\n        let next_preprocessed_slice = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    VerifierConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    p3_baby_bear::GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width16::D },\n                    { BabyBearD4Width16::WIDTH },\n                    { BabyBearD4Width16::WIDTH_EXT },\n                    { BabyBearD4Width16::RATE_EXT },\n                    { BabyBearD4Width16::CAPACITY_EXT },\n                    { BabyBearD4Width16::SBOX_DEGREE },\n                    { BabyBearD4Width16::SBOX_REGISTERS },\n                    { BabyBearD4Width16::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    VerifierConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    p3_baby_bear::GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width24::D },\n                    { BabyBearD4Width24::WIDTH },\n                    { BabyBearD4Width24::WIDTH_EXT },\n                    { BabyBearD4Width24::RATE_EXT },\n                    { BabyBearD4Width24::CAPACITY_EXT },\n                    { BabyBearD4Width24::SBOX_DEGREE },\n                    { BabyBearD4Width24::SBOX_REGISTERS },\n                    { BabyBearD4Width24::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    VerifierConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    p3_koala_bear::GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width16::D },\n                    { KoalaBearD4Width16::WIDTH },\n                    { KoalaBearD4Width16::WIDTH_EXT },\n                    { KoalaBearD4Width16::RATE_EXT },\n                    { KoalaBearD4Width16::CAPACITY_EXT },\n                    { KoalaBearD4Width16::SBOX_DEGREE },\n                    { KoalaBearD4Width16::SBOX_REGISTERS },\n                    { KoalaBearD4Width16::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    VerifierConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    p3_koala_bear::GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width24::D },\n                    { KoalaBearD4Width24::WIDTH },\n                    { KoalaBearD4Width24::WIDTH_EXT },\n                    { KoalaBearD4Width24::RATE_EXT },\n                    { KoalaBearD4Width24::CAPACITY_EXT },\n                    { KoalaBearD4Width24::SBOX_DEGREE },\n                    { KoalaBearD4Width24::SBOX_REGISTERS },\n                    { KoalaBearD4Width24::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n        }\n    }\n\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n        }\n    }\n\n    #[allow(clippy::missing_transmute_annotations)]\n    fn get_lookups(\n        \u0026mut self,\n    ) -\u003e Vec\u003cLookup\u003c\u003cVerifierConstraintFolderWithLookups\u003c'a, SC\u003e as AirBuilder\u003e::F\u003e\u003e {\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n        }\n    }\n}\n\n#[cfg(debug_assertions)]\nimpl\u003c'a, SC\u003e Air\u003cDebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e\u003e\n    for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut DebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e) {\n        let main = builder.main();\n        let local_slice = main.row_slice(0).expect(\"The matrix is empty?\");\n        let next_slice = main.row_slice(1).expect(\"The matrix has only one row?\");\n        let preprocessed = builder\n            .preprocessed()\n            .expect(\"Expected preprocessed columns\");\n        let next_preprocessed_slice = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    DebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width16::D },\n                    { BabyBearD4Width16::WIDTH },\n                    { BabyBearD4Width16::WIDTH_EXT },\n                    { BabyBearD4Width16::RATE_EXT },\n                    { BabyBearD4Width16::CAPACITY_EXT },\n                    { BabyBearD4Width16::SBOX_DEGREE },\n                    { BabyBearD4Width16::SBOX_REGISTERS },\n                    { BabyBearD4Width16::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    DebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width24::D },\n                    { BabyBearD4Width24::WIDTH },\n                    { BabyBearD4Width24::WIDTH_EXT },\n                    { BabyBearD4Width24::RATE_EXT },\n                    { BabyBearD4Width24::CAPACITY_EXT },\n                    { BabyBearD4Width24::SBOX_DEGREE },\n                    { BabyBearD4Width24::SBOX_REGISTERS },\n                    { BabyBearD4Width24::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    DebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width16::D },\n                    { KoalaBearD4Width16::WIDTH },\n                    { KoalaBearD4Width16::WIDTH_EXT },\n                    { KoalaBearD4Width16::RATE_EXT },\n                    { KoalaBearD4Width16::CAPACITY_EXT },\n                    { KoalaBearD4Width16::SBOX_DEGREE },\n                    { KoalaBearD4Width16::SBOX_REGISTERS },\n                    { KoalaBearD4Width16::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    DebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width24::D },\n                    { KoalaBearD4Width24::WIDTH },\n                    { KoalaBearD4Width24::WIDTH_EXT },\n                    { KoalaBearD4Width24::RATE_EXT },\n                    { KoalaBearD4Width24::CAPACITY_EXT },\n                    { KoalaBearD4Width24::SBOX_DEGREE },\n                    { KoalaBearD4Width24::SBOX_REGISTERS },\n                    { KoalaBearD4Width24::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n        }\n    }\n\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    DebugConstraintBuilderWithLookups\u003c\n                        'a,\n                        BabyBear,\n                        BinomialExtensionField\u003cBabyBear, 4\u003e,\n                    \u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    DebugConstraintBuilderWithLookups\u003c\n                        'a,\n                        BabyBear,\n                        BinomialExtensionField\u003cBabyBear, 4\u003e,\n                    \u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    DebugConstraintBuilderWithLookups\u003c\n                        'a,\n                        KoalaBear,\n                        BinomialExtensionField\u003cKoalaBear, 4\u003e,\n                    \u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    DebugConstraintBuilderWithLookups\u003c\n                        'a,\n                        KoalaBear,\n                        BinomialExtensionField\u003cKoalaBear, 4\u003e,\n                    \u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n        }\n    }\n\n    #[allow(clippy::missing_transmute_annotations)] // this gets overly verbose otherwise\n    fn get_lookups(\n        \u0026mut self,\n    ) -\u003e Vec\u003cLookup\u003c\u003cDebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e as AirBuilder\u003e::F\u003e\u003e\n    {\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                // Runtime check: verify Val\u003cSC\u003e == BabyBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                // Runtime check: verify Val\u003cSC\u003e == BabyBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                // Runtime check: verify Val\u003cSC\u003e == KoalaBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width16 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                // Runtime check: verify Val\u003cSC\u003e == KoalaBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width24 as Air\u003c\n                    SymbolicAirBuilder\u003cKoalaBear, BinomialExtensionField\u003cKoalaBear, 4\u003e\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n        }\n    }\n}\n\n/// Poseidon2 prover plugin that supports runtime configuration.\n#[derive(Clone)]\npub struct Poseidon2Prover {\n    /// The configuration that provides permutation and constants.\n    config: Poseidon2Config,\n}\n\nunsafe impl Send for Poseidon2Prover {}\nunsafe impl Sync for Poseidon2Prover {}\n\nimpl Poseidon2Prover {\n    pub const fn new(\n        config: Poseidon2Config,\n        _profile: crate::constraint_profile::ConstraintProfile,\n    ) -\u003e Self {\n        Self { config }\n    }\n\n    const fn baby_bear_constants_16() -\u003e RoundConstants\u003cBabyBear, 16, 4, 13\u003e {\n        let beginning_full: [[BabyBear; 16]; 4] = p3_baby_bear::BABYBEAR_RC16_EXTERNAL_INITIAL;\n        let partial: [BabyBear; 13] = p3_baby_bear::BABYBEAR_RC16_INTERNAL;\n        let ending_full: [[BabyBear; 16]; 4] = p3_baby_bear::BABYBEAR_RC16_EXTERNAL_FINAL;\n        RoundConstants::new(beginning_full, partial, ending_full)\n    }\n\n    const fn baby_bear_constants_24() -\u003e RoundConstants\u003cBabyBear, 24, 4, 21\u003e {\n        let beginning_full: [[BabyBear; 24]; 4] = p3_baby_bear::BABYBEAR_RC24_EXTERNAL_INITIAL;\n        let partial: [BabyBear; 21] = p3_baby_bear::BABYBEAR_RC24_INTERNAL;\n        let ending_full: [[BabyBear; 24]; 4] = p3_baby_bear::BABYBEAR_RC24_EXTERNAL_FINAL;\n        RoundConstants::new(beginning_full, partial, ending_full)\n    }\n\n    const fn koala_bear_constants_16() -\u003e RoundConstants\u003cKoalaBear, 16, 4, 20\u003e {\n        let beginning_full: [[KoalaBear; 16]; 4] = p3_koala_bear::KOALABEAR_RC16_EXTERNAL_INITIAL;\n        let partial: [KoalaBear; 20] = p3_koala_bear::KOALABEAR_RC16_INTERNAL;\n        let ending_full: [[KoalaBear; 16]; 4] = p3_koala_bear::KOALABEAR_RC16_EXTERNAL_FINAL;\n        RoundConstants::new(beginning_full, partial, ending_full)\n    }\n\n    const fn koala_bear_constants_24() -\u003e RoundConstants\u003cKoalaBear, 24, 4, 23\u003e {\n        let beginning_full: [[KoalaBear; 24]; 4] = p3_koala_bear::KOALABEAR_RC24_EXTERNAL_INITIAL;\n        let partial: [KoalaBear; 23] = p3_koala_bear::KOALABEAR_RC24_INTERNAL;\n        let ending_full: [[KoalaBear; 24]; 4] = p3_koala_bear::KOALABEAR_RC24_EXTERNAL_FINAL;\n        RoundConstants::new(beginning_full, partial, ending_full)\n    }\n\n    pub(crate) fn air_wrapper_for_config(config: Poseidon2Config) -\u003e Poseidon2AirWrapperInner {\n        match config {\n            Poseidon2Config::BabyBearD1Width16 | Poseidon2Config::BabyBearD4Width16 =\u003e {\n                Poseidon2AirWrapperInner::BabyBearD4Width16(Box::new(\n                    Poseidon2CircuitAirBabyBearD4Width16::new(Self::baby_bear_constants_16()),\n                ))\n            }\n            Poseidon2Config::BabyBearD4Width24 =\u003e {\n                Poseidon2AirWrapperInner::BabyBearD4Width24(Box::new(\n                    Poseidon2CircuitAirBabyBearD4Width24::new(Self::baby_bear_constants_24()),\n                ))\n            }\n            Poseidon2Config::KoalaBearD1Width16 | Poseidon2Config::KoalaBearD4Width16 =\u003e {\n                Poseidon2AirWrapperInner::KoalaBearD4Width16(Box::new(\n                    Poseidon2CircuitAirKoalaBearD4Width16::new(Self::koala_bear_constants_16()),\n                ))\n            }\n            Poseidon2Config::KoalaBearD4Width24 =\u003e {\n                Poseidon2AirWrapperInner::KoalaBearD4Width24(Box::new(\n                    Poseidon2CircuitAirKoalaBearD4Width24::new(Self::koala_bear_constants_24()),\n                ))\n            }\n        }\n    }\n\n    fn air_wrapper_for_config_with_preprocessed\u003cF: Field\u003e(\n        config: Poseidon2Config,\n        preprocessed: Vec\u003cF\u003e,\n        min_height: usize,\n    ) -\u003e Poseidon2AirWrapperInner {\n        match config {\n            Poseidon2Config::BabyBearD1Width16 | Poseidon2Config::BabyBearD4Width16 =\u003e {\n                assert!(F::from_u64(BABY_BEAR_MODULUS) == F::ZERO,);\n                Poseidon2AirWrapperInner::BabyBearD4Width16(Box::new(\n                    Poseidon2CircuitAirBabyBearD4Width16::new_with_preprocessed(\n                        Self::baby_bear_constants_16(),\n                        unsafe { transmute::\u003cVec\u003cF\u003e, Vec\u003cBabyBear\u003e\u003e(preprocessed) },\n                    )\n                    .with_min_height(min_height),\n                ))\n            }\n            Poseidon2Config::BabyBearD4Width24 =\u003e {\n                assert!(F::from_u64(BABY_BEAR_MODULUS) == F::ZERO,);\n                Poseidon2AirWrapperInner::BabyBearD4Width24(Box::new(\n                    Poseidon2CircuitAirBabyBearD4Width24::new_with_preprocessed(\n                        Self::baby_bear_constants_24(),\n                        unsafe { transmute::\u003cVec\u003cF\u003e, Vec\u003cBabyBear\u003e\u003e(preprocessed) },\n                    )\n                    .with_min_height(min_height),\n                ))\n            }\n            Poseidon2Config::KoalaBearD1Width16 | Poseidon2Config::KoalaBearD4Width16 =\u003e {\n                assert!(F::from_u64(KOALA_BEAR_MODULUS) == F::ZERO,);\n                Poseidon2AirWrapperInner::KoalaBearD4Width16(Box::new(\n                    Poseidon2CircuitAirKoalaBearD4Width16::new_with_preprocessed(\n                        Self::koala_bear_constants_16(),\n                        unsafe { transmute::\u003cVec\u003cF\u003e, Vec\u003cKoalaBear\u003e\u003e(preprocessed) },\n                    )\n                    .with_min_height(min_height),\n                ))\n            }\n            Poseidon2Config::KoalaBearD4Width24 =\u003e {\n                assert!(F::from_u64(KOALA_BEAR_MODULUS) == F::ZERO,);\n                Poseidon2AirWrapperInner::KoalaBearD4Width24(Box::new(\n                    Poseidon2CircuitAirKoalaBearD4Width24::new_with_preprocessed(\n                        Self::koala_bear_constants_24(),\n                        unsafe { transmute::\u003cVec\u003cF\u003e, Vec\u003cKoalaBear\u003e\u003e(preprocessed) },\n                    )\n                    .with_min_height(min_height),\n                ))\n            }\n        }\n    }\n\n    pub fn wrapper_from_config_with_preprocessed\u003cSC\u003e(\n        \u0026self,\n        preprocessed: Vec\u003cVal\u003cSC\u003e\u003e,\n        min_height: usize,\n    ) -\u003e DynamicAirEntry\u003cSC\u003e\n    where\n        SC: StarkGenericConfig + 'static + Send + Sync,\n        Val\u003cSC\u003e: StarkField,\n        SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n    {\n        DynamicAirEntry::new(Box::new(Poseidon2AirWrapper {\n            inner: Self::air_wrapper_for_config_with_preprocessed::\u003cVal\u003cSC\u003e\u003e(\n                self.config,\n                preprocessed,\n                min_height,\n            ),\n            width: self.width_from_config(),\n            _phantom: core::marker::PhantomData::\u003cSC\u003e,\n        }))\n    }\n\n    pub fn width_from_config(\u0026self) -\u003e usize {\n        match self.config {\n            Poseidon2Config::BabyBearD1Width16 | Poseidon2Config::BabyBearD4Width16 =\u003e {\n                Poseidon2CircuitAirBabyBearD4Width16::new(Self::baby_bear_constants_16()).width()\n            }\n            Poseidon2Config::BabyBearD4Width24 =\u003e {\n                Poseidon2CircuitAirBabyBearD4Width24::new(Self::baby_bear_constants_24()).width()\n            }\n            Poseidon2Config::KoalaBearD1Width16 | Poseidon2Config::KoalaBearD4Width16 =\u003e {\n                Poseidon2CircuitAirKoalaBearD4Width16::new(Self::koala_bear_constants_16()).width()\n            }\n            Poseidon2Config::KoalaBearD4Width24 =\u003e {\n                Poseidon2CircuitAirKoalaBearD4Width24::new(Self::koala_bear_constants_24()).width()\n            }\n        }\n    }\n\n    pub const fn preprocessed_width_from_config(\u0026self) -\u003e usize {\n        match self.config {\n            Poseidon2Config::BabyBearD1Width16 | Poseidon2Config::BabyBearD4Width16 =\u003e {\n                Poseidon2CircuitAirBabyBearD4Width16::preprocessed_width()\n            }\n            Poseidon2Config::BabyBearD4Width24 =\u003e {\n                Poseidon2CircuitAirBabyBearD4Width24::preprocessed_width()\n            }\n            Poseidon2Config::KoalaBearD1Width16 | Poseidon2Config::KoalaBearD4Width16 =\u003e {\n                Poseidon2CircuitAirKoalaBearD4Width16::preprocessed_width()\n            }\n            Poseidon2Config::KoalaBearD4Width24 =\u003e {\n                Poseidon2CircuitAirKoalaBearD4Width24::preprocessed_width()\n            }\n        }\n    }\n\n    fn batch_instance_from_traces\u003cSC, CF\u003e(\n        \u0026self,\n        _config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cCF\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e\n    where\n        SC: StarkGenericConfig + 'static + Send + Sync,\n        Val\u003cSC\u003e: StarkField,\n        CF: Field + ExtensionField\u003cVal\u003cSC\u003e\u003e,\n        SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n    {\n        let t = traces.non_primitive_trace::\u003cPoseidon2Trace\u003cVal\u003cSC\u003e\u003e\u003e(\n            NonPrimitiveOpType::Poseidon2Perm(self.config),\n        )?;\n\n        let rows = t.total_rows();\n        if rows == 0 {\n            return None;\n        }\n\n        let min_height = packing.min_trace_height();\n        match self.config {\n            Poseidon2Config::BabyBearD1Width16 | Poseidon2Config::BabyBearD4Width16 =\u003e {\n                self.batch_instance_base_impl::\u003cSC, 16, 4, 13, 2\u003e(t, min_height)\n            }\n            Poseidon2Config::BabyBearD4Width24 =\u003e {\n                self.batch_instance_base_impl::\u003cSC, 24, 4, 21, 4\u003e(t, min_height)\n            }\n            Poseidon2Config::KoalaBearD1Width16 | Poseidon2Config::KoalaBearD4Width16 =\u003e {\n                self.batch_instance_base_impl::\u003cSC, 16, 4, 20, 2\u003e(t, min_height)\n            }\n            Poseidon2Config::KoalaBearD4Width24 =\u003e {\n                self.batch_instance_base_impl::\u003cSC, 24, 4, 23, 4\u003e(t, min_height)\n            }\n        }\n    }\n\n    fn batch_instance_base_impl\u003c\n        SC,\n        const WIDTH: usize,\n        const HALF_FULL_ROUNDS: usize,\n        const PARTIAL_ROUNDS: usize,\n        const RATE_EXT: usize,\n    \u003e(\n        \u0026self,\n        t: \u0026Poseidon2Trace\u003cVal\u003cSC\u003e\u003e,\n        min_height: usize,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e\n    where\n        SC: StarkGenericConfig + 'static + Send + Sync,\n        Val\u003cSC\u003e: StarkField,\n        SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n    {\n        let rows = t.total_rows();\n\n        let padded_rows = rows.next_power_of_two();\n        let mut padded_ops = t.operations.clone();\n        while padded_ops.len() \u003c padded_rows {\n            padded_ops.push(\n                padded_ops\n                    .last()\n                    .cloned()\n                    .unwrap_or_else(|| Poseidon2CircuitRow {\n                        new_start: true,\n                        merkle_path: false,\n                        mmcs_bit: false,\n                        mmcs_index_sum: Val::\u003cSC\u003e::ZERO,\n                        input_values: vec![Val::\u003cSC\u003e::ZERO; WIDTH],\n                        in_ctl: [false; 4],\n                        input_indices: [0; 4],\n                        out_ctl: [false; 2],\n                        output_indices: [0; 2],\n                        mmcs_index_sum_idx: 0,\n                        mmcs_ctl_enabled: false,\n                    }),\n            );\n        }\n\n        let (air, matrix) = match self.config {\n            Poseidon2Config::BabyBearD1Width16 | Poseidon2Config::BabyBearD4Width16 =\u003e {\n                let constants = Self::baby_bear_constants_16();\n                let preprocessed =\n                    extract_preprocessed_from_operations::\u003cBabyBear, Val\u003cSC\u003e\u003e(\u0026t.operations);\n                let air = Poseidon2CircuitAirBabyBearD4Width16::new_with_preprocessed(\n                    constants.clone(),\n                    preprocessed.clone(),\n                )\n                .with_min_height(min_height);\n                let ops_babybear: Vec\u003cPoseidon2CircuitRow\u003cBabyBear\u003e\u003e =\n                    unsafe { transmute(padded_ops.clone()) };\n                let matrix_f = air.generate_trace_rows(\u0026ops_babybear, \u0026constants, 0);\n                let matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e = unsafe { transmute(matrix_f) };\n                (\n                    Poseidon2AirWrapper {\n                        inner: Self::air_wrapper_for_config_with_preprocessed::\u003cBabyBear\u003e(\n                            self.config,\n                            preprocessed,\n                            min_height,\n                        ),\n                        width: air.width(),\n                        _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                    },\n                    matrix,\n                )\n            }\n            Poseidon2Config::BabyBearD4Width24 =\u003e {\n                let constants = Self::baby_bear_constants_24();\n                let preprocessed =\n                    extract_preprocessed_from_operations::\u003cBabyBear, Val\u003cSC\u003e\u003e(\u0026t.operations);\n                let air = Poseidon2CircuitAirBabyBearD4Width24::new_with_preprocessed(\n                    constants.clone(),\n                    preprocessed.clone(),\n                )\n                .with_min_height(min_height);\n                let ops_babybear: Vec\u003cPoseidon2CircuitRow\u003cBabyBear\u003e\u003e =\n                    unsafe { transmute(padded_ops.clone()) };\n                let matrix_f = air.generate_trace_rows(\u0026ops_babybear, \u0026constants, 0);\n                let matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e = unsafe { transmute(matrix_f) };\n                (\n                    Poseidon2AirWrapper {\n                        inner: Self::air_wrapper_for_config_with_preprocessed(\n                            self.config,\n                            preprocessed,\n                            min_height,\n                        ),\n                        width: air.width(),\n                        _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                    },\n                    matrix,\n                )\n            }\n            Poseidon2Config::KoalaBearD1Width16 | Poseidon2Config::KoalaBearD4Width16 =\u003e {\n                let constants = Self::koala_bear_constants_16();\n                let preprocessed =\n                    extract_preprocessed_from_operations::\u003cKoalaBear, Val\u003cSC\u003e\u003e(\u0026t.operations);\n                let air = Poseidon2CircuitAirKoalaBearD4Width16::new_with_preprocessed(\n                    constants.clone(),\n                    preprocessed.clone(),\n                )\n                .with_min_height(min_height);\n                let ops_koalabear: Vec\u003cPoseidon2CircuitRow\u003cKoalaBear\u003e\u003e =\n                    unsafe { transmute(padded_ops.clone()) };\n                let matrix_f = air.generate_trace_rows(\u0026ops_koalabear, \u0026constants, 0);\n                let matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e = unsafe { transmute(matrix_f) };\n                (\n                    Poseidon2AirWrapper {\n                        inner: Self::air_wrapper_for_config_with_preprocessed(\n                            self.config,\n                            preprocessed,\n                            min_height,\n                        ),\n                        width: air.width(),\n                        _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                    },\n                    matrix,\n                )\n            }\n            Poseidon2Config::KoalaBearD4Width24 =\u003e {\n                let constants = Self::koala_bear_constants_24();\n                let preprocessed =\n                    extract_preprocessed_from_operations::\u003cKoalaBear, Val\u003cSC\u003e\u003e(\u0026t.operations);\n                let air = Poseidon2CircuitAirKoalaBearD4Width24::new_with_preprocessed(\n                    constants.clone(),\n                    preprocessed.clone(),\n                )\n                .with_min_height(min_height);\n                let ops_koalabear: Vec\u003cPoseidon2CircuitRow\u003cKoalaBear\u003e\u003e =\n                    unsafe { transmute(padded_ops.clone()) };\n                let matrix_f = air.generate_trace_rows(\u0026ops_koalabear, \u0026constants, 0);\n                let matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e = unsafe { transmute(matrix_f) };\n                (\n                    Poseidon2AirWrapper {\n                        inner: Self::air_wrapper_for_config_with_preprocessed(\n                            self.config,\n                            preprocessed,\n                            min_height,\n                        ),\n                        width: air.width(),\n                        _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                    },\n                    matrix,\n                )\n            }\n        };\n\n        Some(BatchTableInstance {\n            op_type: NonPrimitiveOpType::Poseidon2Perm(self.config),\n            air: DynamicAirEntry::new(Box::new(air)),\n            trace: matrix,\n            public_values: Vec::new(),\n            rows: padded_rows,\n        })\n    }\n}\n\nimpl\u003cSC\u003e TableProver\u003cSC\u003e for Poseidon2Prover\nwhere\n    SC: StarkGenericConfig + 'static + Send + Sync,\n    Val\u003cSC\u003e: StarkField + BinomiallyExtendable\u003c4\u003e,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    fn op_type(\u0026self) -\u003e NonPrimitiveOpType {\n        NonPrimitiveOpType::Poseidon2Perm(self.config)\n    }\n\n    fn batch_instance_d1(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cVal\u003cSC\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n        self.batch_instance_from_traces::\u003cSC, Val\u003cSC\u003e\u003e(config, packing, traces)\n    }\n\n    fn batch_instance_d2(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 2\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n        let _ = (config, packing, traces);\n        None\n    }\n\n    fn batch_instance_d4(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 4\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n        self.batch_instance_from_traces::\u003cSC, BinomialExtensionField\u003cVal\u003cSC\u003e, 4\u003e\u003e(\n            config, packing, traces,\n        )\n    }\n\n    fn batch_instance_d6(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 6\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n        let _ = (config, packing, traces);\n        None\n    }\n\n    fn batch_instance_d8(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 8\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n        let _ = (config, packing, traces);\n        None\n    }\n\n    fn batch_air_from_table_entry(\n        \u0026self,\n        _config: \u0026SC,\n        _degree: usize,\n        _table_entry: \u0026NonPrimitiveTableEntry\u003cSC\u003e,\n    ) -\u003e Result\u003cDynamicAirEntry\u003cSC\u003e, String\u003e {\n        let inner = Self::air_wrapper_for_config(self.config);\n        let width = inner.width();\n        let wrapper = Poseidon2AirWrapper {\n            inner,\n            width,\n            _phantom: core::marker::PhantomData::\u003cSC\u003e,\n        };\n        Ok(DynamicAirEntry::new(Box::new(wrapper)))\n    }\n}\n","traces":[{"line":54,"address":[8667136],"length":1,"stats":{"Line":2}},{"line":55,"address":[8667150],"length":1,"stats":{"Line":2}},{"line":56,"address":[6931282,6931462],"length":1,"stats":{"Line":5}},{"line":57,"address":[6544844,6544623],"length":1,"stats":{"Line":0}},{"line":58,"address":[4182296,4182044],"length":1,"stats":{"Line":0}},{"line":59,"address":[11363527,11363241],"length":1,"stats":{"Line":0}},{"line":65,"address":[4633856],"length":1,"stats":{"Line":0}},{"line":66,"address":[11350141],"length":1,"stats":{"Line":0}},{"line":67,"address":[4633904],"length":1,"stats":{"Line":0}},{"line":68,"address":[2123363],"length":1,"stats":{"Line":0}},{"line":69,"address":[11350246],"length":1,"stats":{"Line":0}},{"line":70,"address":[11350281],"length":1,"stats":{"Line":0}},{"line":90,"address":[5434144],"length":1,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[5434200],"length":1,"stats":{"Line":0}},{"line":104,"address":[4509360],"length":1,"stats":{"Line":2}},{"line":105,"address":[4509365],"length":1,"stats":{"Line":2}},{"line":108,"address":[4507568],"length":1,"stats":{"Line":2}},{"line":109,"address":[9050878,9054462,9052670],"length":1,"stats":{"Line":2}},{"line":110,"address":[9052706,9054498,9050914],"length":1,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[4508116],"length":1,"stats":{"Line":2}},{"line":113,"address":[5488991],"length":1,"stats":{"Line":2}},{"line":114,"address":[4508255],"length":1,"stats":{"Line":2}},{"line":117,"address":[4507732],"length":1,"stats":{"Line":0}},{"line":118,"address":[6382971,6382341],"length":1,"stats":{"Line":0}},{"line":119,"address":[6383018],"length":1,"stats":{"Line":0}},{"line":120,"address":[4508653],"length":1,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[6383344],"length":1,"stats":{"Line":0}},{"line":127,"address":[5489651],"length":1,"stats":{"Line":0}},{"line":128,"address":[4508915],"length":1,"stats":{"Line":0}},{"line":131,"address":[4507964],"length":1,"stats":{"Line":0}},{"line":132,"address":[6383623,6382573],"length":1,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[6391216],"length":1,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[6391279],"length":1,"stats":{"Line":2}},{"line":150,"address":[5555752,5555389],"length":1,"stats":{"Line":2}},{"line":152,"address":[5555798],"length":1,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[5555806],"length":1,"stats":{"Line":2}},{"line":157,"address":[5555464],"length":1,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[6391790],"length":1,"stats":{"Line":0}},{"line":165,"address":[5555562],"length":1,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[9149952,9149196,9148416],"length":1,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[9148424,9149204,9149960],"length":1,"stats":{"Line":0}},{"line":173,"address":[4576204],"length":1,"stats":{"Line":0}},{"line":174,"address":[4576220,4576527],"length":1,"stats":{"Line":0}},{"line":176,"address":[6391932],"length":1,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[9148500,9149280,9150036],"length":1,"stats":{"Line":0}},{"line":184,"address":[9147328,9147104,9147552],"length":1,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[4575690],"length":1,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[6391088],"length":1,"stats":{"Line":0}},{"line":193,"address":[4575737],"length":1,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[4575766],"length":1,"stats":{"Line":0}},{"line":199,"address":[9147471,9147695,9147247],"length":1,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[9147724,9147276,9147500],"length":1,"stats":{"Line":0}},{"line":205,"address":[4575813],"length":1,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[9145216,9144240,9146160],"length":1,"stats":{"Line":3}},{"line":217,"address":[4574718],"length":1,"stats":{"Line":3}},{"line":219,"address":[5554632,5554227],"length":1,"stats":{"Line":3}},{"line":220,"address":[4575217],"length":1,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[6390608],"length":1,"stats":{"Line":2}},{"line":227,"address":[4575287,4574869],"length":1,"stats":{"Line":0}},{"line":228,"address":[5554784],"length":1,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[9146439,9146859,9144961,9144527,9145915,9145495],"length":1,"stats":{"Line":0}},{"line":236,"address":[4575434],"length":1,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[9145042,9145996,9146940],"length":1,"stats":{"Line":0}},{"line":243,"address":[6390442,6390868],"length":1,"stats":{"Line":0}},{"line":244,"address":[9146082,9145128,9147026],"length":1,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[6372271],"length":1,"stats":{"Line":0}},{"line":274,"address":[4446312,4445949],"length":1,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[6372360],"length":1,"stats":{"Line":0}},{"line":282,"address":[6372377,6372728],"length":1,"stats":{"Line":0}},{"line":284,"address":[5483574],"length":1,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[5483582],"length":1,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[5483602,5483275],"length":1,"stats":{"Line":0}},{"line":292,"address":[6372848],"length":1,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[5483656],"length":1,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[6372879,6372572],"length":1,"stats":{"Line":0}},{"line":300,"address":[4446588],"length":1,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[8732208],"length":1,"stats":{"Line":0}},{"line":380,"address":[7117784],"length":1,"stats":{"Line":0}},{"line":385,"address":[4437680,4438096,4436848,4434352,4435600,4437264,4433520,4435184,4436432,4436016,4433936,4434768],"length":1,"stats":{"Line":7}},{"line":424,"address":[9034171,9025435,9027931,9029179,9030843,9033755,9025019,9033339,9022939,9027515,9035835,9031259,9035003,9034587,9024603,9028763,9022523,9023771,9028347,9023355,9022107,9030427,9032091,9029595,9036251,9027099,9032507,9031675,9032923,9026683,9036667,9025851,9030011,9026267,9035419,9024187],"length":1,"stats":{"Line":7}},{"line":425,"address":[],"length":0,"stats":{"Line":7}},{"line":426,"address":[],"length":0,"stats":{"Line":7}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":6}},{"line":439,"address":[5481571,5479907,5481155,5479075,5481987,5480739,5479491,5480323,5482403,5478659,5478243,5482819],"length":1,"stats":{"Line":6}},{"line":440,"address":[9023493,9029319,9032229,9027653,9027237,9025575,9025989,9028903,9030567,9032645,9023911,9035141,9025157,9036805,9026407,9031813,9031397,9022661,9028485,9033477,9035559,9029733,9030149,9028069,9024741,9023077,9035973,9036389,9034725,9026821,9033061,9022245,9030981,9033895,9034309,9024325],"length":1,"stats":{"Line":6}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":6}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":6}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[4435964,4436380,4437212,4435132,4436796,4435548,4438460,4437628,4434300,4434716,4433884,4438044],"length":1,"stats":{"Line":6}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[5482132,5482548,5482964,5480052,5480468,5478804,5479636,5481300,5478388,5479220,5480884,5481716],"length":1,"stats":{"Line":6}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":6}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[9041072,9043120,9042096],"length":1,"stats":{"Line":3}},{"line":686,"address":[5484983],"length":1,"stats":{"Line":2}},{"line":687,"address":[5485000],"length":1,"stats":{"Line":2}},{"line":688,"address":[5485072],"length":1,"stats":{"Line":2}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[5485275],"length":1,"stats":{"Line":2}},{"line":713,"address":[9043524,9041476,9042500],"length":1,"stats":{"Line":2}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":2}},{"line":716,"address":[4458094],"length":1,"stats":{"Line":2}},{"line":717,"address":[],"length":0,"stats":{"Line":2}},{"line":736,"address":[9042677,9043701,9041653],"length":1,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[5485519],"length":1,"stats":{"Line":0}},{"line":739,"address":[6375785],"length":1,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[9042836,9043860,9041812],"length":1,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[5485701],"length":1,"stats":{"Line":0}},{"line":763,"address":[6375964],"length":1,"stats":{"Line":0}},{"line":782,"address":[9041959,9042983,9044007],"length":1,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[9041969,9044017,9042993],"length":1,"stats":{"Line":0}},{"line":785,"address":[6376088],"length":1,"stats":{"Line":0}},{"line":786,"address":[9043039,9044063,9042015],"length":1,"stats":{"Line":0}},{"line":792,"address":[5484704],"length":1,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[9040906,9040682,9040458],"length":1,"stats":{"Line":0}},{"line":795,"address":[4457491],"length":1,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[9040944,9040720,9040496],"length":1,"stats":{"Line":0}},{"line":801,"address":[6375049],"length":1,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[5484838],"length":1,"stats":{"Line":0}},{"line":807,"address":[4457567],"length":1,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[6375116],"length":1,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[5483760],"length":1,"stats":{"Line":0}},{"line":825,"address":[5483790],"length":1,"stats":{"Line":0}},{"line":827,"address":[6374488,6374083],"length":1,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[5484320],"length":1,"stats":{"Line":0}},{"line":835,"address":[9040055,9038151,9039111,9038693,9037721,9039637],"length":1,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[6374279,6374699],"length":1,"stats":{"Line":0}},{"line":844,"address":[4457226],"length":1,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[6374780],"length":1,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[5484626],"length":1,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[6374900],"length":1,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":3}},{"line":981,"address":[6377415],"length":1,"stats":{"Line":3}},{"line":982,"address":[5487208],"length":1,"stats":{"Line":2}},{"line":983,"address":[4460010],"length":1,"stats":{"Line":2}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[5487497],"length":1,"stats":{"Line":2}},{"line":1008,"address":[9048114,9050226,9049170],"length":1,"stats":{"Line":2}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[6377807],"length":1,"stats":{"Line":2}},{"line":1011,"address":[4460316],"length":1,"stats":{"Line":2}},{"line":1012,"address":[6377865],"length":1,"stats":{"Line":2}},{"line":1031,"address":[9048291,9049347,9050403],"length":1,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[5487741],"length":1,"stats":{"Line":0}},{"line":1034,"address":[9048327,9049383,9050439],"length":1,"stats":{"Line":0}},{"line":1035,"address":[9050465,9048353,9049409],"length":1,"stats":{"Line":0}},{"line":1054,"address":[5487890],"length":1,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[5487900],"length":1,"stats":{"Line":0}},{"line":1057,"address":[9048483,9049539,9050595],"length":1,"stats":{"Line":0}},{"line":1058,"address":[9049562,9048506,9050618],"length":1,"stats":{"Line":0}},{"line":1077,"address":[6378277],"length":1,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[4460767],"length":1,"stats":{"Line":0}},{"line":1080,"address":[4460790],"length":1,"stats":{"Line":0}},{"line":1081,"address":[9049709,9048653,9050765],"length":1,"stats":{"Line":0}},{"line":1087,"address":[4459616],"length":1,"stats":{"Line":0}},{"line":1088,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[6377194],"length":1,"stats":{"Line":0}},{"line":1090,"address":[4459683],"length":1,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1095,"address":[],"length":0,"stats":{"Line":0}},{"line":1096,"address":[5487001],"length":1,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":0}},{"line":1101,"address":[4459750],"length":1,"stats":{"Line":0}},{"line":1102,"address":[4459759],"length":1,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1107,"address":[6377308],"length":1,"stats":{"Line":0}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1111,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[9045088,9046064,9044144],"length":1,"stats":{"Line":0}},{"line":1120,"address":[5485982],"length":1,"stats":{"Line":0}},{"line":1122,"address":[6376275,6376680],"length":1,"stats":{"Line":0}},{"line":1123,"address":[6376721],"length":1,"stats":{"Line":0}},{"line":1126,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[4459232],"length":1,"stats":{"Line":0}},{"line":1130,"address":[5486133,5486551],"length":1,"stats":{"Line":0}},{"line":1131,"address":[5486592],"length":1,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1135,"address":[4459343],"length":1,"stats":{"Line":0}},{"line":1138,"address":[9045809,9046343,9046763,9045375,9044423,9044843],"length":1,"stats":{"Line":0}},{"line":1139,"address":[5486698],"length":1,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[4459452],"length":1,"stats":{"Line":0}},{"line":1146,"address":[],"length":0,"stats":{"Line":0}},{"line":1147,"address":[6377058],"length":1,"stats":{"Line":0}},{"line":1150,"address":[],"length":0,"stats":{"Line":0}},{"line":1151,"address":[5486852],"length":1,"stats":{"Line":0}},{"line":1164,"address":[6403280],"length":1,"stats":{"Line":3}},{"line":1165,"address":[6403335],"length":1,"stats":{"Line":3}},{"line":1166,"address":[5560456],"length":1,"stats":{"Line":3}},{"line":1167,"address":[4578106],"length":1,"stats":{"Line":3}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1175,"address":[5560745],"length":1,"stats":{"Line":3}},{"line":1192,"address":[9155090,9156146,9154034],"length":1,"stats":{"Line":3}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[4578383],"length":1,"stats":{"Line":3}},{"line":1195,"address":[4578412],"length":1,"stats":{"Line":3}},{"line":1196,"address":[],"length":0,"stats":{"Line":3}},{"line":1215,"address":[6403891],"length":1,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[6403901],"length":1,"stats":{"Line":0}},{"line":1218,"address":[9155303,9156359,9154247],"length":1,"stats":{"Line":0}},{"line":1219,"address":[6403953],"length":1,"stats":{"Line":0}},{"line":1238,"address":[6404050],"length":1,"stats":{"Line":0}},{"line":1239,"address":[],"length":0,"stats":{"Line":0}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[9155459,9156515,9154403],"length":1,"stats":{"Line":0}},{"line":1242,"address":[9154426,9156538,9155482],"length":1,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1263,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[9154550,9155606,9156662],"length":1,"stats":{"Line":0}},{"line":1265,"address":[],"length":0,"stats":{"Line":0}},{"line":1271,"address":[4577712],"length":1,"stats":{"Line":0}},{"line":1272,"address":[4577735],"length":1,"stats":{"Line":0}},{"line":1273,"address":[6403114],"length":1,"stats":{"Line":0}},{"line":1274,"address":[9153443,9152995,9153219],"length":1,"stats":{"Line":0}},{"line":1281,"address":[],"length":0,"stats":{"Line":0}},{"line":1283,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[9153481,9153033,9153257],"length":1,"stats":{"Line":0}},{"line":1291,"address":[],"length":0,"stats":{"Line":0}},{"line":1293,"address":[9153286,9153510,9153062],"length":1,"stats":{"Line":0}},{"line":1294,"address":[4577855],"length":1,"stats":{"Line":0}},{"line":1301,"address":[],"length":0,"stats":{"Line":0}},{"line":1303,"address":[5560316],"length":1,"stats":{"Line":0}},{"line":1304,"address":[5560325],"length":1,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1317,"address":[5559200],"length":1,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1324,"address":[6402195,6402600],"length":1,"stats":{"Line":0}},{"line":1325,"address":[5559729],"length":1,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1329,"address":[],"length":0,"stats":{"Line":0}},{"line":1333,"address":[6402711,6402293],"length":1,"stats":{"Line":0}},{"line":1334,"address":[6402752],"length":1,"stats":{"Line":0}},{"line":1337,"address":[],"length":0,"stats":{"Line":0}},{"line":1338,"address":[6402783],"length":1,"stats":{"Line":0}},{"line":1342,"address":[4577467,4577047],"length":1,"stats":{"Line":0}},{"line":1343,"address":[6402858],"length":1,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[4577548],"length":1,"stats":{"Line":0}},{"line":1351,"address":[5560020,5559594],"length":1,"stats":{"Line":0}},{"line":1352,"address":[],"length":0,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1356,"address":[],"length":0,"stats":{"Line":0}},{"line":1373,"address":[6931200],"length":1,"stats":{"Line":3}},{"line":1380,"address":[2342880],"length":1,"stats":{"Line":3}},{"line":1381,"address":[6930256],"length":1,"stats":{"Line":3}},{"line":1382,"address":[2135257],"length":1,"stats":{"Line":2}},{"line":1383,"address":[8730722],"length":1,"stats":{"Line":2}},{"line":1384,"address":[2342971],"length":1,"stats":{"Line":2}},{"line":1387,"address":[11362272],"length":1,"stats":{"Line":0}},{"line":1388,"address":[4181136],"length":1,"stats":{"Line":0}},{"line":1389,"address":[4181161],"length":1,"stats":{"Line":0}},{"line":1390,"address":[2343154],"length":1,"stats":{"Line":0}},{"line":1391,"address":[6543835],"length":1,"stats":{"Line":0}},{"line":1394,"address":[6930656],"length":1,"stats":{"Line":0}},{"line":1395,"address":[2135649],"length":1,"stats":{"Line":0}},{"line":1396,"address":[8666602],"length":1,"stats":{"Line":0}},{"line":1397,"address":[8731139],"length":1,"stats":{"Line":0}},{"line":1398,"address":[11362572],"length":1,"stats":{"Line":0}},{"line":1401,"address":[3729648],"length":1,"stats":{"Line":0}},{"line":1402,"address":[8666800],"length":1,"stats":{"Line":0}},{"line":1403,"address":[11362745],"length":1,"stats":{"Line":0}},{"line":1404,"address":[2135922],"length":1,"stats":{"Line":0}},{"line":1405,"address":[6544267],"length":1,"stats":{"Line":0}},{"line":1408,"address":[11361280],"length":1,"stats":{"Line":2}},{"line":1409,"address":[8665392],"length":1,"stats":{"Line":2}},{"line":1411,"address":[9015964],"length":1,"stats":{"Line":2}},{"line":1412,"address":[11361343],"length":1,"stats":{"Line":2}},{"line":1416,"address":[4180515],"length":1,"stats":{"Line":0}},{"line":1417,"address":[8665590],"length":1,"stats":{"Line":0}},{"line":1421,"address":[4645571],"length":1,"stats":{"Line":0}},{"line":1422,"address":[2342502],"length":1,"stats":{"Line":0}},{"line":1426,"address":[3728960],"length":1,"stats":{"Line":0}},{"line":1427,"address":[7116022],"length":1,"stats":{"Line":0}},{"line":1433,"address":[6355680,6357062,6354256,6355638,6355667,6357091],"length":1,"stats":{"Line":3}},{"line":1438,"address":[6355745,6354321],"length":1,"stats":{"Line":3}},{"line":1439,"address":[],"length":0,"stats":{"Line":0}},{"line":1440,"address":[9020709,9020822,9017995,9019430,9017856,9019317],"length":1,"stats":{"Line":6}},{"line":1441,"address":[9019667,9018238,9021059],"length":1,"stats":{"Line":2}},{"line":1442,"address":[],"length":0,"stats":{"Line":2}},{"line":1443,"address":[],"length":0,"stats":{"Line":3}},{"line":1444,"address":[4432437,4431013],"length":1,"stats":{"Line":2}},{"line":1446,"address":[9018223,9021044,9019652],"length":1,"stats":{"Line":3}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1450,"address":[6354389,6356208,6354784,6355813],"length":1,"stats":{"Line":0}},{"line":1451,"address":[6355018,6356442],"length":1,"stats":{"Line":0}},{"line":1452,"address":[5477319],"length":1,"stats":{"Line":0}},{"line":1453,"address":[5477208],"length":1,"stats":{"Line":0}},{"line":1454,"address":[],"length":0,"stats":{"Line":0}},{"line":1456,"address":[4431427,4432851],"length":1,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1460,"address":[4430824,4431486,4432910,4432248],"length":1,"stats":{"Line":0}},{"line":1461,"address":[9020236,9021628,9018830],"length":1,"stats":{"Line":0}},{"line":1462,"address":[6355269,6356693],"length":1,"stats":{"Line":0}},{"line":1463,"address":[5477494],"length":1,"stats":{"Line":0}},{"line":1464,"address":[4431598,4433022],"length":1,"stats":{"Line":0}},{"line":1466,"address":[],"length":0,"stats":{"Line":0}},{"line":1469,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[9017925,9019371,9020276,9020763,9021668,9018874],"length":1,"stats":{"Line":0}},{"line":1471,"address":[4432006,4433430],"length":1,"stats":{"Line":0}},{"line":1472,"address":[5477891],"length":1,"stats":{"Line":0}},{"line":1473,"address":[6355444,6356868],"length":1,"stats":{"Line":0}},{"line":1474,"address":[9021776,9018988,9020384],"length":1,"stats":{"Line":0}},{"line":1476,"address":[6355583,6357007],"length":1,"stats":{"Line":0}},{"line":1482,"address":[5476400,5476572],"length":1,"stats":{"Line":3}},{"line":1492,"address":[9017245,9017629,9017437],"length":1,"stats":{"Line":3}},{"line":1493,"address":[9017539,9017347,9017155],"length":1,"stats":{"Line":2}},{"line":1494,"address":[],"length":0,"stats":{"Line":0}},{"line":1495,"address":[],"length":0,"stats":{"Line":0}},{"line":1496,"address":[],"length":0,"stats":{"Line":0}},{"line":1498,"address":[6354019],"length":1,"stats":{"Line":2}},{"line":1499,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[6929226,6929220,6928800],"length":1,"stats":{"Line":2}},{"line":1504,"address":[2133806],"length":1,"stats":{"Line":2}},{"line":1506,"address":[9015585,9015354],"length":1,"stats":{"Line":2}},{"line":1509,"address":[3728007,3727699],"length":1,"stats":{"Line":0}},{"line":1512,"address":[6542602,6542300],"length":1,"stats":{"Line":0}},{"line":1515,"address":[3727845,3728144],"length":1,"stats":{"Line":0}},{"line":1520,"address":[7117072],"length":1,"stats":{"Line":3}},{"line":1521,"address":[2136073],"length":1,"stats":{"Line":3}},{"line":1523,"address":[8731542],"length":1,"stats":{"Line":3}},{"line":1526,"address":[3729907],"length":1,"stats":{"Line":0}},{"line":1529,"address":[4181824],"length":1,"stats":{"Line":0}},{"line":1532,"address":[9017114],"length":1,"stats":{"Line":0}},{"line":1537,"address":[4429680,4430080],"length":1,"stats":{"Line":2}},{"line":1549,"address":[6353207,6353607],"length":1,"stats":{"Line":2}},{"line":1550,"address":[],"length":0,"stats":{"Line":0}},{"line":1553,"address":[6353286,6353686],"length":1,"stats":{"Line":2}},{"line":1554,"address":[6353696,6353296],"length":1,"stats":{"Line":2}},{"line":1555,"address":[6353805,6353405],"length":1,"stats":{"Line":0}},{"line":1558,"address":[6353707,6353307],"length":1,"stats":{"Line":2}},{"line":1559,"address":[6353371,6353771],"length":1,"stats":{"Line":2}},{"line":1560,"address":[],"length":0,"stats":{"Line":0}},{"line":1561,"address":[6353442,6353842],"length":1,"stats":{"Line":2}},{"line":1563,"address":[],"length":0,"stats":{"Line":0}},{"line":1564,"address":[4429997,4430397],"length":1,"stats":{"Line":0}},{"line":1566,"address":[],"length":0,"stats":{"Line":0}},{"line":1567,"address":[4430424,4430024],"length":1,"stats":{"Line":0}},{"line":1569,"address":[],"length":0,"stats":{"Line":0}},{"line":1570,"address":[6353923,6353523],"length":1,"stats":{"Line":0}},{"line":1575,"address":[6342176,6337123,6343837,6338797,6333757,6332096,6337136,6342163,6347216,6348877,6352243,6347203],"length":1,"stats":{"Line":2}},{"line":1591,"address":[],"length":0,"stats":{"Line":2}},{"line":1593,"address":[],"length":0,"stats":{"Line":2}},{"line":1594,"address":[4414364,4424124,4409484,4419244],"length":1,"stats":{"Line":2}},{"line":1595,"address":[],"length":0,"stats":{"Line":4}},{"line":1596,"address":[4428756,4414116,4423876,4418996],"length":1,"stats":{"Line":1}},{"line":1597,"address":[6337504,6347584,6342544,6332464],"length":1,"stats":{"Line":1}},{"line":1598,"address":[6352153,6342073,6347113,6337033],"length":1,"stats":{"Line":1}},{"line":1599,"address":[4428703,4423823,4414063,4418943],"length":1,"stats":{"Line":1}},{"line":1600,"address":[4428710,4429008,4423830,4429232,4429565,4429117,4429456,4414070,4428784,4428893,4429341,4418950],"length":1,"stats":{"Line":1}},{"line":1601,"address":[],"length":0,"stats":{"Line":0}},{"line":1602,"address":[],"length":0,"stats":{"Line":0}},{"line":1603,"address":[],"length":0,"stats":{"Line":0}},{"line":1604,"address":[],"length":0,"stats":{"Line":0}},{"line":1605,"address":[4429022,4428798,4429246,4429470],"length":1,"stats":{"Line":0}},{"line":1606,"address":[4428815,4429039,4429263,4429487],"length":1,"stats":{"Line":0}},{"line":1607,"address":[],"length":0,"stats":{"Line":0}},{"line":1608,"address":[],"length":0,"stats":{"Line":0}},{"line":1609,"address":[4429538,4428866,4429090,4429314],"length":1,"stats":{"Line":0}},{"line":1610,"address":[],"length":0,"stats":{"Line":0}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1616,"address":[],"length":0,"stats":{"Line":4}},{"line":1617,"address":[],"length":0,"stats":{"Line":0}},{"line":1618,"address":[],"length":0,"stats":{"Line":2}},{"line":1619,"address":[4424393,4414633,4419513,4409753],"length":1,"stats":{"Line":2}},{"line":1620,"address":[],"length":0,"stats":{"Line":0}},{"line":1622,"address":[],"length":0,"stats":{"Line":2}},{"line":1623,"address":[6337755,6342795,6347835,6332715],"length":1,"stats":{"Line":2}},{"line":1625,"address":[4419725,4424605,4414845,4409965],"length":1,"stats":{"Line":2}},{"line":1626,"address":[],"length":0,"stats":{"Line":4}},{"line":1627,"address":[],"length":0,"stats":{"Line":0}},{"line":1628,"address":[4424824,4419839,4419944,4410079,4415064,4414959,4424719,4410184],"length":1,"stats":{"Line":4}},{"line":1629,"address":[],"length":0,"stats":{"Line":2}},{"line":1631,"address":[],"length":0,"stats":{"Line":2}},{"line":1632,"address":[4420050,4420129,4410239,4424879,4424930,4415170,4415119,4419999,4410369,4415249,4425009,4410290],"length":1,"stats":{"Line":6}},{"line":1633,"address":[],"length":0,"stats":{"Line":0}},{"line":1634,"address":[4424882,4420002,4415122,4410242],"length":1,"stats":{"Line":2}},{"line":1635,"address":[],"length":0,"stats":{"Line":0}},{"line":1637,"address":[],"length":0,"stats":{"Line":2}},{"line":1638,"address":[],"length":0,"stats":{"Line":0}},{"line":1640,"address":[6338373,6348453,6343413,6333333],"length":1,"stats":{"Line":2}},{"line":1643,"address":[],"length":0,"stats":{"Line":0}},{"line":1644,"address":[4419439,4409679,4414559,4424319],"length":1,"stats":{"Line":0}},{"line":1645,"address":[],"length":0,"stats":{"Line":0}},{"line":1646,"address":[],"length":0,"stats":{"Line":0}},{"line":1648,"address":[],"length":0,"stats":{"Line":0}},{"line":1649,"address":[4425608,4415848,4410968,4420728],"length":1,"stats":{"Line":0}},{"line":1651,"address":[4420810,4411050,4415930,4425690],"length":1,"stats":{"Line":0}},{"line":1652,"address":[6349199,6344108,6339119,6334028,6344159,6349148,6334079,6339068],"length":1,"stats":{"Line":0}},{"line":1653,"address":[],"length":0,"stats":{"Line":0}},{"line":1654,"address":[4411164,4421029,4411269,4425909,4416044,4425804,4420924,4416149],"length":1,"stats":{"Line":0}},{"line":1655,"address":[6349367,6339287,6344327,6334247],"length":1,"stats":{"Line":0}},{"line":1657,"address":[6339541,6334501,6344581,6349621],"length":1,"stats":{"Line":0}},{"line":1658,"address":[4425964,4411454,4426015,4411324,4416204,4421214,4416255,4426094,4416334,4421084,4421135,4411375],"length":1,"stats":{"Line":0}},{"line":1659,"address":[],"length":0,"stats":{"Line":0}},{"line":1660,"address":[4425967,4421087,4416207,4411327],"length":1,"stats":{"Line":0}},{"line":1661,"address":[],"length":0,"stats":{"Line":0}},{"line":1663,"address":[6339465,6349545,6334425,6344505],"length":1,"stats":{"Line":0}},{"line":1664,"address":[],"length":0,"stats":{"Line":0}},{"line":1666,"address":[4411586,4426226,4416466,4421346],"length":1,"stats":{"Line":0}},{"line":1669,"address":[],"length":0,"stats":{"Line":0}},{"line":1670,"address":[4409701,4414581,4419461,4424341],"length":1,"stats":{"Line":0}},{"line":1671,"address":[],"length":0,"stats":{"Line":0}},{"line":1672,"address":[],"length":0,"stats":{"Line":0}},{"line":1674,"address":[4421575,4411815,4426455,4416695],"length":1,"stats":{"Line":0}},{"line":1675,"address":[],"length":0,"stats":{"Line":0}},{"line":1677,"address":[4416845,4421725,4426605,4411965],"length":1,"stats":{"Line":0}},{"line":1678,"address":[],"length":0,"stats":{"Line":0}},{"line":1679,"address":[],"length":0,"stats":{"Line":0}},{"line":1680,"address":[4412079,4421839,4426719,4412172,4417052,4426812,4416959,4421932],"length":1,"stats":{"Line":0}},{"line":1681,"address":[4412195,4417075,4421955,4426835],"length":1,"stats":{"Line":0}},{"line":1683,"address":[4412431,4427071,4417311,4422191],"length":1,"stats":{"Line":0}},{"line":1684,"address":[],"length":0,"stats":{"Line":0}},{"line":1685,"address":[],"length":0,"stats":{"Line":0}},{"line":1686,"address":[],"length":0,"stats":{"Line":0}},{"line":1687,"address":[],"length":0,"stats":{"Line":0}},{"line":1689,"address":[6345402,6350442,6335322,6340362],"length":1,"stats":{"Line":0}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1692,"address":[],"length":0,"stats":{"Line":0}},{"line":1695,"address":[],"length":0,"stats":{"Line":0}},{"line":1696,"address":[],"length":0,"stats":{"Line":0}},{"line":1697,"address":[6335605,6345685,6350725,6340645],"length":1,"stats":{"Line":0}},{"line":1698,"address":[],"length":0,"stats":{"Line":0}},{"line":1700,"address":[6340695,6335655,6345735,6350775],"length":1,"stats":{"Line":0}},{"line":1701,"address":[6350843,6345803,6340763,6335723],"length":1,"stats":{"Line":0}},{"line":1703,"address":[6340845,6335805,6345885,6350925],"length":1,"stats":{"Line":0}},{"line":1704,"address":[6335879,6340919,6345959,6335828,6345908,6350948,6350999,6340868],"length":1,"stats":{"Line":0}},{"line":1705,"address":[],"length":0,"stats":{"Line":0}},{"line":1706,"address":[4422811,4417838,4413051,4417931,4427598,4412958,4422718,4427691],"length":1,"stats":{"Line":0}},{"line":1707,"address":[],"length":0,"stats":{"Line":0}},{"line":1709,"address":[4418190,4423070,4413310,4427950],"length":1,"stats":{"Line":0}},{"line":1710,"address":[4427746,4422917,4422984,4427797,4417986,4422866,4413106,4413224,4413157,4418104,4427864,4418037],"length":1,"stats":{"Line":0}},{"line":1711,"address":[],"length":0,"stats":{"Line":0}},{"line":1712,"address":[6346150,6336070,6341110,6351190],"length":1,"stats":{"Line":0}},{"line":1713,"address":[],"length":0,"stats":{"Line":0}},{"line":1715,"address":[6336201,6351321,6346281,6341241],"length":1,"stats":{"Line":0}},{"line":1716,"address":[],"length":0,"stats":{"Line":0}},{"line":1718,"address":[4418230,4423110,4427990,4413350],"length":1,"stats":{"Line":0}},{"line":1723,"address":[6346787,6351827,6336707,6341747],"length":1,"stats":{"Line":2}},{"line":1724,"address":[6343639,6338599,6348679,6333559],"length":1,"stats":{"Line":2}},{"line":1725,"address":[],"length":0,"stats":{"Line":4}},{"line":1726,"address":[],"length":0,"stats":{"Line":2}},{"line":1727,"address":[],"length":0,"stats":{"Line":2}},{"line":1728,"address":[],"length":0,"stats":{"Line":0}},{"line":1739,"address":[4406352],"length":1,"stats":{"Line":2}},{"line":1740,"address":[6332085],"length":1,"stats":{"Line":2}},{"line":1743,"address":[6331312],"length":1,"stats":{"Line":0}},{"line":1749,"address":[6331339],"length":1,"stats":{"Line":0}},{"line":1752,"address":[4405808],"length":1,"stats":{"Line":0}},{"line":1758,"address":[],"length":0,"stats":{"Line":0}},{"line":1759,"address":[6331426],"length":1,"stats":{"Line":0}},{"line":1762,"address":[6331440],"length":1,"stats":{"Line":2}},{"line":1768,"address":[4405867],"length":1,"stats":{"Line":2}},{"line":1769,"address":[],"length":0,"stats":{"Line":0}},{"line":1773,"address":[4405936],"length":1,"stats":{"Line":0}},{"line":1779,"address":[],"length":0,"stats":{"Line":0}},{"line":1780,"address":[6331554],"length":1,"stats":{"Line":0}},{"line":1783,"address":[6331568],"length":1,"stats":{"Line":0}},{"line":1789,"address":[],"length":0,"stats":{"Line":0}},{"line":1790,"address":[6331586],"length":1,"stats":{"Line":0}},{"line":1793,"address":[6331600,6332070,6332041],"length":1,"stats":{"Line":3}},{"line":1799,"address":[],"length":0,"stats":{"Line":2}},{"line":1800,"address":[],"length":0,"stats":{"Line":5}},{"line":1806,"address":[],"length":0,"stats":{"Line":4}}],"covered":134,"coverable":694},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","batch_stark_prover","tests.rs"],"content":"use p3_baby_bear::BabyBear;\nuse p3_circuit::builder::CircuitBuilder;\nuse p3_field::PrimeCharacteristicRing;\nuse p3_goldilocks::Goldilocks;\nuse p3_koala_bear::KoalaBear;\n\nuse super::*;\nuse crate::ConstraintProfile;\nuse crate::batch_stark_prover::{BABY_BEAR_MODULUS, KOALA_BEAR_MODULUS};\nuse crate::common::get_airs_and_degrees_with_prep;\nuse crate::config::{self, BabyBearConfig, GoldilocksConfig, KoalaBearConfig};\n\n#[test]\nfn test_babybear_batch_stark_base_field() {\n    let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n    // x + 5*2 - 3 + (-1) == expected\n    let x = builder.public_input();\n    let expected = builder.public_input();\n    let c5 = builder.define_const(BabyBear::from_u64(5));\n    let c2 = builder.define_const(BabyBear::from_u64(2));\n    let c3 = builder.define_const(BabyBear::from_u64(3));\n    let neg_one = builder.define_const(BabyBear::NEG_ONE);\n\n    let mul_result = builder.mul(c5, c2); // 10\n    let add_result = builder.add(x, mul_result); // x + 10\n    let sub_result = builder.sub(add_result, c3); // x + 7\n    let final_result = builder.add(sub_result, neg_one); // x + 6\n\n    let diff = builder.sub(final_result, expected);\n    builder.assert_zero(diff);\n\n    let circuit = builder.build().unwrap();\n    let cfg = config::baby_bear().build();\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cBabyBearConfig, _, 1\u003e(\n            \u0026circuit,\n            TablePacking::default(),\n            None,\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n    let (mut airs, log_degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let prover_data = ProverData::from_airs_and_degrees(\u0026cfg, \u0026mut airs, \u0026log_degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    let mut runner = circuit.runner();\n\n    let x_val = BabyBear::from_u64(7);\n    let expected_val = BabyBear::from_u64(13); // 7 + 10 - 3 - 1 = 13\n    runner.set_public_inputs(\u0026[x_val, expected_val]).unwrap();\n    let traces = runner.run().unwrap();\n\n    let prover = BatchStarkProver::new(cfg);\n\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n    assert_eq!(proof.ext_degree, 1);\n    assert!(proof.w_binomial.is_none());\n\n    assert!(\n        prover\n            .verify_all_tables(\u0026proof, circuit_prover_data.common_data())\n            .is_ok()\n    );\n}\n\n#[test]\nfn test_table_lookups() {\n    let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n    let cfg = config::baby_bear().build();\n\n    // x + 5*2 - 3 + (-1) == expected\n    let x = builder.public_input();\n    let expected = builder.public_input();\n    let c5 = builder.define_const(BabyBear::from_u64(5));\n    let c2 = builder.define_const(BabyBear::from_u64(2));\n    let c3 = builder.define_const(BabyBear::from_u64(3));\n    let neg_one = builder.define_const(BabyBear::NEG_ONE);\n\n    let mul_result = builder.mul(c5, c2); // 10\n    let add_result = builder.add(x, mul_result); // x + 10\n    let sub_result = builder.sub(add_result, c3); // x + 7\n    let final_result = builder.add(sub_result, neg_one); // x + 6\n\n    let diff = builder.sub(final_result, expected);\n    builder.assert_zero(diff);\n\n    let circuit = builder.build().unwrap();\n    let default_packing = TablePacking::default();\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cBabyBearConfig, _, 1\u003e(\n            \u0026circuit,\n            default_packing,\n            None,\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n    let (mut airs, log_degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n\n    // Witness multiplicities: index 0 gets c_idx lookups from ALU ops without c; values from preprocessed.\n    // Constant folding evaluates mul(5,2) at build time, so there is no Mul ALU op.\n    let mut expected_multiplicities = vec![BabyBear::from_u64(2); 11];\n    expected_multiplicities[0] = BabyBear::from_u64(6);\n    expected_multiplicities[1] = BabyBear::from_u64(1);\n    expected_multiplicities[2] = BabyBear::from_u64(1);\n    // Pad multiplicities.\n    let total_witness_length = (expected_multiplicities\n        .len()\n        .div_ceil(default_packing.witness_lanes()))\n    .next_power_of_two()\n        * default_packing.witness_lanes();\n    expected_multiplicities.resize(total_witness_length, BabyBear::ZERO);\n\n    // Get expected preprocessed trace for `WitnessAir`.\n    let expected_preprocessed_trace = RowMajorMatrix::new(\n        expected_multiplicities\n            .iter()\n            .enumerate()\n            .flat_map(|(i, m)| vec![*m, BabyBear::from_usize(i)])\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n        2 * TablePacking::default().witness_lanes(),\n    );\n    assert_eq!(\n        airs[0]\n            .preprocessed_trace()\n            .expect(\"Witness table should have preprocessed trace\"),\n        expected_preprocessed_trace,\n        \"witness_multiplicities {:?} expected {:?}\",\n        airs[0].preprocessed_trace(),\n        expected_preprocessed_trace,\n    );\n\n    let mut runner = circuit.runner();\n\n    let x_val = BabyBear::from_u64(7);\n    let expected_val = BabyBear::from_u64(13); // 7 + 10 - 3 - 1 = 13\n    runner.set_public_inputs(\u0026[x_val, expected_val]).unwrap();\n    let traces = runner.run().unwrap();\n    let prover_data = ProverData::from_airs_and_degrees(\u0026cfg, \u0026mut airs, \u0026log_degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    let prover = BatchStarkProver::new(cfg);\n\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n    assert_eq!(proof.ext_degree, 1);\n    assert!(proof.w_binomial.is_none());\n\n    assert!(\n        prover\n            .verify_all_tables(\u0026proof, circuit_prover_data.common_data())\n            .is_ok()\n    );\n\n    // Check that the generated lookups are correct and consistent across tables.\n    for air in airs.iter_mut() {\n        let lookups =\n            Air::\u003cSymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e\u003e::get_lookups(\n                air,\n            );\n\n        match air {\n            CircuitTableAir::Witness(_) =\u003e {\n                assert_eq!(\n                    lookups.len(),\n                    default_packing.witness_lanes(),\n                    \"Witness table should have {} lookups, found {}\",\n                    default_packing.witness_lanes(),\n                    lookups.len()\n                );\n            }\n            CircuitTableAir::Const(_) =\u003e {\n                assert_eq!(lookups.len(), 1, \"Const table should have one lookup\");\n            }\n            CircuitTableAir::Public(_) =\u003e {\n                assert_eq!(lookups.len(), 1, \"Public table should have one lookup\");\n            }\n            CircuitTableAir::Alu(_) =\u003e {\n                // ALU table sends 4 lookups per lane: one for each operand (a, b, c, out)\n                let expected_num_lookups = default_packing.alu_lanes() * 4;\n                assert_eq!(\n                    lookups.len(),\n                    expected_num_lookups,\n                    \"ALU table should have {} lookups, found {}\",\n                    expected_num_lookups,\n                    lookups.len()\n                );\n            }\n            CircuitTableAir::Dynamic(_dynamic_air) =\u003e {\n                assert!(\n                    lookups.is_empty(),\n                    \"There is no dynamic table in this test, so no lookups expected\"\n                );\n            }\n        }\n    }\n}\n\n#[test]\nfn test_extension_field_batch_stark() {\n    const D: usize = 4;\n    type Ext4 = BinomialExtensionField\u003cBabyBear, D\u003e;\n    let cfg = config::baby_bear().build();\n\n    let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n    let x = builder.public_input();\n    let y = builder.public_input();\n    let z = builder.public_input();\n    let expected = builder.public_input();\n    let xy = builder.mul(x, y);\n    let res = builder.add(xy, z);\n    let diff = builder.sub(res, expected);\n    builder.assert_zero(diff);\n\n    let circuit = builder.build().unwrap();\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cBabyBearConfig, _, D\u003e(\n            \u0026circuit,\n            TablePacking::default(),\n            None,\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n\n    let mut runner = circuit.runner();\n    let xv = Ext4::from_basis_coefficients_slice(\u0026[\n        BabyBear::from_u64(2),\n        BabyBear::from_u64(3),\n        BabyBear::from_u64(5),\n        BabyBear::from_u64(7),\n    ])\n    .unwrap();\n    let yv = Ext4::from_basis_coefficients_slice(\u0026[\n        BabyBear::from_u64(11),\n        BabyBear::from_u64(13),\n        BabyBear::from_u64(17),\n        BabyBear::from_u64(19),\n    ])\n    .unwrap();\n    let zv = Ext4::from_basis_coefficients_slice(\u0026[\n        BabyBear::from_u64(23),\n        BabyBear::from_u64(29),\n        BabyBear::from_u64(31),\n        BabyBear::from_u64(37),\n    ])\n    .unwrap();\n    let expected_v = xv * yv + zv;\n    runner.set_public_inputs(\u0026[xv, yv, zv, expected_v]).unwrap();\n    let traces = runner.run().unwrap();\n\n    let prover_data = ProverData::from_airs_and_degrees(\u0026cfg, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n    let prover = BatchStarkProver::new(cfg);\n\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n    assert_eq!(proof.ext_degree, 4);\n    // Ensure W was captured\n    let expected_w = \u003cExt4 as ExtractBinomialW\u003cBabyBear\u003e\u003e::extract_w().unwrap();\n    assert_eq!(proof.w_binomial, Some(expected_w));\n    prover\n        .verify_all_tables(\u0026proof, circuit_prover_data.common_data())\n        .unwrap();\n}\n\n#[test]\nfn test_extension_field_table_lookups() {\n    const D: usize = 4;\n    type Ext4 = BinomialExtensionField\u003cBabyBear, D\u003e;\n    let cfg = config::baby_bear().build();\n\n    let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n    let x = builder.public_input();\n    let y = builder.public_input();\n    let z = builder.public_input();\n    let expected = builder.public_input();\n    let xy = builder.mul(x, y);\n    let res = builder.add(xy, z);\n    let diff = builder.sub(res, expected);\n    builder.assert_zero(diff);\n\n    let circuit = builder.build().unwrap();\n    let default_packing = TablePacking::default();\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cBabyBearConfig, _, D\u003e(\n            \u0026circuit,\n            default_packing,\n            None,\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n    let (mut airs, log_degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n\n    // Check that the multiplicities of `WitnessAir` are computed correctly.\n    // With MulAdd fusion, mul+add pairs are fused, reducing the number of ALU ops.\n    let mut expected_multiplicities = vec![BabyBear::from_u64(2); 7];\n    expected_multiplicities[0] = BabyBear::from_u64(3); // reduced due to MulAdd fusion\n    expected_multiplicities[5] = BabyBear::from_u64(0); // changed due to fusion\n    // Pad multiplicities.\n    let total_witness_length = (expected_multiplicities\n        .len()\n        .div_ceil(default_packing.witness_lanes()))\n    .next_power_of_two()\n        * default_packing.witness_lanes();\n    expected_multiplicities.resize(total_witness_length, BabyBear::ZERO);\n\n    // Get expected preprocessed trace for `WitnessAir`.\n    let expected_preprocessed_trace = RowMajorMatrix::new(\n        expected_multiplicities\n            .iter()\n            .enumerate()\n            .flat_map(|(i, m)| vec![*m, BabyBear::from_usize(i)])\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n        2 * TablePacking::default().witness_lanes(),\n    );\n\n    assert_eq!(\n        airs[0]\n            .preprocessed_trace()\n            .expect(\"Witness table should have preprocessed trace\"),\n        expected_preprocessed_trace,\n        \"witness_multiplicities {:?} expected {:?}\",\n        airs[0].preprocessed_trace(),\n        expected_preprocessed_trace,\n    );\n\n    let mut runner = circuit.runner();\n\n    let xv = Ext4::from_basis_coefficients_slice(\u0026[\n        BabyBear::from_u64(2),\n        BabyBear::from_u64(3),\n        BabyBear::from_u64(5),\n        BabyBear::from_u64(7),\n    ])\n    .unwrap();\n    let yv = Ext4::from_basis_coefficients_slice(\u0026[\n        BabyBear::from_u64(11),\n        BabyBear::from_u64(13),\n        BabyBear::from_u64(17),\n        BabyBear::from_u64(19),\n    ])\n    .unwrap();\n    let zv = Ext4::from_basis_coefficients_slice(\u0026[\n        BabyBear::from_u64(23),\n        BabyBear::from_u64(29),\n        BabyBear::from_u64(31),\n        BabyBear::from_u64(37),\n    ])\n    .unwrap();\n    let expected_v = xv * yv + zv;\n    runner.set_public_inputs(\u0026[xv, yv, zv, expected_v]).unwrap();\n    let traces = runner.run().unwrap();\n\n    let prover_data = ProverData::from_airs_and_degrees(\u0026cfg, \u0026mut airs, \u0026log_degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    let prover = BatchStarkProver::new(cfg);\n\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n    assert_eq!(proof.ext_degree, 4);\n    // Ensure W was captured\n    let expected_w = \u003cExt4 as ExtractBinomialW\u003cBabyBear\u003e\u003e::extract_w().unwrap();\n    assert_eq!(proof.w_binomial, Some(expected_w));\n\n    assert!(\n        prover\n            .verify_all_tables(\u0026proof, circuit_prover_data.common_data())\n            .is_ok()\n    );\n\n    // Check that the generated lookups are correct and consistent across tables.\n    for air in airs.iter_mut() {\n        let lookups =\n            Air::\u003cSymbolicAirBuilder\u003cBabyBear, BinomialExtensionField\u003cBabyBear, 4\u003e\u003e\u003e::get_lookups(\n                air,\n            );\n\n        match air {\n            CircuitTableAir::Witness(_) =\u003e {\n                assert_eq!(\n                    lookups.len(),\n                    default_packing.witness_lanes(),\n                    \"Witness table should have {} lookups, found {}\",\n                    default_packing.witness_lanes(),\n                    lookups.len()\n                );\n            }\n            CircuitTableAir::Const(_) =\u003e {\n                assert_eq!(lookups.len(), 1, \"Const table should have one lookup\");\n            }\n            CircuitTableAir::Public(_) =\u003e {\n                assert_eq!(lookups.len(), 1, \"Public table should have one lookup\");\n            }\n            CircuitTableAir::Alu(_) =\u003e {\n                // ALU table sends 4 lookups per lane: one for each operand (a, b, c, out)\n                let expected_num_lookups = default_packing.alu_lanes() * 4;\n                assert_eq!(\n                    lookups.len(),\n                    expected_num_lookups,\n                    \"ALU table should have {} lookups, found {}\",\n                    expected_num_lookups,\n                    lookups.len()\n                );\n            }\n            CircuitTableAir::Dynamic(_dynamic_air) =\u003e {\n                assert!(\n                    lookups.is_empty(),\n                    \"There is no dynamic table in this test, so no lookups expected\"\n                );\n            }\n        }\n    }\n}\n\n#[test]\nfn test_koalabear_batch_stark_base_field() {\n    let mut builder = CircuitBuilder::\u003cKoalaBear\u003e::new();\n    let cfg = config::koala_bear().build();\n\n    // a * b + 100 - (-1) == expected\n    let a = builder.public_input();\n    let b = builder.public_input();\n    let expected = builder.public_input();\n    let c = builder.define_const(KoalaBear::from_u64(100));\n    let d = builder.define_const(KoalaBear::NEG_ONE);\n\n    let ab = builder.mul(a, b);\n    let add = builder.add(ab, c);\n    let final_res = builder.sub(add, d);\n    let diff = builder.sub(final_res, expected);\n    builder.assert_zero(diff);\n\n    let circuit = builder.build().unwrap();\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cKoalaBearConfig, _, 1\u003e(\n            \u0026circuit,\n            TablePacking::default(),\n            None,\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    let a_val = KoalaBear::from_u64(42);\n    let b_val = KoalaBear::from_u64(13);\n    let expected_val = KoalaBear::from_u64(647); // 42*13 + 100 - (-1)\n    runner\n        .set_public_inputs(\u0026[a_val, b_val, expected_val])\n        .unwrap();\n    let traces = runner.run().unwrap();\n\n    let prover_data = ProverData::from_airs_and_degrees(\u0026cfg, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n    let prover = BatchStarkProver::new(cfg);\n\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n    assert_eq!(proof.ext_degree, 1);\n    assert!(proof.w_binomial.is_none());\n    prover\n        .verify_all_tables(\u0026proof, circuit_prover_data.common_data())\n        .unwrap();\n}\n\n#[test]\nfn test_koalabear_batch_stark_extension_field_d8() {\n    const D: usize = 8;\n    type KBExtField = BinomialExtensionField\u003cKoalaBear, D\u003e;\n    let mut builder = CircuitBuilder::\u003cKBExtField\u003e::new();\n    let cfg = config::koala_bear().build();\n\n    // x * y * z == expected\n    let x = builder.public_input();\n    let y = builder.public_input();\n    let expected = builder.public_input();\n    let z = builder.define_const(\n        KBExtField::from_basis_coefficients_slice(\u0026[\n            KoalaBear::from_u64(1),\n            KoalaBear::NEG_ONE,\n            KoalaBear::from_u64(2),\n            KoalaBear::from_u64(3),\n            KoalaBear::from_u64(4),\n            KoalaBear::from_u64(5),\n            KoalaBear::from_u64(6),\n            KoalaBear::from_u64(7),\n        ])\n        .unwrap(),\n    );\n\n    let xy = builder.mul(x, y);\n    let xyz = builder.mul(xy, z);\n    let diff = builder.sub(xyz, expected);\n    builder.assert_zero(diff);\n\n    let circuit = builder.build().unwrap();\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cKoalaBearConfig, _, D\u003e(\n            \u0026circuit,\n            TablePacking::default(),\n            None,\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    let x_val = KBExtField::from_basis_coefficients_slice(\u0026[\n        KoalaBear::from_u64(4),\n        KoalaBear::from_u64(6),\n        KoalaBear::from_u64(8),\n        KoalaBear::from_u64(10),\n        KoalaBear::from_u64(12),\n        KoalaBear::from_u64(14),\n        KoalaBear::from_u64(16),\n        KoalaBear::from_u64(18),\n    ])\n    .unwrap();\n    let y_val = KBExtField::from_basis_coefficients_slice(\u0026[\n        KoalaBear::from_u64(12),\n        KoalaBear::from_u64(14),\n        KoalaBear::from_u64(16),\n        KoalaBear::from_u64(18),\n        KoalaBear::from_u64(20),\n        KoalaBear::from_u64(22),\n        KoalaBear::from_u64(24),\n        KoalaBear::from_u64(26),\n    ])\n    .unwrap();\n    let z_val = KBExtField::from_basis_coefficients_slice(\u0026[\n        KoalaBear::from_u64(1),\n        KoalaBear::NEG_ONE,\n        KoalaBear::from_u64(2),\n        KoalaBear::from_u64(3),\n        KoalaBear::from_u64(4),\n        KoalaBear::from_u64(5),\n        KoalaBear::from_u64(6),\n        KoalaBear::from_u64(7),\n    ])\n    .unwrap();\n\n    let expected_val = x_val * y_val * z_val;\n    runner\n        .set_public_inputs(\u0026[x_val, y_val, expected_val])\n        .unwrap();\n    let traces = runner.run().unwrap();\n\n    let prover_data = ProverData::from_airs_and_degrees(\u0026cfg, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n    let prover = BatchStarkProver::new(cfg);\n\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n    assert_eq!(proof.ext_degree, 8);\n    let expected_w = \u003cKBExtField as ExtractBinomialW\u003cKoalaBear\u003e\u003e::extract_w().unwrap();\n    assert_eq!(proof.w_binomial, Some(expected_w));\n    prover\n        .verify_all_tables(\u0026proof, circuit_prover_data.common_data())\n        .unwrap();\n}\n\n#[test]\nfn test_goldilocks_batch_stark_extension_field_d2() {\n    const D: usize = 2;\n    type Ext2 = BinomialExtensionField\u003cGoldilocks, D\u003e;\n    let mut builder = CircuitBuilder::\u003cExt2\u003e::new();\n    let cfg = config::goldilocks().build();\n\n    // x * y + z == expected\n    let x = builder.public_input();\n    let y = builder.public_input();\n    let z = builder.public_input();\n    let expected = builder.public_input();\n\n    let xy = builder.mul(x, y);\n    let res = builder.add(xy, z);\n    let diff = builder.sub(res, expected);\n    builder.assert_zero(diff);\n\n    let circuit = builder.build().unwrap();\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cGoldilocksConfig, _, D\u003e(\n            \u0026circuit,\n            TablePacking::default(),\n            None,\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    let x_val =\n        Ext2::from_basis_coefficients_slice(\u0026[Goldilocks::from_u64(3), Goldilocks::NEG_ONE])\n            .unwrap();\n    let y_val =\n        Ext2::from_basis_coefficients_slice(\u0026[Goldilocks::from_u64(7), Goldilocks::from_u64(11)])\n            .unwrap();\n    let z_val =\n        Ext2::from_basis_coefficients_slice(\u0026[Goldilocks::from_u64(13), Goldilocks::from_u64(17)])\n            .unwrap();\n    let expected_val = x_val * y_val + z_val;\n\n    runner\n        .set_public_inputs(\u0026[x_val, y_val, z_val, expected_val])\n        .unwrap();\n    let traces = runner.run().unwrap();\n\n    let prover_data = ProverData::from_airs_and_degrees(\u0026cfg, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n    let prover = BatchStarkProver::new(cfg);\n\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n    assert_eq!(proof.ext_degree, 2);\n    let expected_w = \u003cExt2 as ExtractBinomialW\u003cGoldilocks\u003e\u003e::extract_w().unwrap();\n    assert_eq!(proof.w_binomial, Some(expected_w));\n    prover\n        .verify_all_tables(\u0026proof, circuit_prover_data.common_data())\n        .unwrap();\n}\n\n#[test]\nfn test_koalabear_modulus_constant() {\n    // Verify KOALA_BEAR_MODULUS matches the actual KoalaBear field modulus.\n    // The modulus p satisfies: from_u64(p) == 0 in the field.\n    assert_eq!(\n        KoalaBear::from_u64(KOALA_BEAR_MODULUS),\n        KoalaBear::ZERO,\n        \"KOALA_BEAR_MODULUS (0x{:x}) does not match KoalaBear's actual modulus\",\n        KOALA_BEAR_MODULUS\n    );\n\n    // Verify the exact hex value (2130706433 = 0x7f000001).\n    assert_eq!(KOALA_BEAR_MODULUS, 0x7f000001);\n    assert_eq!(KOALA_BEAR_MODULUS, 2130706433);\n\n    // Verify arithmetic at the modulus boundary with hardcoded expected values.\n    // (p - 1) + 2 = 1 in the field\n    let p_minus_1 = KoalaBear::from_u64(KOALA_BEAR_MODULUS - 1);\n    assert_eq!(p_minus_1, KoalaBear::NEG_ONE);\n    assert_eq!(p_minus_1 + KoalaBear::TWO, KoalaBear::ONE);\n\n    // (p - 1) * (p - 1) = 1 in the field (since (-1) * (-1) = 1)\n    assert_eq!(p_minus_1 * p_minus_1, KoalaBear::ONE);\n\n    // Verify from_u64(p + 1) == 1\n    assert_eq!(KoalaBear::from_u64(KOALA_BEAR_MODULUS + 1), KoalaBear::ONE);\n}\n\n#[test]\nfn test_babybear_modulus_constant() {\n    // Verify BABY_BEAR_MODULUS matches the actual BabyBear field modulus.\n    assert_eq!(\n        BabyBear::from_u64(BABY_BEAR_MODULUS),\n        BabyBear::ZERO,\n        \"BABY_BEAR_MODULUS (0x{:x}) does not match BabyBear's actual modulus\",\n        BABY_BEAR_MODULUS\n    );\n\n    // Verify the exact hex value (2013265921 = 0x78000001).\n    assert_eq!(BABY_BEAR_MODULUS, 0x78000001);\n    assert_eq!(BABY_BEAR_MODULUS, 2013265921);\n\n    // Verify arithmetic at the modulus boundary.\n    let p_minus_1 = BabyBear::from_u64(BABY_BEAR_MODULUS - 1);\n    assert_eq!(p_minus_1, BabyBear::NEG_ONE);\n    assert_eq!(p_minus_1 + BabyBear::TWO, BabyBear::ONE);\n    assert_eq!(BabyBear::from_u64(BABY_BEAR_MODULUS + 1), BabyBear::ONE);\n}\n\n#[test]\nfn test_mul_only_circuit_padding() {\n    // Circuit with only mul operations; ALU table still needs correct padding/lanes handling.\n    let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n    let cfg = config::baby_bear().build();\n\n    let x = builder.public_input();\n    let y = builder.public_input();\n\n    // Only multiplication, no addition\n    builder.mul(x, y);\n\n    let circuit = builder.build().unwrap();\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cBabyBearConfig, _, 1\u003e(\n            \u0026circuit,\n            TablePacking::default(),\n            None,\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    let x_val = BabyBear::from_u64(7);\n    let y_val = BabyBear::from_u64(11);\n    runner.set_public_inputs(\u0026[x_val, y_val]).unwrap();\n    let traces = runner.run().unwrap();\n\n    let prover_data = ProverData::from_airs_and_degrees(\u0026cfg, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    let common = circuit_prover_data.common_data();\n\n    let prover = BatchStarkProver::new(cfg);\n\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n    prover.verify_all_tables(\u0026proof, common).unwrap();\n}\n\n#[test]\nfn test_add_only_circuit_padding() {\n    // Circuit with only add operations; ALU table still needs correct padding/lanes handling.\n    let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n    let cfg = config::baby_bear().build();\n\n    let x = builder.public_input();\n    let y = builder.public_input();\n    let expected = builder.public_input();\n\n    // Only addition, no multiplication\n    let sum = builder.add(x, y);\n    let diff = builder.sub(sum, expected);\n    builder.assert_zero(diff);\n\n    let circuit = builder.build().unwrap();\n    let (airs_degrees, preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cBabyBearConfig, _, 1\u003e(\n            \u0026circuit,\n            TablePacking::default(),\n            None,\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    let x_val = BabyBear::from_u64(42);\n    let y_val = BabyBear::from_u64(13);\n    let expected_val = x_val + y_val;\n    runner\n        .set_public_inputs(\u0026[x_val, y_val, expected_val])\n        .unwrap();\n    let traces = runner.run().unwrap();\n\n    let prover_data = ProverData::from_airs_and_degrees(\u0026cfg, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    let common = circuit_prover_data.common_data();\n\n    let prover = BatchStarkProver::new(cfg);\n\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n    prover.verify_all_tables(\u0026proof, common).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","batch_stark_prover.rs"],"content":"//! Batch STARK prover and verifier that unifies all circuit tables\n//! into a single batched STARK proof using `p3-batch-stark`.\n\nuse alloc::boxed::Box;\nuse alloc::string::String;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\n\nuse p3_air::{Air, AirBuilder, BaseAir};\n#[cfg(debug_assertions)]\nuse p3_batch_stark::DebugConstraintBuilderWithLookups;\nuse p3_batch_stark::{BatchProof, CommonData, ProverData, StarkGenericConfig, StarkInstance, Val};\nuse p3_circuit::PreprocessedColumns;\nuse p3_circuit::op::{NonPrimitiveOpType, Poseidon2Config, PrimitiveOpType};\nuse p3_circuit::tables::Traces;\nuse p3_field::extension::{BinomialExtensionField, BinomiallyExtendable};\nuse p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing, PrimeField};\nuse p3_lookup::folder::{ProverConstraintFolderWithLookups, VerifierConstraintFolderWithLookups};\nuse p3_lookup::lookup_traits::Lookup;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_uni_stark::{SymbolicAirBuilder, SymbolicExpression};\nuse serde::{Deserialize, Serialize};\nuse thiserror::Error;\nuse tracing::instrument;\n\nuse crate::air::{AluAir, ConstAir, PublicAir, WitnessAir};\nuse crate::batch_stark_prover::dynamic_air::transmute_traces;\nuse crate::common::CircuitTableAir;\nuse crate::config::StarkField;\nuse crate::constraint_profile::ConstraintProfile;\nuse crate::field_params::ExtractBinomialW;\n\nmod dynamic_air;\nmod packing;\nmod poseidon2;\n\npub use dynamic_air::{\n    BatchAir, BatchTableInstance, CloneableBatchAir, DynamicAirEntry, TableProver,\n};\npub use packing::{TablePacking, TraceLengths};\npub use poseidon2::{\n    Poseidon2AirWrapperInner, Poseidon2Prover, poseidon2_verifier_air_from_config,\n};\n\npub const BABY_BEAR_MODULUS: u64 = 0x7800_0001;\npub const KOALA_BEAR_MODULUS: u64 = 0x7f00_0001;\n\n/// Opaque variant tag for a non-primitive AIR in a batch proof.\n///\n/// Each [`NonPrimitiveTableEntry`] has one tag. The **meaning** of the tag is\n/// defined by that entry's `op_type`: the corresponding [`TableProver`] interprets\n/// it when building the AIR in [`TableProver::batch_air_from_table_entry`].\n#[derive(Clone, Copy, Default, Debug, Serialize, Deserialize, PartialEq, Eq)]\npub enum AirVariant {\n    /// Baseline AIR for this op type (default behaviour).\n    #[default]\n    Baseline = 0,\n    /// Recursion-optimized variant.\n    Optimized = 1,\n}\n\n/// Metadata describing a non-primitive table inside a batch proof.\n///\n/// Every non-primitive dynamic plugin produces exactly one `NonPrimitiveTableEntry`\n/// per batch instance. The entry is stored inside a `BatchStarkProof` and later provided\n/// back to the plugin during verification through\n/// [`TableProver::batch_air_from_table_entry`].\n#[derive(Serialize, Deserialize)]\n#[serde(bound = \"\")]\npub struct NonPrimitiveTableEntry\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    /// Operation type (it should match `TableProver::op_type`).\n    pub op_type: NonPrimitiveOpType,\n    /// Number of logical rows produced for this table.\n    pub rows: usize,\n    /// Public values exposed by this table (if any).\n    pub public_values: Vec\u003cVal\u003cSC\u003e\u003e,\n    /// AIR variant used for this non-primitive table.\n    #[serde(default)]\n    pub air_variant: AirVariant,\n}\n\n/// Combined data for circuit proving, including STARK prover data and preprocessed columns.\n///\n/// This struct bundles the upstream [`ProverData`] with circuit-specific [`PreprocessedColumns`],\n/// providing a cleaner API for `prove_all_tables`.\npub struct CircuitProverData\u003cSC: StarkGenericConfig\u003e {\n    /// STARK prover data from p3_batch_stark.\n    pub prover_data: ProverData\u003cSC\u003e,\n    /// Preprocessed columns for all primitive and non-primitive operations.\n    pub preprocessed_columns: PreprocessedColumns\u003cVal\u003cSC\u003e\u003e,\n}\n\nimpl\u003cSC: StarkGenericConfig\u003e CircuitProverData\u003cSC\u003e {\n    /// Create new circuit prover data from components.\n    pub const fn new(\n        prover_data: ProverData\u003cSC\u003e,\n        preprocessed_columns: PreprocessedColumns\u003cVal\u003cSC\u003e\u003e,\n    ) -\u003e Self {\n        Self {\n            prover_data,\n            preprocessed_columns,\n        }\n    }\n\n    /// Get a reference to the common data.\n    pub const fn common_data(\u0026self) -\u003e \u0026CommonData\u003cSC\u003e {\n        \u0026self.prover_data.common\n    }\n\n    /// Get a reference to the preprocessed columns.\n    pub const fn preprocessed_columns(\u0026self) -\u003e \u0026PreprocessedColumns\u003cVal\u003cSC\u003e\u003e {\n        \u0026self.preprocessed_columns\n    }\n}\n\n/// Convenience macro for deriving all degree-specific helpers from a single base\n/// implementation.\n///\n/// Plugins usually implement a single `batch_instance_base` method that operates on\n/// base-field traces. This macro reuses that method to provide the `batch_instance_d*`\n/// variants by casting higher-degree traces back to the base field.\n///\n/// Users can invoke it inside their `TableProver` impl:\n///\n/// ```ignore\n/// impl\u003cSC\u003e TableProver\u003cSC\u003e for MyPlugin {\n///     fn op_type(\u0026self) -\u003e NonPrimitiveOpType {\n///         NonPrimitiveOpType::Poseidon2Perm(Poseidon2Config::BabyBearD4Width16)\n///     }\n///\n///     impl_table_prover_batch_instances_from_base!(batch_instance_base);\n///\n///     fn batch_air_from_table_entry(\n///         \u0026self,\n///         config: \u0026SC,\n///         degree: usize,\n///         table_entry: \u0026NonPrimitiveTableEntry\u003cSC\u003e,\n///     ) -\u003e Result\u003cDynamicAirEntry\u003cSC\u003e, String\u003e {\n///         Ok(DynamicAirEntry::new(Box::new(MyPluginAir::\u003cVal\u003cSC\u003e\u003e::new(config))))\n///     }\n/// }\n/// ```\n#[macro_export]\nmacro_rules! impl_table_prover_batch_instances_from_base {\n    ($base:ident) =\u003e {\n        fn batch_instance_d1(\n            \u0026self,\n            config: \u0026SC,\n            packing: TablePacking,\n            traces: \u0026p3_circuit::tables::Traces\u003cp3_batch_stark::Val\u003cSC\u003e\u003e,\n        ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n            self.$base::\u003cSC\u003e(config, packing, traces)\n        }\n\n        fn batch_instance_d2(\n            \u0026self,\n            config: \u0026SC,\n            packing: TablePacking,\n            traces: \u0026p3_circuit::tables::Traces\u003c\n                p3_field::extension::BinomialExtensionField\u003cp3_batch_stark::Val\u003cSC\u003e, 2\u003e,\n            \u003e,\n        ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n            let t: \u0026p3_circuit::tables::Traces\u003cp3_batch_stark::Val\u003cSC\u003e\u003e =\n                unsafe { transmute_traces(traces) };\n            self.$base::\u003cSC\u003e(config, packing, t)\n        }\n\n        fn batch_instance_d4(\n            \u0026self,\n            config: \u0026SC,\n            packing: TablePacking,\n            traces: \u0026p3_circuit::tables::Traces\u003c\n                p3_field::extension::BinomialExtensionField\u003cp3_batch_stark::Val\u003cSC\u003e, 4\u003e,\n            \u003e,\n        ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n            let t: \u0026p3_circuit::tables::Traces\u003cp3_batch_stark::Val\u003cSC\u003e\u003e =\n                unsafe { transmute_traces(traces) };\n            self.$base::\u003cSC\u003e(config, packing, t)\n        }\n\n        fn batch_instance_d6(\n            \u0026self,\n            config: \u0026SC,\n            packing: TablePacking,\n            traces: \u0026p3_circuit::tables::Traces\u003c\n                p3_field::extension::BinomialExtensionField\u003cp3_batch_stark::Val\u003cSC\u003e, 6\u003e,\n            \u003e,\n        ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n            let t: \u0026p3_circuit::tables::Traces\u003cp3_batch_stark::Val\u003cSC\u003e\u003e =\n                unsafe { transmute_traces(traces) };\n            self.$base::\u003cSC\u003e(config, packing, t)\n        }\n\n        fn batch_instance_d8(\n            \u0026self,\n            config: \u0026SC,\n            packing: TablePacking,\n            traces: \u0026p3_circuit::tables::Traces\u003c\n                p3_field::extension::BinomialExtensionField\u003cp3_batch_stark::Val\u003cSC\u003e, 8\u003e,\n            \u003e,\n        ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n            let t: \u0026p3_circuit::tables::Traces\u003cp3_batch_stark::Val\u003cSC\u003e\u003e =\n                unsafe { transmute_traces(traces) };\n            self.$base::\u003cSC\u003e(config, packing, t)\n        }\n    };\n}\n\npub type PrimitiveTable = PrimitiveOpType;\n\n/// Number of primitive circuit tables included in the unified batch STARK proof.\npub const NUM_PRIMITIVE_TABLES: usize = PrimitiveTable::Alu as usize + 1;\n\n/// Row counts wrapper with type-safe indexing.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub struct RowCounts([usize; NUM_PRIMITIVE_TABLES]);\n\nimpl RowCounts {\n    /// Creates a new RowCounts with the given row counts for each table.\n    pub const fn new(rows: [usize; NUM_PRIMITIVE_TABLES]) -\u003e Self {\n        // Validate that all row counts are non-zero\n        let mut i = 0;\n        while i \u003c rows.len() {\n            assert!(rows[i] \u003e 0);\n            i += 1;\n        }\n        Self(rows)\n    }\n\n    /// Gets the row count for a specific table.\n    #[inline]\n    pub const fn get(\u0026self, t: PrimitiveTable) -\u003e usize {\n        self.0[t as usize]\n    }\n}\n\nimpl core::ops::Index\u003cPrimitiveTable\u003e for RowCounts {\n    type Output = usize;\n    fn index(\u0026self, table: PrimitiveTable) -\u003e \u0026Self::Output {\n        \u0026self.0[table as usize]\n    }\n}\n\nimpl From\u003c[usize; NUM_PRIMITIVE_TABLES]\u003e for RowCounts {\n    fn from(rows: [usize; NUM_PRIMITIVE_TABLES]) -\u003e Self {\n        Self(rows)\n    }\n}\n\n/// Proof bundle and metadata for the unified batch STARK proof across all circuit tables.\n#[derive(Serialize, Deserialize)]\n#[serde(bound = \"\")]\npub struct BatchStarkProof\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    /// The core cryptographic proof generated by `p3-batch-stark`.\n    pub proof: BatchProof\u003cSC\u003e,\n    /// Packing configuration used for the Witness, Public, and unified ALU tables.\n    pub table_packing: TablePacking,\n    /// The number of rows in each of the circuit tables.\n    pub rows: RowCounts,\n    /// Variant used for the primitive ALU table.\n    pub alu_variant: AirVariant,\n    /// The degree of the field extension (`D`) used for the proof.\n    pub ext_degree: usize,\n    /// The binomial coefficient `W` for extension field multiplication, if `ext_degree \u003e 1`.\n    pub w_binomial: Option\u003cVal\u003cSC\u003e\u003e,\n    /// Manifest describing batched non-primitive tables defined at runtime.\n    pub non_primitives: Vec\u003cNonPrimitiveTableEntry\u003cSC\u003e\u003e,\n}\n\nimpl\u003cSC\u003e core::fmt::Debug for BatchStarkProof\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        f.debug_struct(\"BatchStarkProof\")\n            .field(\"table_packing\", \u0026self.table_packing)\n            .field(\"rows\", \u0026self.rows)\n            .field(\"ext_degree\", \u0026self.ext_degree)\n            .field(\"w_binomial\", \u0026self.w_binomial)\n            .finish()\n    }\n}\n\n/// Produces a single batch STARK proof covering all circuit tables.\npub struct BatchStarkProver\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + 'static,\n{\n    config: SC,\n    table_packing: TablePacking,\n    /// Variant used for the primitive ALU AIR.\n    alu_variant: AirVariant,\n    /// Registered dynamic non-primitive table provers.\n    non_primitive_provers: Vec\u003cBox\u003cdyn TableProver\u003cSC\u003e\u003e\u003e,\n    /// When true, run the lookup debugger before proving to report imbalanced multisets.\n    debug_lookups: bool,\n}\n\n/// Errors for the batch STARK table prover.\n#[derive(Debug, Error)]\npub enum BatchStarkProverError {\n    #[error(\"unsupported extension degree: {0} (supported: 1,2,4,6,8)\")]\n    UnsupportedDegree(usize),\n\n    #[error(\"missing binomial parameter W for extension-field multiplication\")]\n    MissingWForExtension,\n\n    #[error(\"verification failed: {0}\")]\n    Verify(String),\n\n    #[error(\"missing table prover for non-primitive op `{0:?}`\")]\n    MissingTableProver(NonPrimitiveOpType),\n}\n\nimpl\u003cSC, const D: usize\u003e BaseAir\u003cVal\u003cSC\u003e\u003e for CircuitTableAir\u003cSC, D\u003e\nwhere\n    SC: StarkGenericConfig,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        match self {\n            Self::Witness(a) =\u003e a.width(),\n            Self::Const(a) =\u003e a.width(),\n            Self::Public(a) =\u003e a.width(),\n            Self::Alu(a) =\u003e a.width(),\n            Self::Dynamic(a) =\u003e \u003cdyn CloneableBatchAir\u003cSC\u003e as BaseAir\u003cVal\u003cSC\u003e\u003e\u003e::width(a.air()),\n        }\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e {\n        match self {\n            Self::Witness(a) =\u003e a.preprocessed_trace(),\n            Self::Const(a) =\u003e a.preprocessed_trace(),\n            Self::Public(a) =\u003e a.preprocessed_trace(),\n            Self::Alu(a) =\u003e a.preprocessed_trace(),\n            Self::Dynamic(a) =\u003e {\n                \u003cdyn CloneableBatchAir\u003cSC\u003e as BaseAir\u003cVal\u003cSC\u003e\u003e\u003e::preprocessed_trace(a.air())\n            }\n        }\n    }\n}\n\nmacro_rules! impl_circuit_table_air_for_builder {\n    ($builder_ty:ty) =\u003e {\n        fn eval(\u0026self, builder: \u0026mut $builder_ty) {\n            match self {\n                Self::Witness(a) =\u003e Air::\u003c$builder_ty\u003e::eval(a, builder),\n                Self::Const(a) =\u003e Air::\u003c$builder_ty\u003e::eval(a, builder),\n                Self::Public(a) =\u003e Air::\u003c$builder_ty\u003e::eval(a, builder),\n                Self::Alu(a) =\u003e Air::\u003c$builder_ty\u003e::eval(a, builder),\n                Self::Dynamic(a) =\u003e Air::\u003c$builder_ty\u003e::eval(a, builder),\n            }\n        }\n\n        fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n            match self {\n                Self::Witness(a) =\u003e Air::\u003c$builder_ty\u003e::add_lookup_columns(a),\n                Self::Const(a) =\u003e Air::\u003c$builder_ty\u003e::add_lookup_columns(a),\n                Self::Public(a) =\u003e Air::\u003c$builder_ty\u003e::add_lookup_columns(a),\n                Self::Alu(a) =\u003e Air::\u003c$builder_ty\u003e::add_lookup_columns(a),\n                Self::Dynamic(a) =\u003e Air::\u003c$builder_ty\u003e::add_lookup_columns(a),\n            }\n        }\n\n        fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003c$builder_ty as AirBuilder\u003e::F\u003e\u003e {\n            match self {\n                Self::Witness(a) =\u003e Air::\u003c$builder_ty\u003e::get_lookups(a),\n                Self::Const(a) =\u003e Air::\u003c$builder_ty\u003e::get_lookups(a),\n                Self::Public(a) =\u003e Air::\u003c$builder_ty\u003e::get_lookups(a),\n                Self::Alu(a) =\u003e Air::\u003c$builder_ty\u003e::get_lookups(a),\n                Self::Dynamic(a) =\u003e Air::\u003c$builder_ty\u003e::get_lookups(a),\n            }\n        }\n    };\n}\n\nimpl\u003cSC, const D: usize\u003e Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e\u003e for CircuitTableAir\u003cSC, D\u003e\nwhere\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: PrimeField,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    impl_circuit_table_air_for_builder!(SymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e);\n}\n\n#[cfg(debug_assertions)]\nimpl\u003c'a, SC, const D: usize\u003e Air\u003cDebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e\u003e\n    for CircuitTableAir\u003cSC, D\u003e\nwhere\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: PrimeField,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    impl_circuit_table_air_for_builder!(\n        DebugConstraintBuilderWithLookups\u003c'a, Val\u003cSC\u003e, SC::Challenge\u003e\n    );\n}\n\nimpl\u003c'a, SC, const D: usize\u003e Air\u003cProverConstraintFolderWithLookups\u003c'a, SC\u003e\u003e\n    for CircuitTableAir\u003cSC, D\u003e\nwhere\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: PrimeField,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    impl_circuit_table_air_for_builder!(ProverConstraintFolderWithLookups\u003c'a, SC\u003e);\n}\n\nimpl\u003c'a, SC, const D: usize\u003e Air\u003cVerifierConstraintFolderWithLookups\u003c'a, SC\u003e\u003e\n    for CircuitTableAir\u003cSC, D\u003e\nwhere\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: PrimeField,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    impl_circuit_table_air_for_builder!(VerifierConstraintFolderWithLookups\u003c'a, SC\u003e);\n}\n\nimpl\u003cSC\u003e BatchStarkProver\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + 'static,\n    Val\u003cSC\u003e: StarkField,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    pub fn new(config: SC) -\u003e Self {\n        Self {\n            config,\n            table_packing: TablePacking::default(),\n            alu_variant: AirVariant::Optimized,\n            non_primitive_provers: Vec::new(),\n            debug_lookups: false,\n        }\n    }\n\n    #[must_use]\n    pub const fn with_table_packing(mut self, table_packing: TablePacking) -\u003e Self {\n        self.table_packing = table_packing;\n        self\n    }\n\n    /// Enable the lookup debugger. When set, `prove_all_tables` will run\n    /// `check_lookups` on the constructed traces before generating the proof,\n    /// panicking with a detailed message on any multiset imbalance.\n    #[must_use]\n    pub const fn with_debug_lookups(mut self) -\u003e Self {\n        self.debug_lookups = true;\n        self\n    }\n\n    /// Register a dynamic non-primitive table prover.\n    pub fn register_table_prover(\u0026mut self, prover: Box\u003cdyn TableProver\u003cSC\u003e\u003e) {\n        self.non_primitive_provers.push(prover);\n    }\n\n    /// Builder-style registration for a dynamic non-primitive table prover.\n    #[must_use]\n    pub fn with_table_prover(mut self, prover: Box\u003cdyn TableProver\u003cSC\u003e\u003e) -\u003e Self {\n        self.register_table_prover(prover);\n        self\n    }\n\n    /// Register the non-primitive Poseidon2 prover plugin with the given configuration.\n    ///\n    /// Uses the standard constraint profile; recursion-specific code paths\n    /// can instantiate `Poseidon2Prover` directly with other profiles if needed.\n    pub fn register_poseidon2_table(\u0026mut self, config: Poseidon2Config)\n    where\n        SC: Send + Sync,\n        Val\u003cSC\u003e: BinomiallyExtendable\u003c4\u003e,\n    {\n        self.register_table_prover(Box::new(Poseidon2Prover::new(\n            config,\n            ConstraintProfile::Standard,\n        )));\n    }\n\n    #[inline]\n    pub const fn table_packing(\u0026self) -\u003e TablePacking {\n        self.table_packing\n    }\n\n    /// Select which ALU AIR variant to use for primitive tables.\n    #[must_use]\n    pub const fn with_alu_variant(mut self, variant: AirVariant) -\u003e Self {\n        self.alu_variant = variant;\n        self\n    }\n\n    /// Generate a unified batch STARK proof for all circuit tables.\n    #[instrument(skip_all)]\n    pub fn prove_all_tables\u003cEF\u003e(\n        \u0026self,\n        traces: \u0026Traces\u003cEF\u003e,\n        circuit_prover_data: \u0026CircuitProverData\u003cSC\u003e,\n    ) -\u003e Result\u003cBatchStarkProof\u003cSC\u003e, BatchStarkProverError\u003e\n    where\n        EF: Field + BasedVectorSpace\u003cVal\u003cSC\u003e\u003e + ExtractBinomialW\u003cVal\u003cSC\u003e\u003e,\n        SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n    {\n        let w_opt = EF::extract_w();\n        match EF::DIMENSION {\n            1 =\u003e self.prove::\u003cEF, 1\u003e(traces, None, circuit_prover_data),\n            2 =\u003e self.prove::\u003cEF, 2\u003e(traces, w_opt, circuit_prover_data),\n            4 =\u003e self.prove::\u003cEF, 4\u003e(traces, w_opt, circuit_prover_data),\n            6 =\u003e self.prove::\u003cEF, 6\u003e(traces, w_opt, circuit_prover_data),\n            8 =\u003e self.prove::\u003cEF, 8\u003e(traces, w_opt, circuit_prover_data),\n            d =\u003e Err(BatchStarkProverError::UnsupportedDegree(d)),\n        }\n    }\n\n    /// Verify the unified batch STARK proof against all tables.\n    pub fn verify_all_tables(\n        \u0026self,\n        proof: \u0026BatchStarkProof\u003cSC\u003e,\n        common: \u0026CommonData\u003cSC\u003e,\n    ) -\u003e Result\u003c(), BatchStarkProverError\u003e {\n        match proof.ext_degree {\n            1 =\u003e self.verify::\u003c1\u003e(proof, None, common),\n            2 =\u003e self.verify::\u003c2\u003e(proof, proof.w_binomial, common),\n            4 =\u003e self.verify::\u003c4\u003e(proof, proof.w_binomial, common),\n            6 =\u003e self.verify::\u003c6\u003e(proof, proof.w_binomial, common),\n            8 =\u003e self.verify::\u003c8\u003e(proof, proof.w_binomial, common),\n            d =\u003e Err(BatchStarkProverError::UnsupportedDegree(d)),\n        }\n    }\n\n    /// Generate a batch STARK proof for a specific extension field degree.\n    ///\n    /// This is the core proving logic that handles all circuit tables for a given\n    /// extension field dimension. It constructs AIRs, converts traces to matrices,\n    /// and generates the unified proof.\n    fn prove\u003cEF, const D: usize\u003e(\n        \u0026self,\n        traces: \u0026Traces\u003cEF\u003e,\n        w_binomial: Option\u003cVal\u003cSC\u003e\u003e,\n        circuit_prover_data: \u0026CircuitProverData\u003cSC\u003e,\n    ) -\u003e Result\u003cBatchStarkProof\u003cSC\u003e, BatchStarkProverError\u003e\n    where\n        EF: Field + BasedVectorSpace\u003cVal\u003cSC\u003e\u003e,\n    {\n        let PreprocessedColumns {\n            primitive,\n            non_primitive: _,\n        } = \u0026circuit_prover_data.preprocessed_columns;\n        let prover_data = \u0026circuit_prover_data.prover_data;\n\n        // Build matrices and AIRs per table.\n        let packing = self.table_packing;\n        let witness_lanes = packing.witness_lanes();\n        let min_height = packing.min_trace_height();\n\n        // Check if Alu table has only dummy operations (trace length \u003c= 1).\n        // The table implementation adds a dummy row when empty, so we check for \u003c= 1.\n        // Using lanes \u003e 1 with only dummy operations causes issues in recursive verification\n        // due to a bug in how multi-lane padding interacts with lookup constraints.\n        // We automatically reduce lanes to 1 in these cases with a warning.\n        //\n        // The trace length check is more reliable than checking preprocessed width because\n        // the circuit tables add dummy rows to avoid empty traces.\n        let alu_trace_only_dummy = traces.alu_trace.op_kind.len() \u003c= 1;\n\n        let alu_lanes = if alu_trace_only_dummy \u0026\u0026 packing.alu_lanes() \u003e 1 {\n            tracing::warn!(\n                \"ALu table has only dummy operations but alu_lanes={} \u003e 1. Reducing to \\\n                 alu_lanes=1 to avoid recursive verification issues. Consider using \\\n                 alu_lanes=1 when no additions are expected.\",\n                packing.alu_lanes()\n            );\n            1\n        } else {\n            packing.alu_lanes()\n        };\n\n        TraceLengths::from_traces(traces, packing).log();\n\n        // Witness\n        let witness_rows = traces.witness_trace.num_rows();\n        let witness_multiplicities = primitive[PrimitiveOpType::Witness as usize].clone();\n        let witness_air = WitnessAir::\u003cVal\u003cSC\u003e, D\u003e::new_with_preprocessed(\n            witness_rows,\n            witness_lanes,\n            witness_multiplicities,\n        )\n        .with_min_height(min_height);\n        let witness_matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e =\n            WitnessAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_matrix(\u0026traces.witness_trace, witness_lanes);\n\n        // Const\n        let const_rows = traces.const_trace.values.len();\n        let const_prep = primitive[PrimitiveOpType::Const as usize].clone();\n        let const_air = ConstAir::\u003cVal\u003cSC\u003e, D\u003e::new_with_preprocessed(const_rows, const_prep)\n            .with_min_height(min_height);\n        let const_matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e =\n            ConstAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_matrix(\u0026traces.const_trace);\n\n        // Public\n        // Similar to other primitive tables, reduce lanes to 1 if the table has only dummy operations.\n        let public_trace_only_dummy = traces.public_trace.values.len() \u003c= 1;\n        let public_lanes = if public_trace_only_dummy \u0026\u0026 packing.public_lanes() \u003e 1 {\n            tracing::warn!(\n                \"Public table has only dummy operations but public_lanes={} \u003e 1. Reducing to \\\n                 public_lanes=1 to avoid recursive verification issues. Consider using \\\n                 public_lanes=1 when few public inputs are expected.\",\n                packing.public_lanes()\n            );\n            1\n        } else {\n            packing.public_lanes()\n        };\n\n        let public_rows = traces.public_trace.values.len();\n        let public_prep = primitive[PrimitiveOpType::Public as usize].clone();\n        let public_air =\n            PublicAir::\u003cVal\u003cSC\u003e, D\u003e::new_with_preprocessed(public_rows, public_lanes, public_prep)\n                .with_min_height(min_height);\n        let public_matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e =\n            PublicAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_matrix(\u0026traces.public_trace, public_lanes);\n\n        // ALU (unified Add/Mul/BoolCheck/MulAdd)\n        // When the ALU trace is empty, we add a dummy operation to match\n        // what get_airs_and_degrees_with_prep does for the CommonData preprocessed commitment.\n        // This ensures the prover's AIR.preprocessed_trace() matches the committed data.\n        let alu_rows = traces.alu_trace.a_values.len();\n        let (alu_rows, alu_prep) = if alu_rows == 0 {\n            // Add dummy operation with indices [0, 0, 0]\n            let dummy_prep =\n                vec![Val::\u003cSC\u003e::ZERO; AluAir::\u003cVal\u003cSC\u003e, D\u003e::preprocessed_lane_width() - 1];\n            (1, dummy_prep)\n        } else {\n            (alu_rows, primitive[PrimitiveOpType::Alu as usize].clone())\n        };\n        let alu_air: AluAir\u003cVal\u003cSC\u003e, D\u003e = if D == 1 {\n            AluAir::\u003cVal\u003cSC\u003e, D\u003e::new_with_preprocessed(alu_rows, alu_lanes, alu_prep)\n                .with_min_height(min_height)\n        } else {\n            let w = w_binomial.ok_or(BatchStarkProverError::MissingWForExtension)?;\n            AluAir::\u003cVal\u003cSC\u003e, D\u003e::new_binomial_with_preprocessed(alu_rows, alu_lanes, w, alu_prep)\n                .with_min_height(min_height)\n        };\n        let alu_matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e =\n            AluAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_matrix(\u0026traces.alu_trace, alu_lanes);\n\n        // We first handle all non-primitive tables dynamically, which will then be batched alongside primitive ones.\n        // Each trace must have a corresponding registered prover for it to be provable.\n        for (\u0026op_type, trace) in \u0026traces.non_primitive_traces {\n            if trace.rows() == 0 {\n                continue;\n            }\n            if !self\n                .non_primitive_provers\n                .iter()\n                .any(|p| p.op_type() == op_type)\n            {\n                return Err(BatchStarkProverError::MissingTableProver(op_type));\n            }\n        }\n\n        let mut dynamic_instances: Vec\u003cBatchTableInstance\u003cSC\u003e\u003e = Vec::new();\n        if D == 1 {\n            let t: \u0026Traces\u003cVal\u003cSC\u003e\u003e = unsafe { transmute_traces(traces) };\n            for p in \u0026self.non_primitive_provers {\n                if let Some(instance) = p.batch_instance_d1(\u0026self.config, packing, t) {\n                    dynamic_instances.push(instance);\n                }\n            }\n        } else if D == 2 {\n            type EF2\u003cF\u003e = BinomialExtensionField\u003cF, 2\u003e;\n            let t: \u0026Traces\u003cEF2\u003cVal\u003cSC\u003e\u003e\u003e = unsafe { transmute_traces(traces) };\n            for p in \u0026self.non_primitive_provers {\n                if let Some(instance) = p.batch_instance_d2(\u0026self.config, packing, t) {\n                    dynamic_instances.push(instance);\n                }\n            }\n        } else if D == 4 {\n            type EF4\u003cF\u003e = BinomialExtensionField\u003cF, 4\u003e;\n            let t: \u0026Traces\u003cEF4\u003cVal\u003cSC\u003e\u003e\u003e = unsafe { transmute_traces(traces) };\n            for p in \u0026self.non_primitive_provers {\n                if let Some(instance) = p.batch_instance_d4(\u0026self.config, packing, t) {\n                    dynamic_instances.push(instance);\n                }\n            }\n        } else if D == 6 {\n            type EF6\u003cF\u003e = BinomialExtensionField\u003cF, 6\u003e;\n            let t: \u0026Traces\u003cEF6\u003cVal\u003cSC\u003e\u003e\u003e = unsafe { transmute_traces(traces) };\n            for p in \u0026self.non_primitive_provers {\n                if let Some(instance) = p.batch_instance_d6(\u0026self.config, packing, t) {\n                    dynamic_instances.push(instance);\n                }\n            }\n        } else if D == 8 {\n            type EF8\u003cF\u003e = BinomialExtensionField\u003cF, 8\u003e;\n            let t: \u0026Traces\u003cEF8\u003cVal\u003cSC\u003e\u003e\u003e = unsafe { transmute_traces(traces) };\n            for p in \u0026self.non_primitive_provers {\n                if let Some(instance) = p.batch_instance_d8(\u0026self.config, packing, t) {\n                    dynamic_instances.push(instance);\n                }\n            }\n        }\n\n        // Wrap AIRs in enum for heterogeneous batching and build instances in fixed order.\n        // TODO: Support public values for tables\n        let mut air_storage: Vec\u003cCircuitTableAir\u003cSC, D\u003e\u003e =\n            Vec::with_capacity(NUM_PRIMITIVE_TABLES + dynamic_instances.len());\n        let mut trace_storage: Vec\u003cRowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e =\n            Vec::with_capacity(NUM_PRIMITIVE_TABLES + dynamic_instances.len());\n        let mut public_storage: Vec\u003cVec\u003cVal\u003cSC\u003e\u003e\u003e =\n            Vec::with_capacity(NUM_PRIMITIVE_TABLES + dynamic_instances.len());\n        let mut non_primitives: Vec\u003cNonPrimitiveTableEntry\u003cSC\u003e\u003e =\n            Vec::with_capacity(dynamic_instances.len());\n\n        // Pad all trace matrices to at least min_height (for FRI compatibility)\n        air_storage.push(CircuitTableAir::Witness(witness_air));\n        trace_storage.push(packing::pad_matrix_to_min_height(\n            witness_matrix,\n            min_height,\n        ));\n        public_storage.push(Vec::new());\n\n        air_storage.push(CircuitTableAir::Const(const_air));\n        trace_storage.push(packing::pad_matrix_to_min_height(const_matrix, min_height));\n        public_storage.push(Vec::new());\n\n        air_storage.push(CircuitTableAir::Public(public_air));\n        trace_storage.push(packing::pad_matrix_to_min_height(public_matrix, min_height));\n        public_storage.push(Vec::new());\n\n        air_storage.push(CircuitTableAir::Alu(alu_air));\n        trace_storage.push(packing::pad_matrix_to_min_height(alu_matrix, min_height));\n        public_storage.push(Vec::new());\n\n        for instance in dynamic_instances {\n            let BatchTableInstance {\n                op_type,\n                air,\n                trace,\n                public_values,\n                rows,\n            } = instance;\n            air_storage.push(CircuitTableAir::Dynamic(air));\n            trace_storage.push(packing::pad_matrix_to_min_height(trace, min_height));\n            public_storage.push(public_values.clone());\n            non_primitives.push(NonPrimitiveTableEntry {\n                op_type,\n                rows,\n                public_values,\n                air_variant: AirVariant::Baseline,\n            });\n        }\n\n        let instances: Vec\u003cStarkInstance\u003c'_, SC, CircuitTableAir\u003cSC, D\u003e\u003e\u003e = air_storage\n            .iter_mut()\n            .zip(trace_storage)\n            .zip(public_storage)\n            .map(|((air, trace), public_values)| {\n                let lookups = Air::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e\u003e::get_lookups(air);\n\n                StarkInstance {\n                    air,\n                    trace,\n                    public_values,\n                    lookups,\n                }\n            })\n            .collect();\n\n        if self.debug_lookups {\n            use p3_lookup::debug_util::{LookupDebugInstance, check_lookups};\n\n            let preprocessed_traces: Vec\u003cOption\u003cRowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e\u003e = instances\n                .iter()\n                .map(|inst| inst.air.preprocessed_trace())\n                .collect();\n            let debug_instances: Vec\u003cLookupDebugInstance\u003c'_, Val\u003cSC\u003e\u003e\u003e = instances\n                .iter()\n                .zip(preprocessed_traces.iter())\n                .map(|(inst, prep)| LookupDebugInstance {\n                    main_trace: \u0026inst.trace,\n                    preprocessed_trace: prep,\n                    public_values: \u0026inst.public_values,\n                    lookups: \u0026inst.lookups,\n                    permutation_challenges: \u0026[],\n                })\n                .collect();\n            check_lookups(\u0026debug_instances);\n        }\n\n        let proof = p3_batch_stark::prove_batch(\u0026self.config, \u0026instances, prover_data);\n\n        // Ensure all primitive table row counts are at least 1\n        // RowCounts::new requires non-zero counts, so pad zeros to 1\n        let witness_rows_padded = witness_rows.max(1);\n        let const_rows_padded = const_rows.max(1);\n        let public_rows_padded = public_rows.max(1);\n        let alu_rows_padded = alu_rows.max(1);\n\n        // Store the effective packing (with reduced lanes if applicable) so the verifier\n        // uses the same configuration that was actually used during proving.\n        let effective_packing = TablePacking::new(witness_lanes, public_lanes, alu_lanes)\n            .with_min_trace_height(min_height);\n\n        Ok(BatchStarkProof {\n            proof,\n            table_packing: effective_packing,\n            rows: RowCounts::new([\n                witness_rows_padded,\n                const_rows_padded,\n                public_rows_padded,\n                alu_rows_padded,\n            ]),\n            alu_variant: self.alu_variant,\n            ext_degree: D,\n            w_binomial: if D \u003e 1 { w_binomial } else { None },\n            non_primitives,\n        })\n    }\n\n    /// Verify a batch STARK proof for a specific extension field degree.\n    ///\n    /// This reconstructs the AIRs from the proof metadata and verifies the proof\n    /// against all circuit tables. The AIRs are reconstructed using the same\n    /// configuration that was used during proof generation.\n    fn verify\u003cconst D: usize\u003e(\n        \u0026self,\n        proof: \u0026BatchStarkProof\u003cSC\u003e,\n        w_binomial: Option\u003cVal\u003cSC\u003e\u003e,\n        common: \u0026CommonData\u003cSC\u003e,\n    ) -\u003e Result\u003c(), BatchStarkProverError\u003e {\n        // Rebuild AIRs in the same order as prove.\n        let packing = proof.table_packing;\n        let witness_lanes = packing.witness_lanes();\n        let public_lanes = packing.public_lanes();\n        let alu_lanes = packing.alu_lanes();\n        let min_height = packing.min_trace_height();\n\n        let witness_air = CircuitTableAir::Witness(\n            WitnessAir::\u003cVal\u003cSC\u003e, D\u003e::new(proof.rows[PrimitiveTable::Witness], witness_lanes)\n                .with_min_height(min_height),\n        );\n        let const_air = CircuitTableAir::Const(\n            ConstAir::\u003cVal\u003cSC\u003e, D\u003e::new(proof.rows[PrimitiveTable::Const])\n                .with_min_height(min_height),\n        );\n        let public_air = CircuitTableAir::Public(\n            PublicAir::\u003cVal\u003cSC\u003e, D\u003e::new(proof.rows[PrimitiveTable::Public], public_lanes)\n                .with_min_height(min_height),\n        );\n        let alu_air: CircuitTableAir\u003cSC, D\u003e = if D == 1 {\n            CircuitTableAir::Alu(\n                AluAir::\u003cVal\u003cSC\u003e, D\u003e::new(proof.rows[PrimitiveTable::Alu], alu_lanes)\n                    .with_min_height(min_height),\n            )\n        } else {\n            let w = w_binomial.ok_or(BatchStarkProverError::MissingWForExtension)?;\n            CircuitTableAir::Alu(\n                AluAir::\u003cVal\u003cSC\u003e, D\u003e::new_binomial(proof.rows[PrimitiveTable::Alu], alu_lanes, w)\n                    .with_min_height(min_height),\n            )\n        };\n        let mut airs = vec![witness_air, const_air, public_air, alu_air];\n        // TODO: Handle public values.\n        let mut pvs: Vec\u003cVec\u003cVal\u003cSC\u003e\u003e\u003e = vec![Vec::new(); NUM_PRIMITIVE_TABLES];\n\n        for entry in \u0026proof.non_primitives {\n            let plugin = self\n                .non_primitive_provers\n                .iter()\n                .find(|p| {\n                    let tp = p.as_ref();\n                    TableProver::op_type(tp) == entry.op_type\n                })\n                .ok_or_else(|| {\n                    BatchStarkProverError::Verify(format!(\n                        \"unknown non-primitive op: {:?}\",\n                        entry.op_type\n                    ))\n                })?;\n            let air = plugin\n                .batch_air_from_table_entry(\u0026self.config, D, entry)\n                .map_err(BatchStarkProverError::Verify)?;\n            airs.push(CircuitTableAir::Dynamic(air));\n            pvs.push(entry.public_values.clone());\n        }\n\n        p3_batch_stark::verify_batch(\u0026self.config, \u0026airs, \u0026proof.proof, \u0026pvs, common)\n            .map_err(|e| BatchStarkProverError::Verify(format!(\"{e:?}\")))\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":98,"address":[5662048],"length":1,"stats":{"Line":7}},{"line":109,"address":[5662032],"length":1,"stats":{"Line":6}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[2341216],"length":1,"stats":{"Line":4}},{"line":225,"address":[7114579],"length":1,"stats":{"Line":6}},{"line":226,"address":[2133580,2133753],"length":1,"stats":{"Line":10}},{"line":227,"address":[6361654],"length":1,"stats":{"Line":6}},{"line":228,"address":[4179417,4179454],"length":1,"stats":{"Line":4}},{"line":230,"address":[8664531],"length":1,"stats":{"Line":4}},{"line":235,"address":[7114480],"length":1,"stats":{"Line":0}},{"line":236,"address":[11360341,11360379],"length":1,"stats":{"Line":0}},{"line":242,"address":[11355680],"length":1,"stats":{"Line":4}},{"line":243,"address":[4174553,4174598],"length":1,"stats":{"Line":4}},{"line":248,"address":[6225360],"length":1,"stats":{"Line":0}},{"line":249,"address":[6532835],"length":1,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[4722368,4722784,4723200,4722576,4722992],"length":1,"stats":{"Line":16}},{"line":327,"address":[4200157,4199741,4200365,4199949,4199533],"length":1,"stats":{"Line":16}},{"line":328,"address":[4199596,4200220,4200428,4199804,4200012],"length":1,"stats":{"Line":16}},{"line":329,"address":[4723093,4722677,4722469,4723301,4722885],"length":1,"stats":{"Line":15}},{"line":330,"address":[8011774,8012398,8012190,8011982,8012606],"length":1,"stats":{"Line":13}},{"line":331,"address":[4722519,4722727,4722935,4723351,4723143],"length":1,"stats":{"Line":15}},{"line":332,"address":[4199900,4199692,4200316,4200524,4200108],"length":1,"stats":{"Line":2}},{"line":336,"address":[8011200,8011424],"length":1,"stats":{"Line":12}},{"line":337,"address":[4199320],"length":1,"stats":{"Line":10}},{"line":338,"address":[4199389],"length":1,"stats":{"Line":12}},{"line":339,"address":[8011319,8011543],"length":1,"stats":{"Line":12}},{"line":340,"address":[8011569,8011345],"length":1,"stats":{"Line":12}},{"line":341,"address":[4722091,4722315],"length":1,"stats":{"Line":10}},{"line":342,"address":[],"length":0,"stats":{"Line":2}},{"line":343,"address":[8011397,8011621],"length":1,"stats":{"Line":2}},{"line":351,"address":[4720576,4720352,4721024,4724080,4724304,4721696,4720800,4721248,4721472,4723856,4724528,4724752,4724976,4725200],"length":1,"stats":{"Line":52}},{"line":352,"address":[4724328,4725224,4720600,4724552,4721272,4724776,4721048,4720376,4720824,4721496,4723880,4721720,4724104,4725000],"length":1,"stats":{"Line":50}},{"line":353,"address":[12527661,12528765,12528989,12529429,12530093,12539837,12538525,12539181,12538741,12528109,12526381,12535885,12527029,12538957,12535669,12536309,12539405,12527237,12536973,12539621,12537629,12526157,12529213,12529869,12537413,12537197,12536525,12528325,12527885,12527445,12528541,12538301,12526605,12525933,12536101,12538077,12526821,12529645,12536749,12537853],"length":1,"stats":{"Line":51}},{"line":354,"address":[4721143,4720695,4721367,4721815,4723975,4724199,4724871,4720471,4721591,4725095,4720919,4724423,4724647,4725319],"length":1,"stats":{"Line":46}},{"line":355,"address":[12537249,12538793,12529481,12527081,12536153,12527937,12539233,12538129,12536801,12526873,12536577,12526433,12529041,12528377,12539457,12529265,12537025,12527289,12539009,12530145,12529697,12538577,12528593,12529921,12537681,12535721,12537465,12528817,12536361,12525985,12527497,12528161,12538353,12537905,12526657,12535937,12539673,12527713,12539889,12526209],"length":1,"stats":{"Line":50}},{"line":356,"address":[12535747,12527963,12529723,12526899,12527315,12529291,12529507,12537707,12527739,12528187,12528403,12528619,12538155,12526011,12538379,12536387,12530171,12526235,12536179,12537491,12538819,12535963,12527107,12536827,12537931,12536603,12539259,12526459,12539483,12538603,12529067,12537275,12528843,12539915,12527523,12539699,12537051,12529947,12539035,12526683],"length":1,"stats":{"Line":48}},{"line":357,"address":[4200977,4201425,4199041,4198369,4198145,4198817,4201873,4202097,4199265,4201201,4198593,4201649],"length":1,"stats":{"Line":9}},{"line":371,"address":[4200560],"length":1,"stats":{"Line":11}},{"line":372,"address":[8012936,8012712],"length":1,"stats":{"Line":11}},{"line":373,"address":[12534549,12534781,12535229,12535005,12535453],"length":1,"stats":{"Line":11}},{"line":374,"address":[4200679],"length":1,"stats":{"Line":11}},{"line":375,"address":[12535281,12535505,12534601,12534833,12535057],"length":1,"stats":{"Line":12}},{"line":376,"address":[12534627,12535307,12535531,12535083,12534859],"length":1,"stats":{"Line":12}},{"line":377,"address":[12535105,12535553,12535329,12534649,12534881],"length":1,"stats":{"Line":3}},{"line":431,"address":[5038965,5038704],"length":1,"stats":{"Line":7}},{"line":434,"address":[5619315],"length":1,"stats":{"Line":7}},{"line":436,"address":[2916211],"length":1,"stats":{"Line":7}},{"line":442,"address":[5619088],"length":1,"stats":{"Line":4}},{"line":443,"address":[5619096],"length":1,"stats":{"Line":4}},{"line":444,"address":[],"length":0,"stats":{"Line":4}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[5619168],"length":1,"stats":{"Line":2}},{"line":458,"address":[],"length":0,"stats":{"Line":2}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[5619216],"length":1,"stats":{"Line":2}},{"line":477,"address":[5619236],"length":1,"stats":{"Line":2}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[6232544,6234560,6235538,6233516,6232493,6235544,6231475,6231520,6234518,6233552,6231469,6230496,6232499,6233510,6234524],"length":1,"stats":{"Line":13}},{"line":506,"address":[2915423,2914813],"length":1,"stats":{"Line":24}},{"line":507,"address":[5617469,5618493],"length":1,"stats":{"Line":12}},{"line":508,"address":[2915471],"length":1,"stats":{"Line":6}},{"line":509,"address":[],"length":0,"stats":{"Line":1}},{"line":510,"address":[5617510],"length":1,"stats":{"Line":4}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":1}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[5618720],"length":1,"stats":{"Line":6}},{"line":523,"address":[5618763],"length":1,"stats":{"Line":6}},{"line":524,"address":[6236465,6235761,6236097],"length":1,"stats":{"Line":5}},{"line":525,"address":[],"length":0,"stats":{"Line":1}},{"line":526,"address":[],"length":0,"stats":{"Line":3}},{"line":527,"address":[5619006],"length":1,"stats":{"Line":0}},{"line":528,"address":[5619045],"length":1,"stats":{"Line":1}},{"line":529,"address":[2915759],"length":1,"stats":{"Line":0}},{"line":538,"address":[2926625,2916400,2925299],"length":1,"stats":{"Line":14}},{"line":547,"address":[5629940,5619669],"length":1,"stats":{"Line":13}},{"line":548,"address":[],"length":0,"stats":{"Line":13}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[5039261,5049886],"length":1,"stats":{"Line":13}},{"line":554,"address":[6268822,6279015,6247973,6237782,6258405],"length":1,"stats":{"Line":13}},{"line":555,"address":[5619890,5630161],"length":1,"stats":{"Line":13}},{"line":556,"address":[],"length":0,"stats":{"Line":13}},{"line":566,"address":[5039525,5050150],"length":1,"stats":{"Line":13}},{"line":568,"address":[],"length":0,"stats":{"Line":19}},{"line":569,"address":[2917439],"length":1,"stats":{"Line":1}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[5040001,5050626],"length":1,"stats":{"Line":2}},{"line":577,"address":[2916953],"length":1,"stats":{"Line":11}},{"line":580,"address":[5620330,5631223,5630601,5620952],"length":1,"stats":{"Line":13}},{"line":583,"address":[6259579,6280189,6238956,6249147,6269996],"length":1,"stats":{"Line":15}},{"line":584,"address":[6270017,6239189,6280210,6259600,6259812,6280426,6249380,6270229,6238977,6249168],"length":1,"stats":{"Line":13}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":15}},{"line":591,"address":[2918080,2918149],"length":1,"stats":{"Line":26}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":25}},{"line":596,"address":[6239332,6249523,6270372,6280569,6259955],"length":1,"stats":{"Line":14}},{"line":597,"address":[5040952,5051577],"length":1,"stats":{"Line":12}},{"line":598,"address":[],"length":0,"stats":{"Line":14}},{"line":599,"address":[2918515,2918447],"length":1,"stats":{"Line":24}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[6249812,6239621,6280862,6249877,6239686,6280927,6260244,6260309,6270661,6270726],"length":1,"stats":{"Line":26}},{"line":605,"address":[],"length":0,"stats":{"Line":17}},{"line":606,"address":[2919110,2918828,2918747,2919238],"length":1,"stats":{"Line":4}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[6260802,6271219,6240179,6250370,6281420],"length":1,"stats":{"Line":1}},{"line":614,"address":[5621779,5621951,5632222,5632050],"length":1,"stats":{"Line":24}},{"line":617,"address":[6250760,6281126,6281810,6239885,6261192,6271609,6250076,6240569,6270925,6260508],"length":1,"stats":{"Line":26}},{"line":618,"address":[2919495],"length":1,"stats":{"Line":12}},{"line":619,"address":[6240689,6261312,6281934,6271729,6250880],"length":1,"stats":{"Line":14}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[6250967,6282021,6261399,6271816,6240776],"length":1,"stats":{"Line":12}},{"line":622,"address":[6250990,6240875,6240799,6271915,6282120,6251066,6261422,6282044,6271839,6261498],"length":1,"stats":{"Line":26}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[6240951,6251074,6251142,6271991,6261574,6282196,6240883,6261506,6282128,6271923],"length":1,"stats":{"Line":26}},{"line":630,"address":[2920079,2919881,2920299],"length":1,"stats":{"Line":25}},{"line":632,"address":[2919911,2920172],"length":1,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[6241313,6272353,6261936,6282564,6251504],"length":1,"stats":{"Line":0}},{"line":636,"address":[6251156,6282268,6261646,6272005,6240965,6261588,6272063,6282210,6241023,6251214],"length":1,"stats":{"Line":26}},{"line":638,"address":[5042766,5053391,5053760],"length":1,"stats":{"Line":20}},{"line":639,"address":[5053544],"length":1,"stats":{"Line":6}},{"line":640,"address":[],"length":0,"stats":{"Line":8}},{"line":642,"address":[],"length":0,"stats":{"Line":12}},{"line":643,"address":[],"length":0,"stats":{"Line":6}},{"line":644,"address":[],"length":0,"stats":{"Line":5}},{"line":646,"address":[5634244,5623600,5634136,5623747],"length":1,"stats":{"Line":28}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[2920647,2920587],"length":1,"stats":{"Line":26}},{"line":652,"address":[5043633,5049033,5054032,5059408],"length":1,"stats":{"Line":4}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[5639811,5639858,5629241,5629349,5639750,5629302],"length":1,"stats":{"Line":6}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[6278189,6288656,6257578,6268010,6247149],"length":1,"stats":{"Line":2}},{"line":658,"address":[5059519,5060739,5060784,5060803,5049144,5060720],"length":1,"stats":{"Line":6}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":12}},{"line":665,"address":[6241915,6262764,6272955,6283396,6252332],"length":1,"stats":{"Line":14}},{"line":666,"address":[5624025,5624123],"length":1,"stats":{"Line":13}},{"line":667,"address":[6273077,6242037],"length":1,"stats":{"Line":6}},{"line":668,"address":[5628936,5624299],"length":1,"stats":{"Line":0}},{"line":669,"address":[2925905],"length":1,"stats":{"Line":0}},{"line":672,"address":[6252340,6283404,6262772],"length":1,"stats":{"Line":6}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":2}},{"line":675,"address":[],"length":0,"stats":{"Line":1}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[5634516],"length":1,"stats":{"Line":5}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[5634526,5634624],"length":1,"stats":{"Line":7}},{"line":683,"address":[],"length":0,"stats":{"Line":4}},{"line":684,"address":[5044095],"length":1,"stats":{"Line":2}},{"line":685,"address":[5635000],"length":1,"stats":{"Line":2}},{"line":688,"address":[],"length":0,"stats":{"Line":1}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":1}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":2}},{"line":699,"address":[6262868],"length":1,"stats":{"Line":1}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[6263258],"length":1,"stats":{"Line":0}},{"line":708,"address":[2920880,2921205],"length":1,"stats":{"Line":26}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[5624506,5624443,5635265,5635202],"length":1,"stats":{"Line":26}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":28}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[5635557,5635485,5624726,5624798],"length":1,"stats":{"Line":28}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[2921645],"length":1,"stats":{"Line":14}},{"line":719,"address":[5635854,5625095],"length":1,"stats":{"Line":13}},{"line":720,"address":[],"length":0,"stats":{"Line":14}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[6284774,6243039,6274079,6264150,6253718],"length":1,"stats":{"Line":13}},{"line":725,"address":[2921999],"length":1,"stats":{"Line":13}},{"line":726,"address":[6243222,6264333,6274262,6284951,6253901],"length":1,"stats":{"Line":14}},{"line":727,"address":[5625406,5636165],"length":1,"stats":{"Line":13}},{"line":729,"address":[],"length":0,"stats":{"Line":13}},{"line":730,"address":[],"length":0,"stats":{"Line":12}},{"line":731,"address":[6274665,6264736,6254304,6285348,6243625],"length":1,"stats":{"Line":14}},{"line":733,"address":[5625761,5636520],"length":1,"stats":{"Line":12}},{"line":734,"address":[6243822,6254501,6285577,6264933,6274862],"length":1,"stats":{"Line":13}},{"line":735,"address":[2922846],"length":1,"stats":{"Line":11}},{"line":737,"address":[5626056,5639595,5628825,5636815,5626246,5637005],"length":1,"stats":{"Line":26}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[5626383,5637142],"length":1,"stats":{"Line":2}},{"line":740,"address":[],"length":0,"stats":{"Line":2}},{"line":741,"address":[2923268],"length":1,"stats":{"Line":2}},{"line":742,"address":[5637235,5626476],"length":1,"stats":{"Line":2}},{"line":743,"address":[6286161,6275446,6255085,6244406,6265517],"length":1,"stats":{"Line":2}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[6275470,6286185,6255109,6244430,6265541],"length":1,"stats":{"Line":2}},{"line":746,"address":[],"length":0,"stats":{"Line":2}},{"line":747,"address":[5058811,5048697],"length":1,"stats":{"Line":2}},{"line":748,"address":[2925563],"length":1,"stats":{"Line":2}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[5058876,5048762],"length":1,"stats":{"Line":2}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[2923455],"length":1,"stats":{"Line":13}},{"line":758,"address":[5626701,5637460],"length":1,"stats":{"Line":11}},{"line":759,"address":[6255333,6244654,6275694,6265765,6286403],"length":1,"stats":{"Line":13}},{"line":760,"address":[2927050,2926704,2927068,2926729,2923683],"length":1,"stats":{"Line":35}},{"line":761,"address":[5060370,5061154],"length":1,"stats":{"Line":13}},{"line":763,"address":[5060518,5061302],"length":1,"stats":{"Line":16}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[6291025,6290593,6289585,6292257,6291473],"length":1,"stats":{"Line":11}},{"line":766,"address":[5641631,5640847],"length":1,"stats":{"Line":14}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":16}},{"line":775,"address":[5637699,5626940],"length":1,"stats":{"Line":0}},{"line":777,"address":[2927088,2923890,2927109],"length":1,"stats":{"Line":0}},{"line":779,"address":[6245010,6276050,6255689,6286759,6266121],"length":1,"stats":{"Line":0}},{"line":781,"address":[6266263,6286898,6255831,6245152,6276192],"length":1,"stats":{"Line":0}},{"line":782,"address":[2927248,2927367,2924213,2927293],"length":1,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[5060903,5060071],"length":1,"stats":{"Line":0}},{"line":786,"address":[6292926,6291966,6291790,6292751,6289950],"length":1,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[6255982,6287046,6266414,6256049,6245309,6276349,6245376,6276416,6266481,6287113],"length":1,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":31}},{"line":797,"address":[5627664,5638342,5627589,5638417],"length":1,"stats":{"Line":24}},{"line":798,"address":[5638425,5627672],"length":1,"stats":{"Line":11}},{"line":799,"address":[6256277,6245604,6266709,6276644,6287341],"length":1,"stats":{"Line":11}},{"line":800,"address":[6266751,6245646,6276686,6287383,6256319],"length":1,"stats":{"Line":10}},{"line":804,"address":[5047852,5057983],"length":1,"stats":{"Line":11}},{"line":805,"address":[6276783,6287480,6256416,6245743,6266848],"length":1,"stats":{"Line":10}},{"line":807,"address":[2924964],"length":1,"stats":{"Line":11}},{"line":808,"address":[5058053,5047922],"length":1,"stats":{"Line":10}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[2924758],"length":1,"stats":{"Line":12}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[5628033,5638786],"length":1,"stats":{"Line":12}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[2924875],"length":1,"stats":{"Line":10}},{"line":819,"address":[6267054,6256622,6287690,6276972,6245932],"length":1,"stats":{"Line":11}},{"line":828,"address":[5071830,5065136,5068237,5068438,5072064,5079199,5061552,5064902,5068480,5075414,5065103,5072031,5078998,5075615,5075648],"length":1,"stats":{"Line":10}},{"line":835,"address":[2931109,2927525,2934693,2938262,2941621],"length":1,"stats":{"Line":10}},{"line":836,"address":[5642043,5649211,5652780,5656139,5645627],"length":1,"stats":{"Line":11}},{"line":837,"address":[5645692,5656204,5649276,5642108,5652845],"length":1,"stats":{"Line":11}},{"line":838,"address":[2931312,2934896,2938465,2941824,2927728],"length":1,"stats":{"Line":11}},{"line":839,"address":[6321208,6335432,6324744,6297033,6317850,6328280,6314328,6300344,6303880,6331818,6342584,6338970,6307401,6293434,6310714],"length":1,"stats":{"Line":11}},{"line":842,"address":[],"length":0,"stats":{"Line":11}},{"line":843,"address":[2938714,2931561,2927977,2942073,2935145],"length":1,"stats":{"Line":11}},{"line":846,"address":[5069217,5065785,5076312,5072728,5062289,5072801,5076385,5069144,5065858,5062216],"length":1,"stats":{"Line":20}},{"line":847,"address":[],"length":0,"stats":{"Line":10}},{"line":850,"address":[6328755,6300910,6300819,6318313,6335998,6339433,6293897,6318404,6307876,6332372,6297599,6304355,6293988,6297508,6321683,6328846,6335907,6311268,6332281,6339524,6314894,6311177,6307967,6343059,6304446,6314803,6325310,6321774,6325219,6343150],"length":1,"stats":{"Line":22}},{"line":851,"address":[5642877,5650045,5653614,5656973,5646461],"length":1,"stats":{"Line":11}},{"line":853,"address":[2939470],"length":1,"stats":{"Line":5}},{"line":855,"address":[5066347,5066197],"length":1,"stats":{"Line":10}},{"line":856,"address":[5066389],"length":1,"stats":{"Line":5}},{"line":859,"address":[],"length":0,"stats":{"Line":10}},{"line":861,"address":[5076998,5062902,5069830,5073414],"length":1,"stats":{"Line":5}},{"line":862,"address":[],"length":0,"stats":{"Line":6}},{"line":865,"address":[],"length":0,"stats":{"Line":24}},{"line":867,"address":[5658101,5651173,5654428,5643925,5654508,5658021,5651093,5644005,5647509,5647589],"length":1,"stats":{"Line":24}},{"line":869,"address":[6327668,6333689,6310091,6317252,6302170,6333606,6341957,6323034,6340841,6306804,6326570,6299723,6338356,6312502,6305623,6319481,6324132,6330023,6337175,6331204,6313701,6316154,6296421,6298625,6305706,6303268,6302087,6330106,6322951,6344410,6326487,6308993,6316071,6334805,6344327,6319398,6295305,6312585,6295222,6340758,6320591,6337258,6308910,6298542,6345508],"length":1,"stats":{"Line":25}},{"line":870,"address":[],"length":0,"stats":{"Line":6}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":4}},{"line":874,"address":[5660558,5660750,5660654,5660846,5659982],"length":1,"stats":{"Line":2}},{"line":875,"address":[6352048,6350976,6346400,6351792,6349984,6346144,6348352,6353152,6345808,6346496,6352400,6350240,6352144,6349728,6352896],"length":1,"stats":{"Line":2}},{"line":877,"address":[],"length":0,"stats":{"Line":2}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[2933898,2940884,2933965,2934049,2937633,2944477,2930465,2930314,2937482,2930381,2944561,2940817,2937549,2944410,2940968],"length":1,"stats":{"Line":4}},{"line":884,"address":[6327259,6330795,6302859,6313294,6296014,6309682,6320184,6341550,6306395,6334398,6316843,6323723,6299314,6345099,6337947],"length":1,"stats":{"Line":2}},{"line":885,"address":[2940936,2930433,2937526,2933942,2934017,2944454,2930358,2937601,2940861,2944529],"length":1,"stats":{"Line":2}},{"line":886,"address":[6327499,6331035,6306635,6334638,6317083,6296254,6338187,6345339,6323963,6309922,6313534,6303099,6320424,6299554,6341790],"length":1,"stats":{"Line":2}},{"line":887,"address":[5648733,5655652,5652317,5659245,5645149],"length":1,"stats":{"Line":2}},{"line":890,"address":[],"length":0,"stats":{"Line":11}},{"line":891,"address":[],"length":0,"stats":{"Line":11}}],"covered":208,"coverable":309},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","common.rs"],"content":"use alloc::collections::btree_map::BTreeMap;\nuse alloc::vec;\nuse alloc::vec::Vec;\n\nuse hashbrown::HashMap;\nuse p3_circuit::op::{\n    NonPrimitiveOpType, NonPrimitivePreprocessedMap, Poseidon2Config, PrimitiveOpType,\n};\nuse p3_circuit::{Circuit, CircuitError, PreprocessedColumns};\nuse p3_field::{ExtensionField, PrimeCharacteristicRing, PrimeField64};\nuse p3_uni_stark::{StarkGenericConfig, SymbolicExpression, Val};\nuse p3_util::log2_ceil_usize;\n\nuse crate::air::{AluAir, ConstAir, PublicAir, WitnessAir};\nuse crate::config::StarkField;\nuse crate::constraint_profile::ConstraintProfile;\nuse crate::field_params::ExtractBinomialW;\nuse crate::{DynamicAirEntry, Poseidon2Prover, TablePacking};\n\n/// Enum wrapper to allow heterogeneous table AIRs in a single batch STARK aggregation.\n///\n/// This enables different AIR types to be collected into a single vector for\n/// batch STARK proving/verification while maintaining type safety.\npub enum CircuitTableAir\u003cSC, const D: usize\u003e\nwhere\n    SC: StarkGenericConfig,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    Witness(WitnessAir\u003cVal\u003cSC\u003e, D\u003e),\n    Const(ConstAir\u003cVal\u003cSC\u003e, D\u003e),\n    Public(PublicAir\u003cVal\u003cSC\u003e, D\u003e),\n    /// Unified ALU table for all arithmetic operations\n    Alu(AluAir\u003cVal\u003cSC\u003e, D\u003e),\n    Dynamic(DynamicAirEntry\u003cSC\u003e),\n}\n\n/// Non-primitive operation configurations.\n///\n/// This enables the preprocessing of preprocessing data depending on the non-primitive configurations.\npub enum NonPrimitiveConfig {\n    Poseidon2(Poseidon2Config),\n}\n\nimpl\u003cSC, const D: usize\u003e Clone for CircuitTableAir\u003cSC, D\u003e\nwhere\n    SC: StarkGenericConfig,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    fn clone(\u0026self) -\u003e Self {\n        match self {\n            Self::Witness(air) =\u003e Self::Witness(air.clone()),\n            Self::Const(air) =\u003e Self::Const(air.clone()),\n            Self::Public(air) =\u003e Self::Public(air.clone()),\n            Self::Alu(air) =\u003e Self::Alu(air.clone()),\n            Self::Dynamic(air) =\u003e Self::Dynamic(air.clone()),\n        }\n    }\n}\n\n/// Type alias for a vector of circuit table AIRs paired with their respective degrees (log of their trace height).\ntype CircuitAirsWithDegrees\u003cSC, const D: usize\u003e = Vec\u003c(CircuitTableAir\u003cSC, D\u003e, usize)\u003e;\n\npub fn get_airs_and_degrees_with_prep\u003c\n    SC: StarkGenericConfig + 'static + Send + Sync,\n    ExtF: ExtensionField\u003cVal\u003cSC\u003e\u003e + ExtractBinomialW\u003cVal\u003cSC\u003e\u003e,\n    const D: usize,\n\u003e(\n    circuit: \u0026Circuit\u003cExtF\u003e,\n    packing: TablePacking,\n    non_primitive_configs: Option\u003c\u0026[NonPrimitiveConfig]\u003e,\n    constraint_profile: ConstraintProfile,\n) -\u003e Result\u003c(CircuitAirsWithDegrees\u003cSC, D\u003e, PreprocessedColumns\u003cVal\u003cSC\u003e\u003e), CircuitError\u003e\nwhere\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n    Val\u003cSC\u003e: StarkField,\n{\n    let mut preprocessed = circuit.generate_preprocessed_columns()?;\n\n    // Check if Public/Alu tables are empty and lanes \u003e 1.\n    // Using lanes \u003e 1 with empty tables causes issues in recursive verification\n    // due to a bug in how multi-lane padding interacts with lookup constraints.\n    // We automatically reduce lanes to 1 in these cases with a warning.\n    // IMPORTANT: This must be synchronized with prove_all_tables in batch_stark_prover.rs\n    let witness_idx = PrimitiveOpType::Witness as usize;\n    let public_idx = PrimitiveOpType::Public as usize;\n    let alu_idx = PrimitiveOpType::Alu as usize;\n\n    let public_rows = preprocessed.primitive[public_idx].len();\n    let public_trace_only_dummy = public_rows \u003c= 1;\n    let effective_public_lanes = if public_trace_only_dummy \u0026\u0026 packing.public_lanes() \u003e 1 {\n        tracing::warn!(\n            \"Public table has \u003c=1 row but public_lanes={} \u003e 1. Reducing to public_lanes=1 to avoid \\\n             recursive verification issues. Consider using public_lanes=1 when few public inputs \\\n             are expected.\",\n            packing.public_lanes()\n        );\n        1\n    } else {\n        packing.public_lanes()\n    };\n\n    let alu_empty = preprocessed.primitive[alu_idx].is_empty();\n    let effective_alu_lanes = if alu_empty \u0026\u0026 packing.alu_lanes() \u003e 1 {\n        tracing::warn!(\n            \"ALU table is empty but alu_lanes={} \u003e 1. Reducing to alu_lanes=1 to avoid \\\n             recursive verification issues. Consider using alu_lanes=1 when no additions \\\n             are expected.\",\n            packing.alu_lanes()\n        );\n        1\n    } else {\n        packing.alu_lanes()\n    };\n\n    // If Alu table is empty, we add a dummy row to avoid issues in the AIRs.\n    // That means we need to update the witness multiplicities accordingly.\n    if alu_empty {\n        let num_extra = AluAir::\u003cVal\u003cSC\u003e, D\u003e::lane_width() / D;\n        preprocessed.primitive[witness_idx][0] += ExtF::from_usize(num_extra);\n        preprocessed.primitive[alu_idx].extend(vec![\n            ExtF::ZERO;\n            AluAir::\u003cVal\u003cSC\u003e, D\u003e::preprocessed_lane_width()\n                - 1\n        ]);\n    }\n\n    let w_binomial = ExtF::extract_w();\n    // First, get base field elements for the preprocessed values.\n    let mut base_prep: Vec\u003cVec\u003cVal\u003cSC\u003e\u003e\u003e = preprocessed\n        .primitive\n        .iter()\n        .map(|vals| {\n            vals.iter()\n                .map(|v| v.as_base().ok_or(CircuitError::InvalidPreprocessedValues))\n                .collect::\u003cResult\u003cVec\u003c_\u003e, CircuitError\u003e\u003e()\n        })\n        .collect::\u003cResult\u003cVec\u003c_\u003e, CircuitError\u003e\u003e()?;\n\n    // Pre-processing: Update witness multiplicities for mmcs_index_sum lookups.\n    //\n    // The Poseidon2 AIR sends an mmcs_index_sum lookup when:\n    //   next_row.new_start * current_row.merkle_path = 1\n    //\n    // This lookup uses the witness index from mmcs_index_sum_ctl_idx (which is 0 when\n    // mmcs_index_sum is not explicitly set). The preprocessing function doesn't update\n    // witness multiplicities for this case because it processes operations one at a time\n    // without knowing the next operation's new_start value.\n    //\n    // We fix this by scanning the Poseidon2 preprocessed data and incrementing the witness\n    // multiplicity for each such lookup.\n    //\n    // This must be done BEFORE creating the Witness AIR so it captures the correct multiplicities.\n    //\n    // TODO: Update these indices once generic Poseidon2 is implemented.\n    // Poseidon2 preprocessed row layout (24 fields per row):\n    //   [0..16]  = 4 input limbs (each: in_idx, in_ctl, normal_chain_sel, merkle_chain_sel)\n    //   [16..20] = 2 output limbs (each: out_idx, out_ctl)\n    //   [20]     = mmcs_index_sum_ctl_idx\n    //   [21]     = mmcs_merkle_flag (precomputed: mmcs_ctl * merkle_path)\n    //   [22]     = new_start\n    //   [23]     = merkle_path\n    const POSEIDON2_PREP_ROW_WIDTH: usize = 24;\n    const MMCS_INDEX_SUM_CTL_IDX_OFFSET: usize = 20;\n    const MMCS_MERKLE_FLAG_OFFSET: usize = 21;\n    const NEW_START_OFFSET: usize = 22;\n\n    let mut mmcs_lookup_count = 0usize;\n    for (op_type, prep) in preprocessed.non_primitive.iter() {\n        if matches!(op_type, NonPrimitiveOpType::Poseidon2Perm(_)) {\n            let prep_base: Vec\u003cVal\u003cSC\u003e\u003e = prep\n                .iter()\n                .map(|v| v.as_base().ok_or(CircuitError::InvalidPreprocessedValues))\n                .collect::\u003cResult\u003cVec\u003c_\u003e, CircuitError\u003e\u003e()?;\n\n            let num_rows = prep_base.len() / POSEIDON2_PREP_ROW_WIDTH;\n\n            // Check if padding will be added (trace height is padded to power of two)\n            let trace_height = num_rows.next_power_of_two();\n            let has_padding = trace_height \u003e num_rows;\n\n            for row_idx in 0..num_rows {\n                let row_start = row_idx * POSEIDON2_PREP_ROW_WIDTH;\n                // mmcs_merkle_flag is precomputed as: mmcs_ctl * merkle_path\n                let current_mmcs_merkle_flag = prep_base[row_start + MMCS_MERKLE_FLAG_OFFSET];\n\n                // Check if next row exists and has new_start = 1\n                // Note: The Poseidon2 AIR pads the trace and sets new_start = 1 in the first\n                // padding row (only if padding exists). This means the LAST real row will\n                // also trigger a lookup if its mmcs_merkle_flag = 1 and there is padding.\n                let next_new_start = if row_idx + 1 \u003c num_rows {\n                    let next_row_start = (row_idx + 1) * POSEIDON2_PREP_ROW_WIDTH;\n                    prep_base[next_row_start + NEW_START_OFFSET]\n                } else if has_padding {\n                    // Last real row with padding - the AIR sets new_start = 1 in first padding row\n                    \u003cVal\u003cSC\u003e as PrimeCharacteristicRing\u003e::ONE\n                } else {\n                    // No padding - the AIR wraps around (cyclically), so next row is the first row\n                    // The first row's new_start value determines the multiplicity\n                    prep_base[NEW_START_OFFSET]\n                };\n\n                // If multiplicity = mmcs_merkle_flag * next_new_start != 0\n                let multiplicity = current_mmcs_merkle_flag * next_new_start;\n                if multiplicity != \u003cVal\u003cSC\u003e as PrimeCharacteristicRing\u003e::ZERO {\n                    // Get the mmcs_index_sum witness index for this row\n                    let mmcs_idx = prep_base[row_start + MMCS_INDEX_SUM_CTL_IDX_OFFSET];\n\n                    // Convert to usize for indexing\n                    // The witness index should be a small integer that fits in usize\n                    let mmcs_idx_u64 = \u003cVal\u003cSC\u003e as PrimeField64\u003e::as_canonical_u64(\u0026mmcs_idx);\n                    let mmcs_idx_usize = mmcs_idx_u64 as usize;\n\n                    // Ensure witness multiplicity vector is large enough\n                    if mmcs_idx_usize \u003e= base_prep[witness_idx].len() {\n                        base_prep[witness_idx].resize(\n                            mmcs_idx_usize + 1,\n                            \u003cVal\u003cSC\u003e as PrimeCharacteristicRing\u003e::ZERO,\n                        );\n                    }\n\n                    // Increment the multiplicity\n                    base_prep[witness_idx][mmcs_idx_usize] += multiplicity;\n                    mmcs_lookup_count += 1;\n                }\n            }\n        }\n    }\n    if mmcs_lookup_count \u003e 0 {\n        tracing::debug!(\n            \"Updated {} mmcs_index_sum lookups in witness multiplicities\",\n            mmcs_lookup_count\n        );\n    }\n\n    // Now create the AIRs with the updated multiplicities\n    // Get min_height from packing configuration and pass it to AIRs\n    let min_height = packing.min_trace_height();\n\n    // Helper to compute degree that respects min_height\n    let compute_degree = |num_rows: usize| -\u003e usize {\n        let natural_height = num_rows.next_power_of_two();\n        let min_rows = min_height.next_power_of_two();\n        log2_ceil_usize(natural_height.max(min_rows))\n    };\n\n    let default_air = WitnessAir::new(1, 1);\n    let mut table_preps = (0..base_prep.len())\n        .map(|_| (CircuitTableAir::Witness(default_air.clone()), 1))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    base_prep\n        .iter()\n        .enumerate()\n        .try_for_each(|(idx, prep)| -\u003e Result\u003c(), CircuitError\u003e {\n            let table = PrimitiveOpType::from(idx);\n            match table {\n                PrimitiveOpType::Alu =\u003e {\n                    // ALU preprocessed per op (excluding multiplicity): 7 values\n                    // [sel_add_vs_mul, sel_bool, sel_muladd, a_idx, b_idx, c_idx, out_idx]\n                    let lane_without_multiplicities =\n                        AluAir::\u003cVal\u003cSC\u003e, D\u003e::preprocessed_lane_width() - 1;\n                    assert!(\n                        prep.len() % lane_without_multiplicities == 0,\n                        \"ALU preprocessed length {} is not a multiple of {}\",\n                        prep.len(),\n                        lane_without_multiplicities\n                    );\n\n                    let num_ops = prep.len().div_ceil(lane_without_multiplicities);\n                    let alu_air = if D == 1 {\n                        AluAir::new_with_preprocessed(num_ops, effective_alu_lanes, prep.clone())\n                            .with_min_height(min_height)\n                    } else {\n                        let w = w_binomial.unwrap();\n                        AluAir::new_binomial_with_preprocessed(\n                            num_ops,\n                            effective_alu_lanes,\n                            w,\n                            prep.clone(),\n                        )\n                        .with_min_height(min_height)\n                    };\n                    let num_rows = num_ops.div_ceil(packing.alu_lanes());\n                    table_preps[idx] = (CircuitTableAir::Alu(alu_air), compute_degree(num_rows));\n                }\n                PrimitiveOpType::Public =\u003e {\n                    let num_ops = prep.len();\n                    let public_air = PublicAir::new_with_preprocessed(\n                        num_ops,\n                        effective_public_lanes,\n                        prep.clone(),\n                    )\n                    .with_min_height(min_height);\n                    let num_rows = num_ops.div_ceil(effective_public_lanes);\n                    table_preps[idx] = (\n                        CircuitTableAir::Public(public_air),\n                        compute_degree(num_rows),\n                    );\n                }\n                PrimitiveOpType::Const =\u003e {\n                    let height = prep.len();\n                    let const_air = ConstAir::new_with_preprocessed(height, prep.clone())\n                        .with_min_height(min_height);\n                    table_preps[idx] = (CircuitTableAir::Const(const_air), compute_degree(height));\n                }\n                PrimitiveOpType::Witness =\u003e {\n                    let num_witnesses = prep.len();\n                    let witness_air = WitnessAir::new_with_preprocessed(\n                        num_witnesses,\n                        packing.witness_lanes(),\n                        prep.clone(),\n                    )\n                    .with_min_height(min_height);\n                    let num_rows = num_witnesses.div_ceil(packing.witness_lanes());\n                    table_preps[idx] = (\n                        CircuitTableAir::Witness(witness_air),\n                        compute_degree(num_rows),\n                    );\n                }\n            }\n\n            Ok(())\n        })?;\n\n    let mut config_map = BTreeMap::new();\n    if let Some(configs) = non_primitive_configs {\n        for config in configs {\n            match config {\n                NonPrimitiveConfig::Poseidon2(cfg) =\u003e {\n                    let op_type = NonPrimitiveOpType::Poseidon2Perm(*cfg);\n                    config_map.insert(op_type, *cfg);\n                }\n            }\n        }\n    }\n    // Convert non-primitive preprocessed data to base field\n    let mut non_primitive_base: NonPrimitivePreprocessedMap\u003cVal\u003cSC\u003e\u003e = HashMap::new();\n    for (op_type, prep) in preprocessed.non_primitive.iter() {\n        match op_type {\n            NonPrimitiveOpType::Poseidon2Perm(_) =\u003e {\n                let cfg = config_map\n                    .get(op_type)\n                    .copied()\n                    .ok_or(CircuitError::InvalidPreprocessedValues)?;\n                let prep_base: Vec\u003cVal\u003cSC\u003e\u003e = prep\n                    .iter()\n                    .map(|v| v.as_base().ok_or(CircuitError::InvalidPreprocessedValues))\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, CircuitError\u003e\u003e()?;\n                non_primitive_base.insert(*op_type, prep_base.clone());\n                let poseidon2_prover = Poseidon2Prover::new(cfg, constraint_profile);\n                let width = poseidon2_prover.preprocessed_width_from_config();\n                let poseidon2_wrapper =\n                    poseidon2_prover.wrapper_from_config_with_preprocessed(prep_base, min_height);\n                let poseidon2_wrapper_air: CircuitTableAir\u003cSC, D\u003e =\n                    CircuitTableAir::Dynamic(poseidon2_wrapper);\n                let num_rows = prep.len().div_ceil(width);\n                table_preps.push((poseidon2_wrapper_air, compute_degree(num_rows)));\n            }\n            // Unconstrained operations do not use tables\n            NonPrimitiveOpType::Unconstrained =\u003e {}\n        }\n    }\n\n    // Construct the PreprocessedColumns with base field elements\n    let preprocessed_columns = PreprocessedColumns {\n        primitive: base_prep,\n        non_primitive: non_primitive_base,\n    };\n\n    Ok((table_preps, preprocessed_columns))\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[4211851,4209764,4202128],"length":1,"stats":{"Line":10}},{"line":77,"address":[12559577,12549785,12578969,12540057,12569273],"length":1,"stats":{"Line":12}},{"line":84,"address":[12550029,12569517,12540360,12579272,12579213,12550088,12540301,12559821,12569576,12559880],"length":1,"stats":{"Line":10}},{"line":85,"address":[8024940,8024848,8015164,8024972,8015196,8015072],"length":1,"stats":{"Line":22}},{"line":86,"address":[8025044,8015230,8015172,8015268,8024948,8025006],"length":1,"stats":{"Line":23}},{"line":88,"address":[8025073,8025014,8015238,8015297],"length":1,"stats":{"Line":24}},{"line":89,"address":[4726048,4735792],"length":1,"stats":{"Line":13}},{"line":90,"address":[12550405,12580018,12569893,12570322,12541106,12550339,12540677,12579589,12560626,12560131,12540611,12550834,12560197,12569827,12579523],"length":1,"stats":{"Line":14}},{"line":91,"address":[12570045,12570327,12580146,12579649,12550557,12569953,12560754,12560257,12560349,12560631,12550962,12550465,12550839,12540829,12570450,12541234,12579741,12540737,12541111,12580023],"length":1,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[4736306,4726562],"length":1,"stats":{"Line":1}},{"line":99,"address":[8015521,8025297,8015359,8025135],"length":1,"stats":{"Line":23}},{"line":102,"address":[8015537,8025313,8026011,8016235],"length":1,"stats":{"Line":22}},{"line":103,"address":[],"length":0,"stats":{"Line":15}},{"line":104,"address":[4737276,4727532],"length":1,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[12551406,12580440,12541678,12541528,12551256,12561048,12570744,12570894,12561198,12580590],"length":1,"stats":{"Line":20}},{"line":117,"address":[4203881],"length":1,"stats":{"Line":10}},{"line":118,"address":[8017151,8026927],"length":1,"stats":{"Line":3}},{"line":119,"address":[4727923,4737668],"length":1,"stats":{"Line":3}},{"line":120,"address":[12552365,12581619,12542636,12562071,12562207,12542715,12581548,12571859,12552283,12562163,12571903,12542554,12552436,12581466,12571767],"length":1,"stats":{"Line":9}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[4204773,4204842],"length":1,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[8027257,8017501,8026903,8017127],"length":1,"stats":{"Line":24}},{"line":129,"address":[4205075,4205211,4204927,4211849],"length":1,"stats":{"Line":21}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":22}},{"line":133,"address":[8038035,8038387],"length":1,"stats":{"Line":11}},{"line":134,"address":[4215625,4215939,4215904],"length":1,"stats":{"Line":36}},{"line":135,"address":[],"length":0,"stats":{"Line":12}},{"line":167,"address":[12552949,12543224,12582128,12562716,12572412],"length":1,"stats":{"Line":11}},{"line":168,"address":[],"length":0,"stats":{"Line":22}},{"line":169,"address":[12553208,12562975,12582387,12543483,12572671],"length":1,"stats":{"Line":2}},{"line":170,"address":[4211800,4210082,4210218,4209934],"length":1,"stats":{"Line":4}},{"line":172,"address":[4745203,4743072,4733308,4749408,4749443,4745168],"length":1,"stats":{"Line":6}},{"line":175,"address":[12567707,12577403,12557962,12558033,12577462,12587119,12548274,12587178,12567766,12548215],"length":1,"stats":{"Line":4}},{"line":178,"address":[8032852,8023096],"length":1,"stats":{"Line":2}},{"line":179,"address":[4210539],"length":1,"stats":{"Line":2}},{"line":181,"address":[8032912,8023156],"length":1,"stats":{"Line":2}},{"line":182,"address":[4743871,4734107,4743788,4734024,4734077,4743841],"length":1,"stats":{"Line":4}},{"line":184,"address":[12548609,12568101,12577797,12558419,12587513,12548660,12568152,12558368,12587564,12577848],"length":1,"stats":{"Line":4}},{"line":190,"address":[12558876,12558505,12568598,12578294,12588016,12587647,12548743,12568235,12549112,12577931],"length":1,"stats":{"Line":4}},{"line":191,"address":[12558713,12587855,12578133,12558786,12548951,12568437,12587928,12558590,12578016,12587732,12568320,12568510,12578206,12549024,12548828],"length":1,"stats":{"Line":4}},{"line":192,"address":[8023781,8033531,8033576,8023826],"length":1,"stats":{"Line":4}},{"line":193,"address":[4734290,4734369,4744054,4744136],"length":1,"stats":{"Line":3}},{"line":195,"address":[12548885,12558644,12578070,12587789,12568374],"length":1,"stats":{"Line":1}},{"line":199,"address":[12568392,12587810,12548906,12568342,12578088,12558663,12548850,12578038,12587754,12558612],"length":1,"stats":{"Line":2}},{"line":203,"address":[4211096,4211295],"length":1,"stats":{"Line":4}},{"line":204,"address":[12569086,12578310,12588032,12559384,12549602,12588506,12578782,12549128,12568614,12558894],"length":1,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[12549312,12588216,12578494,12559085,12568798],"length":1,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[4734924,4734960,4744694,4744730],"length":1,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[8033913,8034052,8024302,8024163],"length":1,"stats":{"Line":0}},{"line":223,"address":[4744804,4735034,4744847,4735075],"length":1,"stats":{"Line":0}},{"line":228,"address":[8018272,8028028],"length":1,"stats":{"Line":11}},{"line":229,"address":[8028100,8018344],"length":1,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[12543531,12553907,12573370,12553256,12582435,12572719,12583086,12563674,12544182,12563023],"length":1,"stats":{"Line":22}},{"line":240,"address":[],"length":0,"stats":{"Line":23}},{"line":241,"address":[12608782,12604158,12599582,12589006,12608398],"length":1,"stats":{"Line":10}},{"line":242,"address":[4744994,4745314],"length":1,"stats":{"Line":11}},{"line":243,"address":[4745018,4745338],"length":1,"stats":{"Line":11}},{"line":246,"address":[12544219,12563711,12553944,12583123,12573407],"length":1,"stats":{"Line":11}},{"line":247,"address":[4206405],"length":1,"stats":{"Line":11}},{"line":248,"address":[],"length":0,"stats":{"Line":33}},{"line":250,"address":[8019130,8029315,8019423,8029179,8028886,8022461,8032217,8019559],"length":1,"stats":{"Line":22}},{"line":253,"address":[12606448,12601244,12589154,12592594,12544516,12597626,12596178,12597632,12594042,12592512,12596096,12564008,12573704,12604912,12590602,12594048,12589072,12604994,12554241,12583420,12606442,12599696,12599778,12590608,12601250],"length":1,"stats":{"Line":34}},{"line":254,"address":[],"length":0,"stats":{"Line":10}},{"line":255,"address":[4745578,4749866],"length":1,"stats":{"Line":10}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[12594872,12602037,12591401,12598456,12594841,12600663,12602069,12607241,12591432,12607272,12590015,12593455,12605855,12597039,12598425],"length":1,"stats":{"Line":22}},{"line":261,"address":[8041195,8036791],"length":1,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":22}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[4214615],"length":1,"stats":{"Line":11}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[4214672],"length":1,"stats":{"Line":6}},{"line":271,"address":[],"length":0,"stats":{"Line":6}},{"line":273,"address":[],"length":0,"stats":{"Line":7}},{"line":274,"address":[12602480,12591875,12595315],"length":1,"stats":{"Line":6}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[8037078],"length":1,"stats":{"Line":5}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[8037089],"length":1,"stats":{"Line":5}},{"line":280,"address":[],"length":0,"stats":{"Line":6}},{"line":282,"address":[4752610,4748278,4748380,4752508],"length":1,"stats":{"Line":22}},{"line":283,"address":[12595526,12599279,12599420,12592478,12592340,12602691,12602980,12603121,12607838,12602883,12599182,12607998,12608236,12592246,12595686,12592086,12608095,12595918,12595780,12599022],"length":1,"stats":{"Line":11}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[8039497,8035081],"length":1,"stats":{"Line":11}},{"line":287,"address":[12605758,12593358,12596942,12600566,12589918],"length":1,"stats":{"Line":11}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":11}},{"line":290,"address":[8035136,8039549],"length":1,"stats":{"Line":11}},{"line":292,"address":[12589939,12593379,12605779,12596963,12600587],"length":1,"stats":{"Line":11}},{"line":293,"address":[12601578,12597960,12590936,12605823,12593423,12589983,12597007,12600631,12606776,12594376],"length":1,"stats":{"Line":22}},{"line":294,"address":[4751826,4751866,4747590,4747550],"length":1,"stats":{"Line":11}},{"line":295,"address":[12606784,12597968,12601586,12590944,12594384],"length":1,"stats":{"Line":11}},{"line":296,"address":[8040793,8036389],"length":1,"stats":{"Line":11}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[4750210,4745922],"length":1,"stats":{"Line":11}},{"line":301,"address":[],"length":0,"stats":{"Line":11}},{"line":302,"address":[8039357,8034941],"length":1,"stats":{"Line":11}},{"line":303,"address":[4747240,4751516,4750353,4746065,4747007,4751283,4751377,4747101],"length":1,"stats":{"Line":11}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":12}},{"line":307,"address":[],"length":0,"stats":{"Line":10}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[4749954,4745666],"length":1,"stats":{"Line":10}},{"line":310,"address":[8034646,8039062],"length":1,"stats":{"Line":12}},{"line":312,"address":[12596492,12589468,12600100,12605308,12592908],"length":1,"stats":{"Line":12}},{"line":313,"address":[8034776,8035387,8039192,8039791],"length":1,"stats":{"Line":22}},{"line":314,"address":[8040106,8040066,8035662,8035702],"length":1,"stats":{"Line":11}},{"line":315,"address":[],"length":0,"stats":{"Line":12}},{"line":316,"address":[4213225],"length":1,"stats":{"Line":10}},{"line":321,"address":[],"length":0,"stats":{"Line":11}},{"line":324,"address":[4730372,4740136],"length":1,"stats":{"Line":11}},{"line":325,"address":[4730379,4740143],"length":1,"stats":{"Line":11}},{"line":326,"address":[4740206,4730539,4730442,4740303],"length":1,"stats":{"Line":4}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[4730645,4740409],"length":1,"stats":{"Line":3}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[12554734,12583913,12545009,12574197,12564501],"length":1,"stats":{"Line":12}},{"line":337,"address":[],"length":0,"stats":{"Line":23}},{"line":338,"address":[8020243,8029999],"length":1,"stats":{"Line":3}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[12576841,12557408,12567145,12575412,12546224,12575276,12586557,12555949,12565716,12547653,12584992,12565580,12585128,12546088,12555813],"length":1,"stats":{"Line":3}},{"line":341,"address":[4208152],"length":1,"stats":{"Line":3}},{"line":343,"address":[],"length":0,"stats":{"Line":3}},{"line":344,"address":[4741734,4741870,4731970,4741586,4731822,4732106],"length":1,"stats":{"Line":6}},{"line":346,"address":[4208604,4215747,4215712],"length":1,"stats":{"Line":9}},{"line":348,"address":[8031431,8031347,8021591,8021675],"length":1,"stats":{"Line":6}},{"line":349,"address":[4209142],"length":1,"stats":{"Line":2}},{"line":350,"address":[4209183],"length":1,"stats":{"Line":3}},{"line":351,"address":[4209226],"length":1,"stats":{"Line":3}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[12566665,12586077,12547173,12576361,12556902],"length":1,"stats":{"Line":2}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[12586191,12556938,12547215,12557010,12576475,12576403,12547287,12586119,12566779,12566707],"length":1,"stats":{"Line":4}},{"line":356,"address":[8022101,8031857],"length":1,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":12}}],"covered":116,"coverable":165},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","config.rs"],"content":"//! STARK proving configurations.\n//!\n//! This module provides STARK configurations for different prime fields.\n//!\n//! # Quick Start\n//!\n//! ```ignore\n//! use p3_circuit_prover::config;\n//!\n//! // Use a preconfigured setup\n//! let config = config::baby_bear()\n//!     .build();\n//! ```\n\nuse core::marker::PhantomData;\n\nuse p3_baby_bear::{BabyBear, Poseidon2BabyBear, default_babybear_poseidon2_16};\nuse p3_challenger::DuplexChallenger;\nuse p3_commit::ExtensionMmcs;\nuse p3_dft::Radix2DitParallel;\nuse p3_field::extension::BinomialExtensionField;\nuse p3_field::{Field, PrimeCharacteristicRing, PrimeField64, TwoAdicField};\nuse p3_fri::{TwoAdicFriPcs, create_benchmark_fri_params_high_arity};\nuse p3_goldilocks::{Goldilocks, Poseidon2Goldilocks};\nuse p3_koala_bear::{KoalaBear, Poseidon2KoalaBear, default_koalabear_poseidon2_16};\nuse p3_merkle_tree::MerkleTreeMmcs;\nuse p3_symmetric::{\n    CryptographicPermutation, PaddingFreeSponge, PseudoCompressionFunction, TruncatedPermutation,\n};\nuse p3_uni_stark::StarkConfig;\n\n/// Compression function arity (number of inputs per compression).\nconst COMPRESS_ARITY: usize = 2;\n\n/// A STARK configuration with all cryptographic primitives specified.\n///\n/// ### Type Parameters\n/// - `F`: Base field.\n/// - `PermHash`: Permutation function used for sponge hashing (leaves, transcript absorption).\n/// - `PermCompress`: Permutation function used for Merkle tree compression.\n/// - `HASH_PERM_WIDTH`: Width of the hash permutation state.\n/// - `COMPRESS_PERM_WIDTH`: Width of the compression permutation state.\n/// - `RATE`: Number of field elements absorbed per permutation in sponge mode.\n/// - `OUT`: Number of output elements squeezed per permutation.\n/// - `COMPRESS_CHUNK`: Number of elements per compression chunk in Merkle commitments.\n/// - `CHALLENGE_DEGREE`: Extension field degree.\npub type Config\u003c\n    F,\n    PermHash,\n    PermCompress,\n    const HASH_PERM_WIDTH: usize,\n    const COMPRESS_PERM_WIDTH: usize,\n    const RATE: usize,\n    const OUT: usize,\n    const COMPRESS_CHUNK: usize,\n    const CHALLENGE_DEGREE: usize,\n\u003e = StarkConfig\u003c\n    TwoAdicFriPcs\u003c\n        F,\n        Radix2DitParallel\u003cF\u003e,\n        MerkleTreeMmcs\u003c\n            F,\n            F,\n            PaddingFreeSponge\u003cPermHash, HASH_PERM_WIDTH, RATE, OUT\u003e,\n            TruncatedPermutation\u003cPermCompress, COMPRESS_ARITY, COMPRESS_CHUNK, COMPRESS_PERM_WIDTH\u003e,\n            COMPRESS_CHUNK,\n        \u003e,\n        ExtensionMmcs\u003c\n            F,\n            BinomialExtensionField\u003cF, CHALLENGE_DEGREE\u003e,\n            MerkleTreeMmcs\u003c\n                F,\n                F,\n                PaddingFreeSponge\u003cPermHash, HASH_PERM_WIDTH, RATE, OUT\u003e,\n                TruncatedPermutation\u003c\n                    PermCompress,\n                    COMPRESS_ARITY,\n                    COMPRESS_CHUNK,\n                    COMPRESS_PERM_WIDTH,\n                \u003e,\n                COMPRESS_CHUNK,\n            \u003e,\n        \u003e,\n    \u003e,\n    BinomialExtensionField\u003cF, CHALLENGE_DEGREE\u003e,\n    DuplexChallenger\u003cF, PermHash, HASH_PERM_WIDTH, RATE\u003e,\n\u003e;\n\n/// Configuration builder for STARK provers.\npub struct ConfigBuilder\u003c\n    F,\n    PermHash,\n    PermCompress,\n    const HASH_PERM_WIDTH: usize,\n    const COMPRESS_PERM_WIDTH: usize,\n    const RATE: usize,\n    const OUT: usize,\n    const COMPRESS_CHUNK: usize,\n    const CHALLENGE_DEGREE: usize,\n\u003e {\n    perm_hash: PermHash,\n    perm_compress: PermCompress,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003c\n    F,\n    PermHash,\n    PermCompress,\n    const HASH_PERM_WIDTH: usize,\n    const COMPRESS_PERM_WIDTH: usize,\n    const RATE: usize,\n    const OUT: usize,\n    const COMPRESS_CHUNK: usize,\n    const CHALLENGE_DEGREE: usize,\n\u003e\n    ConfigBuilder\u003c\n        F,\n        PermHash,\n        PermCompress,\n        HASH_PERM_WIDTH,\n        COMPRESS_PERM_WIDTH,\n        RATE,\n        OUT,\n        COMPRESS_CHUNK,\n        CHALLENGE_DEGREE,\n    \u003e\nwhere\n    F: Field,\n    PermHash: Clone + CryptographicPermutation\u003c[F; HASH_PERM_WIDTH]\u003e,\n    PermCompress: Clone + CryptographicPermutation\u003c[F; COMPRESS_PERM_WIDTH]\u003e,\n{\n    const fn new(perm_hash: PermHash, perm_compress: PermCompress) -\u003e Self {\n        Self {\n            perm_hash,\n            perm_compress,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Builds the final STARK configuration.\n    pub fn build(\n        self,\n    ) -\u003e Config\u003c\n        F,\n        PermHash,\n        PermCompress,\n        HASH_PERM_WIDTH,\n        COMPRESS_PERM_WIDTH,\n        RATE,\n        OUT,\n        COMPRESS_CHUNK,\n        CHALLENGE_DEGREE,\n    \u003e {\n        type Hash\u003cPerm, const PERM_WIDTH: usize, const RATE: usize, const OUT: usize\u003e =\n            PaddingFreeSponge\u003cPerm, PERM_WIDTH, RATE, OUT\u003e;\n        type Compress\u003cPerm, const PERM_WIDTH: usize, const COMPRESS_CHUNK: usize\u003e =\n            TruncatedPermutation\u003cPerm, COMPRESS_ARITY, COMPRESS_CHUNK, PERM_WIDTH\u003e;\n\n        let hash = Hash::\u003cPermHash, HASH_PERM_WIDTH, RATE, OUT\u003e::new(self.perm_hash.clone());\n        let compress = Compress::\u003cPermCompress, COMPRESS_PERM_WIDTH, COMPRESS_CHUNK\u003e::new(\n            self.perm_compress.clone(),\n        );\n        let val_mmcs = MerkleTreeMmcs::new(hash, compress, 3);\n        let challenge_mmcs = ExtensionMmcs::new(val_mmcs.clone());\n        let dft = Radix2DitParallel::default();\n        let fri_params = create_benchmark_fri_params_high_arity(challenge_mmcs);\n        let pcs = TwoAdicFriPcs::new(dft, val_mmcs, fri_params);\n        let challenger = DuplexChallenger::new(self.perm_hash);\n\n        StarkConfig::new(pcs, challenger)\n    }\n\n    /// Creates the compression function for this configuration.\n    pub fn compression_function(\n        \u0026self,\n    ) -\u003e TruncatedPermutation\u003cPermCompress, COMPRESS_ARITY, COMPRESS_CHUNK, COMPRESS_PERM_WIDTH\u003e\n    {\n        TruncatedPermutation::new(self.perm_compress.clone())\n    }\n}\n\n/// Creates a standard BabyBear configuration.\n///\n/// BabyBear is a 31-bit prime field (2^31 - 2^27 + 1).\n///\n/// # Parameters\n/// - **Hash permutation width**: 16 (appropriate for 32-bit fields)\n/// - **Compression permutation width**: 16\n/// - **Rate**: 8 (256 bits / 32 bits per element)\n/// - **Output size**: 8 (256 bits / 32 bits per element)\n/// - **Challenge degree**: 4\n///\n/// # Examples\n///\n/// ```ignore\n/// let config = config::baby_bear().build();\n/// let prover = BatchStarkProver::new(config);\n/// ```\n#[inline]\npub fn baby_bear()\n-\u003e ConfigBuilder\u003cBabyBear, Poseidon2BabyBear\u003c16\u003e, Poseidon2BabyBear\u003c16\u003e, 16, 16, 8, 8, 8, 4\u003e {\n    let perm = default_babybear_poseidon2_16();\n    ConfigBuilder::new(perm.clone(), perm)\n}\n\n/// Creates the standard BabyBear compression function.\n///\n/// # Parameters\n/// - **Input arrays**: 2\n/// - **Elements per array**: 8 (256 bits / 32 bits per element)\n/// - **Output size**: 8 BabyBear elements (256 bits)\n#[inline]\npub fn baby_bear_compression() -\u003e impl PseudoCompressionFunction\u003c[BabyBear; 8], 2\u003e {\n    baby_bear().compression_function()\n}\n\n/// Creates a standard KoalaBear configuration.\n///\n/// KoalaBear is a 31-bit prime field (2^31 - 2^24 + 1).\n///\n/// # Parameters\n/// - **Hash permutation width**: 16 (appropriate for 32-bit fields)\n/// - **Compression permutation width**: 16\n/// - **Rate**: 8 (256 bits / 32 bits per element)\n/// - **Output size**: 8 (256 bits / 32 bits per element)\n/// - **Challenge degree**: 4\n///\n/// # Examples\n///\n/// ```ignore\n/// let config = config::koala_bear().build();\n/// let prover = BatchStarkProver::new(config);\n/// ```\n#[inline]\npub fn koala_bear()\n-\u003e ConfigBuilder\u003cKoalaBear, Poseidon2KoalaBear\u003c16\u003e, Poseidon2KoalaBear\u003c16\u003e, 16, 16, 8, 8, 8, 4\u003e {\n    let perm = default_koalabear_poseidon2_16();\n    ConfigBuilder::new(perm.clone(), perm)\n}\n\n/// Creates the standard KoalaBear compression function.\n///\n/// # Parameters\n/// - **Input arrays**: 2\n/// - **Elements per array**: 8 (256 bits / 32 bits per element)\n/// - **Output size**: 8 KoalaBear elements (256 bits)\n#[inline]\npub fn koala_bear_compression() -\u003e impl PseudoCompressionFunction\u003c[KoalaBear; 8], 2\u003e {\n    koala_bear().compression_function()\n}\n\n/// Creates a standard Goldilocks configuration.\n///\n/// Goldilocks is a 64-bit prime field (2^64 - 2^32 + 1).\n///\n/// # Parameters\n/// - **Hash permutation width**: 8 (appropriate for 64-bit fields)\n/// - **Compression permutation width**: 8\n/// - **Rate**: 4 (256 bits / 64 bits per element)\n/// - **Output size**: 4 (256 bits / 64 bits per element)\n/// - **Challenge degree**: 2\n///\n/// # Examples\n///\n/// ```ignore\n/// let config = config::goldilocks().build();\n/// let prover = BatchStarkProver::new(config);\n/// ```\n#[inline]\npub fn goldilocks()\n-\u003e ConfigBuilder\u003cGoldilocks, Poseidon2Goldilocks\u003c8\u003e, Poseidon2Goldilocks\u003c8\u003e, 8, 8, 4, 4, 4, 2\u003e {\n    use rand::SeedableRng;\n    let mut rng = rand::rngs::SmallRng::seed_from_u64(1);\n    let perm = p3_goldilocks::Poseidon2Goldilocks::\u003c8\u003e::new_from_rng_128(\u0026mut rng);\n    ConfigBuilder::new(perm.clone(), perm)\n}\n\n/// Creates the standard Goldilocks compression function.\n///\n/// # Parameters\n/// - **Input arrays**: 2\n/// - **Elements per array**: 4 (256 bits / 64 bits per element)\n/// - **Output size**: 4 Goldilocks elements (256 bits)\n#[inline]\npub fn goldilocks_compression() -\u003e impl PseudoCompressionFunction\u003c[Goldilocks; 4], 2\u003e {\n    goldilocks().compression_function()\n}\n\n/// Type alias for BabyBear STARK configuration.\npub type BabyBearConfig =\n    Config\u003cBabyBear, Poseidon2BabyBear\u003c16\u003e, Poseidon2BabyBear\u003c16\u003e, 16, 16, 8, 8, 8, 4\u003e;\n\n/// Type alias for KoalaBear STARK configuration.\npub type KoalaBearConfig =\n    Config\u003cKoalaBear, Poseidon2KoalaBear\u003c16\u003e, Poseidon2KoalaBear\u003c16\u003e, 16, 16, 8, 8, 8, 4\u003e;\n\n/// Type alias for Goldilocks STARK configuration.\npub type GoldilocksConfig =\n    Config\u003cGoldilocks, Poseidon2Goldilocks\u003c8\u003e, Poseidon2Goldilocks\u003c8\u003e, 8, 8, 4, 4, 4, 2\u003e;\n\n/// Trait bounds for STARK-compatible fields.\npub trait StarkField: Field + PrimeCharacteristicRing + TwoAdicField + PrimeField64 {}\n\nimpl\u003cF\u003e StarkField for F where F: Field + PrimeCharacteristicRing + TwoAdicField + PrimeField64 {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn all_fields_configs_compile() {\n        let _bb: BabyBearConfig = baby_bear().build();\n        let _kb: KoalaBearConfig = koala_bear().build();\n        let _gl: GoldilocksConfig = goldilocks().build();\n    }\n\n    #[test]\n    fn compression_function_works() {\n        let _compress = baby_bear_compression();\n        let _compress = koala_bear_compression();\n        let _compress = goldilocks_compression();\n    }\n}\n","traces":[{"line":133,"address":[7119184,7119120,7119056],"length":1,"stats":{"Line":4}},{"line":142,"address":[11490985,11492416,11491088,11491104,11492297,11493609,11493712,11492400,11489792],"length":1,"stats":{"Line":4}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":164,"address":[11491351,11490039,11492663],"length":1,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":7}},{"line":166,"address":[11492969,11490345,11491657],"length":1,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":4}},{"line":168,"address":[11490499,11491811,11493123],"length":1,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":171,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[6932880,6933008,6932944],"length":1,"stats":{"Line":3}},{"line":179,"address":[7118883,7118947,7119011],"length":1,"stats":{"Line":3}},{"line":201,"address":[6933530,6933264,6933501],"length":1,"stats":{"Line":1}},{"line":203,"address":[8733697],"length":1,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[4648026],"length":1,"stats":{"Line":1}},{"line":236,"address":[6545472,6545709,6545738],"length":1,"stats":{"Line":1}},{"line":238,"address":[11364017],"length":1,"stats":{"Line":2}},{"line":239,"address":[4182905,4182967],"length":1,"stats":{"Line":4}},{"line":249,"address":[6546032,6546145,6546151],"length":1,"stats":{"Line":1}},{"line":250,"address":[3731530],"length":1,"stats":{"Line":1}},{"line":271,"address":[4647683,4647376,4647712],"length":1,"stats":{"Line":1}},{"line":274,"address":[6931841],"length":1,"stats":{"Line":1}},{"line":275,"address":[2344545],"length":1,"stats":{"Line":1}},{"line":276,"address":[7117991,7117926],"length":1,"stats":{"Line":2}},{"line":286,"address":[11364529,11364416,11364535],"length":1,"stats":{"Line":1}},{"line":287,"address":[7118602],"length":1,"stats":{"Line":1}}],"covered":29,"coverable":33},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","constraint_profile.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// High-level constraint profiles used to instantiate AIR variants.\n///\n/// Profiles are selected per proof shape / recursion layer and must be\n/// applied consistently across:\n/// - circuit construction,\n/// - native batch proving,\n/// - recursive verification.\n#[derive(Clone, Copy, Default, Debug, Eq, PartialEq, Serialize, Deserialize)]\npub enum ConstraintProfile {\n    /// Existing behaviour: all AIRs keep their current low-degree constraints.\n    #[default]\n    Standard,\n    /// Recursion-optimised profile.\n    RecursionOptimized,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","field_params.rs"],"content":"//! Utilities for extracting extension field parameters.\n//!\n//! Glossary:\n//! - `F`: Base field (BabyBear/KoalaBear/Goldilocks) that extension fields are built over.\n//! - `EF`: Element field for circuit traces. If `EF = F`, there is no binomial parameter. If\n//!   `EF = BinomialExtensionField\u003cF, D\u003e`, then there is a binomial parameter `W` with `x^D = W`.\n//! - `D`: Element-field extension degree.\n//!\n//! Provides traits to dynamically determine binomial extension parameters\n//! from field types at runtime, supporting both base fields and extension fields.\n\nuse p3_field::Field;\nuse p3_field::extension::{BinomialExtensionField, BinomiallyExtendable};\n\n/// Extract binomial parameters from field types.\n///\n/// Enables runtime detection of extension field parameters without\n/// requiring compile-time knowledge of the field structure.\npub trait ExtractBinomialW\u003cF: Field\u003e {\n    /// Extract the binomial parameter W for the current extension degree (e.g., x^D = W).\n    /// Returns None for base fields, Some(W) for supported binomial extensions.\n    fn extract_w() -\u003e Option\u003cF\u003e;\n}\n\n/// When the element field is the same as the base field (no extension), there's no binomial parameter W.\nimpl\u003cF\u003e ExtractBinomialW\u003cF\u003e for F\nwhere\n    F: Field,\n{\n    fn extract_w() -\u003e Option\u003cF\u003e {\n        None\n    }\n}\n\n/// Binomial extension fields (for any supported degree D) provide their parameter W.\nimpl\u003cF, const D: usize\u003e ExtractBinomialW\u003cF\u003e for BinomialExtensionField\u003cF, D\u003e\nwhere\n    F: Field + BinomiallyExtendable\u003cD\u003e,\n{\n    fn extract_w() -\u003e Option\u003cF\u003e {\n        Some(F::W)\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":5}},{"line":41,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":4},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","lib.rs"],"content":"//! Plonky3 circuit prover (PoC): generic over base field and permutation.\n//!\n//! Generics glossary used across this crate:\n//! - `F`: Prover/verifier base field (BabyBear/KoalaBear/Goldilocks). PCS and FFTs operate over `F`.\n//! - `P`: Cryptographic permutation over `F` used by hash/compress and the challenger.\n//! - `EF`: Element field in circuit traces. Either `F` (base) or `BinomialExtensionField\u003cF, D\u003e`.\n//! - `D`: Element-field extension degree. Must equal `EF::DIMENSION`. AIRs are parameterized as `\u003cF, D\u003e`.\n//! - `CD`: FRI challenge field degree, independent of `D`.\n//!\n//! - Build a field-specific config via `config::{babybear_config, koalabear_config, goldilocks_config}`.\n//! - Create a `BatchStarkProver` from that config.\n//! - Generate traces from a `p3_circuit::Circuit` runner and prove/verify.\n//!\n//! Example (BabyBear):\n//!\n//! ```ignore\n//! use p3_baby_bear::BabyBear;\n//! use p3_circuit::builder::CircuitBuilder;\n//! use p3_circuit_prover::config::babybear_config::build_standard_config_babybear;\n//! use p3_circuit_prover::BatchStarkProver;\n//!\n//! let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n//! let x = builder.public_input();\n//! let y = builder.public_input();\n//! let z = builder.add(x, y);\n//! builder.assert_zero(builder.sub(z, builder.define_const(BabyBear::from_u64(3))));\n//! let circuit = builder.build();\n//! let mut runner = circuit.runner();\n//! runner.set_public_inputs(\u0026[BabyBear::from_u64(1), BabyBear::from_u64(2)]).unwrap();\n//! let traces = runner.run().unwrap();\n//! let cfg = build_standard_config_babybear();\n//! let prover = BatchStarkProver::new(cfg);\n//! let proof = prover.prove_all_tables(\u0026traces).unwrap();\n//! prover.verify_all_tables(\u0026proof).unwrap();\n//! ```\n#![no_std]\n\nextern crate alloc;\n\npub mod air;\npub mod batch_stark_prover;\npub mod common;\npub mod config;\npub mod constraint_profile;\npub mod field_params;\n\n// Re-export main API\npub use batch_stark_prover::*;\npub use constraint_profile::ConstraintProfile;\npub use p3_circuit::op::Poseidon2Config;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","field-air","src","main.rs"],"content":"pub fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[{"line":1,"address":[389904,389872],"length":1,"stats":{"Line":1}},{"line":2,"address":[389873],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","fri-air","src","main.rs"],"content":"pub fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[{"line":1,"address":[389904,389872],"length":1,"stats":{"Line":1}},{"line":2,"address":[389905],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","interpolation-air","src","main.rs"],"content":"pub fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[{"line":1,"address":[389872,389904],"length":1,"stats":{"Line":1}},{"line":2,"address":[389873],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","poseidon2-circuit-air","src","air.rs"],"content":"use alloc::string::ToString;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::borrow::Borrow;\nuse core::iter;\nuse core::mem::MaybeUninit;\n\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues, BaseAir, PermutationAirBuilder};\nuse p3_circuit::ops::Poseidon2CircuitRow;\nuse p3_field::{Field, PrimeCharacteristicRing, PrimeField};\nuse p3_lookup::lookup_traits::{Direction, Kind, Lookup};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_maybe_rayon::prelude::*;\nuse p3_poseidon2::GenericPoseidon2LinearLayers;\nuse p3_poseidon2_air::{Poseidon2Air, Poseidon2Cols, RoundConstants, generate_trace_rows_for_perm};\nuse p3_uni_stark::{SubAirBuilder, SymbolicAirBuilder, SymbolicExpression, SymbolicVariable};\n\nuse crate::columns::{POSEIDON2_LIMBS, POSEIDON2_PUBLIC_OUTPUT_LIMBS};\nuse crate::{Poseidon2CircuitCols, num_cols};\n\n/// Extends the Poseidon2 AIR with recursion circuit-specific columns and constraints.\n///\n/// This implements the Poseidon2 Permutation Table specification.\n/// See: https://github.com/Plonky3/Plonky3-recursion/discussions/186\n///\n/// The AIR enforces:\n/// - Poseidon2 permutation constraint: out[0..3] = Poseidon2(in[0..3])\n/// - Chaining rules for normal sponge and Merkle-path modes\n/// - MMCS index accumulator updates\n///\n/// Assumes the field size is at least 16 bits.\n///\n/// SPECIFIC ASSUMPTIONS:\n/// - Memory elements from the witness table are extension elements of degree D.\n/// - RATE and CAPACITY are the number of extension elements in the rate/capacity.\n/// - WIDTH is the number of field elements in the state, i.e., (RATE + CAPACITY) * D.\n#[derive(Debug)]\npub struct Poseidon2CircuitAir\u003c\n    F: PrimeCharacteristicRing,\n    LinearLayers,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e {\n    p3_poseidon2: Poseidon2Air\u003c\n        F,\n        LinearLayers,\n        WIDTH,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e,\n    /// Current number of lookup columns registered.\n    pub num_lookup_cols: usize,\n    /// Preprocessed values for the AIR. These values are only needed by the prover. During verification, the `Vec` can be empty.\n    preprocessed: Vec\u003cF\u003e,\n    /// Minimum trace height (for FRI compatibility with higher log_final_poly_len).\n    min_height: usize,\n}\n\nimpl\u003c\n    F: PrimeField,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e Clone\n    for Poseidon2CircuitAir\u003c\n        F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e\n{\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            p3_poseidon2: self.p3_poseidon2.clone(),\n            num_lookup_cols: self.num_lookup_cols,\n            preprocessed: self.preprocessed.clone(),\n            min_height: self.min_height,\n        }\n    }\n}\n\npub const fn poseidon2_preprocessed_width() -\u003e usize {\n    // Witness index, `in_ctl`, `normal_chain_sel` and `merkle_chain_sel` for all input limbs,\n    // witness index and `out_ctl` for all output limbs,\n    // `mmcs_index_sum_ctl_idx`, `mmcs_merkle_flag` (precomputed: mmcs_ctl * merkle_path),\n    // `new_start` and `merkle_path`.\n    4 * POSEIDON2_LIMBS + 2 * POSEIDON2_PUBLIC_OUTPUT_LIMBS + 4\n}\n\nimpl\u003c\n    F: PrimeField,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e\n    Poseidon2CircuitAir\u003c\n        F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e\n{\n    pub const fn new(\n        constants: RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\n    ) -\u003e Self {\n        const {\n            assert!(CAPACITY_EXT + RATE_EXT == WIDTH_EXT);\n            assert!(WIDTH_EXT * D == WIDTH);\n        }\n\n        Self {\n            p3_poseidon2: Poseidon2Air::new(constants),\n            num_lookup_cols: 0,\n            preprocessed: Vec::new(),\n            min_height: 1,\n        }\n    }\n\n    pub fn with_min_height(mut self, min_height: usize) -\u003e Self {\n        self.min_height = min_height.next_power_of_two().max(1);\n        self\n    }\n\n    pub const fn new_with_preprocessed(\n        constants: RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\n        preprocessed: Vec\u003cF\u003e,\n    ) -\u003e Self {\n        const {\n            assert!(CAPACITY_EXT + RATE_EXT == WIDTH_EXT);\n            assert!(WIDTH_EXT * D == WIDTH);\n        }\n\n        Self {\n            p3_poseidon2: Poseidon2Air::new(constants),\n            num_lookup_cols: 0,\n            preprocessed,\n            min_height: 1,\n        }\n    }\n\n    pub const fn preprocessed_width() -\u003e usize {\n        poseidon2_preprocessed_width()\n    }\n\n    pub fn generate_trace_rows(\n        \u0026self,\n        sponge_ops: \u0026[Poseidon2CircuitRow\u003cF\u003e],\n        constants: \u0026RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\n        extra_capacity_bits: usize,\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\n        let n = sponge_ops.len();\n        assert!(\n            n.is_power_of_two(),\n            \"Callers expected to pad inputs to a power of two\"\n        );\n\n        let p2_ncols = p3_poseidon2_air::num_cols::\u003c\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e();\n        let ncols = self.width();\n        let circuit_ncols = ncols - p2_ncols;\n\n        // We allocate the final vector immediately with uninitialized memory.\n        //\n        // The extra capacity bits only enlarges the Poseidon2 columns, not the circuit columns.\n        let mut trace_vec: Vec\u003cF\u003e =\n            Vec::with_capacity(n * ((p2_ncols \u003c\u003c extra_capacity_bits) + circuit_ncols));\n        let trace_slice = trace_vec.spare_capacity_mut();\n\n        // We need a lightweight vector to store the state inputs for the parallel pass.\n        //\n        // This is much smaller than the full trace (WIDTH vs NUM_COLS).\n        let mut inputs = Vec::with_capacity(n);\n        let mut prev_mmcs_index_sum = F::ZERO;\n\n        // Split slice into rows\n        let rows = trace_slice[..n * ncols].chunks_exact_mut(ncols);\n\n        for (row_index, (op, row)) in sponge_ops.iter().zip(rows).enumerate() {\n            let Poseidon2CircuitRow {\n                new_start,\n                merkle_path,\n                mmcs_bit,\n                mmcs_index_sum,\n                input_values,\n                ..\n            } = op;\n\n            // Copy input_values into fixed-size array, padding with zeros.\n            // Note: input_values already contains the fully resolved state with chaining\n            // applied during circuit execution, so no additional chaining is needed here.\n            assert_eq!(\n                input_values.len(),\n                WIDTH,\n                \"Trace row input_values must have length WIDTH\"\n            );\n            let mut state = [F::ZERO; WIDTH];\n            state[..WIDTH].copy_from_slice(\u0026input_values[..WIDTH]);\n\n            // Update MMCS index accumulator\n            let acc = if row_index \u003e 0 \u0026\u0026 *merkle_path \u0026\u0026 !*new_start {\n                // mmcs_index_sum_{r+1} = mmcs_index_sum_r * 2 + mmcs_bit_r\n                prev_mmcs_index_sum + prev_mmcs_index_sum + F::from_bool(*mmcs_bit)\n            } else {\n                // Reset / non-Merkle behavior.\n                // The AIR does not constrain mmcs_index_sum on these rows;\n                // we simply use the value stored in the op.\n                *mmcs_index_sum\n            };\n            prev_mmcs_index_sum = acc;\n\n            let (_p2_part, circuit_part) = row.split_at_mut(p2_ncols);\n\n            circuit_part[0].write(F::from_bool(*mmcs_bit));\n            circuit_part[1].write(acc);\n\n            // Save the state to be used as input for the heavy Poseidon2 trace generation\n            inputs.push(state);\n        }\n\n        // Poseidon2 trace generation\n        //\n        // Now that we have the inputs, we can generate the expensive Poseidon2 columns in parallel.\n\n        trace_slice[..n * ncols]\n            .par_chunks_exact_mut(ncols)\n            .zip(inputs.into_par_iter())\n            .for_each(|(row, input)| {\n                let (p2_part, _circuit_part) = row.split_at_mut(p2_ncols);\n\n                // Align the raw field elements to the Poseidon2Cols struct\n                let (prefix, p2_cols, suffix) = unsafe {\n                    p2_part.align_to_mut::\u003cPoseidon2Cols\u003c\n                        MaybeUninit\u003cF\u003e,\n                        WIDTH,\n                        SBOX_DEGREE,\n                        SBOX_REGISTERS,\n                        HALF_FULL_ROUNDS,\n                        PARTIAL_ROUNDS,\n                    \u003e\u003e()\n                };\n\n                // Sanity checks to ensure memory layout is what we expect\n                debug_assert!(prefix.is_empty(), \"Alignment mismatch\");\n                debug_assert!(suffix.is_empty(), \"Alignment mismatch\");\n                debug_assert_eq!(p2_cols.len(), 1);\n\n                // Generate the heavy trace\n                generate_trace_rows_for_perm::\u003c\n                    F,\n                    LinearLayers,\n                    WIDTH,\n                    SBOX_DEGREE,\n                    SBOX_REGISTERS,\n                    HALF_FULL_ROUNDS,\n                    PARTIAL_ROUNDS,\n                \u003e(\u0026mut p2_cols[0], input, constants);\n            });\n\n        // SAFETY: We have written to all columns in the slice [0..n*ncols].\n        // 1. Circuit columns were written in the sequential loop.\n        // 2. Poseidon2 columns were written in the parallel loop.\n        unsafe {\n            trace_vec.set_len(n * ncols);\n        }\n\n        RowMajorMatrix::new(trace_vec, ncols)\n    }\n}\n\nimpl\u003c\n    F: PrimeField + Sync,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e + Sync,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e BaseAir\u003cF\u003e\n    for Poseidon2CircuitAir\u003c\n        F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e\n{\n    fn width(\u0026self) -\u003e usize {\n        num_cols::\u003c\n            Poseidon2Cols\u003cu8, WIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\n        \u003e()\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\n        debug_assert!(\n            self.preprocessed\n                .len()\n                .is_multiple_of(Self::preprocessed_width()),\n            \"Preprocessed trace length is not a multiple of preprocessed width. Expected multiple of {}, got {}\",\n            Self::preprocessed_width(),\n            self.preprocessed.len(),\n        );\n\n        let width = Self::preprocessed_width();\n        let natural_rows = self.preprocessed.len() / width;\n        let num_extra_rows = natural_rows\n            .next_power_of_two()\n            .saturating_sub(natural_rows);\n\n        let mut preprocessed = self.preprocessed.clone();\n        let start_len = preprocessed.len();\n        preprocessed.resize(start_len + num_extra_rows * width, F::ZERO);\n\n        if num_extra_rows \u003e 0 {\n            preprocessed[start_len + width - 2] = F::ONE;\n        }\n\n        let mut mat = RowMajorMatrix::new(preprocessed, width);\n        let current_height = mat.height();\n        let target_height = current_height\n            .next_power_of_two()\n            .max(self.min_height.next_power_of_two());\n        if current_height \u003c target_height {\n            let padding_rows = target_height - current_height;\n            mat.values\n                .extend(core::iter::repeat_n(F::ZERO, padding_rows * width));\n        }\n        Some(mat)\n    }\n}\n\npub fn extract_preprocessed_from_operations\u003cF: Field, OF: Field\u003e(\n    operations: \u0026[Poseidon2CircuitRow\u003cOF\u003e],\n) -\u003e Vec\u003cF\u003e {\n    let mut preprocessed = Vec::with_capacity(operations.len() * poseidon2_preprocessed_width());\n\n    for operation in operations {\n        let Poseidon2CircuitRow {\n            in_ctl,\n            input_indices,\n            out_ctl,\n            output_indices,\n            mmcs_index_sum_idx,\n            mmcs_ctl_enabled,\n            new_start,\n            merkle_path,\n            ..\n        } = operation;\n\n        for limb_idx in 0..4 {\n            let ctl = in_ctl[limb_idx];\n            let idx = input_indices[limb_idx];\n\n            preprocessed.extend(\u0026[F::from_u32(idx), F::from_bool(ctl)]);\n\n            let normal_chain_sel = if !*new_start \u0026\u0026 !*merkle_path \u0026\u0026 !ctl {\n                F::ONE\n            } else {\n                F::ZERO\n            };\n            preprocessed.push(normal_chain_sel);\n\n            let merkle_chain_sel = if !new_start \u0026\u0026 *merkle_path \u0026\u0026 !ctl {\n                F::ONE\n            } else {\n                F::ZERO\n            };\n            preprocessed.push(merkle_chain_sel);\n        }\n        out_ctl\n            .iter()\n            .zip(output_indices.iter())\n            .for_each(|(ctl, idx)| {\n                preprocessed.extend(\u0026[F::from_u32(*idx), F::from_bool(*ctl)]);\n            });\n        preprocessed.push(F::from_u64(*mmcs_index_sum_idx as u64));\n        // mmcs_merkle_flag = mmcs_ctl_enabled * merkle_path (precomputed)\n        let mmcs_merkle_flag = if *mmcs_ctl_enabled \u0026\u0026 *merkle_path {\n            F::ONE\n        } else {\n            F::ZERO\n        };\n        preprocessed.push(mmcs_merkle_flag);\n        preprocessed.push(F::from_bool(*new_start));\n        preprocessed.push(F::from_bool(*merkle_path));\n    }\n\n    preprocessed\n}\n\npub(crate) fn eval\u003c\n    AB: AirBuilder,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e(\n    air: \u0026Poseidon2CircuitAir\u003c\n        AB::F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e,\n    builder: \u0026mut AB,\n    local: \u0026Poseidon2CircuitCols\u003c\n        AB::Var,\n        Poseidon2Cols\u003c\n            AB::Var,\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e,\n    \u003e,\n    next: \u0026Poseidon2CircuitCols\u003c\n        AB::Var,\n        Poseidon2Cols\u003c\n            AB::Var,\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e,\n    \u003e,\n    next_preprocessed: \u0026[AB::Var],\n) {\n    // Control flags (new_start, merkle_path, in_ctl, out_ctl) are preprocessed columns,\n    // so they are known to the verifier and don't need bool assertions.\n    // Note: mmcs_bit is a value column (not transparent) because it's used in constraints\n    // with the value column mmcs_index_sum.\n\n    let next_bit = next.mmcs_bit.clone();\n    let local_out = \u0026local.poseidon2.ending_full_rounds[HALF_FULL_ROUNDS - 1].post;\n    let next_in = \u0026next.poseidon2.inputs;\n\n    // mmcs_bit should always be boolean.\n    builder.assert_bool(local.mmcs_bit.clone());\n\n    // Preprocessing layout:\n    // [in_idx[0], in_ctl[0], normal_chain_sel[0], merkle_chain_sel[0], ..., in_idx[3], in_ctl[3], normal_chain_sel[3], merkle_chain_sel[3],\n    //  out_idx[0], out_ctl[0], out_idx[1], out_ctl[1], mmcs_index_sum_ctl_idx, mmcs_merkle_flag, new_start, merkle_path]\n    // The following corresponds to the size of the data related to one input limb (in_idx[i], in_ctl[i], normal_chain_sel[i], merkle_chain_sel[i]).\n    let preprocessing_limb_data_size = 4;\n    let normal_chain_idx = 2;\n    let merkle_chain_idx = 3;\n    let new_start_idx = 4 * POSEIDON2_LIMBS + 2 * POSEIDON2_PUBLIC_OUTPUT_LIMBS + 2;\n    let merkle_path_idx = new_start_idx + 1;\n    // Normal chaining.\n    // If new_start_{r+1} = 0 and merkle_path_{r+1} = 0:\n    //   in_{r+1}[i] = out_r[i] for i = 0..3\n    // BUT: If in_ctl[i] = 1, CTL overrides chaining (limb is not chained).\n    // Chaining only applies when in_ctl[limb] = 0.\n    for limb in 0..POSEIDON2_LIMBS {\n        for d in 0..D {\n            let idx = limb * D + d;\n            let gate =\n                next_preprocessed[preprocessing_limb_data_size * limb + normal_chain_idx].clone();\n            builder\n                .when_transition()\n                .when(gate)\n                .assert_zero(next_in[idx].clone() - local_out[idx].clone());\n        }\n    }\n\n    // Merkle-path chaining.\n    // If new_start_{r+1} = 0 and merkle_path_{r+1} = 1:\n    //   - If mmcs_bit_{r+1} = 0 (left = previous hash): in_{r+1}[0] = out_r[0], in_{r+1}[1] = out_r[1].\n    //     Input limbs 2-3 are free/private.\n    //   - If mmcs_bit_{r+1} = 1 (right = previous hash): in_{r+1}[2] = out_r[0], in_{r+1}[3] = out_r[1].\n    //     Input limbs 0-1 are free/private.\n    // BUT: If in_ctl[i] = 1, CTL overrides chaining (limb is not chained).\n    // Chaining only applies when in_ctl[limb] = 0.\n    let is_left = AB::Expr::ONE - next_bit.clone();\n\n    // Limb 0: chain from out_r[0] when mmcs_bit = 0 (left), unless in_ctl[0] = 1.\n    // When mmcs_bit = 1 (right), limb 0 is private (sibling).\n    for d in 0..D {\n        let gate_left_0 = next_preprocessed[merkle_chain_idx].clone() * is_left.clone();\n        builder\n            .when_transition()\n            .when(gate_left_0)\n            .assert_zero(next_in[d].clone() - local_out[d].clone());\n    }\n\n    // Limb 1: chain from out_r[1] when mmcs_bit = 0 (left), unless in_ctl[1] = 1.\n    // When mmcs_bit = 1 (right), limb 1 is private (sibling).\n    for d in 0..D {\n        let gate_left_1 = next_preprocessed[preprocessing_limb_data_size + merkle_chain_idx]\n            .clone()\n            * is_left.clone();\n        builder\n            .when_transition()\n            .when(gate_left_1)\n            .assert_zero(next_in[D + d].clone() - local_out[D + d].clone());\n    }\n\n    // Limb 2: chain from out_r[0] when mmcs_bit = 1. Uses merkle_chain_sel[0] since\n    // physical limb 2 contains logical limb 0's value when permuted.\n    for d in 0..D {\n        let gate_right_2 = next_preprocessed[merkle_chain_idx].clone() * next_bit.clone();\n        builder\n            .when_transition()\n            .when(gate_right_2)\n            .assert_zero(next_in[2 * D + d].clone() - local_out[d].clone());\n    }\n\n    // Limb 3: chain from out_r[1] when mmcs_bit = 1. Uses merkle_chain_sel[1].\n    for d in 0..D {\n        let gate_right_3 = next_preprocessed[preprocessing_limb_data_size + merkle_chain_idx]\n            .clone()\n            * next_bit.clone();\n        builder\n            .when_transition()\n            .when(gate_right_3)\n            .assert_zero(next_in[3 * D + d].clone() - local_out[D + d].clone());\n    }\n\n    // MMCS accumulator update.\n    // If merkle_path_{r+1} = 1 and new_start_{r+1} = 0:\n    //   mmcs_index_sum_{r+1} = mmcs_index_sum_r * 2 + mmcs_bit_{r+1}\n    let two = AB::Expr::ONE + AB::Expr::ONE;\n    let not_next_new_start = AB::Expr::ONE - next_preprocessed[new_start_idx].clone();\n    builder\n        .when_transition()\n        .when(not_next_new_start)\n        .when(next_preprocessed[merkle_path_idx].clone())\n        .assert_zero(\n            next.mmcs_index_sum.clone()\n                - (local.mmcs_index_sum.clone() * two + next.mmcs_bit.clone()),\n        );\n\n    let p3_poseidon2_num_cols = p3_poseidon2_air::num_cols::\u003c\n        WIDTH,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e();\n    let mut sub_builder = SubAirBuilder::\u003c\n        AB,\n        Poseidon2Air\u003c\n            AB::F,\n            LinearLayers,\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e,\n        AB::Var,\n    \u003e::new(builder, 0..p3_poseidon2_num_cols);\n\n    // Enforce Poseidon2 permutation constraint:\n    // out[0..3] = Poseidon2(in[0..3])\n    // This holds regardless of merkle_path, new_start, CTL flags, chaining, or MMCS accumulator.\n    air.p3_poseidon2.eval(\u0026mut sub_builder);\n}\n\n/// Unsafe version of `eval` that allows calling with a builder whose field type\n/// doesn't match the AIR's field type at compile time, but matches at runtime.\n///\n/// # Safety\n/// The caller must ensure that `F == AB::F` at runtime. Violating this will cause\n/// undefined behavior.\npub unsafe fn eval_unchecked\u003c\n    F: PrimeField,\n    AB: AirBuilder,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e(\n    air: \u0026Poseidon2CircuitAir\u003c\n        F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e,\n    builder: \u0026mut AB,\n    local: \u0026Poseidon2CircuitCols\u003c\n        AB::Var,\n        Poseidon2Cols\u003c\n            AB::Var,\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e,\n    \u003e,\n    next: \u0026Poseidon2CircuitCols\u003c\n        AB::Var,\n        Poseidon2Cols\u003c\n            AB::Var,\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e,\n    \u003e,\n    next_preprocessed: \u0026[AB::Var],\n) where\n    AB::F: PrimeField,\n{\n    // SAFETY: Caller guarantees F == AB::F at runtime, so the struct layouts are identical.\n    // The transmute is safe because all field types have the same runtime representation.\n    unsafe {\n        let air_transmuted: \u0026Poseidon2CircuitAir\u003c\n            AB::F,\n            LinearLayers,\n            D,\n            WIDTH,\n            WIDTH_EXT,\n            RATE_EXT,\n            CAPACITY_EXT,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e = core::mem::transmute(air);\n\n        eval::\u003c\n            AB,\n            LinearLayers,\n            D,\n            WIDTH,\n            WIDTH_EXT,\n            RATE_EXT,\n            CAPACITY_EXT,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e(air_transmuted, builder, local, next, next_preprocessed);\n    }\n}\n\nimpl\u003c\n    AB: AirBuilder,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e Air\u003cAB\u003e\n    for Poseidon2CircuitAir\u003c\n        AB::F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e\nwhere\n    AB::F: PrimeField,\n{\n    #[inline]\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n        let local = main.row_slice(0).expect(\"The matrix is empty?\");\n        let local = (*local).borrow();\n        let next = main.row_slice(1).expect(\"The matrix has only one row?\");\n        let next = (*next).borrow();\n\n        let preprocessed = builder\n            .preprocessed()\n            .expect(\"Expected preprocessed columns\");\n        let next_preprocessed = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n        let next_preprocessed = (*next_preprocessed).borrow();\n\n        eval::\u003c\n            _,\n            _,\n            D,\n            WIDTH,\n            WIDTH_EXT,\n            RATE_EXT,\n            CAPACITY_EXT,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e(self, builder, local, next, next_preprocessed);\n    }\n\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        let lookup_column_idx = self.num_lookup_cols;\n        self.num_lookup_cols += 1;\n        vec![lookup_column_idx]\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cAB\u003e::F\u003e\u003e\n    where\n        AB: PermutationAirBuilder + AirBuilderWithPublicValues,\n    {\n        let symbolic_air_builder = SymbolicAirBuilder::\u003cAB::F\u003e::new(\n            Self::preprocessed_width(),\n            BaseAir::\u003cAB::F\u003e::width(self),\n            0,\n            0, // Here, we do not need the permutation trace\n            0,\n        );\n        let symbolic_main = symbolic_air_builder.main();\n        let symbolic_main_local = symbolic_main.row_slice(0).expect(\"The matrix is empty?\");\n\n        let local: \u0026Poseidon2CircuitCols\u003c\n            SymbolicVariable\u003cAB::F\u003e,\n            Poseidon2Cols\u003c\n                SymbolicVariable\u003cAB::F\u003e,\n                WIDTH,\n                SBOX_DEGREE,\n                SBOX_REGISTERS,\n                HALF_FULL_ROUNDS,\n                PARTIAL_ROUNDS,\n            \u003e,\n        \u003e = (*symbolic_main_local).borrow();\n\n        // Preprocessing layout:\n        // [in_idx[0], in_ctl[0], normal_chain_sel[0], merkle_chain_sel[0], ..., in_idx[3], in_ctl[3], normal_chain_sel[3], merkle_chain_sel[3],\n        //  out_idx[0], out_ctl[0], out_idx[1], out_ctl[1], mmcs_index_sum_ctl_idx, mmcs_merkle_flag, new_start, merkle_path]\n        // The following corresponds to the size of the data related to one input limb (in_idx[i], in_ctl[i], normal_chain_sel[i], merkle_chain_sel[i]).\n        let preprocessing_limb_input_data_size = 4;\n        let preprocessing_limb_output_data_size = 2;\n        let in_ctl_idx = 1;\n        let start_output_idx = preprocessing_limb_input_data_size * POSEIDON2_LIMBS;\n        let mmcs_index_sum_ctl_idx =\n            start_output_idx + preprocessing_limb_output_data_size * POSEIDON2_PUBLIC_OUTPUT_LIMBS;\n        let mmcs_merkle_flag_idx = mmcs_index_sum_ctl_idx + 1;\n        let new_start_idx = mmcs_merkle_flag_idx + 1;\n        let merkle_path_idx = new_start_idx + 1;\n\n        let preprocessed = symbolic_air_builder\n            .preprocessed()\n            .expect(\"Expected preprocessed columns\");\n        let local_preprocessed = preprocessed\n            .row_slice(0)\n            .expect(\"The preprocessed matrix has only one row?\");\n        let local_preprocessed: \u0026[SymbolicVariable\u003cAB::F\u003e] = (*local_preprocessed).borrow();\n        let next_preprocessed = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n        let next_preprocessed: \u0026[SymbolicVariable\u003cAB::F\u003e] = (*next_preprocessed).borrow();\n        // There are POSEIDON2_LIMBS input limbs and POSEIDON2_PUBLIC_OUTPUT_LIMBS output limbs to be looked up in the `Witness` table.\n        let mut lookups = Vec::with_capacity(POSEIDON2_LIMBS + POSEIDON2_PUBLIC_OUTPUT_LIMBS);\n\n        // Input CTL lookups disabled for merkle_path=1 rows due to degree constraints:\n        // permuting CTL metadata based on runtime would make `mmcs_bit` exceed degree 3.\n        //\n        // This is sound because:\n        // - Row digest values are bound to expression IDs that were CTL-verified\n        //   during creation (in `add_hash_slice` with merkle_path=false)\n        // - Sibling values are private proof data (wrong siblings → wrong root)\n        // - Chained values are AIR-constrained to equal previous Poseidon2 outputs\n        let local_merkle_path = local_preprocessed[merkle_path_idx];\n        let not_merkle =\n            SymbolicExpression::Constant(AB::F::ONE) - SymbolicExpression::from(local_merkle_path);\n\n        for limb_idx in 0..POSEIDON2_LIMBS {\n            let in_ctl =\n                local_preprocessed[limb_idx * preprocessing_limb_input_data_size + in_ctl_idx];\n            let input_idx_limb =\n                iter::once(local_preprocessed[limb_idx * preprocessing_limb_input_data_size])\n                    .chain(\n                        local.poseidon2.inputs[limb_idx * D..(limb_idx + 1) * D]\n                            .iter()\n                            .cloned(),\n                    )\n                    .map(SymbolicExpression::from)\n                    .collect::\u003cVec\u003c_\u003e\u003e();\n\n            // Multiplicity = in_ctl * (1 - merkle_path), both preprocessed, so degree 0\n            let mult = SymbolicExpression::from(in_ctl) * not_merkle.clone();\n\n            lookups.push(\u003cSelf as Air\u003cAB\u003e\u003e::register_lookup(\n                self,\n                Kind::Global(\"WitnessChecks\".to_string()),\n                \u0026[(input_idx_limb, mult, Direction::Send)],\n            ));\n        }\n\n        for limb_idx in 0..POSEIDON2_PUBLIC_OUTPUT_LIMBS {\n            let out_ctl = local_preprocessed[start_output_idx + limb_idx * 2 + 1];\n\n            let output_idx_limb = iter::once(local_preprocessed[start_output_idx + limb_idx * 2]) // output witness index\n                .chain(\n                    local.poseidon2.ending_full_rounds[HALF_FULL_ROUNDS - 1].post\n                        [limb_idx * D..(limb_idx + 1) * D]\n                        .iter()\n                        .cloned(),\n                )\n                .map(SymbolicExpression::from)\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            let lookup_output = vec![(\n                output_idx_limb,\n                SymbolicExpression::from(out_ctl),\n                Direction::Send,\n            )];\n\n            lookups.push(\u003cSelf as Air\u003cAB\u003e\u003e::register_lookup(\n                self,\n                Kind::Global(\"WitnessChecks\".to_string()),\n                \u0026lookup_output,\n            ));\n        }\n\n        // If mmcs_merkle_flag = 1 AND next.new_start = 1, then mmcs_index_sum is exposed via CTL.\n        // mmcs_merkle_flag is precomputed as: mmcs_ctl_enabled * merkle_path\n        // This keeps the multiplicity at degree 2 (safe for constraint evaluation).\n        // When mmcs_index_sum is not allocated (mmcs_ctl = 0) or merkle_path = 0, the flag is 0.\n        let local_mmcs_merkle_flag = local_preprocessed[mmcs_merkle_flag_idx];\n        let next_new_start = next_preprocessed[new_start_idx];\n        let multiplicity = local_mmcs_merkle_flag * next_new_start;\n\n        let local_mmcs_index_sum_idx = local_preprocessed[mmcs_index_sum_ctl_idx];\n        let mut mmcs_index_sum_lookup = vec![\n            SymbolicExpression::from(local_mmcs_index_sum_idx),\n            SymbolicExpression::from(local.mmcs_index_sum),\n        ];\n        // Extend `mmcs_index_sum` to D elements with zeros.\n        mmcs_index_sum_lookup.extend(iter::repeat_n(\n            SymbolicExpression::Constant(AB::F::ZERO),\n            D - 1,\n        ));\n\n        let lookup_mmcs = (\n            mmcs_index_sum_lookup.to_vec(),\n            multiplicity,\n            Direction::Send,\n        );\n        lookups.push(\u003cSelf as Air\u003cAB\u003e\u003e::register_lookup(\n            self,\n            Kind::Global(\"WitnessChecks\".to_string()),\n            \u0026[lookup_mmcs],\n        ));\n\n        lookups\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use alloc::vec;\n\n    use p3_baby_bear::{BabyBear, Poseidon2BabyBear};\n    use p3_challenger::{HashChallenger, SerializingChallenger32};\n    use p3_commit::ExtensionMmcs;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_fri::{TwoAdicFriPcs, create_benchmark_fri_params};\n    use p3_keccak::{Keccak256Hash, KeccakF};\n    use p3_merkle_tree::MerkleTreeHidingMmcs;\n    use p3_poseidon2::ExternalLayerConstants;\n    use p3_poseidon2_air::RoundConstants;\n    use p3_symmetric::{\n        CompressionFunctionFromHasher, PaddingFreeSponge, Permutation, SerializingHasher,\n    };\n    use p3_uni_stark::{\n        StarkConfig, prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed,\n    };\n    use rand::rngs::SmallRng;\n    use rand::{RngExt, SeedableRng};\n\n    use super::*;\n    use crate::Poseidon2CircuitAirBabyBearD4Width16;\n    use crate::columns::{POSEIDON2_LIMBS, POSEIDON2_PUBLIC_OUTPUT_LIMBS};\n\n    const WIDTH: usize = 16;\n\n    #[test]\n    fn prove_poseidon2_sponge() -\u003e Result\u003c\n        (),\n        p3_uni_stark::VerificationError\u003c\n            p3_fri::verifier::FriError\u003c\n                p3_merkle_tree::MerkleTreeError,\n                p3_merkle_tree::MerkleTreeError,\n            \u003e,\n        \u003e,\n    \u003e {\n        type Val = BabyBear;\n        type Challenge = BinomialExtensionField\u003cVal, 4\u003e;\n\n        type ByteHash = Keccak256Hash;\n        let byte_hash = ByteHash {};\n\n        type U64Hash = PaddingFreeSponge\u003cKeccakF, 25, 17, 4\u003e;\n        let u64_hash = U64Hash::new(KeccakF {});\n\n        type FieldHash = SerializingHasher\u003cU64Hash\u003e;\n        let field_hash = FieldHash::new(u64_hash);\n\n        type MyCompress = CompressionFunctionFromHasher\u003cU64Hash, 2, 4\u003e;\n        let compress = MyCompress::new(u64_hash);\n\n        // WARNING: DO NOT USE SmallRng in proper applications! Use a real PRNG instead!\n        type ValMmcs = MerkleTreeHidingMmcs\u003c\n            [Val; p3_keccak::VECTOR_LEN],\n            [u64; p3_keccak::VECTOR_LEN],\n            FieldHash,\n            MyCompress,\n            SmallRng,\n            4,\n            4,\n        \u003e;\n        let mut rng = SmallRng::seed_from_u64(1);\n        let val_mmcs = ValMmcs::new(field_hash, compress, 0, rng.clone());\n\n        type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\n        let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n\n        type Challenger = SerializingChallenger32\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\n        let challenger = Challenger::from_hasher(vec![], byte_hash);\n\n        let mut fri_params = create_benchmark_fri_params(challenge_mmcs);\n        fri_params.log_blowup = 4;\n\n        let beginning_full_constants = rng.random();\n        let partial_constants = rng.random();\n        let ending_full_constants = rng.random();\n\n        let constants = RoundConstants::new(\n            beginning_full_constants,\n            partial_constants,\n            ending_full_constants,\n        );\n\n        let perm = Poseidon2BabyBear::\u003cWIDTH\u003e::new(\n            ExternalLayerConstants::new(\n                beginning_full_constants.to_vec(),\n                ending_full_constants.to_vec(),\n            ),\n            partial_constants.to_vec(),\n        );\n\n        // Generate random inputs.\n        let mut rng = SmallRng::seed_from_u64(1);\n\n        // Row A: new_start=true, sponge mode - use random initial state\n        let state_a: [Val; WIDTH] = core::array::from_fn(|_| rng.random());\n        let output_a = perm.permute(state_a);\n\n        let sponge_a: Poseidon2CircuitRow\u003cVal\u003e = Poseidon2CircuitRow {\n            new_start: true,\n            merkle_path: false,\n            mmcs_bit: false,\n            mmcs_index_sum: Val::ZERO,\n            input_values: state_a.to_vec(),\n            in_ctl: [false; POSEIDON2_LIMBS],\n            input_indices: [0; POSEIDON2_LIMBS],\n            out_ctl: [false; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            output_indices: [0; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            mmcs_index_sum_idx: 0,\n            mmcs_ctl_enabled: false,\n        };\n\n        // Row B: new_start=false, sponge mode - chain from output_a\n        let state_b = output_a;\n        let output_b = perm.permute(state_b);\n\n        let sponge_b: Poseidon2CircuitRow\u003cVal\u003e = Poseidon2CircuitRow {\n            new_start: false,\n            merkle_path: false,\n            mmcs_bit: true,\n            mmcs_index_sum: Val::ZERO,\n            input_values: state_b.to_vec(),\n            in_ctl: [false; POSEIDON2_LIMBS],\n            input_indices: [0; POSEIDON2_LIMBS],\n            out_ctl: [false; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            output_indices: [0; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            mmcs_index_sum_idx: 0,\n            mmcs_ctl_enabled: false,\n        };\n\n        // Row C: new_start=false, merkle mode, mmcs_bit=false\n        // In merkle mode with mmcs_bit=0: prev digest (out[0..1]) goes to input limbs 0..1\n        // The rest (limbs 2..3) can be zeros (sibling)\n        const D: usize = 4; // extension degree\n        let mut state_c = [Val::ZERO; WIDTH];\n        // Chain prev output[0..2*D] into input[0..2*D] (limbs 0-1)\n        state_c[0..2 * D].copy_from_slice(\u0026output_b[0..2 * D]);\n        let output_c = perm.permute(state_c);\n\n        let sponge_c: Poseidon2CircuitRow\u003cVal\u003e = Poseidon2CircuitRow {\n            new_start: false,\n            merkle_path: true,\n            mmcs_bit: false,\n            mmcs_index_sum: Val::ZERO,\n            input_values: state_c.to_vec(),\n            in_ctl: [false; POSEIDON2_LIMBS],\n            input_indices: [0; POSEIDON2_LIMBS],\n            out_ctl: [false; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            output_indices: [0; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            mmcs_index_sum_idx: 0,\n            mmcs_ctl_enabled: false,\n        };\n\n        // Row D: new_start=false, sponge mode - chain from output_c\n        let state_d = output_c;\n\n        let sponge_d: Poseidon2CircuitRow\u003cVal\u003e = Poseidon2CircuitRow {\n            new_start: false,\n            merkle_path: false,\n            mmcs_bit: false,\n            mmcs_index_sum: Val::ZERO,\n            input_values: state_d.to_vec(),\n            in_ctl: [false; POSEIDON2_LIMBS],\n            input_indices: [0; POSEIDON2_LIMBS],\n            out_ctl: [false; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            output_indices: [0; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            mmcs_index_sum_idx: 0,\n            mmcs_ctl_enabled: false,\n        };\n\n        let mut rows = vec![sponge_a, sponge_b, sponge_c, sponge_d];\n        let degree_bits = 5;\n        let target_rows = 1 \u003c\u003c degree_bits;\n        if rows.len() \u003c target_rows {\n            // Filler rows must have new_start=true to avoid chaining constraints\n            let filler = Poseidon2CircuitRow {\n                new_start: true,\n                merkle_path: false,\n                mmcs_bit: false,\n                mmcs_index_sum: Val::ZERO,\n                input_values: vec![Val::ZERO; WIDTH],\n                in_ctl: [false; POSEIDON2_LIMBS],\n                input_indices: [0; POSEIDON2_LIMBS],\n                out_ctl: [false; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n                output_indices: [0; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n                mmcs_index_sum_idx: 0,\n                mmcs_ctl_enabled: false,\n            };\n            rows.resize(target_rows, filler);\n        }\n\n        let preprocessed = extract_preprocessed_from_operations::\u003cVal, Val\u003e(\u0026rows);\n        let air = Poseidon2CircuitAirBabyBearD4Width16::new_with_preprocessed(\n            constants.clone(),\n            preprocessed,\n        );\n\n        let trace = air.generate_trace_rows(\u0026rows, \u0026constants, fri_params.log_blowup);\n\n        type Dft = p3_dft::Radix2Bowers;\n        let dft = Dft::default();\n\n        type Pcs = TwoAdicFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs\u003e;\n        let pcs = Pcs::new(dft, val_mmcs, fri_params);\n\n        type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\n        let config = MyConfig::new(pcs, challenger);\n\n        let (preprocessed_prover, preprocessed_verifier) =\n            setup_preprocessed(\u0026config, \u0026air, degree_bits).unzip();\n        let proof =\n            prove_with_preprocessed(\u0026config, \u0026air, trace, \u0026[], preprocessed_prover.as_ref());\n\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026[], preprocessed_verifier.as_ref())\n    }\n\n    #[test]\n    fn test_air_constraint_degree() {\n        let mut rng = SmallRng::seed_from_u64(1);\n        let constants = RoundConstants::new(rng.random(), rng.random(), rng.random());\n\n        let air = Poseidon2CircuitAirBabyBearD4Width16::new(constants);\n        p3_test_utils::assert_air_constraint_degree!(air, \"Poseidon2CircuitAir\");\n    }\n}\n","traces":[{"line":96,"address":[2129040,2129232,2129424,2129616],"length":1,"stats":{"Line":0}},{"line":98,"address":[2336926,2337117,2337309,2336734],"length":1,"stats":{"Line":0}},{"line":99,"address":[6924306,6924114,6924496,6924688],"length":1,"stats":{"Line":0}},{"line":100,"address":[7110299,7110489,7110107,7110684],"length":1,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[13401360],"length":1,"stats":{"Line":6}},{"line":111,"address":[3956197,3956052],"length":1,"stats":{"Line":6}},{"line":141,"address":[3733312,3733472,3732976,3733136],"length":1,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[7120544,7120704,7120368,7120208],"length":1,"stats":{"Line":3}},{"line":152,"address":[6547557,6548053,6547717,6547893],"length":1,"stats":{"Line":3}},{"line":157,"address":[6251536,6251696,6251552,6251216,6251363,6251392,6251200,6251056],"length":1,"stats":{"Line":3}},{"line":158,"address":[3760886,3760661,3761046,3761157,3760837,3760710,3760997,3761206],"length":1,"stats":{"Line":4}},{"line":159,"address":[6251180,6251516,6251676,6251343],"length":1,"stats":{"Line":2}},{"line":162,"address":[4840768,4841584,4841312,4841040,4841553,4841009,4841281,4841831],"length":1,"stats":{"Line":5}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[1627790],"length":1,"stats":{"Line":5}},{"line":179,"address":[6547440,6547456,6547472,6547488],"length":1,"stats":{"Line":6}},{"line":180,"address":[4184833,4184865,4184849,4184817],"length":1,"stats":{"Line":6}},{"line":183,"address":[4830251,4830304,4838219,4838225,4827616,4835584,4832897,4830257,4832944,4832891,4835531,4835537],"length":1,"stats":{"Line":4}},{"line":189,"address":[4830418,4833058,4827730,4835698],"length":1,"stats":{"Line":4}},{"line":190,"address":[4600115],"length":1,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[1624679],"length":1,"stats":{"Line":4}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[4600172],"length":1,"stats":{"Line":4}},{"line":203,"address":[6254626,6251938,6254685,6259906,6257266,6251997,6257325,6259965],"length":1,"stats":{"Line":4}},{"line":208,"address":[6259994,6254677,6260161,6254881,6257354,6251989,6257317,6254714,6252026,6257521,6252193,6259957],"length":1,"stats":{"Line":9}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[6254959,6252170,6257599,6257498,6260138,6252271,6254858,6260239],"length":1,"stats":{"Line":10}},{"line":215,"address":[4828221,4836189,4830909,4833549],"length":1,"stats":{"Line":5}},{"line":216,"address":[1625131],"length":1,"stats":{"Line":5}},{"line":219,"address":[4836231,4830951,4828263,4833591,4831106,4836386,4828418,4833746],"length":1,"stats":{"Line":10}},{"line":221,"address":[6260520,6255240,6252552,6257880],"length":1,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[4601144],"length":1,"stats":{"Line":4}},{"line":224,"address":[4601167],"length":1,"stats":{"Line":4}},{"line":225,"address":[1625717],"length":1,"stats":{"Line":4}},{"line":226,"address":[1625740],"length":1,"stats":{"Line":4}},{"line":227,"address":[1625763],"length":1,"stats":{"Line":4}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[4601726,4601893],"length":1,"stats":{"Line":4}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[6258883,6261523,6253555,6256243],"length":1,"stats":{"Line":4}},{"line":240,"address":[4601959,4601846],"length":1,"stats":{"Line":9}},{"line":243,"address":[4829717,4835006,4837662,4832389,4832366,4829694,4835029,4837685],"length":1,"stats":{"Line":10}},{"line":245,"address":[6256513,6259153,6253841,6261809],"length":1,"stats":{"Line":2}},{"line":250,"address":[4602044],"length":1,"stats":{"Line":5}},{"line":252,"address":[4602169],"length":1,"stats":{"Line":5}},{"line":254,"address":[],"length":0,"stats":{"Line":5}},{"line":256,"address":[1626814],"length":1,"stats":{"Line":5}},{"line":257,"address":[4602377],"length":1,"stats":{"Line":4}},{"line":260,"address":[4602441],"length":1,"stats":{"Line":4}},{"line":267,"address":[1625805],"length":1,"stats":{"Line":4}},{"line":268,"address":[1625928],"length":1,"stats":{"Line":4}},{"line":269,"address":[6253152,6258480,6255840,6261120],"length":1,"stats":{"Line":4}},{"line":270,"address":[],"length":0,"stats":{"Line":13}},{"line":271,"address":[],"length":0,"stats":{"Line":5}},{"line":274,"address":[1627310],"length":1,"stats":{"Line":5}},{"line":275,"address":[],"length":0,"stats":{"Line":5}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[4840450,4839202,4838578,4839826],"length":1,"stats":{"Line":5}},{"line":287,"address":[6263353,6264601,6263977,6262729],"length":1,"stats":{"Line":5}},{"line":288,"address":[6264651,6264027,6262779,6263403],"length":1,"stats":{"Line":5}},{"line":291,"address":[],"length":0,"stats":{"Line":5}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[4603122,4603200],"length":1,"stats":{"Line":5}},{"line":306,"address":[4834525,4837165,4829197,4831885],"length":1,"stats":{"Line":5}},{"line":309,"address":[6256055,6261335,6253367,6258695],"length":1,"stats":{"Line":4}},{"line":340,"address":[8725408,8725392,8725376,8725424],"length":1,"stats":{"Line":5}},{"line":341,"address":[8660901,8660917,8660869,8660885],"length":1,"stats":{"Line":5}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[8274810,8277655,8276272,8273383,8276225,8272000,8273377,8273424,8274804,8274848,8276231,8277649],"length":1,"stats":{"Line":4}},{"line":347,"address":[4657098,4654218,4655658,4652778],"length":1,"stats":{"Line":2}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[4541323],"length":1,"stats":{"Line":4}},{"line":357,"address":[3561452,3565772,3561289,3564169,3564332,3562892,3562729,3565609],"length":1,"stats":{"Line":4}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[1581798],"length":1,"stats":{"Line":4}},{"line":362,"address":[4541466],"length":1,"stats":{"Line":4}},{"line":363,"address":[3565847,3562967,3564407,3565757,3564317,3561527,3561437,3562877],"length":1,"stats":{"Line":8}},{"line":364,"address":[8272580,8274004,8275428,8276852],"length":1,"stats":{"Line":4}},{"line":366,"address":[3563084,3565964,3561644,3564524,3564746,3561866,3563306,3566186],"length":1,"stats":{"Line":6}},{"line":367,"address":[8274209,8277057,8275633,8272785],"length":1,"stats":{"Line":2}},{"line":370,"address":[1582079],"length":1,"stats":{"Line":4}},{"line":371,"address":[6087239,6088736,6085799,6087296,6088679,6090119,6085856,6090176],"length":1,"stats":{"Line":8}},{"line":372,"address":[1582437],"length":1,"stats":{"Line":4}},{"line":374,"address":[4542028],"length":1,"stats":{"Line":4}},{"line":375,"address":[4656680,4653800,4655243,4658120],"length":1,"stats":{"Line":4}},{"line":376,"address":[4542302,4542250],"length":1,"stats":{"Line":0}},{"line":377,"address":[8276220,8274799,8273372,8277644],"length":1,"stats":{"Line":0}},{"line":378,"address":[3565146,3562223,3563706,3562266,3565103,3566546,3566589,3563663],"length":1,"stats":{"Line":0}},{"line":380,"address":[6087409,6090289,6085972,6088849],"length":1,"stats":{"Line":4}},{"line":384,"address":[4707024,4708491,4709979,4709985,4708497,4708512],"length":1,"stats":{"Line":4}},{"line":387,"address":[4568839,4568932],"length":1,"stats":{"Line":4}},{"line":389,"address":[],"length":0,"stats":{"Line":8}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[6132940,6131452],"length":1,"stats":{"Line":4}},{"line":392,"address":[],"length":0,"stats":{"Line":4}},{"line":393,"address":[1594070],"length":1,"stats":{"Line":4}},{"line":394,"address":[1594093],"length":1,"stats":{"Line":4}},{"line":395,"address":[],"length":0,"stats":{"Line":4}},{"line":396,"address":[6133052,6131564],"length":1,"stats":{"Line":4}},{"line":397,"address":[6131587,6133075],"length":1,"stats":{"Line":4}},{"line":398,"address":[6131610,6133098],"length":1,"stats":{"Line":4}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[1594316,1594205],"length":1,"stats":{"Line":8}},{"line":403,"address":[1594820,1594422,1594790],"length":1,"stats":{"Line":8}},{"line":404,"address":[4709679,4709705,4708140,4708191,4709628,4708217],"length":1,"stats":{"Line":8}},{"line":406,"address":[],"length":0,"stats":{"Line":8}},{"line":408,"address":[1594981,1595010],"length":1,"stats":{"Line":8}},{"line":409,"address":[6132447,6133935],"length":1,"stats":{"Line":3}},{"line":411,"address":[],"length":0,"stats":{"Line":4}},{"line":413,"address":[6132458,6133946],"length":1,"stats":{"Line":4}},{"line":415,"address":[],"length":0,"stats":{"Line":8}},{"line":416,"address":[1595120],"length":1,"stats":{"Line":2}},{"line":418,"address":[6133997,6132509],"length":1,"stats":{"Line":4}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[1594495],"length":1,"stats":{"Line":4}},{"line":425,"address":[4707905,4710023,4710135,4709393,4710000,4710112],"length":1,"stats":{"Line":12}},{"line":426,"address":[4570305],"length":1,"stats":{"Line":4}},{"line":428,"address":[6133500,6132012],"length":1,"stats":{"Line":4}},{"line":430,"address":[6132070,6133542,6132054,6133558],"length":1,"stats":{"Line":8}},{"line":431,"address":[4569753],"length":1,"stats":{"Line":0}},{"line":433,"address":[1594634],"length":1,"stats":{"Line":4}},{"line":435,"address":[6133584,6132096],"length":1,"stats":{"Line":4}},{"line":436,"address":[6133614,6132126],"length":1,"stats":{"Line":4}},{"line":437,"address":[4569835],"length":1,"stats":{"Line":4}},{"line":440,"address":[],"length":0,"stats":{"Line":4}},{"line":443,"address":[6192752,6200400,6178528,6214560,6178128,6173679,6236432,6222272,6170480,6134723,6185040,6214963,6225071,6142035,6192352,6195551,6236835,6207648,6221872,6229520,6163968,6244147,6170880,6203199,6200000,6208048,6134320,6163568,6229920,6156256,6185443,6148944,6149347,6156659,6141632,6243744],"length":1,"stats":{"Line":19}},{"line":499,"address":[1595430,1602742,1610054,1616966],"length":1,"stats":{"Line":19}},{"line":500,"address":[1595610,1617146,1602922,1610234],"length":1,"stats":{"Line":19}},{"line":501,"address":[1880902,1873590],"length":1,"stats":{"Line":18}},{"line":504,"address":[6185418,6178506,6215013,6192730,6156634,6208099,6200451,6214938,6149322,6236810,6163946,6229898,6156709,6170931,6170858,6222323,6244197,6134698,6142010,6185493,6192803,6200378,6134773,6178579,6149397,6236885,6229971,6208026,6164019,6142085,6244122,6222250],"length":1,"stats":{"Line":37}},{"line":510,"address":[6215020,6134780,6192810,6208106,6142092,6164026,6156716,6178586,6149404,6185500,6200458,6244204,6170938,6222330,6236892,6229978],"length":1,"stats":{"Line":20}},{"line":511,"address":[8384362,8398986,8529018,8500122,8550650,8572522,8377450,8586746,8600970,8406634,8325834,8492810,8514746,8464314,8443130,8471626,8333482,8557562,8435818,8391674,8457402,8340794,8318922,8478986,8564874,8348106,8421594,8413946,8485898,8579434,8450042,8507434,8370138,8362778,8522106,8536378,8593658,8543738,8355466,8428906],"length":1,"stats":{"Line":20}},{"line":512,"address":[6236904,6185512,6178598,6192822,6222342,6170950,6229990,6156728,6164038,6244216,6142104,6215032,6149416,6134792,6200470,6208118],"length":1,"stats":{"Line":19}},{"line":513,"address":[1603303,1610613,1595991,1610402,1617525,1617314,1603092,1595780],"length":1,"stats":{"Line":19}},{"line":514,"address":[1603281,1610591,1610686,1603332,1596064,1603376,1617554,1617598,1596020,1617503,1595969,1610642],"length":1,"stats":{"Line":38}},{"line":520,"address":[6200730,6200803,6149676,6193082,6142437,6230323,6171283,6237237,6156988,6237164,6149749,6135052,6142364,6157061,6185772,6185845,6222602,6178931,6164371,6208378,6215292,6230250,6164298,6135125,6244476,6178858,6222675,6193155,6244549,6208451,6215365,6171210],"length":1,"stats":{"Line":38}},{"line":521,"address":[3730566,3740014,3760607,3666684,3696268,3732364,3650573,3679832,3759736,3702965,3747324,3702029,3680703,3652462,3711228,3688958,3673381,3716342,3725452,3739061,3754238,3703918,3717193,3672445,3674334,3724511,3658831,3723640,3731417,3738125,3659772,3665737,3687144,3688015,3753289,3709416,3694456,3746383,3664886,3752438,3644812,3681646,3710287,3695327,3718142,3745512,3657960,3651509],"length":1,"stats":{"Line":59}},{"line":522,"address":[1601946,1609258,1609150,1623743,1601838,1616076,1623635,1616184],"length":1,"stats":{"Line":20}},{"line":523,"address":[4599332,4592020,4599286,4577275,4577321,4584708,4584662,4591974],"length":1,"stats":{"Line":42}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[4775176,4818920,4767864,4782488,4767949,4819005,4745928,4753240,4724877,4724792,4746013,4753325,4760552,4760637,4775261,4782573],"length":1,"stats":{"Line":22}},{"line":527,"address":[1887704,1880167],"length":1,"stats":{"Line":19}},{"line":528,"address":[],"length":0,"stats":{"Line":19}},{"line":540,"address":[8326675,8580311,8371015,8565715,8356309,8369106,8522993,8592641,8392551,8458289,8397955,8414848,8506403,8537250,8436661,8376419,8556545,8363619,8332371,8484881,8528001,8479873,8465191,8443971,8549633,8470595,8477954,8573409,8601842,8594535,8551537,8508311,8450914,8513715,8370981,8319809,8407477,8607298,8486785,8347075,8442099,8601811,8587633,8493653,8585715,8390643,8422471,8385205,8578417,8500999,8529859,8436695,8334359,8521074,8522947,8341637,8472467,8414787,8450883,8508277,8515587,8587587,8356343,8378291,8334325,8385239,8429793,8378337,8354434,8405523,8348947,8458243,8399827,8434801,8422437,8412915,8363650,8348978,8544625,8544579,8449025,8529890,8565776,8341671,8571411,8499091,8535346,8537219,8493687,8399888,8361747,8515618,8580277,8444017,8599939,8491793,8319763,8429747,8594501,8479827,8465157,8551491,8558439,8326736,8383345,8427875,8573363,8324817,8420483,8392517,8339763,8463297,8500965,8407511,8542706,8563843,8472498,8558405,8486739,8456370],"length":1,"stats":{"Line":18}},{"line":544,"address":[1874328,1879615,1874407,1881656,1881748,1887162],"length":1,"stats":{"Line":55}},{"line":545,"address":[4591032,4598434,4598344,4576363,4591122,4584430,4576279,4579336,4591742,4586648,4583810,4577030,4593960,4583720,4599054,4571717],"length":1,"stats":{"Line":38}},{"line":546,"address":[],"length":0,"stats":{"Line":20}},{"line":548,"address":[1601289,1615515,1622971,1608601],"length":1,"stats":{"Line":19}},{"line":549,"address":[8361506,8405119,8563602,8420447,8361372,8477564,8484514,8484624,8412674,8477939,8556210,8556288,8456237,8383088,8346759,8456119,8491426,8376103,8448886,8535331,8361624,8339522,8324482,8441976,8339748,8420079,8442084,8513399,8324802,8376178,8527666,8456355,8571007,8578160,8331930,8397639,8592384,8427500,8491458,8376404,8491654,8520823,8498968,8592274,8542316,8368716,8484866,8499076,8420293,8578082,8585700,8376044,8354183,8585340,8477703,8434434,8592502,8427752,8527744,8412599,8549298,8390520,8606908,8607165,8427634,8542573,8339388,8368855,8470279,8484742,8527986,8346952,8556530,8513700,8578402,8585592,8592626,8606972,8563468,8578050,8346834,8331967,8470580,8441858,8383330,8397940,8354108,8470472,8477821,8535020,8390628,8368780,8405487,8448768,8513474,8427559,8455980,8376296,8434786,8441783,8484546,8549494,8520748,8556178,8361732,8549376,8383206,8578278,8599623,8599924,8382978,8607047,8339447,8513340,8506087,8361431,8412900,8563828,8397580,8571221,8599564,8470220,8521059,8427860,8434662,8412540,8448690,8506280,8354419,8332335,8434466,8462962,8324678,8397714,8491778,8390402,8585474,8563720,8534956,8324450,8390268,8397832,8354301,8339640,8390327,8449010,8347060,8354044,8463040,8498775,8513592,8332181,8368973,8462930,8477628,8448658,8520684,8527634,8542691,8324560,8405333,8405082,8542380,8527862,8542455,8549618,8434544,8498850,8549266,8556406,8570970,8571375,8599698,8599816,8607283,8369091,8463158,8491536,8592306,8420042,8585399,8383010,8535213,8346700,8498716,8463282,8412792,8456044,8470354,8535095,8441724,8506388,8506028,8563527,8520941,8506162],"length":1,"stats":{"Line":19}},{"line":554,"address":[4711576,4747643,4726508,4766604,4716078,4751980,4788203,4737419,4769579,4813323,4754955,4802763,4798764,4817660,4730507,4795646,4762267,4719195,4773916,4791144,4820664,4810206,4784204,4723532,4781228,4805704,4733420,4759292,4776891,4744668,4825166,4740331],"length":1,"stats":{"Line":38}},{"line":555,"address":[],"length":0,"stats":{"Line":60}},{"line":556,"address":[],"length":0,"stats":{"Line":40}},{"line":557,"address":[8591307,8418961,8526667,8570634,8426378,8330856,8447691,8490547,8411444,8533828,8477204,8345703,8606548,8447684,8375691,8605899,8577076,8339035,8440602,8469223,8598567,8526755,8533843,8389172,8505031,8541188,8562346,8353035,8454867,8338391,8555299,8555866,8512343,8605780,8345578,8361019,8330849,8374948,8483540,8367707,8374922,8389915,8577171,8548387,8490459,8338266,8461963,8519571,8469098,8541956,8419706,8548954,8338292,8548292,8520324,8433460,8533947,8448346,8427147,8411543,8346347,8490452,8382666,8512987,8331594,8412187,8367588,8512218,8505675,8527322,8323476,8404008,8605795,8353684,8469867,8541307,8577083,8396583,8519675,8512244,8360250,8368356,8469124,8548299,8382004,8418968,8441371,8389271,8426404,8491114,8498363,8584343,8382011,8562372,8584218,8483547,8426503,8577738,8598468,8440628,8454852,8323483,8563115,8599211,8447779,8396458,8462051,8519556,8454971,8591300,8367603,8455620,8497620,8404096,8404001,8411418,8526660,8352931,8360276,8569889,8584987,8497594,8461956,8562471,8360375,8598442,8434122,8591395,8504932,8584244,8484202,8476451,8389146,8324138,8555204,8504906,8541203,8375047,8419056,8476436,8396484,8330944,8569896,8555211,8591962,8433555,8440727,8345604,8352916,8404746,8462618,8476555,8397227,8323571,8483635,8497719,8382099,8433467,8534596,8569984],"length":1,"stats":{"Line":41}},{"line":558,"address":[4817232,4773488,4766076,4744240,4780800,4744140,4751452,4758864,4758764,4780700,4751552,4723004,4817132,4723104,4766176,4773388],"length":1,"stats":{"Line":22}},{"line":560,"address":[6212491,6197656,6241579,6190187,6234363,6146779,6182971,6219707,6205304,6227176,6175784,6168411,6248891,6161403,6154091,6139467],"length":1,"stats":{"Line":20}},{"line":561,"address":[4715607,4795212,4824732,4795430,4802574,4737424,4730163,4758934,4817247,4744673,4744255,4802338,4795175,4723537,4730114,4824950,4773921,4809990,4809735,4817469,4759297,4737230,4730082,4787859,4751505,4723119,4766129,4810211,4751789,4766191,4730512,4817185,4817302,4781233,4787778,4751622,4773725,4715644,4744193,4817665,4825171,4773441,4802419,4751985,4758879,4744477,4780815,4759101,4737026,4730318,4723057,4773503,4781037,4780753,4758817,4788208,4715862,4802370,4809772,4802768,4766413,4766246,4773558,4788014,4780870,4716083,4751567,4723341,4766609,4723174,4737075,4744310,4787810,4736994,4824695,4795651],"length":1,"stats":{"Line":20}},{"line":566,"address":[3754813,3656332,3736438,3692828,3747902,3729081,3667290,3685516,3670758,3645418,3732970,3722012,3758108,3740589,3750953,3653037,3674909,3711806,3707788,3714857,3700342,3660350,3696874,3704493,3718717,3726030,3678204,3743884,3663401,3648886,3682221,3689533],"length":1,"stats":{"Line":37}},{"line":567,"address":[],"length":0,"stats":{"Line":37}},{"line":568,"address":[1877584,1877492],"length":1,"stats":{"Line":20}},{"line":570,"address":[3662910,3714366,3670193,3692307,3728590,3655811,3757587,3684995,3750462,3677683,3648321,3735873,3743363,3699777,3721491,3707267],"length":1,"stats":{"Line":18}},{"line":571,"address":[4780249,4729742,4772623,4743689,4743321,4722323,4714765,4780369,4765257,4743459,4816681,4824161,4736237,4787438,4729325,4801557,4808893,4758083,4809355,4743375,4757945,4757999,4794641,4808864,4758433,4787021,4751001,4809201,4729618,4750771,4772937,4773057,4823853,4801998,4722239,4736312,4751121,4765625,4816801,4779935,4801656,4765311,4722673,4787096,4772707,4801874,4729400,4729301,4794795,4715227,4787314,4780019,4824315,4736530,4794333,4765745,4816313,4786997,4722185,4816367,4736654,4743809,4765395,4750633,4816451,4722553,4750687,4758313,4714736,4794304,4736213,4779881,4715073,4801581,4772569,4823824],"length":1,"stats":{"Line":18}},{"line":575,"address":[1882274,1877174,1874933,1884692],"length":1,"stats":{"Line":37}},{"line":576,"address":[3661895,3645791,3742296,3748272,3669187,3667663,3734769,3749402,3676501,3698625,3713351,3720309,3706085,3749545,3713306,3727575,3683765,3654744,3706200,3691240,3756405,3683813,3647315,3698771,3756520,3720261,3661993,3689906,3712176,3706037,3704866,3683928,3660720,3719090,3691125,3697247,3676453,3653410,3734721,3654581,3755186,3749447,3756357,3669041,3742133,3691077,3726400,3647169,3661850,3733343,3740962,3675282,3676616,3742181,3647217,3727530,3682594,3713449,3654629,3669089,3720424,3727673,3734867,3698673],"length":1,"stats":{"Line":56}},{"line":577,"address":[6137439,6181201,6210721,6225186,6225227,6203314,6239551,6152011,6159375,6144751,6181160,6195707,6246863,6159323,6188159,6217627,6203355,6152063,6232552,6173835,6166641,6166600,6195666,6217679,6144699,6232593,6246811,6210680,6188107,6173794,6137387,6239499],"length":1,"stats":{"Line":38}},{"line":578,"address":[1613725,1598449,1605735,1599253,1613017,1598423,1598548,1621008,1620211,1605860,1620218,1613024,1605761,1620306,1606565,1613112],"length":1,"stats":{"Line":37}},{"line":579,"address":[3756665,3756757,3676853,3691385,3684165,3720569,3654889,3676761,3706345,3691477,3706437,3742533,3720661,3654981,3684073,3742441],"length":1,"stats":{"Line":22}},{"line":581,"address":[4735360,4742376,4800704,4721240,4778936,4807898,4728448,4764312,4793338,4771624,4822858,4786144,4749688,4757000,4713770,4815368],"length":1,"stats":{"Line":19}},{"line":582,"address":[1884198,1884476,1876692,1877179,1876638,1876776,1884697,1876983,1884169],"length":1,"stats":{"Line":18}},{"line":588,"address":[1882452,1875116],"length":1,"stats":{"Line":18}},{"line":589,"address":[4573632,4579970,4588374,4572556,4595686,4572407,4587370,4580058,4587282,4594682,4594594,4581062],"length":1,"stats":{"Line":18}},{"line":590,"address":[1604940,1597628,1597520,1605122,1597810,1604832],"length":1,"stats":{"Line":31}},{"line":592,"address":[],"length":0,"stats":{"Line":18}},{"line":593,"address":[1605077,1604955,1619288,1619433,1612255,1597765,1612383,1597643],"length":1,"stats":{"Line":37}},{"line":595,"address":[],"length":0,"stats":{"Line":58}},{"line":596,"address":[],"length":0,"stats":{"Line":41}},{"line":599,"address":[4573447,4580926,4595550,4588238],"length":1,"stats":{"Line":20}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[4749280,4785797,4756592,4735013,4792915,4728101,4822435,4814960,4800357,4771216,4720832,4778528,4763904,4741968,4807475,4713347],"length":1,"stats":{"Line":20}},{"line":632,"address":[8317264,8318320,8318512,8317120,8318224,8317840,8318272,8317504,8317792,8317360,8317984,8318128,8318176,8317696,8317600,8318608,8317936,8318464,8318416,8317168,8318032,8317216,8318752,8317312,8318080,8318368,8318560,8317648,8318704,8317744,8317888,8317408,8317072,8317552,8318656,8317456],"length":1,"stats":{"Line":6}},{"line":689,"address":[6130673,6130721,6130817,6130913,6131105,6130865,6131009,6130961,6130577,6130769,6130625,6131057],"length":1,"stats":{"Line":6}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[3638610,3639544,3641394,3638616,3637712,3638640,3639568,3640466,3640472,3640496,3641400,3639538],"length":1,"stats":{"Line":12}},{"line":750,"address":[1840279,1841195],"length":1,"stats":{"Line":12}},{"line":751,"address":[],"length":0,"stats":{"Line":24}},{"line":752,"address":[1840523,1841309,1841360,1840457],"length":1,"stats":{"Line":24}},{"line":753,"address":[4566699,4568331,4567489,4565922],"length":1,"stats":{"Line":13}},{"line":754,"address":[3638146,3639074,3639128,3640984,3640930,3640002,3638200,3640056],"length":1,"stats":{"Line":26}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[1591012,1591888],"length":1,"stats":{"Line":8}},{"line":762,"address":[3639422,3641224,3639368,3638494,3638440,3640296,3641278,3640350],"length":1,"stats":{"Line":26}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[1590096],"length":1,"stats":{"Line":3}},{"line":780,"address":[3637064,3636392,3637288,3636840,3635944,3636616,3636168,3637512],"length":1,"stats":{"Line":3}},{"line":781,"address":[6125143,6126720,6126422,6126487,6125529,6125078,6125600,6125367,6125974,6126039,6125750,6126198,6125815,6126263,6126649,6125302],"length":1,"stats":{"Line":3}},{"line":782,"address":[],"length":0,"stats":{"Line":6}},{"line":785,"address":[3618087,3621347,3625367,3628640,3614060,3628620,3632647,3635907,3621360,3606800,3614080,3610807],"length":1,"stats":{"Line":3}},{"line":790,"address":[6110623,6117903,6096063,6103343],"length":1,"stats":{"Line":3}},{"line":791,"address":[1582980],"length":1,"stats":{"Line":3}},{"line":796,"address":[1583044],"length":1,"stats":{"Line":3}},{"line":797,"address":[4692131,4684835,4692055,4670167,4670243,4677539,4677463,4684759],"length":1,"stats":{"Line":6}},{"line":799,"address":[6096373,6103653,6110933,6118213],"length":1,"stats":{"Line":3}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[1583331],"length":1,"stats":{"Line":3}},{"line":816,"address":[4684503,4691799,4669911,4677207],"length":1,"stats":{"Line":3}},{"line":817,"address":[3621411,3628691,3606851,3614131],"length":1,"stats":{"Line":3}},{"line":818,"address":[4692295,4685065,4684999,4670407,4670473,4677703,4692361,4677769],"length":1,"stats":{"Line":3}},{"line":819,"address":[3629277,3621935,3607437,3621997,3614794,3614717,3607375,3607514,3629215,3614655,3622074,3629354],"length":1,"stats":{"Line":6}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[3622052,3607540,3622100,3607570,3614772,3614850,3614820,3622130,3629332,3629380,3629410,3607492],"length":1,"stats":{"Line":6}},{"line":822,"address":[4670620,4685212,4670701,4677997,4677967,4685293,4692508,4692589,4677916,4670671,4685263,4692559],"length":1,"stats":{"Line":6}},{"line":823,"address":[],"length":0,"stats":{"Line":6}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[6111581,6097021,6104301,6118861],"length":1,"stats":{"Line":4}},{"line":831,"address":[4692885,4685589,4678293,4670997],"length":1,"stats":{"Line":4}},{"line":832,"address":[4685815,4671223,4693111,4678519],"length":1,"stats":{"Line":4}},{"line":835,"address":[3630015,3608175,3615455,3622735],"length":1,"stats":{"Line":4}},{"line":837,"address":[],"length":0,"stats":{"Line":4}},{"line":847,"address":[],"length":0,"stats":{"Line":4}},{"line":848,"address":[8298567,8306010,8289672,8291450,8296952,8298730,8284170,8311519,8284007,8304239,8305847,8291287],"length":1,"stats":{"Line":4}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[3613965,3608615,3630455,3623267,3630547,3615987,3635812,3621252,3615895,3628525,3608707,3623175],"length":1,"stats":{"Line":11}},{"line":852,"address":[6116294,6119788,6123581,6105228,6112508,6097948,6101741,6109014,6116471,6123758,6101918,6109191],"length":1,"stats":{"Line":8}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[3620045,3627318,3634605,3612758,3634672,3627385,3620112,3612825],"length":1,"stats":{"Line":7}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[8303175,8295888,8310455,8288608],"length":1,"stats":{"Line":3}},{"line":858,"address":[4690831,4683542,4676239,4698134],"length":1,"stats":{"Line":3}},{"line":859,"address":[8296106,8303393,8288826,8310673],"length":1,"stats":{"Line":3}},{"line":861,"address":[3627812,3613252,3620539,3635099],"length":1,"stats":{"Line":3}},{"line":865,"address":[6124353,6102544,6117066,6109690,6124257,6117676,6124963,6110396,6102417,6124384,6109817,6116970,6109786,6103123,6102513,6117097],"length":1,"stats":{"Line":6}},{"line":867,"address":[6124831,6102991,6124894,6110264,6110327,6103054,6117607,6117544],"length":1,"stats":{"Line":6}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[1589601,1589525],"length":1,"stats":{"Line":6}},{"line":870,"address":[3635465,3620905,3628178,3613618],"length":1,"stats":{"Line":3}},{"line":874,"address":[8299058,8284498,8306338,8295461,8310028,8288181,8302748,8291778],"length":1,"stats":{"Line":6}},{"line":875,"address":[],"length":0,"stats":{"Line":6}},{"line":877,"address":[4681463,4696055,4688759,4674167,4674243,4688835,4681539,4696131],"length":1,"stats":{"Line":6}},{"line":879,"address":[4681730,4674434,4696322,4689026],"length":1,"stats":{"Line":3}},{"line":880,"address":[4681779,4689068,4696371,4674476],"length":1,"stats":{"Line":3}},{"line":881,"address":[6100742,6122582,6108015,6115295],"length":1,"stats":{"Line":3}},{"line":882,"address":[],"length":0,"stats":{"Line":3}},{"line":884,"address":[],"length":0,"stats":{"Line":3}},{"line":887,"address":[8309331,8287627,8294764,8287420,8295496,8294700,8288216,8302194,8287484,8301987,8310063,8302783,8309267,8294907,8302051,8309474],"length":1,"stats":{"Line":9}},{"line":888,"address":[],"length":0,"stats":{"Line":3}},{"line":889,"address":[3619179,3633739,3611892,3626452],"length":1,"stats":{"Line":3}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[8295376,8309943,8288096,8302663,8309998,8288151,8295431,8302718],"length":1,"stats":{"Line":6}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":6}},{"line":896,"address":[1588398],"length":1,"stats":{"Line":3}},{"line":904,"address":[6120037,6098197,6098302,6112862,6105477,6120142,6105582,6112757],"length":1,"stats":{"Line":3}},{"line":905,"address":[4672228,4679524,4672291,4687023,4694116,4679587,4686883,4694319,4679727,4694179,4672431,4686820],"length":1,"stats":{"Line":6}},{"line":906,"address":[],"length":0,"stats":{"Line":6}},{"line":908,"address":[],"length":0,"stats":{"Line":3}},{"line":909,"address":[8285406,8285377,8285205,8307045,8307217,8307116,8299664,8285276,8292384,8293769,8292556,8299937,8299836,8286489,8299765,8292485,8301049,8306944,8285104,8292686,8292657,8307246,8308329,8299966],"length":1,"stats":{"Line":9}},{"line":910,"address":[1585581],"length":1,"stats":{"Line":3}},{"line":911,"address":[3616956,3609676,3631516,3624236],"length":1,"stats":{"Line":3}},{"line":914,"address":[8292987,8300169,8285609,8307547,8292889,8307449,8285707,8300267],"length":1,"stats":{"Line":6}},{"line":915,"address":[1585947],"length":1,"stats":{"Line":3}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[6106616,6099336,6121176,6113896],"length":1,"stats":{"Line":3}},{"line":920,"address":[3610122,3624682,3617402,3631962],"length":1,"stats":{"Line":3}},{"line":921,"address":[1586184],"length":1,"stats":{"Line":3}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":6}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":6}},{"line":927,"address":[3624964,3617684,3632244,3610404],"length":1,"stats":{"Line":3}},{"line":930,"address":[],"length":0,"stats":{"Line":3}}],"covered":232,"coverable":333},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","poseidon2-circuit-air","src","columns.rs"],"content":"use core::borrow::{Borrow, BorrowMut};\nuse core::mem::size_of;\n\nuse p3_poseidon2_air::Poseidon2Cols;\n\npub const POSEIDON2_LIMBS: usize = 4;\npub const POSEIDON2_PUBLIC_OUTPUT_LIMBS: usize = 2;\n\n/// Columns for a Poseidon2 AIR which computes one permutation per row.\n///\n/// This implements the Poseidon2 Permutation Table specification.\n/// See: https://github.com/Plonky3/Plonky3-recursion/discussions/186\n///\n/// The table implements a 4-limb Poseidon2 permutation supporting:\n/// - Standard chaining (Challenger-style sponge use)\n/// - Merkle-path chaining (MMCS directional hashing)\n/// - Selective limb exposure to the witness via CTL\n/// - Optional MMCS index accumulator\n///\n/// Column layout (per spec section 2):\n/// - Value columns: `poseidon2` (contains in[0..3] and out[0..3]), `mmcs_index_sum`, `mmcs_bit`\n/// - Transparent columns: `new_start`, `merkle_path`, CTL flags and indices\n/// - Selector columns (not in spec): `normal_chain_sel`, `merkle_chain_sel`\n///   These are precomputed to reduce constraint degree to 3.\n#[repr(C)]\npub struct Poseidon2CircuitCols\u003cT, P: PermutationColumns\u003cT\u003e\u003e {\n    /// The p3 Poseidon2 columns containing the permutation state.\n    /// Contains in[0..3] (4 extension limbs input) and out[0..3] (4 extension limbs output).\n    pub poseidon2: P,\n    /// Value: Direction bit for Merkle left/right hashing (only meaningful when merkle_path = 1).\n    /// This is a value column (not transparent) because it's used in constraints with mmcs_index_sum.\n    pub mmcs_bit: T,\n    /// Value column: Optional MMCS accumulator (base field, encodes a u32-like integer).\n    pub mmcs_index_sum: T,\n}\n\npub trait PermutationColumns\u003cT\u003e {}\n\nimpl\u003c\n    T,\n    const WIDTH: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e PermutationColumns\u003cT\u003e\n    for Poseidon2Cols\u003cT, WIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e\n{\n}\n\npub const fn num_cols\u003cP: PermutationColumns\u003cu8\u003e\u003e() -\u003e usize {\n    size_of::\u003cPoseidon2CircuitCols\u003cu8, P\u003e\u003e()\n}\n\nimpl\u003cT, P: PermutationColumns\u003cT\u003e\u003e Borrow\u003cPoseidon2CircuitCols\u003cT, P\u003e\u003e for [T] {\n    fn borrow(\u0026self) -\u003e \u0026Poseidon2CircuitCols\u003cT, P\u003e {\n        let (prefix, shorts, suffix) = unsafe { self.align_to::\u003cPoseidon2CircuitCols\u003cT, P\u003e\u003e() };\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\n        debug_assert_eq!(shorts.len(), 1);\n        \u0026shorts[0]\n    }\n}\n\nimpl\u003cT, P: PermutationColumns\u003cT\u003e\u003e BorrowMut\u003cPoseidon2CircuitCols\u003cT, P\u003e\u003e for [T] {\n    fn borrow_mut(\u0026mut self) -\u003e \u0026mut Poseidon2CircuitCols\u003cT, P\u003e {\n        let (prefix, shorts, suffix) = unsafe { self.align_to_mut::\u003cPoseidon2CircuitCols\u003cT, P\u003e\u003e() };\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\n        debug_assert_eq!(shorts.len(), 1);\n        \u0026mut shorts[0]\n    }\n}\n","traces":[{"line":51,"address":[5596912,5596896,5596864,5596880],"length":1,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[1692192],"length":1,"stats":{"Line":11}},{"line":57,"address":[1692215],"length":1,"stats":{"Line":11}},{"line":58,"address":[2123885],"length":1,"stats":{"Line":11}},{"line":59,"address":[9689364,9688260,9688996,9688628],"length":1,"stats":{"Line":11}},{"line":60,"address":[2123990],"length":1,"stats":{"Line":11}},{"line":61,"address":[9688769,9689137,9688401,9689530,9688426,9688794,9689505,9689162],"length":1,"stats":{"Line":11}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":14},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","poseidon2-circuit-air","src","lib.rs"],"content":"//! An AIR for the Poseidon2 table for recursion. Handles sponge operations and compressions.\n\n#![no_std]\n\nextern crate alloc;\n\nmod air;\nmod columns;\nmod public_types;\n\npub use air::*;\npub use columns::*;\npub use public_types::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","poseidon2-circuit-air","src","public_types.rs"],"content":"//! Public types for the Poseidon2 circuit AIR.\n//!\n//! Defines abstracted field-specific parameters for\n//! the Poseidon2 circuit AIR for commonly used configurations.\n\nuse p3_baby_bear::{BabyBear, GenericPoseidon2LinearLayersBabyBear};\nuse p3_circuit::ops::{Poseidon2Config, Poseidon2Params};\nuse p3_koala_bear::{GenericPoseidon2LinearLayersKoalaBear, KoalaBear};\n\nuse crate::Poseidon2CircuitAir;\n\n/// Poseidon2 configuration for BabyBear with D=4, WIDTH=16.\npub struct BabyBearD4Width16;\n\nimpl Poseidon2Params for BabyBearD4Width16 {\n    type BaseField = BabyBear;\n    const CONFIG: Poseidon2Config = Poseidon2Config::BabyBearD4Width16;\n}\n\n/// Poseidon2 configuration for BabyBear with D=4, WIDTH=24.\npub struct BabyBearD4Width24;\n\nimpl Poseidon2Params for BabyBearD4Width24 {\n    type BaseField = BabyBear;\n    const CONFIG: Poseidon2Config = Poseidon2Config::BabyBearD4Width24;\n}\n\n/// Poseidon2 configuration for KoalaBear with D=4, WIDTH=16.\npub struct KoalaBearD4Width16;\n\nimpl Poseidon2Params for KoalaBearD4Width16 {\n    type BaseField = KoalaBear;\n    const CONFIG: Poseidon2Config = Poseidon2Config::KoalaBearD4Width16;\n}\n\n/// Poseidon2 configuration for KoalaBear with D=4, WIDTH=24.\npub struct KoalaBearD4Width24;\n\nimpl Poseidon2Params for KoalaBearD4Width24 {\n    type BaseField = KoalaBear;\n    const CONFIG: Poseidon2Config = Poseidon2Config::KoalaBearD4Width24;\n}\n\n/// BabyBear Poseidon2 circuit AIR with D=4, WIDTH=16.\n/// Uses constants from `BabyBearD4Width16` configuration.\npub type Poseidon2CircuitAirBabyBearD4Width16 = Poseidon2CircuitAir\u003c\n    BabyBear,\n    GenericPoseidon2LinearLayersBabyBear,\n    { BabyBearD4Width16::D },\n    { BabyBearD4Width16::WIDTH },\n    { BabyBearD4Width16::WIDTH_EXT },\n    { BabyBearD4Width16::RATE_EXT },\n    { BabyBearD4Width16::CAPACITY_EXT },\n    { BabyBearD4Width16::SBOX_DEGREE },\n    { BabyBearD4Width16::SBOX_REGISTERS },\n    { BabyBearD4Width16::HALF_FULL_ROUNDS },\n    { BabyBearD4Width16::PARTIAL_ROUNDS },\n\u003e;\n\n/// BabyBear Poseidon2 circuit AIR with D=4, WIDTH=24.\n/// Uses constants from `BabyBearD4Width24` configuration.\npub type Poseidon2CircuitAirBabyBearD4Width24 = Poseidon2CircuitAir\u003c\n    BabyBear,\n    GenericPoseidon2LinearLayersBabyBear,\n    { BabyBearD4Width24::D },\n    { BabyBearD4Width24::WIDTH },\n    { BabyBearD4Width24::WIDTH_EXT },\n    { BabyBearD4Width24::RATE_EXT },\n    { BabyBearD4Width24::CAPACITY_EXT },\n    { BabyBearD4Width24::SBOX_DEGREE },\n    { BabyBearD4Width24::SBOX_REGISTERS },\n    { BabyBearD4Width24::HALF_FULL_ROUNDS },\n    { BabyBearD4Width24::PARTIAL_ROUNDS },\n\u003e;\n\n/// KoalaBear Poseidon2 circuit AIR with D=4, WIDTH=16.\n/// Uses constants from `KoalaBearD4Width16` configuration.\npub type Poseidon2CircuitAirKoalaBearD4Width16 = Poseidon2CircuitAir\u003c\n    KoalaBear,\n    GenericPoseidon2LinearLayersKoalaBear,\n    { KoalaBearD4Width16::D },\n    { KoalaBearD4Width16::WIDTH },\n    { KoalaBearD4Width16::WIDTH_EXT },\n    { KoalaBearD4Width16::RATE_EXT },\n    { KoalaBearD4Width16::CAPACITY_EXT },\n    { KoalaBearD4Width16::SBOX_DEGREE },\n    { KoalaBearD4Width16::SBOX_REGISTERS },\n    { KoalaBearD4Width16::HALF_FULL_ROUNDS },\n    { KoalaBearD4Width16::PARTIAL_ROUNDS },\n\u003e;\n\n/// KoalaBear Poseidon2 circuit AIR with D=4, WIDTH=24.\n/// Uses constants from `KoalaBearD4Width24` configuration.\npub type Poseidon2CircuitAirKoalaBearD4Width24 = Poseidon2CircuitAir\u003c\n    KoalaBear,\n    GenericPoseidon2LinearLayersKoalaBear,\n    { KoalaBearD4Width24::D },\n    { KoalaBearD4Width24::WIDTH },\n    { KoalaBearD4Width24::WIDTH_EXT },\n    { KoalaBearD4Width24::RATE_EXT },\n    { KoalaBearD4Width24::CAPACITY_EXT },\n    { KoalaBearD4Width24::SBOX_DEGREE },\n    { KoalaBearD4Width24::SBOX_REGISTERS },\n    { KoalaBearD4Width24::HALF_FULL_ROUNDS },\n    { KoalaBearD4Width24::PARTIAL_ROUNDS },\n\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","examples","recursive_aggregation.rs"],"content":"//! 2-to-1 proof aggregation example (binary tree).\n//!\n//! Builds a full binary aggregation tree from distinct base proofs:\n//! 1. **Leaves**: `2^(N+1)` dummy circuits (each a single distinct constant),\n//!    each proved independently with batch STARK.\n//! 2. **Levels 1..N+1**: Pairwise 2-to-1 aggregation up the tree until a\n//!    single root proof remains.\n//!\n//! `N` is the `--num-recursive-layers` argument (default 1).\n//!\n//! ## What this proves\n//!\n//! The root proof attests that every base proof in the tree is valid.  All\n//! base proofs are genuinely distinct (different constant values) so the\n//! circuit optimizer cannot collapse the two verifications inside an\n//! aggregation node.\n//!\n//! ## Usage\n//!\n//! ```bash\n//! # 4 base proofs, 2 aggregation levels (default)\n//! cargo run --release --example recursive_aggregation -- --field koala-bear\n//!\n//! # 8 base proofs, 3 aggregation levels, custom FRI parameters\n//! cargo run --release --example recursive_aggregation -- \\\n//!     --field koala-bear \\\n//!     --num-recursive-layers 2 \\\n//!     --log-blowup 3 \\\n//!     --max-log-arity 4 \\\n//!     --log-final-poly-len 5 \\\n//!     --query-pow-bits 16\n//! ```\n\nuse std::rc::Rc;\nuse std::sync::Arc;\n\nuse clap::{Parser, ValueEnum};\nuse p3_batch_stark::ProverData;\nuse p3_challenger::DuplexChallenger;\nuse p3_circuit::ops::generate_poseidon2_trace;\nuse p3_circuit::{CircuitBuilder, CircuitRunner, NonPrimitiveOpId};\nuse p3_circuit_prover::common::get_airs_and_degrees_with_prep;\nuse p3_circuit_prover::{BatchStarkProver, CircuitProverData, ConstraintProfile, TablePacking};\nuse p3_commit::{ExtensionMmcs, Pcs};\nuse p3_dft::Radix2DitParallel;\nuse p3_field::extension::BinomialExtensionField;\nuse p3_field::{Field, PrimeCharacteristicRing as _};\nuse p3_fri::{FriParameters, TwoAdicFriPcs};\nuse p3_lookup::logup::LogUpGadget;\nuse p3_merkle_tree::MerkleTreeMmcs;\nuse p3_recursion::pcs::{\n    InputProofTargets, MerkleCapTargets, RecValMmcs, set_fri_mmcs_private_data,\n};\nuse p3_recursion::traits::{RecursiveAir, RecursivePcs};\nuse p3_recursion::verifier::VerificationError;\nuse p3_recursion::{\n    AggregationPrepCache, BatchOnly, FriRecursionBackend, FriRecursionConfig, FriVerifierParams,\n    Poseidon2Config, ProveNextLayerParams, RecursionInput, RecursionOutput,\n    build_and_prove_aggregation_layer,\n};\nuse p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\nuse p3_uni_stark::{StarkConfig, StarkGenericConfig, Val};\nuse serde::Serialize;\nuse tracing::info;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n#[derive(Debug, Clone, Copy, ValueEnum)]\nenum FieldOption {\n    KoalaBear,\n    BabyBear,\n}\n\n#[derive(Debug, Clone, Copy)]\nstruct FriParams {\n    log_blowup: usize,\n    max_log_arity: usize,\n    cap_height: usize,\n    log_final_poly_len: usize,\n    commit_pow_bits: usize,\n    query_pow_bits: usize,\n}\n\n#[derive(Parser, Debug)]\n#[command(version, about = \"2-to-1 proof aggregation example\")]\nstruct Args {\n    #[arg(short, long, ignore_case = true, value_enum, default_value_t = FieldOption::KoalaBear)]\n    field: FieldOption,\n\n    /// Tree depth (total base proofs = 2^(tree_depth)).  (1 = single pair, 2 = 4 leaves, …)\n    #[arg(\n        long,\n        default_value_t = 1,\n        help = \"Tree depth (total base proofs = 2^(tree_depth))\"\n    )]\n    num_recursive_layers: usize,\n\n    #[arg(\n        long,\n        default_value_t = 3,\n        help = \"Logarithmic blowup factor for the LDE\"\n    )]\n    log_blowup: usize,\n\n    #[arg(\n        long,\n        default_value_t = 4,\n        help = \"Maximum arity allowed during FRI folding phases\"\n    )]\n    max_log_arity: usize,\n\n    #[arg(long, default_value_t = 0, help = \"Height of the Merkle cap to open\")]\n    cap_height: usize,\n\n    #[arg(\n        long,\n        default_value_t = 5,\n        help = \"Log size of final polynomial after FRI folding\"\n    )]\n    log_final_poly_len: usize,\n\n    #[arg(\n        long,\n        default_value_t = 0,\n        help = \"PoW grinding bits during FRI commit phase\"\n    )]\n    commit_pow_bits: usize,\n\n    #[arg(\n        long,\n        default_value_t = 16,\n        help = \"PoW grinding bits during FRI query phase\"\n    )]\n    query_pow_bits: usize,\n\n    #[arg(\n        long,\n        default_value_t = 4,\n        help = \"Number of witness lanes for the table packing in recursive layers\"\n    )]\n    witness_lanes: usize,\n\n    #[arg(\n        long,\n        default_value_t = 4,\n        help = \"Number of public lanes for the table packing in recursive layers\"\n    )]\n    public_lanes: usize,\n\n    #[arg(\n        long,\n        default_value_t = 2,\n        help = \"Number of ALU lanes for the table packing in recursive layers\"\n    )]\n    alu_lanes: usize,\n}\n\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    let _ = Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .try_init();\n}\n\nfn main() {\n    init_logger();\n\n    let args = Args::parse();\n    let fri_params = FriParams {\n        log_blowup: args.log_blowup,\n        max_log_arity: args.max_log_arity,\n        cap_height: args.cap_height,\n        log_final_poly_len: args.log_final_poly_len,\n        commit_pow_bits: args.commit_pow_bits,\n        query_pow_bits: args.query_pow_bits,\n    };\n\n    let table_packing = TablePacking::new(args.witness_lanes, args.public_lanes, args.alu_lanes);\n\n    assert!(args.num_recursive_layers \u003e= 1);\n\n    info!(\n        \"2-to-1 aggregation with field {:?}, {} aggregation recursive layers\",\n        args.field, args.num_recursive_layers\n    );\n\n    match args.field {\n        FieldOption::KoalaBear =\u003e {\n            koala_bear::run(args.num_recursive_layers, \u0026fri_params, \u0026table_packing);\n        }\n        FieldOption::BabyBear =\u003e {\n            baby_bear::run(args.num_recursive_layers, \u0026fri_params, \u0026table_packing);\n        }\n    }\n}\n\nmacro_rules! define_field_module {\n    (\n        $mod_name:ident,\n        $field:ty,\n        $perm:ty,\n        $default_perm:path,\n        $poseidon2_config:expr,\n        $poseidon2_circuit_config:ty\n    ) =\u003e {\n        mod $mod_name {\n            use super::*;\n\n            pub type F = $field;\n            pub const D: usize = 4;\n            const WIDTH: usize = 16;\n            const RATE: usize = 8;\n            const DIGEST_ELEMS: usize = 8;\n\n            type Challenge = BinomialExtensionField\u003cF, D\u003e;\n            type Dft = Radix2DitParallel\u003cF\u003e;\n            type Perm = $perm;\n            type MyHash = PaddingFreeSponge\u003cPerm, 16, RATE, 8\u003e;\n            type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\n            type ValMmcs =\n                MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\n            type ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\n            type Challenger = DuplexChallenger\u003cF, Perm, 16, RATE\u003e;\n            type MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\n            type MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\n            type InnerFri = p3_recursion::pcs::FriProofTargets\u003c\n                F,\n                Challenge,\n                p3_recursion::pcs::RecExtensionValMmcs\u003c\n                    F,\n                    Challenge,\n                    DIGEST_ELEMS,\n                    RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n                \u003e,\n                InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n                p3_recursion::pcs::Witness\u003cF\u003e,\n            \u003e;\n\n            #[derive(Clone)]\n            struct ConfigWithFriParams {\n                config: Arc\u003cMyConfig\u003e,\n                fri_verifier_params: FriVerifierParams,\n            }\n\n            impl core::ops::Deref for ConfigWithFriParams {\n                type Target = MyConfig;\n                fn deref(\u0026self) -\u003e \u0026MyConfig {\n                    \u0026self.config\n                }\n            }\n\n            impl StarkGenericConfig for ConfigWithFriParams {\n                type Challenge = Challenge;\n                type Challenger = Challenger;\n                type Pcs = MyPcs;\n                fn pcs(\u0026self) -\u003e \u0026MyPcs {\n                    self.config.pcs()\n                }\n                fn initialise_challenger(\u0026self) -\u003e Challenger {\n                    self.config.initialise_challenger()\n                }\n            }\n\n            impl FriRecursionConfig for ConfigWithFriParams\n            where\n                MyPcs: RecursivePcs\u003c\n                        ConfigWithFriParams,\n                        InputProofTargets\u003c\n                            F,\n                            Challenge,\n                            RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n                        \u003e,\n                        InnerFri,\n                        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n                        \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::Domain,\n                    \u003e,\n            {\n                type Commitment = MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e;\n                type InputProof = InputProofTargets\u003c\n                    F,\n                    Challenge,\n                    RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n                \u003e;\n                type OpeningProof = InnerFri;\n                type RawOpeningProof = \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::Proof;\n                const DIGEST_ELEMS: usize = 8;\n\n                fn with_fri_opening_proof\u003c'a, A, R\u003e(\n                    prev: \u0026RecursionInput\u003c'a, Self, A\u003e,\n                    f: impl FnOnce(\u0026Self::RawOpeningProof) -\u003e R,\n                ) -\u003e R\n                where\n                    A: RecursiveAir\u003cVal\u003cSelf\u003e, Self::Challenge, LogUpGadget\u003e,\n                {\n                    match prev {\n                        RecursionInput::UniStark { proof, .. } =\u003e f(\u0026proof.opening_proof),\n                        RecursionInput::BatchStark { proof, .. } =\u003e f(\u0026proof.proof.opening_proof),\n                    }\n                }\n\n                fn enable_poseidon2_on_circuit(\n                    \u0026self,\n                    circuit: \u0026mut CircuitBuilder\u003cChallenge\u003e,\n                ) -\u003e Result\u003c(), VerificationError\u003e {\n                    let perm = $default_perm();\n                    circuit.enable_poseidon2_perm::\u003c$poseidon2_circuit_config, _\u003e(\n                        generate_poseidon2_trace::\u003cChallenge, $poseidon2_circuit_config\u003e,\n                        perm,\n                    );\n                    Ok(())\n                }\n\n                fn pcs_verifier_params(\n                    \u0026self,\n                ) -\u003e \u0026\u003cMyPcs as RecursivePcs\u003c\n                    ConfigWithFriParams,\n                    InputProofTargets\u003c\n                        F,\n                        Challenge,\n                        RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n                    \u003e,\n                    InnerFri,\n                    MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n                    \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::Domain,\n                \u003e\u003e::VerifierParams {\n                    \u0026self.fri_verifier_params\n                }\n\n                fn set_fri_private_data(\n                    runner: \u0026mut CircuitRunner\u003cChallenge\u003e,\n                    op_ids: \u0026[NonPrimitiveOpId],\n                    opening_proof: \u0026Self::RawOpeningProof,\n                ) -\u003e Result\u003c(), \u0026'static str\u003e {\n                    set_fri_mmcs_private_data::\u003c\n                        F,\n                        Challenge,\n                        ChallengeMmcs,\n                        ValMmcs,\n                        MyHash,\n                        MyCompress,\n                        DIGEST_ELEMS,\n                    \u003e(runner, op_ids, opening_proof)\n                }\n            }\n\n            fn create_config(fp: \u0026FriParams) -\u003e MyConfig {\n                let perm = $default_perm();\n                let hash = MyHash::new(perm.clone());\n                let compress = MyCompress::new(perm.clone());\n                let val_mmcs = ValMmcs::new(hash, compress, fp.cap_height);\n                let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n                let dft = Dft::default();\n\n                let num_queries = (100 - fp.query_pow_bits) / fp.log_blowup;\n\n                let fri_params = FriParameters {\n                    max_log_arity: fp.max_log_arity,\n                    log_blowup: fp.log_blowup,\n                    log_final_poly_len: fp.log_final_poly_len,\n                    num_queries,\n                    commit_proof_of_work_bits: fp.commit_pow_bits,\n                    query_proof_of_work_bits: fp.query_pow_bits,\n                    mmcs: challenge_mmcs,\n                };\n                let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n                let challenger = Challenger::new(perm);\n                MyConfig::new(pcs, challenger)\n            }\n\n            const fn create_fri_verifier_params(fp: \u0026FriParams) -\u003e FriVerifierParams {\n                FriVerifierParams::with_mmcs(\n                    fp.log_blowup,\n                    fp.log_final_poly_len,\n                    fp.commit_pow_bits,\n                    fp.query_pow_bits,\n                    $poseidon2_config,\n                )\n            }\n\n            fn config_with_fri_params(fp: \u0026FriParams) -\u003e ConfigWithFriParams {\n                ConfigWithFriParams {\n                    config: Arc::new(create_config(fp)),\n                    fri_verifier_params: create_fri_verifier_params(fp),\n                }\n            }\n\n            /// Build a dummy circuit with a single constant and prove it.\n            fn prove_dummy_circuit(\n                constant_value: u32,\n                config: \u0026ConfigWithFriParams,\n                table_packing: TablePacking,\n            ) -\u003e RecursionOutput\u003cConfigWithFriParams\u003e {\n                let mut builder = CircuitBuilder::new();\n                let c = builder.alloc_const(F::from_u32(constant_value), \"dummy_const\");\n                let expected = builder.alloc_public_input(\"expected\");\n                builder.connect(c, expected);\n\n                let circuit = builder.build().unwrap();\n                let (airs_degrees, preprocessed_columns) =\n                    get_airs_and_degrees_with_prep::\u003cConfigWithFriParams, _, 1\u003e(\n                        \u0026circuit,\n                        table_packing,\n                        None,\n                        ConstraintProfile::Standard,\n                    )\n                    .unwrap();\n                let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003c_\u003e) = airs_degrees.into_iter().unzip();\n\n                let mut runner = circuit.runner();\n                runner\n                    .set_public_inputs(\u0026[F::from_u32(constant_value)])\n                    .unwrap();\n                let traces = runner.run().unwrap();\n\n                let prover_data = ProverData::from_airs_and_degrees(config, \u0026mut airs, \u0026degrees);\n                let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n                let prover =\n                    BatchStarkProver::new(config.clone()).with_table_packing(table_packing);\n\n                let proof = prover\n                    .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n                    .expect(\"Failed to prove dummy circuit\");\n                report_proof_size(\u0026proof);\n\n                prover\n                    .verify_all_tables(\u0026proof, circuit_prover_data.common_data())\n                    .expect(\"Failed to verify dummy proof\");\n\n                RecursionOutput(proof, Rc::new(circuit_prover_data))\n            }\n\n            pub fn run(\n                num_recursive_layers: usize,\n                fri_params: \u0026FriParams,\n                table_packing: \u0026TablePacking,\n            ) {\n                let config = config_with_fri_params(fri_params);\n                let base_table_packing = TablePacking::new(1, 1, 1)\n                    .with_fri_params(fri_params.log_final_poly_len, fri_params.log_blowup);\n                let backend = FriRecursionBackend::\u003cWIDTH, RATE\u003e::new($poseidon2_config);\n\n                let tree_depth = num_recursive_layers;\n                let num_leaves = 1usize \u003c\u003c tree_depth;\n                info!(\"Binary aggregation tree: {num_leaves} base proofs, {tree_depth} levels\");\n\n                // --- Leaf layer: produce distinct base proofs ---\n                let mut proofs: Vec\u003cRecursionOutput\u003cConfigWithFriParams\u003e\u003e = (0..num_leaves)\n                    .map(|i| {\n                        let val = (i + 1) as u32;\n                        info!(\"Base proof {i} (const = {val})\");\n                        prove_dummy_circuit(val, \u0026config, base_table_packing)\n                    })\n                    .collect();\n\n                // --- Aggregate pairwise, bottom-up ---\n                let mut level = 0u32;\n                while proofs.len() \u003e 1 {\n                    level += 1;\n                    let pairs = proofs.len() / 2;\n                    info!(\n                        \"Aggregation level {level}: {} proofs -\u003e {pairs}\",\n                        proofs.len()\n                    );\n\n                    let agg_params = ProveNextLayerParams {\n                        table_packing: if level == 1 {\n                            TablePacking::new(3, 1, 2)\n                        } else {\n                            table_packing.clone()\n                        }\n                        .with_fri_params(fri_params.log_final_poly_len, fri_params.log_blowup),\n                        use_poseidon2_in_circuit: true,\n                        constraint_profile: ConstraintProfile::Standard,\n                    };\n\n                    let mut next_level = Vec::with_capacity(pairs);\n                    let mut prep_cache: Option\u003cAggregationPrepCache\u003cConfigWithFriParams\u003e\u003e = None;\n                    for pair_idx in 0..pairs {\n                        let li = pair_idx * 2;\n                        let left = proofs[li].into_recursion_input::\u003cBatchOnly\u003e();\n                        let right = proofs[li + 1].into_recursion_input::\u003cBatchOnly\u003e();\n\n                        let out =\n                            build_and_prove_aggregation_layer::\u003cConfigWithFriParams, _, _, _, D\u003e(\n                                \u0026left,\n                                \u0026right,\n                                \u0026config,\n                                \u0026backend,\n                                \u0026agg_params,\n                                Some(\u0026mut prep_cache),\n                            )\n                            .unwrap_or_else(|e| {\n                                panic!(\"Failed at level {level}, pair {pair_idx}: {e:?}\")\n                            });\n\n                        report_proof_size(\u0026out.0);\n\n                        let mut verifier = BatchStarkProver::new(config.clone())\n                            .with_table_packing(agg_params.table_packing);\n                        verifier.register_poseidon2_table($poseidon2_config);\n                        verifier\n                            .verify_all_tables(\u0026out.0, out.1.common_data())\n                            .unwrap_or_else(|e| {\n                                panic!(\n                                    \"Verification failed at level {level}, pair {pair_idx}: {e:?}\"\n                                )\n                            });\n\n                        next_level.push(out);\n                    }\n                    proofs = next_level;\n                }\n\n                info!(\"All levels verified successfully\");\n            }\n        }\n    };\n}\n\ndefine_field_module!(\n    koala_bear,\n    p3_koala_bear::KoalaBear,\n    p3_koala_bear::Poseidon2KoalaBear\u003c16\u003e,\n    p3_koala_bear::default_koalabear_poseidon2_16,\n    Poseidon2Config::KoalaBearD4Width16,\n    p3_poseidon2_circuit_air::KoalaBearD4Width16\n);\n\ndefine_field_module!(\n    baby_bear,\n    p3_baby_bear::BabyBear,\n    p3_baby_bear::Poseidon2BabyBear\u003c16\u003e,\n    p3_baby_bear::default_babybear_poseidon2_16,\n    Poseidon2Config::BabyBearD4Width16,\n    p3_poseidon2_circuit_air::BabyBearD4Width16\n);\n\n#[inline]\npub fn report_proof_size\u003cS: Serialize\u003e(proof: \u0026S) {\n    let proof_bytes = postcard::to_allocvec(proof).expect(\"Failed to serialize proof\");\n    println!(\"Proof size: {} bytes\", proof_bytes.len());\n}\n","traces":[{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","examples","recursive_fibonacci.rs"],"content":"//! Recursive Fibonacci proof verification example.\n//!\n//! This example demonstrates end-to-end multi-layer recursive verification:\n//! 1. **Layer 0 (Base)**: Create a Fibonacci(n) circuit and prove it with Plonky3 STARK\n//! 2. **Layer 1+ (Recursive)**: Build verification circuits that check the previous layer's proof,\n//!    then prove each verification circuit itself\n//!\n//! ## What this proves\n//!\n//! The final proof attests that:\n//! - The original Fibonacci(n) computation was performed correctly\n//! - All intermediate Plonky3 STARK verifications succeeded\n//! - The recursive proof chain is valid\n//!\n//! ## Multi-layer recursion\n//!\n//! This example supports configurable recursion depth via `--num-recursive-layers`.\n//! Each recursive layer verifies the previous layer's proof, creating a chain of proofs.\n//!\n//! ## Usage\n//!\n//! ```bash\n//! # Basic usage with default parameters (3 recursive layers)\n//! cargo run --release --example recursive_fibonacci -- --field koala-bear --n 10000\n//!\n//! # With custom FRI parameters and recursion depth\n//! cargo run --release --example recursive_fibonacci -- \\\n//!     --field koala-bear \\\n//!     --n 10000 \\\n//!     --num-recursive-layers 5 \\\n//!     --log-blowup 3 \\\n//!     --max-log-arity 4 \\\n//!     --log-final-poly-len 5 \\\n//!     --query-pow-bits 16\n//! ```\n\nuse std::rc::Rc;\nuse std::sync::Arc;\n\nuse clap::{Parser, ValueEnum};\nuse p3_batch_stark::ProverData;\nuse p3_challenger::DuplexChallenger;\nuse p3_circuit::ops::generate_poseidon2_trace;\nuse p3_circuit::{CircuitBuilder, CircuitRunner, NonPrimitiveOpId};\nuse p3_circuit_prover::common::get_airs_and_degrees_with_prep;\nuse p3_circuit_prover::{BatchStarkProver, CircuitProverData, ConstraintProfile, TablePacking};\nuse p3_commit::{ExtensionMmcs, Pcs};\nuse p3_dft::Radix2DitParallel;\nuse p3_field::extension::BinomialExtensionField;\nuse p3_field::{Field, PrimeCharacteristicRing};\nuse p3_fri::{FriParameters, TwoAdicFriPcs};\nuse p3_lookup::logup::LogUpGadget;\nuse p3_merkle_tree::MerkleTreeMmcs;\nuse p3_recursion::pcs::{\n    InputProofTargets, MerkleCapTargets, RecValMmcs, set_fri_mmcs_private_data,\n};\nuse p3_recursion::traits::{RecursiveAir, RecursivePcs};\nuse p3_recursion::verifier::VerificationError;\nuse p3_recursion::{\n    BatchOnly, FriRecursionBackend, FriRecursionConfig, FriVerifierParams, Poseidon2Config,\n    ProveNextLayerParams, RecursionInput, RecursionOutput, build_and_prove_next_layer,\n};\nuse p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\nuse p3_uni_stark::{StarkConfig, StarkGenericConfig, Val};\nuse serde::Serialize;\nuse tracing::info;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n#[derive(Debug, Clone, Copy, ValueEnum)]\nenum FieldOption {\n    KoalaBear,\n    BabyBear,\n}\n\n#[derive(Debug, Clone, Copy)]\nstruct FriParams {\n    log_blowup: usize,\n    max_log_arity: usize,\n    cap_height: usize,\n    log_final_poly_len: usize,\n    commit_pow_bits: usize,\n    query_pow_bits: usize,\n}\n\n#[derive(Parser, Debug)]\n#[command(version, about = \"Recursive Fibonacci proof verification example\")]\nstruct Args {\n    /// The field to use for the proof.\n    #[arg(short, long, ignore_case = true, value_enum, default_value_t = FieldOption::KoalaBear)]\n    field: FieldOption,\n\n    /// The Fibonacci index to compute (F(n)).\n    #[arg(short, long, default_value_t = 100)]\n    n: usize,\n\n    /// Number of recursive verification layers (1 = verify base once, 3 = base + 3 recursive layers).\n    #[arg(\n        long,\n        default_value_t = 3,\n        help = \"Number of recursive verification layers\"\n    )]\n    num_recursive_layers: usize,\n\n    #[arg(\n        long,\n        default_value_t = 3,\n        help = \"Logarithmic blowup factor for the LDE\"\n    )]\n    log_blowup: usize,\n\n    #[arg(\n        long,\n        default_value_t = 4,\n        help = \"Maximum arity allowed during FRI folding phases\"\n    )]\n    max_log_arity: usize,\n\n    #[arg(long, default_value_t = 0, help = \"Height of the Merkle cap to open\")]\n    cap_height: usize,\n\n    #[arg(\n        long,\n        default_value_t = 5,\n        help = \"Log size of final polynomial after FRI folding\"\n    )]\n    log_final_poly_len: usize,\n\n    #[arg(\n        long,\n        default_value_t = 0,\n        help = \"PoW grinding bits during FRI commit phase\"\n    )]\n    commit_pow_bits: usize,\n\n    #[arg(\n        long,\n        default_value_t = 16,\n        help = \"PoW grinding bits during FRI query phase\"\n    )]\n    query_pow_bits: usize,\n\n    #[arg(\n        long,\n        default_value_t = 4,\n        help = \"Number of witness lanes for the table packing in recursive layers\"\n    )]\n    witness_lanes: usize,\n\n    #[arg(\n        long,\n        default_value_t = 1,\n        help = \"Number of public lanes for the table packing in recursive layers\"\n    )]\n    public_lanes: usize,\n\n    #[arg(\n        long,\n        default_value_t = 2,\n        help = \"Number of ALU lanes for the table packing in recursive layers\"\n    )]\n    alu_lanes: usize,\n}\n\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    let _ = Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .try_init();\n}\n\nfn main() {\n    init_logger();\n\n    let args = Args::parse();\n    let fri_params = FriParams {\n        log_blowup: args.log_blowup,\n        max_log_arity: args.max_log_arity,\n        cap_height: args.cap_height,\n        log_final_poly_len: args.log_final_poly_len,\n        commit_pow_bits: args.commit_pow_bits,\n        query_pow_bits: args.query_pow_bits,\n    };\n    let table_packing = TablePacking::new(args.witness_lanes, args.public_lanes, args.alu_lanes);\n\n    if args.num_recursive_layers \u003c 1 {\n        panic!(\"Number of recursive layers should be at least 1\");\n    }\n\n    info!(\n        \"Recursively proving {} Fibonacci iterations with field {:?}\",\n        args.n, args.field\n    );\n\n    match args.field {\n        FieldOption::KoalaBear =\u003e koala_bear::run(\n            args.n,\n            args.num_recursive_layers,\n            \u0026fri_params,\n            \u0026table_packing,\n        ),\n        FieldOption::BabyBear =\u003e baby_bear::run(\n            args.n,\n            args.num_recursive_layers,\n            \u0026fri_params,\n            \u0026table_packing,\n        ),\n    }\n}\n\nmacro_rules! define_field_module {\n    (\n        $mod_name:ident,\n        $field:ty,\n        $perm:ty,\n        $default_perm:path,\n        $poseidon2_config:expr,\n        $poseidon2_circuit_config:ty\n    ) =\u003e {\n        mod $mod_name {\n            use super::*;\n\n            pub type F = $field;\n            pub const D: usize = 4;\n            const WIDTH: usize = 16;\n            const RATE: usize = 8;\n            const DIGEST_ELEMS: usize = 8;\n\n            type Challenge = BinomialExtensionField\u003cF, D\u003e;\n            type Dft = Radix2DitParallel\u003cF\u003e;\n            type Perm = $perm;\n            type MyHash = PaddingFreeSponge\u003cPerm, 16, RATE, 8\u003e;\n            type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\n            type ValMmcs =\n                MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\n            type ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\n            type Challenger = DuplexChallenger\u003cF, Perm, 16, RATE\u003e;\n            type MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\n            type MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\n            type InnerFri = p3_recursion::pcs::FriProofTargets\u003c\n                F,\n                Challenge,\n                p3_recursion::pcs::RecExtensionValMmcs\u003c\n                    F,\n                    Challenge,\n                    DIGEST_ELEMS,\n                    RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n                \u003e,\n                InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n                p3_recursion::pcs::Witness\u003cF\u003e,\n            \u003e;\n\n            #[derive(Clone)]\n            struct ConfigWithFriParams {\n                config: Arc\u003cMyConfig\u003e,\n                fri_verifier_params: FriVerifierParams,\n            }\n\n            impl core::ops::Deref for ConfigWithFriParams {\n                type Target = MyConfig;\n                fn deref(\u0026self) -\u003e \u0026MyConfig {\n                    \u0026self.config\n                }\n            }\n\n            impl StarkGenericConfig for ConfigWithFriParams {\n                type Challenge = Challenge;\n                type Challenger = Challenger;\n                type Pcs = MyPcs;\n                fn pcs(\u0026self) -\u003e \u0026MyPcs {\n                    self.config.pcs()\n                }\n                fn initialise_challenger(\u0026self) -\u003e Challenger {\n                    self.config.initialise_challenger()\n                }\n            }\n\n            impl FriRecursionConfig for ConfigWithFriParams\n            where\n                MyPcs: RecursivePcs\u003c\n                        ConfigWithFriParams,\n                        InputProofTargets\u003c\n                            F,\n                            Challenge,\n                            RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n                        \u003e,\n                        InnerFri,\n                        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n                        \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::Domain,\n                    \u003e,\n            {\n                type Commitment = MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e;\n                type InputProof = InputProofTargets\u003c\n                    F,\n                    Challenge,\n                    RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n                \u003e;\n                type OpeningProof = InnerFri;\n                type RawOpeningProof = \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::Proof;\n                const DIGEST_ELEMS: usize = 8;\n\n                fn with_fri_opening_proof\u003c'a, A, R\u003e(\n                    prev: \u0026RecursionInput\u003c'a, Self, A\u003e,\n                    f: impl FnOnce(\u0026Self::RawOpeningProof) -\u003e R,\n                ) -\u003e R\n                where\n                    A: RecursiveAir\u003cVal\u003cSelf\u003e, Self::Challenge, LogUpGadget\u003e,\n                {\n                    match prev {\n                        RecursionInput::UniStark { proof, .. } =\u003e f(\u0026proof.opening_proof),\n                        RecursionInput::BatchStark { proof, .. } =\u003e f(\u0026proof.proof.opening_proof),\n                    }\n                }\n\n                fn enable_poseidon2_on_circuit(\n                    \u0026self,\n                    circuit: \u0026mut CircuitBuilder\u003cChallenge\u003e,\n                ) -\u003e Result\u003c(), VerificationError\u003e {\n                    let perm = $default_perm();\n                    circuit.enable_poseidon2_perm::\u003c$poseidon2_circuit_config, _\u003e(\n                        generate_poseidon2_trace::\u003cChallenge, $poseidon2_circuit_config\u003e,\n                        perm,\n                    );\n                    Ok(())\n                }\n\n                fn pcs_verifier_params(\n                    \u0026self,\n                ) -\u003e \u0026\u003cMyPcs as RecursivePcs\u003c\n                    ConfigWithFriParams,\n                    InputProofTargets\u003c\n                        F,\n                        Challenge,\n                        RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n                    \u003e,\n                    InnerFri,\n                    MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n                    \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::Domain,\n                \u003e\u003e::VerifierParams {\n                    \u0026self.fri_verifier_params\n                }\n\n                fn set_fri_private_data(\n                    runner: \u0026mut CircuitRunner\u003cChallenge\u003e,\n                    op_ids: \u0026[NonPrimitiveOpId],\n                    opening_proof: \u0026Self::RawOpeningProof,\n                ) -\u003e Result\u003c(), \u0026'static str\u003e {\n                    set_fri_mmcs_private_data::\u003c\n                        F,\n                        Challenge,\n                        ChallengeMmcs,\n                        ValMmcs,\n                        MyHash,\n                        MyCompress,\n                        DIGEST_ELEMS,\n                    \u003e(runner, op_ids, opening_proof)\n                }\n            }\n\n            fn create_config(fp: \u0026FriParams) -\u003e MyConfig {\n                let perm = $default_perm();\n                let hash = MyHash::new(perm.clone());\n                let compress = MyCompress::new(perm.clone());\n                let val_mmcs = ValMmcs::new(hash, compress, fp.cap_height);\n                let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n                let dft = Dft::default();\n\n                let num_queries = (100 - fp.query_pow_bits) / fp.log_blowup;\n\n                let fri_params = FriParameters {\n                    max_log_arity: fp.max_log_arity,\n                    log_blowup: fp.log_blowup,\n                    log_final_poly_len: fp.log_final_poly_len,\n                    num_queries,\n                    commit_proof_of_work_bits: fp.commit_pow_bits,\n                    query_proof_of_work_bits: fp.query_pow_bits,\n                    mmcs: challenge_mmcs,\n                };\n                let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n                let challenger = Challenger::new(perm);\n                MyConfig::new(pcs, challenger)\n            }\n\n            const fn create_fri_verifier_params(fp: \u0026FriParams) -\u003e FriVerifierParams {\n                FriVerifierParams::with_mmcs(\n                    fp.log_blowup,\n                    fp.log_final_poly_len,\n                    fp.commit_pow_bits,\n                    fp.query_pow_bits,\n                    $poseidon2_config,\n                )\n            }\n\n            fn config_with_fri_params(fp: \u0026FriParams) -\u003e ConfigWithFriParams {\n                ConfigWithFriParams {\n                    config: Arc::new(create_config(fp)),\n                    fri_verifier_params: create_fri_verifier_params(fp),\n                }\n            }\n\n            fn compute_fibonacci(n: usize) -\u003e F {\n                if n == 0 {\n                    return F::ZERO;\n                }\n                if n == 1 {\n                    return F::ONE;\n                }\n                let mut a = F::ZERO;\n                let mut b = F::ONE;\n                for _ in 2..=n {\n                    let next = a + b;\n                    a = b;\n                    b = next;\n                }\n                b\n            }\n\n            pub fn run(\n                n: usize,\n                num_recursive_layers: usize,\n                fri_params: \u0026FriParams,\n                table_packing: \u0026TablePacking,\n            ) {\n                let mut builder = CircuitBuilder::new();\n                let expected_result = builder.alloc_public_input(\"expected_result\");\n\n                let mut a = builder.alloc_const(F::ZERO, \"F(0)\");\n                let mut b = builder.alloc_const(F::ONE, \"F(1)\");\n\n                for _ in 2..=n {\n                    let next = builder.add(a, b);\n                    a = b;\n                    b = next;\n                }\n\n                builder.connect(b, expected_result);\n\n                let base_circuit = builder.build().unwrap();\n                let table_packing_0 = TablePacking::new(1, 1, 1)\n                    .with_fri_params(fri_params.log_final_poly_len, fri_params.log_blowup);\n\n                let config_0 = config_with_fri_params(fri_params);\n                let (airs_degrees_0, preprocessed_columns_0) =\n                    get_airs_and_degrees_with_prep::\u003cConfigWithFriParams, _, 1\u003e(\n                        \u0026base_circuit,\n                        table_packing_0,\n                        None,\n                        ConstraintProfile::Standard,\n                    )\n                    .unwrap();\n                let (mut airs_0, degrees_0): (Vec\u003c_\u003e, Vec\u003c_\u003e) = airs_degrees_0.into_iter().unzip();\n\n                let mut runner_0 = base_circuit.runner();\n                let expected_fib = compute_fibonacci(n);\n                runner_0.set_public_inputs(\u0026[expected_fib]).unwrap();\n\n                let traces_0 = runner_0.run().unwrap();\n                let prover_data_0 =\n                    ProverData::from_airs_and_degrees(\u0026config_0, \u0026mut airs_0, \u0026degrees_0);\n                let circuit_prover_data_0 =\n                    CircuitProverData::new(prover_data_0, preprocessed_columns_0);\n                let common_0 = circuit_prover_data_0.common_data();\n                let prover_0 =\n                    BatchStarkProver::new(config_0.clone()).with_table_packing(table_packing_0);\n                let proof_0 = prover_0\n                    .prove_all_tables(\u0026traces_0, \u0026circuit_prover_data_0)\n                    .expect(\"Failed to prove base circuit\");\n                report_proof_size(\u0026proof_0);\n\n                prover_0\n                    .verify_all_tables(\u0026proof_0, \u0026common_0)\n                    .expect(\"Failed to verify base proof\");\n\n                if num_recursive_layers == 0 {\n                    info!(\"Recursive proof verified successfully\");\n                    return;\n                }\n\n                let backend = FriRecursionBackend::\u003cWIDTH, RATE\u003e::new($poseidon2_config);\n                let mut output = RecursionOutput(proof_0, Rc::new(circuit_prover_data_0));\n\n                for layer in 1..=num_recursive_layers {\n                    let params = ProveNextLayerParams {\n                        table_packing: table_packing\n                            .with_fri_params(fri_params.log_final_poly_len, fri_params.log_blowup),\n                        use_poseidon2_in_circuit: true,\n                        constraint_profile: ConstraintProfile::Standard,\n                    };\n                    let config = config_with_fri_params(fri_params);\n\n                    let input = output.into_recursion_input::\u003cBatchOnly\u003e();\n                    let out = build_and_prove_next_layer::\u003cConfigWithFriParams, _, _, D\u003e(\n                        \u0026input, \u0026config, \u0026backend, \u0026params,\n                    )\n                    .unwrap_or_else(|e| panic!(\"Failed to prove layer {layer}: {e:?}\"));\n\n                    report_proof_size(\u0026out.0);\n                    let mut prover = BatchStarkProver::new(config.clone())\n                        .with_table_packing(params.table_packing);\n                    prover.register_poseidon2_table($poseidon2_config);\n                    prover\n                        .verify_all_tables(\u0026out.0, out.1.common_data())\n                        .unwrap_or_else(|e| panic!(\"Failed to verify layer {layer}: {e:?}\"));\n\n                    output = out;\n                }\n\n                info!(\"Recursive proof verified successfully\");\n            }\n        }\n    };\n}\n\ndefine_field_module!(\n    koala_bear,\n    p3_koala_bear::KoalaBear,\n    p3_koala_bear::Poseidon2KoalaBear\u003c16\u003e,\n    p3_koala_bear::default_koalabear_poseidon2_16,\n    Poseidon2Config::KoalaBearD4Width16,\n    p3_poseidon2_circuit_air::KoalaBearD4Width16\n);\n\ndefine_field_module!(\n    baby_bear,\n    p3_baby_bear::BabyBear,\n    p3_baby_bear::Poseidon2BabyBear\u003c16\u003e,\n    p3_baby_bear::default_babybear_poseidon2_16,\n    Poseidon2Config::BabyBearD4Width16,\n    p3_poseidon2_circuit_air::BabyBearD4Width16\n);\n\n/// Report the size of the serialized proof.\n#[inline]\npub fn report_proof_size\u003cS: Serialize\u003e(proof: \u0026S) {\n    let proof_bytes = postcard::to_allocvec(proof).expect(\"Failed to serialize proof\");\n    println!(\"Proof size: {} bytes\", proof_bytes.len());\n}\n","traces":[{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","examples","recursive_keccak.rs"],"content":"//! Recursive Keccak proof verification example.\n//!\n//! This example demonstrates end-to-end multi-layer recursive verification:\n//! 1. **Layer 0 (Base)**: Create a Keccak AIR proof with Plonky3 STARK\n//! 2. **Layer 1+ (Recursive)**: Build verification circuits that check the previous layer's proof,\n//!    then prove each verification circuit itself\n//!\n//! ## What this proves\n//!\n//! The final proof attests that:\n//! - The Keccak hash computation was performed correctly\n//! - All intermediate Plonky3 STARK verifications succeeded\n//! - The recursive proof chain is valid\n//!\n//! ## Multi-layer recursion\n//!\n//! This example supports configurable recursion depth via `--num-recursive-layers`.\n//! Each recursive layer verifies the previous layer's proof, creating a chain of proofs.\n//!\n//! ## Note on Performance\n//!\n//! The Keccak AIR produces a large verification circuit due to the complexity of Keccak\n//! constraints (~2600 columns) and hence may require either additional recursive layers\n//! or more aggressive recursion parameters.\n//!\n//! ## Usage\n//!\n//! ```bash\n//! # Basic usage with default parameters (3 recursive layers)\n//! cargo run --release --example recursive_keccak -- --field koala-bear --num-hashes 1000\n//!\n//! # With custom FRI parameters and recursion depth\n//! cargo run --release --example recursive_keccak -- \\\n//!     --field koala-bear \\\n//!     --num-hashes 1000 \\\n//!     --num-recursive-layers 5 \\\n//!     --log-blowup 3 \\\n//!     --max-log-arity 4 \\\n//!     --log-final-poly-len 5 \\\n//!     --query-pow-bits 16\n//! ```\n\nuse std::sync::Arc;\n\nuse clap::{Parser, ValueEnum};\nuse p3_challenger::DuplexChallenger;\nuse p3_circuit::ops::generate_poseidon2_trace;\nuse p3_circuit::{CircuitBuilder, CircuitRunner, NonPrimitiveOpId};\nuse p3_circuit_prover::{BatchStarkProver, ConstraintProfile, TablePacking};\nuse p3_commit::{ExtensionMmcs, Pcs};\nuse p3_dft::Radix2DitParallel;\nuse p3_field::Field;\nuse p3_field::extension::BinomialExtensionField;\nuse p3_fri::{FriParameters, TwoAdicFriPcs};\nuse p3_keccak_air::KeccakAir;\nuse p3_lookup::logup::LogUpGadget;\nuse p3_merkle_tree::MerkleTreeMmcs;\nuse p3_recursion::pcs::{\n    InputProofTargets, MerkleCapTargets, RecValMmcs, set_fri_mmcs_private_data,\n};\nuse p3_recursion::traits::{RecursiveAir, RecursivePcs};\nuse p3_recursion::verifier::VerificationError;\nuse p3_recursion::{\n    BatchOnly, FriRecursionBackend, FriRecursionConfig, FriVerifierParams, Poseidon2Config,\n    ProveNextLayerParams, RecursionInput, RecursionOutput, build_and_prove_next_layer,\n};\nuse p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\nuse p3_uni_stark::{StarkConfig, StarkGenericConfig, Val, prove, verify};\nuse serde::Serialize;\nuse tracing::info;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n#[derive(Debug, Clone, Copy, ValueEnum)]\nenum FieldOption {\n    KoalaBear,\n    BabyBear,\n}\n\n#[derive(Debug, Clone, Copy)]\nstruct FriParams {\n    log_blowup: usize,\n    max_log_arity: usize,\n    cap_height: usize,\n    log_final_poly_len: usize,\n    commit_pow_bits: usize,\n    query_pow_bits: usize,\n}\n\n#[derive(Parser, Debug)]\n#[command(version, about = \"Recursive Keccak proof verification example\")]\nstruct Args {\n    /// The field to use for the proof.\n    #[arg(short, long, ignore_case = true, value_enum, default_value_t = FieldOption::KoalaBear)]\n    field: FieldOption,\n\n    /// Number of Keccak permutations to prove.\n    #[arg(short, long, default_value_t = 4)]\n    num_hashes: usize,\n\n    /// Number of recursive verification layers (1 = verify base once, 3 = base + 3 recursive layers).\n    #[arg(\n        long,\n        default_value_t = 3,\n        help = \"Number of recursive verification layers\"\n    )]\n    num_recursive_layers: usize,\n\n    #[arg(\n        long,\n        default_value_t = 3,\n        help = \"Logarithmic blowup factor for the LDE\"\n    )]\n    log_blowup: usize,\n\n    #[arg(\n        long,\n        default_value_t = 4,\n        help = \"Maximum arity allowed during FRI folding phases\"\n    )]\n    max_log_arity: usize,\n\n    #[arg(long, default_value_t = 0, help = \"Height of the Merkle cap to open\")]\n    cap_height: usize,\n\n    #[arg(\n        long,\n        default_value_t = 5,\n        help = \"Log size of final polynomial after FRI folding\"\n    )]\n    log_final_poly_len: usize,\n\n    #[arg(\n        long,\n        default_value_t = 0,\n        help = \"PoW grinding bits during FRI commit phase\"\n    )]\n    commit_pow_bits: usize,\n\n    #[arg(\n        long,\n        default_value_t = 16,\n        help = \"PoW grinding bits during FRI query phase\"\n    )]\n    query_pow_bits: usize,\n\n    #[arg(\n        long,\n        default_value_t = 4,\n        help = \"Number of witness lanes for the table packing in recursive layers\"\n    )]\n    witness_lanes: usize,\n\n    #[arg(\n        long,\n        default_value_t = 1,\n        help = \"Number of public lanes for the table packing in recursive layers\"\n    )]\n    public_lanes: usize,\n\n    #[arg(\n        long,\n        default_value_t = 2,\n        help = \"Number of ALU lanes for the table packing in recursive layers\"\n    )]\n    alu_lanes: usize,\n}\n\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    let _ = Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .try_init();\n}\n\nfn main() {\n    init_logger();\n\n    let args = Args::parse();\n    let fri_params = FriParams {\n        log_blowup: args.log_blowup,\n        max_log_arity: args.max_log_arity,\n        cap_height: args.cap_height,\n        log_final_poly_len: args.log_final_poly_len,\n        commit_pow_bits: args.commit_pow_bits,\n        query_pow_bits: args.query_pow_bits,\n    };\n\n    let table_packing = TablePacking::new(args.witness_lanes, args.public_lanes, args.alu_lanes);\n\n    if args.num_recursive_layers \u003c 1 {\n        panic!(\"Number of recursive layers should be at least 1\");\n    }\n\n    info!(\n        \"Recursively proving {} Keccak hashes with field {:?}\",\n        args.num_hashes, args.field\n    );\n\n    match args.field {\n        FieldOption::KoalaBear =\u003e {\n            koala_bear::run(\n                args.num_hashes,\n                args.num_recursive_layers,\n                \u0026fri_params,\n                \u0026table_packing,\n            );\n        }\n        FieldOption::BabyBear =\u003e {\n            baby_bear::run(\n                args.num_hashes,\n                args.num_recursive_layers,\n                \u0026fri_params,\n                \u0026table_packing,\n            );\n        }\n    }\n}\n\nmacro_rules! define_field_module {\n    (\n        $mod_name:ident,\n        $field:ty,\n        $perm:ty,\n        $default_perm:path,\n        $poseidon2_config:expr,\n        $poseidon2_circuit_config:ty\n    ) =\u003e {\n        mod $mod_name {\n            use super::*;\n\n            pub type F = $field;\n            pub const D: usize = 4;\n            const WIDTH: usize = 16;\n            const RATE: usize = 8;\n            const DIGEST_ELEMS: usize = 8;\n\n            type Challenge = BinomialExtensionField\u003cF, D\u003e;\n            type Dft = Radix2DitParallel\u003cF\u003e;\n            type Perm = $perm;\n            type MyHash = PaddingFreeSponge\u003cPerm, 16, RATE, 8\u003e;\n            type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\n            type ValMmcs =\n                MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\n            type ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\n            type Challenger = DuplexChallenger\u003cF, Perm, 16, RATE\u003e;\n            type MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\n            type MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\n            type InnerFri = p3_recursion::pcs::FriProofTargets\u003c\n                F,\n                Challenge,\n                p3_recursion::pcs::RecExtensionValMmcs\u003c\n                    F,\n                    Challenge,\n                    DIGEST_ELEMS,\n                    RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n                \u003e,\n                InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n                p3_recursion::pcs::Witness\u003cF\u003e,\n            \u003e;\n\n            #[derive(Clone)]\n            struct ConfigWithFriParams {\n                config: Arc\u003cMyConfig\u003e,\n                fri_verifier_params: FriVerifierParams,\n            }\n\n            impl core::ops::Deref for ConfigWithFriParams {\n                type Target = MyConfig;\n                fn deref(\u0026self) -\u003e \u0026MyConfig {\n                    \u0026self.config\n                }\n            }\n\n            impl StarkGenericConfig for ConfigWithFriParams {\n                type Challenge = Challenge;\n                type Challenger = Challenger;\n                type Pcs = MyPcs;\n                fn pcs(\u0026self) -\u003e \u0026MyPcs {\n                    self.config.pcs()\n                }\n                fn initialise_challenger(\u0026self) -\u003e Challenger {\n                    self.config.initialise_challenger()\n                }\n            }\n\n            impl FriRecursionConfig for ConfigWithFriParams\n            where\n                MyPcs: RecursivePcs\u003c\n                    ConfigWithFriParams,\n                    InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n                    InnerFri,\n                    MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n                    \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::Domain,\n                \u003e,\n            {\n                type Commitment = MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e;\n                type InputProof =\n                    InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e;\n                type OpeningProof = InnerFri;\n                type RawOpeningProof = \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::Proof;\n                const DIGEST_ELEMS: usize = 8;\n\n                fn with_fri_opening_proof\u003c'a, A, R\u003e(\n                    prev: \u0026RecursionInput\u003c'a, Self, A\u003e,\n                    f: impl FnOnce(\u0026Self::RawOpeningProof) -\u003e R,\n                ) -\u003e R\n                where\n                    A: RecursiveAir\u003cVal\u003cSelf\u003e, Self::Challenge, LogUpGadget\u003e,\n                {\n                    match prev {\n                        RecursionInput::UniStark { proof, .. } =\u003e f(\u0026proof.opening_proof),\n                        RecursionInput::BatchStark { proof, .. } =\u003e {\n                            f(\u0026proof.proof.opening_proof)\n                        }\n                    }\n                }\n\n                fn enable_poseidon2_on_circuit(\n                    \u0026self,\n                    circuit: \u0026mut CircuitBuilder\u003cChallenge\u003e,\n                ) -\u003e Result\u003c(), VerificationError\u003e {\n                    let perm = $default_perm();\n                    circuit.enable_poseidon2_perm::\u003c$poseidon2_circuit_config, _\u003e(\n                        generate_poseidon2_trace::\u003cChallenge, $poseidon2_circuit_config\u003e,\n                        perm,\n                    );\n                    Ok(())\n                }\n\n                fn pcs_verifier_params(\n                    \u0026self,\n                ) -\u003e \u0026\u003cMyPcs as RecursivePcs\u003c\n                    ConfigWithFriParams,\n                    InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n                    InnerFri,\n                    MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n                    \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::Domain,\n                \u003e\u003e::VerifierParams {\n                    \u0026self.fri_verifier_params\n                }\n\n                fn set_fri_private_data(\n                    runner: \u0026mut CircuitRunner\u003cChallenge\u003e,\n                    op_ids: \u0026[NonPrimitiveOpId],\n                    opening_proof: \u0026Self::RawOpeningProof,\n                ) -\u003e Result\u003c(), \u0026'static str\u003e {\n                    set_fri_mmcs_private_data::\u003c\n                        F,\n                        Challenge,\n                        ChallengeMmcs,\n                        ValMmcs,\n                        MyHash,\n                        MyCompress,\n                        DIGEST_ELEMS,\n                    \u003e(runner, op_ids, opening_proof)\n                }\n            }\n\n            fn create_config(fp: \u0026FriParams) -\u003e MyConfig {\n                let perm = $default_perm();\n                let hash = MyHash::new(perm.clone());\n                let compress = MyCompress::new(perm.clone());\n                let val_mmcs = ValMmcs::new(hash, compress, fp.cap_height);\n                let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n                let dft = Dft::default();\n\n                let num_queries = (100 - fp.query_pow_bits) / fp.log_blowup;\n\n                let fri_params = FriParameters {\n                    max_log_arity: fp.max_log_arity,\n                    log_blowup: fp.log_blowup,\n                    log_final_poly_len: fp.log_final_poly_len,\n                    num_queries,\n                    commit_proof_of_work_bits: fp.commit_pow_bits,\n                    query_proof_of_work_bits: fp.query_pow_bits,\n                    mmcs: challenge_mmcs,\n                };\n                let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n                let challenger = Challenger::new(perm);\n                MyConfig::new(pcs, challenger)\n            }\n\n            const fn create_fri_verifier_params(fp: \u0026FriParams) -\u003e FriVerifierParams {\n                FriVerifierParams::with_mmcs(\n                    fp.log_blowup,\n                    fp.log_final_poly_len,\n                    fp.commit_pow_bits,\n                    fp.query_pow_bits,\n                    $poseidon2_config,\n                )\n            }\n\n            fn config_with_fri_params(fp: \u0026FriParams) -\u003e ConfigWithFriParams {\n                ConfigWithFriParams {\n                    config: Arc::new(create_config(fp)),\n                    fri_verifier_params: create_fri_verifier_params(fp),\n                }\n            }\n\n            pub fn run(num_hashes: usize, num_recursive_layers: usize, fri_params: \u0026FriParams, table_packing: \u0026TablePacking) {\n                let keccak_air = KeccakAir {};\n                let min_trace_rows: usize =\n                    1 \u003c\u003c (fri_params.log_final_poly_len + fri_params.log_blowup + 1);\n                let min_keccak_hashes = min_trace_rows.div_ceil(p3_keccak_air::NUM_ROUNDS);\n                let effective_num_hashes = num_hashes.max(min_keccak_hashes);\n                if effective_num_hashes != num_hashes {\n                    tracing::warn!(\"Number of equivalent Keccak hashes after mandatory padding: {effective_num_hashes}\");\n                }\n                let trace =\n                    keccak_air.generate_trace_rows(effective_num_hashes, fri_params.log_blowup);\n\n                let config_0 = config_with_fri_params(fri_params);\n                let pis: Vec\u003cF\u003e = vec![];\n\n                let proof_0 = prove(\u0026config_0, \u0026keccak_air, trace, \u0026pis);\n                report_proof_size(\u0026proof_0);\n\n                verify(\u0026config_0, \u0026keccak_air, \u0026proof_0, \u0026pis)\n                    .expect(\"Failed to verify Keccak proof natively\");\n\n                if num_recursive_layers \u003c 1 {\n                    return;\n                }\n\n                let backend = FriRecursionBackend::\u003cWIDTH, RATE\u003e::new($poseidon2_config);\n                let mut output: Option\u003cRecursionOutput\u003cConfigWithFriParams\u003e\u003e = None;\n\n                for layer in 1..=num_recursive_layers {\n                    let table_packing = if layer == 1 {\n                        TablePacking::new(1, 1, 1)\n                    } else {\n                        table_packing.clone()\n                    }\n                    .with_fri_params(fri_params.log_final_poly_len, fri_params.log_blowup);\n                    let params = ProveNextLayerParams {\n                        table_packing,\n                        use_poseidon2_in_circuit: true,\n                        constraint_profile: ConstraintProfile::Standard,\n                    };\n                    let config = config_with_fri_params(fri_params);\n\n                    let out = if layer == 1 {\n                        let input = RecursionInput::UniStark {\n                            proof: \u0026proof_0,\n                            air: \u0026keccak_air,\n                            public_inputs: pis.clone(),\n                            preprocessed_commit: None,\n                        };\n                        build_and_prove_next_layer::\u003cConfigWithFriParams, _, _, D\u003e(\n                            \u0026input,\n                            \u0026config,\n                            \u0026backend,\n                            \u0026params,\n                        )\n                    } else {\n                        let input = output.as_ref().unwrap().into_recursion_input::\u003cBatchOnly\u003e();\n                        build_and_prove_next_layer::\u003cConfigWithFriParams, _, _, D\u003e(\n                            \u0026input,\n                            \u0026config,\n                            \u0026backend,\n                            \u0026params,\n                        )\n                    }\n                    .unwrap_or_else(|e| panic!(\"Failed to prove layer {layer}: {e:?}\"));\n\n                    report_proof_size(\u0026out.0);\n                    let mut prover = BatchStarkProver::new(config.clone())\n                        .with_table_packing(params.table_packing);\n                    prover.register_poseidon2_table($poseidon2_config);\n                    prover\n                        .verify_all_tables(\u0026out.0, out.1.common_data())\n                        .unwrap_or_else(|e| panic!(\"Failed to verify layer {layer}: {e:?}\"));\n\n                    output = Some(out);\n                }\n\n                info!(\"Recursive proof verified successfully\");\n            }\n        }\n    };\n}\n\ndefine_field_module!(\n    koala_bear,\n    p3_koala_bear::KoalaBear,\n    p3_koala_bear::Poseidon2KoalaBear\u003c16\u003e,\n    p3_koala_bear::default_koalabear_poseidon2_16,\n    Poseidon2Config::KoalaBearD4Width16,\n    p3_poseidon2_circuit_air::KoalaBearD4Width16\n);\n\ndefine_field_module!(\n    baby_bear,\n    p3_baby_bear::BabyBear,\n    p3_baby_bear::Poseidon2BabyBear\u003c16\u003e,\n    p3_baby_bear::default_babybear_poseidon2_16,\n    Poseidon2Config::BabyBearD4Width16,\n    p3_poseidon2_circuit_air::BabyBearD4Width16\n);\n\n/// Report the size of the serialized proof.\n#[inline]\npub fn report_proof_size\u003cS: Serialize\u003e(proof: \u0026S) {\n    let proof_bytes = postcard::to_allocvec(proof).expect(\"Failed to serialize proof\");\n    println!(\"Proof size: {} bytes\", proof_bytes.len());\n}\n","traces":[{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","backend","fri.rs"],"content":"//! FRI PCS backend for the unified recursion API.\n\nuse alloc::vec::Vec;\n\nuse p3_circuit::{CircuitBuilder, CircuitRunner, NonPrimitiveOpId};\nuse p3_commit::Pcs;\nuse p3_field::{BasedVectorSpace, PrimeField64};\nuse p3_lookup::logup::LogUpGadget;\nuse p3_uni_stark::{StarkGenericConfig, Val};\n\nuse crate::ops::Poseidon2Config;\nuse crate::public_inputs::{BatchStarkVerifierInputsBuilder, StarkVerifierInputsBuilder};\nuse crate::recursion::{PcsRecursionBackend, RecursionInput, VerifierCircuitResult};\nuse crate::traits::RecursiveAir;\nuse crate::verifier::{\n    ObservableCommitment, VerificationError, verify_p3_batch_proof_circuit,\n    verify_p3_uni_proof_circuit,\n};\nuse crate::{Recursive, RecursivePcs};\n\n/// Config that uses FRI with Merkle-tree MMCS and fixed constants (WIDTH, RATE, DIGEST_ELEMS).\n/// Implement this for your StarkConfig to use [`FriRecursionBackend`].\npub trait FriRecursionConfig: StarkGenericConfig + Sized\nwhere\n    Self::Pcs: RecursivePcs\u003c\n            Self,\n            Self::InputProof,\n            Self::OpeningProof,\n            Self::Commitment,\n            \u003cSelf::Pcs as Pcs\u003cSelf::Challenge, Self::Challenger\u003e\u003e::Domain,\n        \u003e,\n{\n    /// Commitment type used in the verifier circuit (e.g. HashTargets).\n    type Commitment: Recursive\u003c\n            Self::Challenge,\n            Input = \u003cSelf::Pcs as Pcs\u003cSelf::Challenge, Self::Challenger\u003e\u003e::Commitment,\n        \u003e + Clone\n        + ObservableCommitment;\n\n    /// Input proof type for the PCS (e.g. batch opening targets for FRI).\n    type InputProof: Recursive\u003cSelf::Challenge\u003e;\n\n    /// Opening proof type used in the verifier circuit (e.g. FRI proof targets).\n    type OpeningProof: Recursive\u003c\n            Self::Challenge,\n            Input = \u003cSelf::Pcs as Pcs\u003cSelf::Challenge, Self::Challenger\u003e\u003e::Proof,\n        \u003e;\n\n    /// Raw FRI opening proof type (value type, not circuit targets). Used to set private data.\n    type RawOpeningProof;\n\n    const DIGEST_ELEMS: usize;\n\n    /// Invoke a closure with the FRI opening proof extracted from the recursion input.\n    fn with_fri_opening_proof\u003c'a, A, R\u003e(\n        prev: \u0026RecursionInput\u003c'a, Self, A\u003e,\n        f: impl FnOnce(\u0026Self::RawOpeningProof) -\u003e R,\n    ) -\u003e R\n    where\n        A: RecursiveAir\u003cVal\u003cSelf\u003e, Self::Challenge, LogUpGadget\u003e;\n\n    /// Enable Poseidon2 permutation on the circuit (for MMCS verification). Called by the backend before building the verifier.\n    fn enable_poseidon2_on_circuit(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cSelf::Challenge\u003e,\n    ) -\u003e Result\u003c(), VerificationError\u003e;\n\n    /// Return the PCS verifier params (e.g. FRI params). The config must hold these and return a reference.\n    #[allow(clippy::type_complexity)]\n    fn pcs_verifier_params(\n        \u0026self,\n    ) -\u003e \u0026\u003cSelf::Pcs as RecursivePcs\u003c\n        Self,\n        Self::InputProof,\n        Self::OpeningProof,\n        Self::Commitment,\n        \u003cSelf::Pcs as Pcs\u003cSelf::Challenge, Self::Challenger\u003e\u003e::Domain,\n    \u003e\u003e::VerifierParams;\n\n    /// Set FRI Merkle path private data on the runner. Implement by calling\n    /// [`crate::pcs::set_fri_mmcs_private_data`] with your concrete MMCS/hasher types.\n    fn set_fri_private_data(\n        runner: \u0026mut CircuitRunner\u003cSelf::Challenge\u003e,\n        op_ids: \u0026[NonPrimitiveOpId],\n        opening_proof: \u0026Self::RawOpeningProof,\n    ) -\u003e Result\u003c(), \u0026'static str\u003e;\n}\n\n/// FRI-based recursion backend. Holds Poseidon2 config; verifier params come from the config via [`FriRecursionConfig::pcs_verifier_params`].\n/// `WIDTH` and `RATE` are the Poseidon2 circuit parameters (typically 16 and 8).\n#[derive(Clone)]\npub struct FriRecursionBackend\u003cconst WIDTH: usize = 16, const RATE: usize = 8\u003e {\n    pub poseidon2_config: Poseidon2Config,\n}\n\nimpl\u003cconst WIDTH: usize, const RATE: usize\u003e FriRecursionBackend\u003cWIDTH, RATE\u003e {\n    pub const fn new(poseidon2_config: Poseidon2Config) -\u003e Self {\n        Self { poseidon2_config }\n    }\n}\n\n/// Verifier result from the FRI backend: either uni-stark or batch-stark builder + op_ids.\npub enum FriVerifierResult\u003cSC\u003e\nwhere\n    SC: FriRecursionConfig,\n    SC::Pcs: RecursivePcs\u003c\n            SC,\n            SC::InputProof,\n            SC::OpeningProof,\n            SC::Commitment,\n            \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain,\n        \u003e,\n{\n    UniStark(\n        StarkVerifierInputsBuilder\u003cSC, SC::Commitment, SC::OpeningProof\u003e,\n        Vec\u003cNonPrimitiveOpId\u003e,\n    ),\n    BatchStark(\n        BatchStarkVerifierInputsBuilder\u003cSC, SC::Commitment, SC::OpeningProof\u003e,\n        Vec\u003cNonPrimitiveOpId\u003e,\n    ),\n}\n\nimpl\u003cSC, A\u003e VerifierCircuitResult\u003cSC, A\u003e for FriVerifierResult\u003cSC\u003e\nwhere\n    SC: FriRecursionConfig,\n    SC::Pcs: RecursivePcs\u003c\n            SC,\n            SC::InputProof,\n            SC::OpeningProof,\n            SC::Commitment,\n            \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain,\n        \u003e,\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    Val\u003cSC\u003e: PrimeField64,\n    SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e + From\u003cVal\u003cSC\u003e\u003e,\n{\n    fn pack_public_inputs(\n        \u0026self,\n        prev: \u0026RecursionInput\u003c'_, SC, A\u003e,\n    ) -\u003e Result\u003cVec\u003cSC::Challenge\u003e, VerificationError\u003e {\n        match (self, prev) {\n            (\n                Self::UniStark(builder, _),\n                RecursionInput::UniStark {\n                    proof,\n                    public_inputs,\n                    preprocessed_commit,\n                    ..\n                },\n            ) =\u003e Ok(builder.pack_values(public_inputs, proof, preprocessed_commit)),\n            (\n                Self::BatchStark(builder, _),\n                RecursionInput::BatchStark {\n                    proof,\n                    common_data,\n                    table_public_inputs,\n                },\n            ) =\u003e Ok(builder.pack_values(table_public_inputs, \u0026proof.proof, common_data)),\n            _ =\u003e Err(VerificationError::InvalidProofShape(\n                alloc::string::ToString::to_string(\n                    \"RecursionInput variant does not match verifier result\",\n                ),\n            )),\n        }\n    }\n\n    fn op_ids(\u0026self) -\u003e \u0026[NonPrimitiveOpId] {\n        match self {\n            Self::UniStark(_, ids) | Self::BatchStark(_, ids) =\u003e ids,\n        }\n    }\n}\n\nimpl\u003cSC, A, const WIDTH: usize, const RATE: usize\u003e PcsRecursionBackend\u003cSC, A\u003e\n    for FriRecursionBackend\u003cWIDTH, RATE\u003e\nwhere\n    SC: FriRecursionConfig,\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    Val\u003cSC\u003e: PrimeField64,\n    SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e\n        + From\u003cVal\u003cSC\u003e\u003e\n        + p3_field::ExtensionField\u003cVal\u003cSC\u003e\u003e\n        + p3_field::PrimeCharacteristicRing,\n    \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain: Clone,\n    p3_uni_stark::SymbolicExpression\u003cSC::Challenge\u003e:\n        From\u003cp3_uni_stark::SymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n    SC::Pcs: RecursivePcs\u003c\n            SC,\n            SC::InputProof,\n            SC::OpeningProof,\n            SC::Commitment,\n            \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain,\n        \u003e,\n{\n    type VerifierResult = FriVerifierResult\u003cSC\u003e;\n\n    fn prepare_circuit(\n        \u0026self,\n        config: \u0026SC,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    ) -\u003e Result\u003c(), VerificationError\u003e {\n        config.enable_poseidon2_on_circuit(circuit)\n    }\n\n    fn build_verifier_circuit(\n        \u0026self,\n        prev: \u0026RecursionInput\u003c'_, SC, A\u003e,\n        config: \u0026SC,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    ) -\u003e Result\u003cSelf::VerifierResult, VerificationError\u003e {\n        match prev {\n            RecursionInput::UniStark {\n                proof,\n                air,\n                public_inputs,\n                preprocessed_commit,\n            } =\u003e {\n                let verifier_inputs =\n                    StarkVerifierInputsBuilder::\u003cSC, SC::Commitment, SC::OpeningProof\u003e::allocate(\n                        circuit,\n                        proof,\n                        preprocessed_commit.as_ref(),\n                        public_inputs.len(),\n                    );\n                let op_ids = verify_p3_uni_proof_circuit::\u003c\n                    A,\n                    SC,\n                    SC::Commitment,\n                    SC::InputProof,\n                    SC::OpeningProof,\n                    WIDTH,\n                    RATE,\n                \u003e(\n                    config,\n                    air,\n                    circuit,\n                    \u0026verifier_inputs.proof_targets,\n                    \u0026verifier_inputs.air_public_targets,\n                    \u0026verifier_inputs.preprocessed_commit,\n                    config.pcs_verifier_params(),\n                    self.poseidon2_config,\n                )?;\n                Ok(FriVerifierResult::UniStark(verifier_inputs, op_ids))\n            }\n            RecursionInput::BatchStark {\n                proof,\n                common_data,\n                table_public_inputs,\n            } =\u003e {\n                let lookup_gadget = p3_lookup::logup::LogUpGadget::new();\n                let (verifier_inputs, op_ids) = match proof.ext_degree {\n                    1 =\u003e verify_p3_batch_proof_circuit::\u003c\n                        SC,\n                        SC::Commitment,\n                        SC::InputProof,\n                        SC::OpeningProof,\n                        _,\n                        WIDTH,\n                        RATE,\n                        1,\n                    \u003e(\n                        config,\n                        circuit,\n                        proof,\n                        config.pcs_verifier_params(),\n                        common_data,\n                        \u0026lookup_gadget,\n                        self.poseidon2_config,\n                    )?,\n                    4 =\u003e verify_p3_batch_proof_circuit::\u003c\n                        SC,\n                        SC::Commitment,\n                        SC::InputProof,\n                        SC::OpeningProof,\n                        _,\n                        WIDTH,\n                        RATE,\n                        4,\n                    \u003e(\n                        config,\n                        circuit,\n                        proof,\n                        config.pcs_verifier_params(),\n                        common_data,\n                        \u0026lookup_gadget,\n                        self.poseidon2_config,\n                    )?,\n                    d =\u003e {\n                        return Err(VerificationError::InvalidProofShape(alloc::format!(\n                            \"unsupported batch proof ext_degree {}\",\n                            d\n                        )));\n                    }\n                };\n                let _ = table_public_inputs;\n                Ok(FriVerifierResult::BatchStark(verifier_inputs, op_ids))\n            }\n        }\n    }\n\n    fn set_private_data(\n        \u0026self,\n        config: \u0026SC,\n        runner: \u0026mut CircuitRunner\u003cSC::Challenge\u003e,\n        op_ids: \u0026[NonPrimitiveOpId],\n        prev: \u0026RecursionInput\u003c'_, SC, A\u003e,\n    ) -\u003e Result\u003c(), \u0026'static str\u003e {\n        let _ = config;\n        SC::with_fri_opening_proof(prev, |opening_proof| {\n            SC::set_fri_private_data(runner, op_ids, opening_proof)\n        })\n    }\n\n    fn poseidon2_config_for_circuit(\u0026self) -\u003e Option\u003cPoseidon2Config\u003e {\n        Some(self.poseidon2_config)\n    }\n}\n","traces":[{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":75},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","backend","mod.rs"],"content":"//! PCS-specific backends for the unified recursion API.\n\npub mod fri;\n\npub use fri::FriRecursionBackend;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","challenger","circuit.rs"],"content":"//! Circuit-based challenger implementation matching native DuplexChallenger exactly.\n//!\n//! This module provides [`CircuitChallenger`], which maintains state as coefficient-level\n//! targets to ensure exact transcript compatibility with the native `DuplexChallenger`.\n//!\n//! # Soundness\n//!\n//! All Poseidon2 permutations in the challenger are CTL-verified against the Poseidon2 AIR table.\n//! The circuit builder's `add_poseidon2_perm_for_challenger` / `add_poseidon2_perm_for_challenger_base`\n//! (in `p3_circuit`) delegate to the standard Poseidon2 non-primitive op with full input and rate-output CTL exposure,\n//! and the executor runs the real permutation so the lookup argument enforces correctness.\n\nuse alloc::vec;\nuse alloc::vec::Vec;\n\nuse p3_circuit::ops::Poseidon2Config;\nuse p3_circuit::{CircuitBuilder, CircuitBuilderError};\nuse p3_field::{ExtensionField, PrimeField64};\n\nuse crate::Target;\nuse crate::traits::RecursiveChallenger;\n\n/// Circuit challenger with coefficient-level state management.\n///\n/// Maintains state as WIDTH base field coefficient targets to exactly match\n/// the native `DuplexChallenger\u003cF, P, WIDTH, RATE\u003e` behavior.\n///\n/// # Type Parameters\n/// - `WIDTH`: Sponge state width (16 for Poseidon2)\n/// - `RATE`: Sponge rate (8 for typical configuration)\n///\n/// # Design\n/// The state is represented as WIDTH targets, each representing a base field element\n/// embedded in the extension field (i.e., higher coefficients are zero).\n/// When duplexing:\n/// 1. State[0..input_buffer.len()] is overwritten with inputs\n/// 2. State is recomposed to WIDTH/D extension elements\n/// 3. Poseidon2 permutation is applied (CTL-verified against Poseidon2 AIR table)\n/// 4. Output extension elements are decomposed back to coefficients\n/// 5. Output buffer is filled from state[0..RATE]\npub struct CircuitChallenger\u003cconst WIDTH: usize, const RATE: usize\u003e {\n    /// Poseidon2 configuration for the permutation.\n    poseidon2_config: Poseidon2Config,\n\n    /// Sponge state: WIDTH base field coefficient targets.\n    /// Each target represents a base field element embedded in EF.\n    state: Vec\u003cTarget\u003e,\n\n    /// Buffered inputs not yet absorbed into state.\n    input_buffer: Vec\u003cTarget\u003e,\n\n    /// Buffered outputs from last duplexing.\n    output_buffer: Vec\u003cTarget\u003e,\n\n    /// Whether the challenger has been initialized with zero state.\n    initialized: bool,\n}\n\nimpl\u003cconst WIDTH: usize, const RATE: usize\u003e CircuitChallenger\u003cWIDTH, RATE\u003e {\n    /// Create a new uninitialized circuit challenger.\n    ///\n    /// # Parameters\n    /// - `poseidon2_config`: The Poseidon2 configuration to use for permutations\n    ///\n    /// Call `init()` to initialize the state with zeros before use.\n    pub const fn new(poseidon2_config: Poseidon2Config) -\u003e Self {\n        Self {\n            poseidon2_config,\n            state: Vec::new(),\n            input_buffer: Vec::new(),\n            output_buffer: Vec::new(),\n            initialized: false,\n        }\n    }\n\n    /// Initialize the challenger state with zeros.\n    ///\n    /// This must be called before any observe/sample operations.\n    pub fn init\u003cBF, EF\u003e(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e)\n    where\n        BF: PrimeField64,\n        EF: ExtensionField\u003cBF\u003e,\n    {\n        if self.initialized {\n            return;\n        }\n        let zero = circuit.define_const(EF::ZERO);\n        self.state = vec![zero; WIDTH];\n        self.initialized = true;\n    }\n\n    /// Perform duplexing: absorb inputs, permute, fill output buffer.\n    ///\n    /// Matches native `DuplexChallenger::duplexing()` exactly.\n    fn duplexing\u003cBF, EF\u003e(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e)\n    where\n        BF: PrimeField64,\n        EF: ExtensionField\u003cBF\u003e,\n    {\n        debug_assert!(self.initialized, \"Challenger must be initialized\");\n        debug_assert!(self.input_buffer.len() \u003c= RATE, \"Input buffer exceeds RATE\");\n\n        // Validate config matches extension field dimension\n        let config_d = self.poseidon2_config.d();\n        assert_eq!(\n            config_d,\n            EF::DIMENSION,\n            \"Poseidon2 config dimension mismatch: config D={} but EF::DIMENSION={}\",\n            config_d,\n            EF::DIMENSION\n        );\n\n        // 1. Overwrite state[0..n] with inputs (NOT XOR, matches native)\n        for (i, val) in self.input_buffer.drain(..).enumerate() {\n            self.state[i] = val;\n        }\n\n        // Branch based on extension degree\n        if EF::DIMENSION == 1 {\n            // D=1: Use base field permutation directly\n            self.duplexing_base(circuit);\n        } else {\n            // D=4: Use extension field permutation with recomposition\n            self.duplexing_ext::\u003cBF, EF\u003e(circuit);\n        }\n\n        // 5. Fill output buffer from state[0..RATE]\n        self.output_buffer.clear();\n        self.output_buffer.extend_from_slice(\u0026self.state[..RATE]);\n    }\n\n    /// Duplexing for D=1 (base field): permutation operates directly on 16 elements.\n    fn duplexing_base\u003cEF\u003e(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e)\n    where\n        EF: p3_field::Field,\n    {\n        // State is already 16 base field elements, use directly\n        let inputs: [Target; 16] = self\n            .state\n            .clone()\n            .try_into()\n            .expect(\"state should have WIDTH=16 elements\");\n\n        // CTL-verified within `add_poseidon2_perm_for_challenger_base`.\n        let outputs = circuit\n            .add_poseidon2_perm_for_challenger_base(self.poseidon2_config, inputs)\n            .expect(\"poseidon2 base permutation should succeed\");\n\n        // Update state directly\n        self.state = outputs.to_vec();\n    }\n\n    /// Duplexing for D=4 (extension field): pack/unpack around permutation.\n    // TODO: Generalize for D=2 (Goldilocks) when needed.\n    fn duplexing_ext\u003cBF, EF\u003e(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e)\n    where\n        BF: PrimeField64,\n        EF: ExtensionField\u003cBF\u003e,\n    {\n        // 2. Recompose WIDTH coefficient targets → WIDTH/D extension element targets\n        let num_ext_limbs = WIDTH / EF::DIMENSION;\n        assert_eq!(num_ext_limbs, 4, \"Expected 4 extension limbs for WIDTH/D\");\n\n        let ext_inputs: [Target; 4] = [\n            circuit\n                .recompose_base_coeffs_to_ext::\u003cBF\u003e(\u0026self.state[0..EF::DIMENSION])\n                .expect(\"recomposition should succeed\"),\n            circuit\n                .recompose_base_coeffs_to_ext::\u003cBF\u003e(\u0026self.state[EF::DIMENSION..2 * EF::DIMENSION])\n                .expect(\"recomposition should succeed\"),\n            circuit\n                .recompose_base_coeffs_to_ext::\u003cBF\u003e(\n                    \u0026self.state[2 * EF::DIMENSION..3 * EF::DIMENSION],\n                )\n                .expect(\"recomposition should succeed\"),\n            circuit\n                .recompose_base_coeffs_to_ext::\u003cBF\u003e(\n                    \u0026self.state[3 * EF::DIMENSION..4 * EF::DIMENSION],\n                )\n                .expect(\"recomposition should succeed\"),\n        ];\n\n        // 3. Apply Poseidon2 permutation (CTL-verified against Poseidon2 AIR table)\n        let ext_outputs = circuit\n            .add_poseidon2_perm_for_challenger(self.poseidon2_config, ext_inputs)\n            .expect(\"poseidon2 permutation should succeed\");\n\n        // 4. Decompose 4 extension outputs → WIDTH coefficient targets\n        for (limb, \u0026ext_out) in ext_outputs.iter().enumerate() {\n            let coeffs = circuit\n                .decompose_ext_to_base_coeffs::\u003cBF\u003e(ext_out)\n                .expect(\"decomposition should succeed\");\n            let start = limb * EF::DIMENSION;\n            for (i, coeff) in coeffs.into_iter().enumerate() {\n                self.state[start + i] = coeff;\n            }\n        }\n    }\n}\n\nimpl\u003cconst WIDTH: usize, const RATE: usize\u003e CircuitChallenger\u003cWIDTH, RATE\u003e {\n    /// Create a challenger with BabyBear D4 Width16 configuration (default).\n    pub const fn new_babybear() -\u003e Self {\n        Self::new(Poseidon2Config::BabyBearD4Width16)\n    }\n\n    /// Create a challenger with BabyBear D1 Width16 configuration (base field challenges).\n    pub const fn new_babybear_base() -\u003e Self {\n        Self::new(Poseidon2Config::BabyBearD1Width16)\n    }\n\n    /// Create a challenger with KoalaBear D4 Width16 configuration.\n    pub const fn new_koalabear() -\u003e Self {\n        Self::new(Poseidon2Config::KoalaBearD4Width16)\n    }\n\n    /// Create a challenger with KoalaBear D1 Width16 configuration (base field challenges).\n    pub const fn new_koalabear_base() -\u003e Self {\n        Self::new(Poseidon2Config::KoalaBearD1Width16)\n    }\n}\n\nimpl\u003cBF, EF, const WIDTH: usize, const RATE: usize\u003e RecursiveChallenger\u003cBF, EF\u003e\n    for CircuitChallenger\u003cWIDTH, RATE\u003e\nwhere\n    BF: PrimeField64,\n    EF: ExtensionField\u003cBF\u003e,\n{\n    fn observe(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e, value: Target) {\n        // Ensure initialized\n        self.init::\u003cBF, EF\u003e(circuit);\n\n        // Any buffered output is now invalid (matches native behavior)\n        self.output_buffer.clear();\n\n        self.input_buffer.push(value);\n\n        if self.input_buffer.len() == RATE {\n            self.duplexing::\u003cBF, EF\u003e(circuit);\n        }\n    }\n\n    fn sample(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e) -\u003e Target {\n        // Ensure initialized\n        self.init::\u003cBF, EF\u003e(circuit);\n\n        // If we have buffered inputs or ran out of outputs, duplex\n        // (matches native DuplexChallenger::sample behavior)\n        if !self.input_buffer.is_empty() || self.output_buffer.is_empty() {\n            self.duplexing::\u003cBF, EF\u003e(circuit);\n        }\n\n        self.output_buffer\n            .pop()\n            .expect(\"Output buffer should be non-empty after duplexing\")\n    }\n\n    fn observe_ext(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e, value: Target) {\n        // Decompose extension element to D base coefficients\n        let coeffs = circuit\n            .decompose_ext_to_base_coeffs::\u003cBF\u003e(value)\n            .expect(\"decomposition should succeed\");\n\n        // Observe each coefficient (matches native observe_algebra_element)\n        for coeff in coeffs {\n            self.observe(circuit, coeff);\n        }\n    }\n\n    fn sample_ext(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e) -\u003e Target {\n        // Sample D base elements (matches native sample_algebra_element)\n        let coeffs: Vec\u003c_\u003e = (0..EF::DIMENSION).map(|_| self.sample(circuit)).collect();\n\n        // Recompose into extension element\n        circuit\n            .recompose_base_coeffs_to_ext::\u003cBF\u003e(\u0026coeffs)\n            .expect(\"recomposition should succeed\")\n    }\n\n    fn sample_bits(\n        \u0026mut self,\n        circuit: \u0026mut CircuitBuilder\u003cEF\u003e,\n        num_bits: usize,\n    ) -\u003e Result\u003cVec\u003cTarget\u003e, CircuitBuilderError\u003e {\n        let base_sample = self.sample(circuit);\n        // Decompose base field element to bits\n        // We decompose the full base field bit width to ensure correct reconstruction\n        let bits = circuit.decompose_to_bits::\u003cBF\u003e(base_sample, BF::bits())?;\n        Ok(bits[..num_bits].to_vec())\n    }\n\n    fn check_pow_witness(\n        \u0026mut self,\n        circuit: \u0026mut CircuitBuilder\u003cEF\u003e,\n        witness_bits: usize,\n        witness: Target,\n    ) -\u003e Result\u003c(), CircuitBuilderError\u003e {\n        // When no PoW is required, keep challenger state unchanged\n        if witness_bits == 0 {\n            return Ok(());\n        }\n\n        // Observe witness as base field element\n        self.observe(circuit, witness);\n\n        // Sample and check leading bits are zero\n        let bits = self.sample_bits(circuit, witness_bits)?;\n        for bit in bits {\n            circuit.assert_zero(bit);\n        }\n\n        Ok(())\n    }\n\n    fn clear(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e) {\n        let zero = circuit.define_const(EF::ZERO);\n        self.state = vec![zero; WIDTH];\n        self.input_buffer.clear();\n        self.output_buffer.clear();\n        self.initialized = true;\n    }\n}\n","traces":[{"line":66,"address":[4332582,4332588,4332352],"length":1,"stats":{"Line":11}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":70,"address":[2786199],"length":1,"stats":{"Line":10}},{"line":71,"address":[4638966],"length":1,"stats":{"Line":9}},{"line":79,"address":[5848334,5848208],"length":1,"stats":{"Line":10}},{"line":84,"address":[2786440],"length":1,"stats":{"Line":10}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[3046291],"length":1,"stats":{"Line":10}},{"line":88,"address":[4332765,4332708,4332677],"length":1,"stats":{"Line":20}},{"line":89,"address":[3046439],"length":1,"stats":{"Line":10}},{"line":95,"address":[4640022,4639328,4640016],"length":1,"stats":{"Line":9}},{"line":100,"address":[4332833],"length":1,"stats":{"Line":9}},{"line":101,"address":[4639408],"length":1,"stats":{"Line":10}},{"line":104,"address":[5848536],"length":1,"stats":{"Line":9}},{"line":105,"address":[5848551],"length":1,"stats":{"Line":9}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[1806297,1806475,1806155],"length":1,"stats":{"Line":30}},{"line":115,"address":[4010505,4010382],"length":1,"stats":{"Line":19}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[3047048],"length":1,"stats":{"Line":8}},{"line":128,"address":[4010434],"length":1,"stats":{"Line":10}},{"line":129,"address":[4092256],"length":1,"stats":{"Line":10}},{"line":133,"address":[4638464,4638790],"length":1,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[4332063],"length":1,"stats":{"Line":1}},{"line":146,"address":[1805051,1805128],"length":1,"stats":{"Line":2}},{"line":150,"address":[3045950,3045849,3045875],"length":1,"stats":{"Line":2}},{"line":155,"address":[4008907,4008913,4007232],"length":1,"stats":{"Line":10}},{"line":161,"address":[4007271],"length":1,"stats":{"Line":8}},{"line":162,"address":[4089115],"length":1,"stats":{"Line":10}},{"line":164,"address":[5846609],"length":1,"stats":{"Line":9}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[2784208],"length":1,"stats":{"Line":8}},{"line":167,"address":[2784263],"length":1,"stats":{"Line":9}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[4330491,4330649],"length":1,"stats":{"Line":9}},{"line":170,"address":[],"length":0,"stats":{"Line":9}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[2784563],"length":1,"stats":{"Line":11}},{"line":173,"address":[],"length":0,"stats":{"Line":16}},{"line":175,"address":[3044416],"length":1,"stats":{"Line":9}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[4089765],"length":1,"stats":{"Line":9}},{"line":178,"address":[5846404,5846442,5846842],"length":1,"stats":{"Line":18}},{"line":180,"address":[4089778],"length":1,"stats":{"Line":9}},{"line":184,"address":[4331041],"length":1,"stats":{"Line":11}},{"line":185,"address":[],"length":0,"stats":{"Line":17}},{"line":189,"address":[2785063,2784945,2785633],"length":1,"stats":{"Line":27}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[2785173],"length":1,"stats":{"Line":7}},{"line":193,"address":[],"length":0,"stats":{"Line":18}},{"line":194,"address":[1804464,1804604,1804884,1804723],"length":1,"stats":{"Line":36}},{"line":195,"address":[4331843,4331784],"length":1,"stats":{"Line":18}},{"line":203,"address":[],"length":0,"stats":{"Line":2}},{"line":204,"address":[1803192],"length":1,"stats":{"Line":2}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[4030656],"length":1,"stats":{"Line":10}},{"line":231,"address":[4642640],"length":1,"stats":{"Line":10}},{"line":234,"address":[4350762],"length":1,"stats":{"Line":10}},{"line":236,"address":[4350780],"length":1,"stats":{"Line":10}},{"line":238,"address":[4030730],"length":1,"stats":{"Line":10}},{"line":239,"address":[4642712],"length":1,"stats":{"Line":10}},{"line":243,"address":[4127456],"length":1,"stats":{"Line":9}},{"line":245,"address":[4642488],"length":1,"stats":{"Line":8}},{"line":249,"address":[4127490,4127525],"length":1,"stats":{"Line":17}},{"line":250,"address":[2802057],"length":1,"stats":{"Line":8}},{"line":253,"address":[4642551],"length":1,"stats":{"Line":9}},{"line":258,"address":[4126236,4125888,4126242],"length":1,"stats":{"Line":11}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[4125928],"length":1,"stats":{"Line":9}},{"line":265,"address":[2800516,2800694],"length":1,"stats":{"Line":20}},{"line":266,"address":[4029287,4029259],"length":1,"stats":{"Line":20}},{"line":270,"address":[4125807,4125813,4125584],"length":1,"stats":{"Line":9}},{"line":272,"address":[2800384,2800401,2800181],"length":1,"stats":{"Line":25}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[4348787,4348862],"length":1,"stats":{"Line":17}},{"line":280,"address":[4349830,4349836,4349376],"length":1,"stats":{"Line":9}},{"line":285,"address":[4029384],"length":1,"stats":{"Line":9}},{"line":288,"address":[4349464],"length":1,"stats":{"Line":9}},{"line":289,"address":[],"length":0,"stats":{"Line":15}},{"line":292,"address":[2801280,2801951,2801957],"length":1,"stats":{"Line":7}},{"line":299,"address":[4349925],"length":1,"stats":{"Line":8}},{"line":300,"address":[6000691],"length":1,"stats":{"Line":1}},{"line":304,"address":[3083281],"length":1,"stats":{"Line":9}},{"line":307,"address":[4127010,4126853,4126923],"length":1,"stats":{"Line":17}},{"line":308,"address":[2801712,2801614,2801847],"length":1,"stats":{"Line":22}},{"line":309,"address":[4350471,4350522],"length":1,"stats":{"Line":15}},{"line":312,"address":[4642386],"length":1,"stats":{"Line":8}},{"line":315,"address":[],"length":0,"stats":{"Line":1}},{"line":316,"address":[1807216],"length":1,"stats":{"Line":1}},{"line":317,"address":[],"length":0,"stats":{"Line":2}},{"line":318,"address":[],"length":0,"stats":{"Line":1}},{"line":319,"address":[],"length":0,"stats":{"Line":1}},{"line":320,"address":[],"length":0,"stats":{"Line":1}}],"covered":83,"coverable":105},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","challenger","mod.rs"],"content":"//! Challenger implementations for recursive Fiat-Shamir transformations.\n\nmod circuit;\n\npub use circuit::CircuitChallenger;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","generation.rs"],"content":"use alloc::vec;\nuse alloc::vec::Vec;\n\nuse hashbrown::HashMap;\nuse itertools::zip_eq;\nuse p3_air::Air;\nuse p3_batch_stark::config::observe_instance_binding;\nuse p3_batch_stark::symbolic::get_log_num_quotient_chunks as get_batch_log_num_quotient_chunks;\nuse p3_batch_stark::{BatchProof, CommonData};\nuse p3_challenger::{CanObserve, CanSample, CanSampleBits, FieldChallenger, GrindingChallenger};\nuse p3_commit::{BatchOpening, Mmcs, Pcs, PolynomialSpace};\nuse p3_field::{BasedVectorSpace, PrimeCharacteristicRing, PrimeField, TwoAdicField};\nuse p3_fri::{FriProof, TwoAdicFriPcs};\nuse p3_lookup::lookup_traits::{Kind, Lookup, LookupGadget, lookup_data_to_expr};\nuse p3_uni_stark::{\n    Domain, Proof, StarkGenericConfig, SymbolicAirBuilder, SymbolicExpression, Val,\n    VerifierConstraintFolder, get_log_num_quotient_chunks,\n};\nuse thiserror::Error;\nuse tracing::debug_span;\n\n#[derive(Debug, Error)]\npub enum GenerationError {\n    #[error(\"Missing parameter for challenge generation\")]\n    MissingParameterError,\n\n    #[error(\n        \"Invalid number of parameters provided for challenge generation: got {0}, expected {1}\"\n    )]\n    InvalidParameterCount(usize, usize),\n\n    #[error(\"The FRI batch randomization does not correspond to the ZK setting.\")]\n    RandomizationError,\n\n    #[error(\"Witness check failed during challenge generation.\")]\n    InvalidPowWitness,\n\n    #[error(\"Invalid proof shape: {0}\")]\n    InvalidProofShape(\u0026'static str),\n}\n\n/// A type alias for a single opening point and its values.\ntype PointOpening\u003cSC\u003e = (\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\n    Vec\u003c\u003cSC as StarkGenericConfig\u003e::Challenge\u003e,\n);\n\n/// A type alias for all openings within a specific domain.\ntype DomainOpenings\u003cSC\u003e = Vec\u003c(Domain\u003cSC\u003e, Vec\u003cPointOpening\u003cSC\u003e\u003e)\u003e;\n\n/// A type alias for a commitment and its associated domain openings.\ntype CommitmentWithOpenings\u003cSC\u003e = (\n    \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\n        \u003cSC as StarkGenericConfig\u003e::Challenge,\n        \u003cSC as StarkGenericConfig\u003e::Challenger,\n    \u003e\u003e::Commitment,\n    DomainOpenings\u003cSC\u003e,\n);\n\n/// The final type alias for a slice of commitments with their openings.\ntype ComsWithOpenings\u003cSC\u003e = [CommitmentWithOpenings\u003cSC\u003e];\n\n/// Trait which defines the methods necessary\n/// for a Pcs to generate challenge values.\npub trait PcsGeneration\u003cSC: StarkGenericConfig, OpeningProof\u003e {\n    fn generate_challenges(\n        \u0026self,\n        config: \u0026SC,\n        challenger: \u0026mut SC::Challenger,\n        coms_to_verify: \u0026ComsWithOpenings\u003cSC\u003e,\n        opening_proof: \u0026OpeningProof,\n        // Depending on the `OpeningProof`, we might need additional parameters. For example, for a `FriProof`, we need the `log_max_height` to sample query indices.\n        extra_params: Option\u003c\u0026[usize]\u003e,\n    ) -\u003e Result\u003cVec\u003cSC::Challenge\u003e, GenerationError\u003e;\n\n    fn num_challenges(\n        opening_proof: \u0026OpeningProof,\n        extra_params: Option\u003c\u0026[usize]\u003e,\n    ) -\u003e Result\u003cusize, GenerationError\u003e;\n}\n\n// TODO: This could be used on the Plonky3 side as well.\n/// Generates the challenges used in the verification of a STARK proof.\npub fn generate_challenges\u003cSC: StarkGenericConfig, A\u003e(\n    air: \u0026A,\n    config: \u0026SC,\n    proof: \u0026Proof\u003cSC\u003e,\n    public_values: \u0026[Val\u003cSC\u003e],\n    extra_params: Option\u003c\u0026[usize]\u003e,\n) -\u003e Result\u003cVec\u003cSC::Challenge\u003e, GenerationError\u003e\nwhere\n    A: Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e + for\u003c'a\u003e Air\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e,\n    SC::Pcs: PcsGeneration\u003cSC, \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n{\n    let Proof {\n        commitments,\n        opened_values,\n        opening_proof,\n        degree_bits,\n    } = proof;\n\n    let preprocessed = air.preprocessed_trace();\n    let preprocessed_width = preprocessed.as_ref().map(|m| m.width).unwrap_or(0);\n\n    let degree = 1 \u003c\u003c degree_bits;\n    let pcs = config.pcs();\n    let log_quotient_degree = get_log_num_quotient_chunks::\u003cVal\u003cSC\u003e, A\u003e(\n        air,\n        preprocessed_width,\n        public_values.len(),\n        config.is_zk(),\n    );\n    let quotient_degree = 1 \u003c\u003c (log_quotient_degree + config.is_zk());\n\n    let trace_domain = pcs.natural_domain_for_degree(degree);\n    let init_trace_domain = pcs.natural_domain_for_degree(degree \u003e\u003e (config.is_zk()));\n    let quotient_domain =\n        trace_domain.create_disjoint_domain(1 \u003c\u003c (degree_bits + log_quotient_degree));\n    let quotient_chunks_domains = quotient_domain.split_domains(quotient_degree);\n\n    let randomized_quotient_chunks_domains = quotient_chunks_domains\n        .iter()\n        .map(|domain| pcs.natural_domain_for_degree(domain.size() \u003c\u003c (config.is_zk())))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let preprocessed_commit = if preprocessed_width \u003e 0 {\n        assert_eq!(config.is_zk(), 0); // TODO: preprocessed columns not supported in zk mode\n\n        let prep = preprocessed.expect(\"If the width is \u003e 0, then the commit exists.\");\n        let height = prep.values.len() / preprocessed_width;\n\n        if height != trace_domain.size() {\n            return Err(GenerationError::InvalidProofShape(\n                \"Verifier's preprocessed trace height must be equal to trace domain size\",\n            ));\n        }\n\n        let (preprocessed_commit, _) = debug_span!(\"process preprocessed trace\")\n            .in_scope(|| pcs.commit([(trace_domain, prep)]));\n        Some(preprocessed_commit)\n    } else {\n        None\n    };\n\n    let num_challenges = 3 // alpha, zeta and zeta_next\n     + SC::Pcs::num_challenges(opening_proof, extra_params)?;\n\n    let mut challenges = Vec::with_capacity(num_challenges);\n\n    let mut challenger = config.initialise_challenger();\n\n    challenger.observe(Val::\u003cSC\u003e::from_usize(*degree_bits));\n    challenger.observe(Val::\u003cSC\u003e::from_usize(*degree_bits - config.is_zk()));\n\n    challenger.observe(Val::\u003cSC\u003e::from_usize(preprocessed_width));\n    challenger.observe(commitments.trace.clone());\n    if preprocessed_width \u003e 0 {\n        challenger.observe(\n            preprocessed_commit\n                .as_ref()\n                .expect(\"If the width is \u003e 0, then the commit exists.\")\n                .clone(),\n        );\n    }\n    challenger.observe_slice(public_values);\n\n    // Get the first Fiat-Shamir challenge which will be used to combine all constraint polynomials into a single polynomial.\n    challenges.push(challenger.sample_algebra_element());\n    challenger.observe(commitments.quotient_chunks.clone());\n\n    if let Some(r_commit) = commitments.random.clone() {\n        challenger.observe(r_commit);\n    }\n\n    // Get an out-of-domain point to open our values at.\n    let zeta = challenger.sample_algebra_element();\n    challenges.push(zeta);\n    let zeta_next = init_trace_domain.next_point(zeta).unwrap();\n    challenges.push(zeta_next);\n\n    let mut coms_to_verify = if let Some(r_commit) = \u0026commitments.random {\n        let random_values = opened_values\n            .random\n            .as_ref()\n            .ok_or(GenerationError::RandomizationError)?;\n        vec![(\n            r_commit.clone(),\n            vec![(trace_domain, vec![(zeta, random_values.clone())])],\n        )]\n    } else {\n        vec![]\n    };\n    coms_to_verify.extend(vec![\n        (\n            commitments.trace.clone(),\n            vec![(\n                trace_domain,\n                vec![\n                    (zeta, opened_values.trace_local.clone()),\n                    (zeta_next, opened_values.trace_next.clone()),\n                ],\n            )],\n        ),\n        (\n            commitments.quotient_chunks.clone(),\n            // Check the commitment on the randomized domains.\n            zip_eq(\n                randomized_quotient_chunks_domains.iter(),\n                opened_values.quotient_chunks.clone(),\n            )\n            .map(|(domain, values)| (*domain, vec![(zeta, values)]))\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n        ),\n    ]);\n\n    // Add preprocessed commitment verification if present\n    if preprocessed_width \u003e 0 {\n        // If preprocessed_width \u003e 0, then preprocessed opened values must be present.\n        let opened_prep_local =\n            \u0026opened_values\n                .preprocessed_local\n                .clone()\n                .ok_or(GenerationError::InvalidProofShape(\n                    \"Missing preprocessed local opened values\",\n                ))?;\n\n        let opened_prep_next =\n            \u0026opened_values\n                .preprocessed_next\n                .clone()\n                .ok_or(GenerationError::InvalidProofShape(\n                    \"Missing preprocessed next opened values\",\n                ))?;\n\n        coms_to_verify.push((\n            preprocessed_commit.unwrap(),\n            vec![(\n                trace_domain,\n                vec![\n                    (zeta, opened_prep_local.clone()),\n                    (zeta_next, opened_prep_next.clone()),\n                ],\n            )],\n        ));\n    }\n\n    let pcs_challenges = pcs.generate_challenges(\n        config,\n        \u0026mut challenger,\n        \u0026coms_to_verify,\n        opening_proof,\n        extra_params,\n    )?;\n\n    challenges.extend(pcs_challenges);\n\n    Ok(challenges)\n}\n\n/// Generates the challenges used in the verification of a batch-STARK proof.\npub fn generate_batch_challenges\u003cSC: StarkGenericConfig, A, LG: LookupGadget\u003e(\n    airs: \u0026[A],\n    config: \u0026SC,\n    proof: \u0026BatchProof\u003cSC\u003e,\n    public_values: \u0026[Vec\u003cVal\u003cSC\u003e\u003e],\n    extra_params: Option\u003c\u0026[usize]\u003e,\n    common_data: \u0026CommonData\u003cSC\u003e,\n    lookup_gadget: \u0026LG,\n) -\u003e Result\u003cVec\u003cSC::Challenge\u003e, GenerationError\u003e\nwhere\n    A: Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e, SC::Challenge\u003e\u003e,\n    SC::Pcs: PcsGeneration\u003cSC, \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    debug_assert_eq!(config.is_zk(), 0, \"batch recursion assumes non-ZK\");\n    if SC::Pcs::ZK {\n        return Err(GenerationError::InvalidProofShape(\n            \"batch-STARK challenge generation does not support ZK mode\",\n        ));\n    }\n\n    let all_lookups = \u0026common_data.lookups;\n\n    let BatchProof {\n        commitments,\n        opened_values,\n        opening_proof,\n        global_lookup_data,\n        degree_bits,\n    } = proof;\n\n    // Check that the global lookup data is consistent with the lookups.\n    all_lookups\n        .iter()\n        .zip(global_lookup_data)\n        .try_for_each(|(lookups, global_lookups)| {\n            let mut counter = 0;\n            lookups.iter().try_for_each(|lookup| match \u0026lookup.kind {\n                Kind::Global(name) =\u003e {\n                    if counter \u003e= global_lookups.len() || global_lookups[counter].name != *name {\n                        Err(GenerationError::InvalidProofShape(\n                            \"Global lookups are inconsistent with lookups\",\n                        ))\n                    } else {\n                        counter += 1;\n                        Ok(())\n                    }\n                }\n                Kind::Local =\u003e Ok(()),\n            })?;\n            if counter != global_lookups.len() {\n                Err(GenerationError::InvalidProofShape(\n                    \"Global lookups are inconsistent with lookups\",\n                ))\n            } else {\n                Ok(())\n            }\n        })?;\n\n    let n_instances = airs.len();\n    if n_instances == 0\n        || opened_values.instances.len() != n_instances\n        || public_values.len() != n_instances\n        || degree_bits.len() != n_instances\n    {\n        return Err(GenerationError::InvalidProofShape(\n            \"instance metadata length mismatch\",\n        ));\n    }\n\n    let pcs = config.pcs();\n    let mut challenger = config.initialise_challenger();\n\n    challenger.observe_base_as_algebra_element::\u003cSC::Challenge\u003e(Val::\u003cSC\u003e::from_usize(n_instances));\n\n    for inst in \u0026opened_values.instances {\n        if inst\n            .base_opened_values\n            .quotient_chunks\n            .iter()\n            .any(|c| c.len() != SC::Challenge::DIMENSION)\n        {\n            return Err(GenerationError::InvalidProofShape(\n                \"invalid quotient chunk length\",\n            ));\n        }\n    }\n\n    let mut preprocessed_widths = Vec::with_capacity(airs.len());\n    let mut log_quotient_degrees = Vec::with_capacity(n_instances);\n    let mut quotient_degrees = Vec::with_capacity(n_instances);\n    for (i, (air, pv)) in airs.iter().zip(public_values.iter()).enumerate() {\n        let pre_w = common_data\n            .preprocessed\n            .as_ref()\n            .and_then(|g| g.instances[i].as_ref().map(|m| m.width))\n            .unwrap_or(0);\n        preprocessed_widths.push(pre_w);\n\n        let log_qd = get_batch_log_num_quotient_chunks(\n            air,\n            pre_w,\n            pv.len(),\n            \u0026all_lookups[i],\n            \u0026lookup_data_to_expr(\u0026global_lookup_data[i]),\n            config.is_zk(),\n            lookup_gadget,\n        );\n        let quotient_degree = 1 \u003c\u003c (log_qd + config.is_zk());\n        log_quotient_degrees.push(log_qd);\n        quotient_degrees.push(quotient_degree);\n    }\n\n    for i in 0..n_instances {\n        let ext_db = degree_bits[i];\n        let base_db =\n            ext_db\n                .checked_sub(config.is_zk())\n                .ok_or(GenerationError::InvalidProofShape(\n                    \"extended degree smaller than zk adjustment\",\n                ))?;\n\n        observe_instance_binding::\u003cSC\u003e(\n            \u0026mut challenger,\n            ext_db,\n            base_db,\n            A::width(\u0026airs[i]),\n            quotient_degrees[i],\n        );\n    }\n\n    challenger.observe(commitments.main.clone());\n    for pv in public_values {\n        challenger.observe_slice(pv);\n    }\n    for pre_w in \u0026preprocessed_widths {\n        challenger.observe_base_as_algebra_element::\u003cSC::Challenge\u003e(Val::\u003cSC\u003e::from_usize(*pre_w));\n    }\n    if let Some(global) = \u0026common_data.preprocessed {\n        challenger.observe(global.commitment.clone());\n    }\n\n    let is_lookup = commitments.permutation.is_some();\n\n    // Fetch lookups and sample their challenges.\n    // We use `get_different_perm_challenges` to ensure we only store the newly created challenges, in their order of sampling.\n    let different_challenges =\n        get_different_perm_challenges::\u003cSC, LG\u003e(\u0026mut challenger, all_lookups, lookup_gadget);\n\n    // Then, observe the permutation tables, if any.\n    if is_lookup {\n        challenger.observe(\n            commitments\n                .permutation\n                .clone()\n                .expect(\"We checked that the commitment exists\"),\n        );\n    }\n\n    let alpha = challenger.sample_algebra_element();\n\n    challenger.observe(commitments.quotient_chunks.clone());\n    let zeta = challenger.sample_algebra_element();\n\n    // TODO: Update to support ZK.\n    let ext_trace_domains: Vec\u003c_\u003e = degree_bits\n        .iter()\n        .map(|\u0026ext_db| pcs.natural_domain_for_degree(1 \u003c\u003c ext_db))\n        .collect();\n\n    // We have, in the typical lookup case, up to four rounds:\n    // trace, quotient, optional preprocessed, and optional permutation.\n    let mut coms_to_verify = Vec::with_capacity(4);\n\n    let trace_round = ext_trace_domains\n        .iter()\n        .zip(opened_values.instances.iter())\n        .map(|(ext_dom, inst)| {\n            let zeta_next = ext_dom\n                .next_point(zeta)\n                .ok_or(GenerationError::InvalidProofShape(\n                    \"trace domain lacks next point\",\n                ))?;\n            Ok((\n                *ext_dom,\n                vec![\n                    (zeta, inst.base_opened_values.trace_local.clone()),\n                    (zeta_next, inst.base_opened_values.trace_next.clone()),\n                ],\n            ))\n        })\n        .collect::\u003cResult\u003cVec\u003c_\u003e, GenerationError\u003e\u003e()?;\n    coms_to_verify.push((commitments.main.clone(), trace_round));\n\n    let quotient_domains: Vec\u003cVec\u003c_\u003e\u003e = degree_bits\n        .iter()\n        .zip(ext_trace_domains.iter())\n        .zip(log_quotient_degrees.iter())\n        .map(|((\u0026ext_db, ext_dom), \u0026log_qd)| {\n            let base_db = ext_db - config.is_zk();\n            let q_domain = ext_dom.create_disjoint_domain(1 \u003c\u003c (base_db + log_qd + config.is_zk()));\n            q_domain.split_domains(1 \u003c\u003c (log_qd + config.is_zk()))\n        })\n        .collect();\n\n    let mut quotient_round =\n        Vec::with_capacity(quotient_domains.iter().map(|domains| domains.len()).sum());\n    for (domains, inst) in quotient_domains.iter().zip(opened_values.instances.iter()) {\n        if inst.base_opened_values.quotient_chunks.len() != domains.len() {\n            return Err(GenerationError::InvalidProofShape(\n                \"quotient chunk count mismatch\",\n            ));\n        }\n        for (domain, values) in domains\n            .iter()\n            .zip(inst.base_opened_values.quotient_chunks.iter())\n        {\n            quotient_round.push((*domain, vec![(zeta, values.clone())]));\n        }\n    }\n    coms_to_verify.push((commitments.quotient_chunks.clone(), quotient_round));\n\n    if let Some(global) = \u0026common_data.preprocessed {\n        let mut pre_round = Vec::with_capacity(global.matrix_to_instance.len());\n\n        for (matrix_index, \u0026inst_idx) in global.matrix_to_instance.iter().enumerate() {\n            let pre_w = preprocessed_widths[inst_idx];\n            if pre_w == 0 {\n                return Err(GenerationError::InvalidProofShape(\n                    \"preprocessed width is zero but commitment exists\",\n                ));\n            }\n\n            let inst = \u0026opened_values.instances[inst_idx];\n            let local = inst.base_opened_values.preprocessed_local.as_ref().ok_or(\n                GenerationError::InvalidProofShape(\"preprocessed local values should exist\"),\n            )?;\n            let next = inst.base_opened_values.preprocessed_next.as_ref().ok_or(\n                GenerationError::InvalidProofShape(\"preprocessed next values should exist\"),\n            )?;\n\n            // Validate that the preprocessed data's base degree matches what we expect.\n            let ext_db = degree_bits[inst_idx];\n            let expected_base_db = ext_db - config.is_zk();\n\n            let meta =\n                global.instances[inst_idx]\n                    .as_ref()\n                    .ok_or(GenerationError::InvalidProofShape(\n                        \"Missing preprocessed instance metadata\",\n                    ))?;\n            if meta.matrix_index != matrix_index || meta.degree_bits != expected_base_db {\n                return Err(GenerationError::InvalidProofShape(\n                    \"Preprocessed instance metadata mismatch\",\n                ));\n            }\n\n            let base_db = meta.degree_bits;\n            let pre_domain = pcs.natural_domain_for_degree(1 \u003c\u003c base_db);\n            let zeta_next_i = ext_trace_domains[inst_idx].next_point(zeta).ok_or(\n                GenerationError::InvalidProofShape(\"Preprocessed domain lacks next point\"),\n            )?;\n\n            pre_round.push((\n                pre_domain,\n                vec![(zeta, local.clone()), (zeta_next_i, next.clone())],\n            ));\n        }\n\n        coms_to_verify.push((global.commitment.clone(), pre_round));\n    }\n\n    if is_lookup {\n        let permutation_commit = commitments.permutation.clone().unwrap();\n        let mut permutation_round = Vec::with_capacity(ext_trace_domains.len());\n        for (ext_dom, inst_opened_vals) in\n            ext_trace_domains.iter().zip(opened_values.instances.iter())\n        {\n            if inst_opened_vals.permutation_local.len() != inst_opened_vals.permutation_next.len() {\n                return Err(GenerationError::InvalidProofShape(\n                    \"Permutation opened values length mismatch\",\n                ));\n            }\n            if !inst_opened_vals.permutation_local.is_empty() {\n                let zeta_next =\n                    ext_dom\n                        .next_point(zeta)\n                        .ok_or(GenerationError::InvalidProofShape(\n                            \"Missing preprocessed instance metadata\",\n                        ))?;\n                permutation_round.push((\n                    *ext_dom,\n                    vec![\n                        (zeta, inst_opened_vals.permutation_local.clone()),\n                        (zeta_next, inst_opened_vals.permutation_next.clone()),\n                    ],\n                ));\n            }\n        }\n        coms_to_verify.push((permutation_commit, permutation_round));\n    }\n\n    let pcs_challenges = pcs.generate_challenges(\n        config,\n        \u0026mut challenger,\n        \u0026coms_to_verify,\n        opening_proof,\n        extra_params,\n    )?;\n\n    let mut challenges = Vec::with_capacity(2 + pcs_challenges.len());\n    challenges.extend(different_challenges);\n    challenges.push(alpha);\n    challenges.push(zeta);\n    challenges.extend(pcs_challenges);\n\n    Ok(challenges)\n}\n\ntype InnerFriProof\u003cSC, InputMmcs, FriMmcs\u003e = FriProof\u003c\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\n    FriMmcs,\n    Val\u003cSC\u003e,\n    Vec\u003cBatchOpening\u003cVal\u003cSC\u003e, InputMmcs\u003e\u003e,\n\u003e;\n\nimpl\u003cSC: StarkGenericConfig, Dft, InputMmcs: Mmcs\u003cVal\u003cSC\u003e\u003e, FriMmcs: Mmcs\u003cSC::Challenge\u003e\u003e\n    PcsGeneration\u003cSC, InnerFriProof\u003cSC, InputMmcs, FriMmcs\u003e\u003e\n    for TwoAdicFriPcs\u003cVal\u003cSC\u003e, Dft, InputMmcs, FriMmcs\u003e\nwhere\n    Val\u003cSC\u003e: TwoAdicField + PrimeField,\n    SC::Challenger: FieldChallenger\u003cVal\u003cSC\u003e\u003e\n        + GrindingChallenger\u003cWitness = Val\u003cSC\u003e\u003e\n        + CanObserve\u003cFriMmcs::Commitment\u003e,\n{\n    fn generate_challenges(\n        \u0026self,\n        _config: \u0026SC,\n        challenger: \u0026mut SC::Challenger,\n        coms_to_verify: \u0026ComsWithOpenings\u003cSC\u003e,\n        opening_proof: \u0026InnerFriProof\u003cSC, InputMmcs, FriMmcs\u003e,\n        extra_params: Option\u003c\u0026[usize]\u003e,\n    ) -\u003e Result\u003cVec\u003cSC::Challenge\u003e, GenerationError\u003e {\n        let num_challenges =\n            \u003cSelf as PcsGeneration\u003cSC, InnerFriProof\u003cSC, InputMmcs, FriMmcs\u003e\u003e\u003e::num_challenges(\n                opening_proof,\n                None,\n            )?;\n        let mut challenges = Vec::with_capacity(num_challenges);\n\n        // Observe all openings.\n        for (_, round) in coms_to_verify {\n            for (_, mat) in round {\n                for (_, point) in mat {\n                    point\n                        .iter()\n                        .for_each(|\u0026opening| challenger.observe_algebra_element(opening));\n                }\n            }\n        }\n\n        challenges.push(challenger.sample_algebra_element());\n\n        // Get `beta` challenges for the FRI rounds.\n        opening_proof\n            .commit_phase_commits\n            .iter()\n            .zip(\u0026opening_proof.commit_pow_witnesses)\n            .for_each(|(comm, pow_witness)| {\n                // To match with the prover (and for security purposes),\n                // we observe the commitment before sampling the challenge.\n                challenger.observe(comm.clone());\n                challenger.observe(*pow_witness);\n                // Sample a challenge as H(transcript || pow_witness). The circuit later\n                // verifies that the challenge begins with the required number of leading zeros.\n                let rand_f: Val\u003cSC\u003e = challenger.sample();\n                let rand_usize = rand_f.as_canonical_biguint().to_u64_digits()[0] as usize;\n                challenges.push(SC::Challenge::from_usize(rand_usize));\n\n                challenges.push(challenger.sample_algebra_element());\n            });\n\n        // Observe all coefficients of the final polynomial.\n        opening_proof\n            .final_poly\n            .iter()\n            .for_each(|x| challenger.observe_algebra_element(*x));\n\n        // Bind the variable-arity schedule into the transcript before query grinding,\n        // matching the native FRI verifier in Plonky3.\n        if let Some(first_qp) = opening_proof.query_proofs.first() {\n            for step in \u0026first_qp.commit_phase_openings {\n                challenger.observe(Val::\u003cSC\u003e::from_usize(step.log_arity as usize));\n            }\n        }\n\n        let params = extra_params.ok_or(GenerationError::MissingParameterError)?;\n\n        if params.len() != 2 {\n            return Err(GenerationError::InvalidParameterCount(params.len(), 2));\n        }\n\n        // Check PoW witness.\n        challenger.observe(opening_proof.query_pow_witness);\n\n        // Sample a challenge as H(transcript || pow_witness). The circuit later\n        // verifies that the challenge begins with the required number of leading zeros.\n        let rand_f: Val\u003cSC\u003e = challenger.sample();\n        let rand_usize = rand_f.as_canonical_biguint().to_u64_digits()[0] as usize;\n        challenges.push(SC::Challenge::from_usize(rand_usize));\n\n        let log_height_max = params[1];\n        let log_global_max_height = opening_proof.commit_phase_commits.len() + log_height_max;\n        for _ in \u0026opening_proof.query_proofs {\n            // For each query proof, we start by generating the random index.\n            challenges.push(SC::Challenge::from_usize(\n                challenger.sample_bits(log_global_max_height),\n            ));\n        }\n\n        Ok(challenges)\n    }\n\n    fn num_challenges(\n        opening_proof: \u0026InnerFriProof\u003cSC, InputMmcs, FriMmcs\u003e,\n        _extra_params: Option\u003c\u0026[usize]\u003e,\n    ) -\u003e Result\u003cusize, GenerationError\u003e {\n        let num_challenges =\n            1 + opening_proof.commit_phase_commits.len() + opening_proof.query_proofs.len();\n\n        Ok(num_challenges)\n    }\n}\n\n/// Samples all the different permutation challenges in the right order.\n/// This method is used to generate values for the challenge public values, and so it must store\n/// only the newly created challenges, in their order of sampling.\npub fn get_different_perm_challenges\u003cSC: StarkGenericConfig, LG: LookupGadget\u003e(\n    challenger: \u0026mut SC::Challenger,\n    all_lookups: \u0026[Vec\u003cLookup\u003cVal\u003cSC\u003e\u003e\u003e],\n    lookup_gadget: \u0026LG,\n) -\u003e Vec\u003cSC::Challenge\u003e {\n    let num_challenges_per_lookup = lookup_gadget.num_challenges();\n    let approx_global_names: usize = all_lookups.iter().map(|contexts| contexts.len()).sum();\n    let approx_total_challenges: usize = all_lookups\n        .iter()\n        .map(|contexts| contexts.len() * num_challenges_per_lookup)\n        .sum();\n    let mut global_perm_names = HashMap::with_capacity(approx_global_names);\n    let mut different_challenges = Vec::with_capacity(approx_total_challenges);\n\n    all_lookups.iter().for_each(|contexts| {\n        for context in contexts {\n            match \u0026context.kind {\n                Kind::Global(name) =\u003e {\n                    // Get or create the global challenges.\n                    // We only store the newly created challenges, in `different_challenges`.\n                    // `global_perm_challenges` is just used to track the names already encountered, so\n                    // we only insert `(name, ())` when a new name is encountered.\n                    global_perm_names.entry(name).or_insert_with(|| {\n                        (0..num_challenges_per_lookup).for_each(|_| {\n                            let sampled = challenger.sample_algebra_element();\n                            different_challenges.push(sampled);\n                        });\n                    });\n                }\n                Kind::Local =\u003e {\n                    different_challenges.extend(\n                        (0..num_challenges_per_lookup)\n                            .map(|_| challenger.sample_algebra_element::\u003cSC::Challenge\u003e()),\n                    );\n                }\n            }\n        }\n    });\n    different_challenges\n}\n","traces":[{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[3122944,3131057,3136873],"length":1,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":276,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[3123393],"length":1,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[3123424],"length":1,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":3}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":3}},{"line":297,"address":[],"length":0,"stats":{"Line":1}},{"line":298,"address":[],"length":0,"stats":{"Line":4}},{"line":299,"address":[],"length":0,"stats":{"Line":1}},{"line":300,"address":[],"length":0,"stats":{"Line":4}},{"line":301,"address":[],"length":0,"stats":{"Line":1}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[3139296],"length":1,"stats":{"Line":1}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[3137769],"length":1,"stats":{"Line":1}},{"line":320,"address":[],"length":0,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":1}},{"line":322,"address":[3123768],"length":1,"stats":{"Line":1}},{"line":323,"address":[3123897],"length":1,"stats":{"Line":1}},{"line":324,"address":[3123910],"length":1,"stats":{"Line":1}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":1}},{"line":334,"address":[3123993,3124062],"length":1,"stats":{"Line":2}},{"line":336,"address":[3124077],"length":1,"stats":{"Line":1}},{"line":337,"address":[],"length":0,"stats":{"Line":3}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[3136754,3137296,3137321],"length":1,"stats":{"Line":3}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[3124264],"length":1,"stats":{"Line":1}},{"line":350,"address":[],"length":0,"stats":{"Line":1}},{"line":351,"address":[3124354],"length":1,"stats":{"Line":1}},{"line":352,"address":[],"length":0,"stats":{"Line":2}},{"line":353,"address":[3136038,3124798],"length":1,"stats":{"Line":2}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":5}},{"line":358,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":1}},{"line":364,"address":[3136096],"length":1,"stats":{"Line":1}},{"line":365,"address":[],"length":0,"stats":{"Line":1}},{"line":366,"address":[],"length":0,"stats":{"Line":1}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":1}},{"line":370,"address":[],"length":0,"stats":{"Line":1}},{"line":371,"address":[],"length":0,"stats":{"Line":1}},{"line":374,"address":[],"length":0,"stats":{"Line":1}},{"line":375,"address":[],"length":0,"stats":{"Line":2}},{"line":376,"address":[],"length":0,"stats":{"Line":1}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":379,"address":[],"length":0,"stats":{"Line":1}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":1}},{"line":388,"address":[],"length":0,"stats":{"Line":1}},{"line":392,"address":[],"length":0,"stats":{"Line":1}},{"line":393,"address":[],"length":0,"stats":{"Line":1}},{"line":394,"address":[],"length":0,"stats":{"Line":2}},{"line":396,"address":[],"length":0,"stats":{"Line":1}},{"line":397,"address":[],"length":0,"stats":{"Line":2}},{"line":399,"address":[],"length":0,"stats":{"Line":1}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":1}},{"line":412,"address":[],"length":0,"stats":{"Line":1}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":1}},{"line":416,"address":[3125776],"length":1,"stats":{"Line":1}},{"line":420,"address":[],"length":0,"stats":{"Line":1}},{"line":422,"address":[],"length":0,"stats":{"Line":1}},{"line":423,"address":[],"length":0,"stats":{"Line":1}},{"line":426,"address":[],"length":0,"stats":{"Line":1}},{"line":428,"address":[],"length":0,"stats":{"Line":3}},{"line":433,"address":[],"length":0,"stats":{"Line":1}},{"line":435,"address":[3126502,3126441,3126123,3135220],"length":1,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":1}},{"line":438,"address":[],"length":0,"stats":{"Line":3}},{"line":439,"address":[3138186,3138270],"length":1,"stats":{"Line":1}},{"line":440,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[3138124],"length":1,"stats":{"Line":1}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":1}},{"line":445,"address":[],"length":0,"stats":{"Line":1}},{"line":446,"address":[3138382,3138666,3138934,3138557,3138445],"length":1,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":2}},{"line":448,"address":[],"length":0,"stats":{"Line":2}},{"line":453,"address":[3126647,3126695],"length":1,"stats":{"Line":2}},{"line":455,"address":[],"length":0,"stats":{"Line":1}},{"line":457,"address":[3126936],"length":1,"stats":{"Line":1}},{"line":458,"address":[],"length":0,"stats":{"Line":1}},{"line":459,"address":[3136923,3136896,3127182],"length":1,"stats":{"Line":3}},{"line":460,"address":[],"length":0,"stats":{"Line":1}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":462,"address":[],"length":0,"stats":{"Line":2}},{"line":466,"address":[3127220,3137872,3127299,3137897],"length":1,"stats":{"Line":4}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[3127511,3127431],"length":1,"stats":{"Line":2}},{"line":469,"address":[3127874,3134129],"length":1,"stats":{"Line":2}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":2}},{"line":475,"address":[],"length":0,"stats":{"Line":1}},{"line":476,"address":[3134370],"length":1,"stats":{"Line":1}},{"line":478,"address":[],"length":0,"stats":{"Line":1}},{"line":481,"address":[],"length":0,"stats":{"Line":1}},{"line":483,"address":[3128058,3128753],"length":1,"stats":{"Line":2}},{"line":484,"address":[3128122,3128177],"length":1,"stats":{"Line":2}},{"line":486,"address":[3128200,3128284],"length":1,"stats":{"Line":2}},{"line":487,"address":[3128562,3128766],"length":1,"stats":{"Line":2}},{"line":488,"address":[],"length":0,"stats":{"Line":1}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":2}},{"line":495,"address":[],"length":0,"stats":{"Line":2}},{"line":496,"address":[],"length":0,"stats":{"Line":1}},{"line":498,"address":[],"length":0,"stats":{"Line":2}},{"line":499,"address":[3129228],"length":1,"stats":{"Line":1}},{"line":503,"address":[],"length":0,"stats":{"Line":1}},{"line":504,"address":[3129535,3129643],"length":1,"stats":{"Line":1}},{"line":506,"address":[3131085,3129617,3129847,3129772],"length":1,"stats":{"Line":2}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[3129694],"length":1,"stats":{"Line":1}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[3129936],"length":1,"stats":{"Line":1}},{"line":513,"address":[3129971],"length":1,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":1}},{"line":519,"address":[],"length":0,"stats":{"Line":1}},{"line":520,"address":[3130302,3130162,3131068,3130400],"length":1,"stats":{"Line":2}},{"line":521,"address":[3130239],"length":1,"stats":{"Line":1}},{"line":524,"address":[],"length":0,"stats":{"Line":1}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":1}},{"line":530,"address":[],"length":0,"stats":{"Line":1}},{"line":533,"address":[],"length":0,"stats":{"Line":2}},{"line":534,"address":[],"length":0,"stats":{"Line":1}},{"line":535,"address":[3131243,3131315],"length":1,"stats":{"Line":2}},{"line":536,"address":[],"length":0,"stats":{"Line":1}},{"line":537,"address":[],"length":0,"stats":{"Line":2}},{"line":539,"address":[3131778,3132942],"length":1,"stats":{"Line":2}},{"line":540,"address":[3133022],"length":1,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":2}},{"line":545,"address":[],"length":0,"stats":{"Line":1}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[3133134],"length":1,"stats":{"Line":1}},{"line":548,"address":[3133173],"length":1,"stats":{"Line":1}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":1}},{"line":552,"address":[],"length":0,"stats":{"Line":1}},{"line":553,"address":[],"length":0,"stats":{"Line":2}},{"line":554,"address":[],"length":0,"stats":{"Line":2}},{"line":555,"address":[],"length":0,"stats":{"Line":2}},{"line":560,"address":[3131803],"length":1,"stats":{"Line":1}},{"line":563,"address":[],"length":0,"stats":{"Line":1}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[3131144],"length":1,"stats":{"Line":1}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":2}},{"line":572,"address":[],"length":0,"stats":{"Line":1}},{"line":573,"address":[3132527],"length":1,"stats":{"Line":1}},{"line":574,"address":[],"length":0,"stats":{"Line":1}},{"line":575,"address":[],"length":0,"stats":{"Line":1}},{"line":577,"address":[3132676],"length":1,"stats":{"Line":1}},{"line":596,"address":[4876125,4876473,4873728],"length":1,"stats":{"Line":1}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[4874135],"length":1,"stats":{"Line":1}},{"line":612,"address":[4874156,4874235],"length":1,"stats":{"Line":2}},{"line":613,"address":[4876164,4874341],"length":1,"stats":{"Line":2}},{"line":614,"address":[],"length":0,"stats":{"Line":1}},{"line":615,"address":[],"length":0,"stats":{"Line":2}},{"line":617,"address":[4876461],"length":1,"stats":{"Line":3}},{"line":622,"address":[4874383],"length":1,"stats":{"Line":1}},{"line":625,"address":[],"length":0,"stats":{"Line":1}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":1}},{"line":629,"address":[3195817,3196223,3196217,3195776],"length":1,"stats":{"Line":3}},{"line":632,"address":[3195833],"length":1,"stats":{"Line":1}},{"line":633,"address":[3195881],"length":1,"stats":{"Line":1}},{"line":636,"address":[],"length":0,"stats":{"Line":1}},{"line":637,"address":[],"length":0,"stats":{"Line":1}},{"line":638,"address":[3196123],"length":1,"stats":{"Line":1}},{"line":640,"address":[],"length":0,"stats":{"Line":1}},{"line":644,"address":[],"length":0,"stats":{"Line":1}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[3196254,3196240],"length":1,"stats":{"Line":3}},{"line":651,"address":[],"length":0,"stats":{"Line":1}},{"line":652,"address":[],"length":0,"stats":{"Line":2}},{"line":653,"address":[4874994],"length":1,"stats":{"Line":1}},{"line":657,"address":[4874834,4876146,4875057],"length":1,"stats":{"Line":2}},{"line":659,"address":[],"length":0,"stats":{"Line":1}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":1}},{"line":668,"address":[],"length":0,"stats":{"Line":1}},{"line":669,"address":[4875417],"length":1,"stats":{"Line":1}},{"line":670,"address":[4875651],"length":1,"stats":{"Line":1}},{"line":672,"address":[4875752,4875689],"length":1,"stats":{"Line":1}},{"line":673,"address":[],"length":0,"stats":{"Line":2}},{"line":674,"address":[4875824,4875873],"length":1,"stats":{"Line":2}},{"line":676,"address":[4876090],"length":1,"stats":{"Line":1}},{"line":677,"address":[],"length":0,"stats":{"Line":1}},{"line":681,"address":[],"length":0,"stats":{"Line":1}},{"line":684,"address":[4873552],"length":1,"stats":{"Line":1}},{"line":688,"address":[],"length":0,"stats":{"Line":1}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":1}},{"line":698,"address":[3139823,3139829,3139344],"length":1,"stats":{"Line":1}},{"line":703,"address":[],"length":0,"stats":{"Line":1}},{"line":704,"address":[],"length":0,"stats":{"Line":3}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[3140254,3139518,3140224],"length":1,"stats":{"Line":3}},{"line":709,"address":[3139556],"length":1,"stats":{"Line":1}},{"line":710,"address":[],"length":0,"stats":{"Line":1}},{"line":712,"address":[],"length":0,"stats":{"Line":3}},{"line":713,"address":[],"length":0,"stats":{"Line":2}},{"line":714,"address":[],"length":0,"stats":{"Line":1}},{"line":715,"address":[],"length":0,"stats":{"Line":1}},{"line":720,"address":[3140041,3140352],"length":1,"stats":{"Line":2}},{"line":721,"address":[3140384,3140353],"length":1,"stats":{"Line":2}},{"line":722,"address":[],"length":0,"stats":{"Line":1}},{"line":723,"address":[],"length":0,"stats":{"Line":1}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":1}}],"covered":199,"coverable":357},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","lib.rs"],"content":"//! Recursive proof verification for Plonky3 STARKs.\n\n#![no_std]\n\nextern crate alloc;\n\npub mod backend;\npub mod challenger;\npub mod generation;\npub mod pcs;\npub mod prelude;\npub mod public_inputs;\npub mod recursion;\npub mod traits;\npub mod types;\npub mod verifier;\n\n/// FRI PCS backend for the unified recursion API. Use with [`prove_next_layer`] and a config implementing [`FriRecursionConfig`].\npub use backend::FriRecursionBackend;\n/// Implement for your StarkConfig (or a wrapper holding FRI verifier params) to use [`FriRecursionBackend`].\npub use backend::fri::FriRecursionConfig;\npub use challenger::CircuitChallenger;\npub use generation::{\n    GenerationError, PcsGeneration, generate_batch_challenges, generate_challenges,\n};\npub use p3_circuit::ops;\npub use p3_circuit::ops::Poseidon2Config;\npub use pcs::fri::{FriVerifierParams, MAX_QUERY_INDEX_BITS};\npub use public_inputs::{\n    BatchStarkVerifierInputsBuilder, CommitmentOpening, FriVerifierInputs, PublicInputBuilder,\n    StarkVerifierInputs, StarkVerifierInputsBuilder, construct_batch_stark_verifier_inputs,\n};\n/// Unified recursion API: single entry point for proving the next layer over a uni-stark or batch-stark proof.\npub use recursion::{\n    AggregationPrepCache, BatchOnly, PcsRecursionBackend, ProveNextLayerParams, RecursionInput,\n    RecursionOutput, VerifierCircuitResult, build_and_prove_aggregation_layer,\n    build_and_prove_next_layer, prove_aggregation_layer, prove_next_layer,\n};\npub use traits::{\n    Recursive, RecursiveAir, RecursiveChallenger, RecursiveExtensionMmcs, RecursiveMmcs,\n    RecursivePcs,\n};\npub use types::{\n    BatchProofTargets, CommitmentTargets, CommonDataTargets, OpenedValuesTargets, ProofTargets,\n    RecursiveLagrangeSelectors, StarkChallenges, Target,\n};\npub use verifier::{\n    ObservableCommitment, VerificationError, verify_batch_circuit, verify_p3_uni_proof_circuit,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","pcs","fri","mod.rs"],"content":"//! FRI for recursive verification.\n\nmod params;\nmod targets;\nmod verifier;\n\npub use params::{FriVerifierParams, MAX_QUERY_INDEX_BITS};\npub use targets::{\n    BatchOpeningTargets, CommitPhaseProofStepTargets, FriProofTargets, HashProofTargets,\n    InputProofTargets, MerkleCapTargets, QueryProofTargets, RecExtensionValMmcs, RecValMmcs,\n    TwoAdicFriProofTargets, Witness,\n};\npub use verifier::verify_fri_circuit;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","pcs","fri","params.rs"],"content":"use p3_circuit::op::Poseidon2Config;\nuse p3_fri::FriParameters;\n\n/// FRI verifier parameters (subset needed for verification).\n///\n/// These parameters are extracted from the full `FriParameters` and contain\n/// only the information needed during verification (not proving).\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub struct FriVerifierParams {\n    /// Log₂ of the blowup factor (rate = 1/blowup)\n    pub log_blowup: usize,\n    /// Log₂ of the final polynomial length (after all folding rounds)\n    pub log_final_poly_len: usize,\n    /// Number of commit-phase proof-of-work bits required\n    pub commit_pow_bits: usize,\n    /// Number of query proof-of-work bits required\n    pub query_pow_bits: usize,\n    /// Poseidon2 permutation configuration for MMCS verification.\n    /// When `Some`, recursive MMCS verification is performed.\n    /// When `None`, only arithmetic verification is performed (for testing).\n    pub permutation_config: Option\u003cPoseidon2Config\u003e,\n}\n\nimpl FriVerifierParams {\n    /// Create params with MMCS verification enabled.\n    pub const fn with_mmcs(\n        log_blowup: usize,\n        log_final_poly_len: usize,\n        commit_pow_bits: usize,\n        query_pow_bits: usize,\n        permutation_config: Poseidon2Config,\n    ) -\u003e Self {\n        Self {\n            log_blowup,\n            log_final_poly_len,\n            commit_pow_bits,\n            query_pow_bits,\n            permutation_config: Some(permutation_config),\n        }\n    }\n\n    /// Create params without MMCS verification (arithmetic-only, for testing).\n    pub const fn arithmetic_only(\n        log_blowup: usize,\n        log_final_poly_len: usize,\n        commit_pow_bits: usize,\n        query_pow_bits: usize,\n    ) -\u003e Self {\n        Self {\n            log_blowup,\n            log_final_poly_len,\n            commit_pow_bits,\n            query_pow_bits,\n            permutation_config: None,\n        }\n    }\n}\n\nimpl\u003cM\u003e From\u003c\u0026FriParameters\u003cM\u003e\u003e for FriVerifierParams {\n    /// Creates params without MMCS verification by default.\n    /// Use `with_mmcs` or set `permutation_config` manually to enable MMCS verification.\n    fn from(params: \u0026FriParameters\u003cM\u003e) -\u003e Self {\n        Self {\n            log_blowup: params.log_blowup,\n            log_final_poly_len: params.log_final_poly_len,\n            commit_pow_bits: params.commit_proof_of_work_bits,\n            query_pow_bits: params.query_proof_of_work_bits,\n            permutation_config: None,\n        }\n    }\n}\n\n/// Maximum number of bits used for query index decomposition in FRI verification circuits.\n///\n/// This is a fixed size to avoid const generic complexity. The circuit decomposes each\n/// query index into this many bits, but only uses the first `log_max_height` bits that\n/// are actually needed.\n///\n/// This value is set to 31 bits because:\n/// - Query indices are sampled as field elements in the base field (BabyBear/KoalaBear)\n/// - BabyBear: p = 2^31 - 2^27 + 1 (31-bit prime)\n/// - KoalaBear: p = 2^31 - 2^24 + 1 (31-bit prime)\n/// - Field elements fit in 31 bits, so 31 bits is sufficient\n///\n/// For Goldilocks (64-bit field), this would need to be increased, but that's not\n/// currently supported in the recursion circuit.\npub const MAX_QUERY_INDEX_BITS: usize = 31;\n","traces":[{"line":26,"address":[8630704],"length":1,"stats":{"Line":3}},{"line":43,"address":[8630656],"length":1,"stats":{"Line":0}},{"line":62,"address":[3573728],"length":1,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[5125202],"length":1,"stats":{"Line":6}},{"line":66,"address":[3573753],"length":1,"stats":{"Line":4}},{"line":67,"address":[3573760],"length":1,"stats":{"Line":6}}],"covered":6,"coverable":7},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","pcs","fri","targets.rs"],"content":"use alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::marker::PhantomData;\n\nuse p3_challenger::{CanObserve, GrindingChallenger};\nuse p3_circuit::utils::RowSelectorsTargets;\nuse p3_circuit::{CircuitBuilder, CircuitBuilderError, NonPrimitiveOpId};\nuse p3_commit::{BatchOpening, ExtensionMmcs, Mmcs, PolynomialSpace};\nuse p3_field::coset::TwoAdicMultiplicativeCoset;\nuse p3_field::{\n    BasedVectorSpace, ExtensionField, Field, PackedValue, PrimeCharacteristicRing, PrimeField64,\n    TwoAdicField,\n};\nuse p3_fri::{CommitPhaseProofStep, FriProof, QueryProof, TwoAdicFriPcs};\nuse p3_merkle_tree::MerkleTreeMmcs;\nuse p3_symmetric::{CryptographicHasher, MerkleCap, PseudoCompressionFunction};\nuse p3_uni_stark::{StarkGenericConfig, Val};\nuse serde::{Deserialize, Serialize};\n\nuse super::{FriVerifierParams, MAX_QUERY_INDEX_BITS, verify_fri_circuit};\nuse crate::Target;\nuse crate::challenger::CircuitChallenger;\nuse crate::traits::{\n    ComsWithOpeningsTargets, Recursive, RecursiveChallenger, RecursiveExtensionMmcs, RecursiveMmcs,\n    RecursivePcs,\n};\nuse crate::types::{OpenedValuesTargetsWithLookups, RecursiveLagrangeSelectors};\nuse crate::verifier::{ObservableCommitment, VerificationError};\n\n/// `Recursive` version of `FriProof`.\npub struct FriProofTargets\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n    InputProof: Recursive\u003cEF\u003e,\n    Witness: Recursive\u003cEF\u003e,\n\u003e {\n    pub commit_phase_commits: Vec\u003cRecMmcs::Commitment\u003e,\n    pub commit_pow_witnesses: Vec\u003cWitness\u003e,\n    pub query_proofs: Vec\u003cQueryProofTargets\u003cF, EF, InputProof, RecMmcs\u003e\u003e,\n    pub final_poly: Vec\u003cTarget\u003e,\n    pub pow_witness: Witness,\n    pub log_arities: Vec\u003cusize\u003e,\n}\n\nimpl\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n    InputProof: Recursive\u003cEF\u003e,\n    Witness: Recursive\u003cEF\u003e,\n\u003e Recursive\u003cEF\u003e for FriProofTargets\u003cF, EF, RecMmcs, InputProof, Witness\u003e\n{\n    type Input = FriProof\u003cEF, RecMmcs::Input, Witness::Input, InputProof::Input\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let commit_phase_commits = input\n            .commit_phase_commits\n            .iter()\n            .map(|commitment| RecMmcs::Commitment::new(circuit, commitment))\n            .collect();\n\n        let commit_pow_witnesses = input\n            .commit_pow_witnesses\n            .iter()\n            .map(|witness| Witness::new(circuit, witness))\n            .collect();\n\n        let query_proofs = input\n            .query_proofs\n            .iter()\n            .map(|query| QueryProofTargets::new(circuit, query))\n            .collect();\n\n        let final_poly = circuit\n            .alloc_public_inputs(input.final_poly.len(), \"FRI final polynomial coefficients\");\n\n        let log_arities = input\n            .query_proofs\n            .first()\n            .map(|qp| {\n                qp.commit_phase_openings\n                    .iter()\n                    .map(|o| o.log_arity as usize)\n                    .collect()\n            })\n            .unwrap_or_default();\n\n        Self {\n            commit_phase_commits,\n            commit_pow_witnesses,\n            query_proofs,\n            final_poly,\n            pow_witness: Witness::new(circuit, \u0026input.query_pow_witness),\n            log_arities,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        let FriProof {\n            commit_phase_commits,\n            commit_pow_witnesses,\n            query_proofs,\n            final_poly,\n            query_pow_witness,\n        } = input;\n\n        commit_phase_commits\n            .iter()\n            .flat_map(|c| RecMmcs::Commitment::get_values(c))\n            .chain(\n                commit_pow_witnesses\n                    .iter()\n                    .flat_map(|w| Witness::get_values(w)),\n            )\n            .chain(\n                query_proofs\n                    .iter()\n                    .flat_map(|c| QueryProofTargets::\u003cF, EF, InputProof, RecMmcs\u003e::get_values(c)),\n            )\n            .chain(final_poly.iter().copied())\n            .chain(Witness::get_values(query_pow_witness))\n            .collect()\n    }\n}\n\n/// `Recursive` version of `QueryProof`.\npub struct QueryProofTargets\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    InputProof: Recursive\u003cEF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n\u003e {\n    pub input_proof: InputProof,\n    pub commit_phase_openings: Vec\u003cCommitPhaseProofStepTargets\u003cF, EF, RecMmcs\u003e\u003e,\n}\n\nimpl\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    InputProof: Recursive\u003cEF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n\u003e Recursive\u003cEF\u003e for QueryProofTargets\u003cF, EF, InputProof, RecMmcs\u003e\n{\n    type Input = QueryProof\u003cEF, RecMmcs::Input, InputProof::Input\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        // Note that the iterator `lens` is updated by each call to `new`. So we can always pass the same `lens` for all structures.\n        let input_proof = InputProof::new(circuit, \u0026input.input_proof);\n        let commit_phase_openings = input\n            .commit_phase_openings\n            .iter()\n            .map(|commitment| CommitPhaseProofStepTargets::new(circuit, commitment))\n            .collect();\n        Self {\n            input_proof,\n            commit_phase_openings,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        InputProof::get_values(\u0026input.input_proof)\n            .into_iter()\n            .chain(\n                input\n                    .commit_phase_openings\n                    .iter()\n                    .flat_map(|o| CommitPhaseProofStepTargets::\u003c_, _, RecMmcs\u003e::get_values(o)),\n            )\n            .collect()\n    }\n}\n\n/// `Recursive` version of `CommitPhaseProofStep`.\n///\n/// Sibling values are stored as **lifted base field coefficients** to enable MMCS verification.\n/// ExtensionMmcs commits by flattening extension elements to base field, so we need the\n/// coefficients separately for hashing. Use `sibling_values_packed()` to get the packed\n/// extension elements for FRI folding arithmetic.\n///\n/// For arity `k = 2^log_arity`, we store `k - 1` sibling values (the queried value is the\n/// folded evaluation from the previous phase). Each sibling is represented by `EF::DIMENSION`\n/// lifted base field coefficients, giving `(k - 1) * EF::DIMENSION` targets total.\npub struct CommitPhaseProofStepTargets\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n\u003e {\n    pub log_arity: usize,\n    /// Lifted base field coefficients for all (arity - 1) sibling values, flattened.\n    /// Layout: [sib0_c0, sib0_c1, .., sib0_cD, sib1_c0, .., sib{a-2}_cD]\n    pub sibling_coefficients: Vec\u003cTarget\u003e,\n    pub opening_proof: RecMmcs::Proof,\n    _phantom: PhantomData\u003c(F, EF)\u003e,\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e + BasedVectorSpace\u003cF\u003e, RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e\u003e\n    CommitPhaseProofStepTargets\u003cF, EF, RecMmcs\u003e\n{\n    /// Pack a single sibling's lifted base field coefficients into an extension element.\n    fn pack_one_sibling(coeffs: \u0026[Target], circuit: \u0026mut CircuitBuilder\u003cEF\u003e) -\u003e Target {\n        let basis: Vec\u003cEF\u003e = (0..EF::DIMENSION)\n            .map(|i| EF::from_basis_coefficients_fn(|j| if i == j { F::ONE } else { F::ZERO }))\n            .collect();\n\n        let mut result = coeffs[0];\n        for (i, \u0026basis_elem) in basis.iter().enumerate().skip(1) {\n            let basis_const = circuit.define_const(basis_elem);\n            let term = circuit.mul(coeffs[i], basis_const);\n            result = circuit.add(result, term);\n        }\n        result\n    }\n\n    /// Returns all (arity - 1) sibling values as packed extension elements.\n    pub fn sibling_values_packed(\u0026self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e) -\u003e Vec\u003cTarget\u003e {\n        let d = EF::DIMENSION;\n        self.sibling_coefficients\n            .chunks_exact(d)\n            .map(|chunk| Self::pack_one_sibling(chunk, circuit))\n            .collect()\n    }\n\n    /// Returns the single sibling value as a packed extension element (arity-2 convenience).\n    pub fn sibling_value_packed(\u0026self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e) -\u003e Target {\n        debug_assert_eq!(\n            self.log_arity, 1,\n            \"sibling_value_packed is for arity-2 only; use sibling_values_packed for higher arity\"\n        );\n        Self::pack_one_sibling(\u0026self.sibling_coefficients, circuit)\n    }\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e + BasedVectorSpace\u003cF\u003e, RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e\u003e\n    Recursive\u003cEF\u003e for CommitPhaseProofStepTargets\u003cF, EF, RecMmcs\u003e\n{\n    type Input = CommitPhaseProofStep\u003cEF, RecMmcs::Input\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let log_arity = input.log_arity as usize;\n        let arity = 1usize \u003c\u003c log_arity;\n        let num_siblings = arity - 1;\n        let num_coeffs = num_siblings * EF::DIMENSION;\n        let sibling_coefficients =\n            circuit.alloc_public_inputs(num_coeffs, \"FRI commit phase sibling coefficients\");\n        let opening_proof = RecMmcs::Proof::new(circuit, \u0026input.opening_proof);\n        Self {\n            log_arity,\n            sibling_coefficients,\n            opening_proof,\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        let CommitPhaseProofStep {\n            log_arity: _,\n            sibling_values,\n            opening_proof,\n        } = input;\n        let mut values: Vec\u003cEF\u003e = Vec::new();\n        for sibling_value in sibling_values {\n            let coeffs = sibling_value.as_basis_coefficients_slice();\n            values.extend(coeffs.iter().map(|\u0026c| EF::from(c)));\n        }\n        values.extend(RecMmcs::Proof::get_values(opening_proof));\n        values\n    }\n}\n\n/// `Recursive` version of `BatchOpening`.\n///\n/// Uses **lifted representation**: each base field value is represented as a single extension\n/// field element `EF([v, 0, 0, 0])`. This allows 1:1 correspondence with polynomial values\n/// for arithmetic verification.\npub struct BatchOpeningTargets\u003cF: Field, EF: ExtensionField\u003cF\u003e, RecMmcs: RecursiveMmcs\u003cF, EF\u003e\u003e {\n    /// The opened row values from each matrix in the batch.\n    /// Each inner vector has one target per base field value.\n    pub opened_values: Vec\u003cVec\u003cTarget\u003e\u003e,\n    /// The proof showing the values are valid openings.\n    pub opening_proof: RecMmcs::Proof,\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, Inner: RecursiveMmcs\u003cF, EF\u003e\u003e Recursive\u003cEF\u003e\n    for BatchOpeningTargets\u003cF, EF, Inner\u003e\n{\n    type Input = BatchOpening\u003cF, Inner::Input\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let opened_values = input\n            .opened_values\n            .iter()\n            .map(|values| circuit.alloc_public_inputs(values.len(), \"batch opened values\"))\n            .collect();\n\n        let opening_proof = Inner::Proof::new(circuit, \u0026input.opening_proof);\n\n        Self {\n            opened_values,\n            opening_proof,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        let BatchOpening {\n            opened_values,\n            opening_proof,\n        } = input;\n\n        opened_values\n            .iter()\n            .flat_map(|inner| inner.iter().map(|v| EF::from(*v)))\n            .chain(Inner::Proof::get_values(opening_proof))\n            .collect()\n    }\n}\n\n// Now, we define the commitment schemes.\n\n/// `MerkleCapTargets` corresponds to a Merkle cap commitment with `2^cap_height` hash entries,\n/// each having `DIGEST_ELEMS` digest elements.\n///\n/// Uses **lifted representation**: each base field hash element is stored as a separate extension\n/// field target `EF([v, 0, 0, 0])`. This is consistent with Fiat-Shamir observation.\n///\n/// A cap of height 0 contains a single entry (the root), while a cap of height `h` contains\n/// `2^h` entries. The Fiat-Shamir transcript observes all entries sequentially.\n#[derive(Clone)]\npub struct MerkleCapTargets\u003cF, const DIGEST_ELEMS: usize\u003e {\n    pub cap_targets: Vec\u003c[Target; DIGEST_ELEMS]\u003e,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF, const DIGEST_ELEMS: usize\u003e ObservableCommitment for MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e {\n    fn to_observation_targets(\u0026self) -\u003e Vec\u003cTarget\u003e {\n        self.cap_targets\n            .iter()\n            .flat_map(|entry| entry.iter().copied())\n            .collect()\n    }\n}\n\ntype ValMmcsCommitment\u003cF, const DIGEST_ELEMS: usize\u003e =\n    MerkleCap\u003c\u003cF as PackedValue\u003e::Value, [\u003cF as PackedValue\u003e::Value; DIGEST_ELEMS]\u003e;\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, const DIGEST_ELEMS: usize\u003e Recursive\u003cEF\u003e\n    for MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e\n{\n    type Input = ValMmcsCommitment\u003cF, DIGEST_ELEMS\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let cap_targets = (0..input.num_roots())\n            .map(|_| circuit.alloc_public_input_array(\"MMCS commitment cap entry\"))\n            .collect();\n        Self {\n            cap_targets,\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        input\n            .roots()\n            .iter()\n            .flat_map(|entry: \u0026[\u003cF as PackedValue\u003e::Value; DIGEST_ELEMS]| {\n                entry.iter().map(|v| EF::from(*v))\n            })\n            .collect()\n    }\n}\n\n/// `HashProofTargets` corresponds to a Merkle tree `Proof` in the form of a vector of hashes with `DIGEST_ELEMS` digest elements.\npub struct HashProofTargets\u003cF, const DIGEST_ELEMS: usize\u003e {\n    pub hash_proof_targets: Vec\u003c[Target; DIGEST_ELEMS]\u003e,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\ntype ValMmcsProof\u003cPW, const DIGEST_ELEMS: usize\u003e = Vec\u003c[\u003cPW as PackedValue\u003e::Value; DIGEST_ELEMS]\u003e;\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, const DIGEST_ELEMS: usize\u003e Recursive\u003cEF\u003e\n    for HashProofTargets\u003cF, DIGEST_ELEMS\u003e\n{\n    type Input = ValMmcsProof\u003cF, DIGEST_ELEMS\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let proof_len = input.len();\n        let mut proof = Vec::with_capacity(proof_len);\n        for _ in 0..proof_len {\n            proof.push(circuit.alloc_public_input_array(\"Merkle proof hash\"));\n        }\n\n        Self {\n            hash_proof_targets: proof,\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        input\n            .iter()\n            .flat_map(|h| h.iter().map(|v| EF::from(*v)))\n            .collect()\n    }\n}\n\n/// In TwoAdicFriPcs, the POW witness is just a base field element.\npub struct Witness\u003cF\u003e {\n    pub witness: Target,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e Recursive\u003cEF\u003e for Witness\u003cF\u003e {\n    type Input = F;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, _input: \u0026Self::Input) -\u003e Self {\n        Self {\n            witness: circuit.alloc_public_input(\"FRI proof-of-work witness\"),\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        vec![EF::from(*input)]\n    }\n}\n\n/// `Recursive` version of a `MerkleTreeMmcs` where the leaf and digest elements are base field values.\npub struct RecValMmcs\u003cF: Field, const DIGEST_ELEMS: usize, H, C\u003e\nwhere\n    H: CryptographicHasher\u003cF, [F; DIGEST_ELEMS]\u003e\n        + CryptographicHasher\u003cF::Packing, [F::Packing; DIGEST_ELEMS]\u003e\n        + Sync,\n{\n    pub hash: H,\n    pub compress: C,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, const DIGEST_ELEMS: usize, H, C\u003e RecursiveMmcs\u003cF, EF\u003e\n    for RecValMmcs\u003cF, DIGEST_ELEMS, H, C\u003e\nwhere\n    H: CryptographicHasher\u003cF, [F; DIGEST_ELEMS]\u003e\n        + CryptographicHasher\u003cF::Packing, [F::Packing; DIGEST_ELEMS]\u003e\n        + Sync,\n    C: PseudoCompressionFunction\u003c[F; DIGEST_ELEMS], 2\u003e\n        + PseudoCompressionFunction\u003c[F::Packing; DIGEST_ELEMS], 2\u003e\n        + Sync,\n    [F; DIGEST_ELEMS]: Serialize + for\u003c'a\u003e Deserialize\u003c'a\u003e,\n{\n    type Input = MerkleTreeMmcs\u003cF::Packing, F::Packing, H, C, DIGEST_ELEMS\u003e;\n\n    type Commitment = MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e;\n\n    type Proof = HashProofTargets\u003cF, DIGEST_ELEMS\u003e;\n}\n\n/// `Recursive` version of an `ExtensionFieldMmcs` where the inner `Mmcs` is a `MerkleTreeMmcs`.\npub struct RecExtensionValMmcs\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    const DIGEST_ELEMS: usize,\n    ValMmcs: RecursiveMmcs\u003cF, EF\u003e,\n\u003e {\n    _phantom: PhantomData\u003cF\u003e,\n    _phantom_ef: PhantomData\u003cEF\u003e,\n    _phantom_val: PhantomData\u003cValMmcs\u003e,\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, const DIGEST_ELEMS: usize, RecValMmcs: RecursiveMmcs\u003cF, EF\u003e\u003e\n    RecursiveExtensionMmcs\u003cF, EF\u003e for RecExtensionValMmcs\u003cF, EF, DIGEST_ELEMS, RecValMmcs\u003e\n{\n    type Input = ExtensionMmcs\u003cF, EF, RecValMmcs::Input\u003e;\n\n    type Commitment = RecValMmcs::Commitment;\n\n    type Proof = RecValMmcs::Proof;\n}\n\npub type InputProofTargets\u003cF, EF, Inner\u003e = Vec\u003cBatchOpeningTargets\u003cF, EF, Inner\u003e\u003e;\n\npub type TwoAdicFriProofTargets\u003cF, EF, RecMmcs, Inner\u003e =\n    FriProofTargets\u003cF, EF, RecMmcs, InputProofTargets\u003cF, EF, Inner\u003e, Target\u003e;\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, Inner: RecursiveMmcs\u003cF, EF\u003e\u003e Recursive\u003cEF\u003e\n    for InputProofTargets\u003cF, EF, Inner\u003e\n{\n    type Input = Vec\u003cBatchOpening\u003cF, Inner::Input\u003e\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let num_batch_openings = input.len();\n        let mut batch_openings = Self::with_capacity(num_batch_openings);\n        for batch_opening in input.iter() {\n            batch_openings.push(BatchOpeningTargets::new(circuit, batch_opening));\n        }\n\n        batch_openings\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        input\n            .iter()\n            .flat_map(|batch_opening| {\n                BatchOpeningTargets::\u003cF, EF, Inner\u003e::get_values(batch_opening)\n            })\n            .collect()\n    }\n}\n\n// Recursive type for the `FriProof` of `TwoAdicFriPcs`.\ntype RecursiveFriProof\u003cSC, RecursiveFriMmcs, RecursiveInputProof\u003e = FriProofTargets\u003c\n    Val\u003cSC\u003e,\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\n    RecursiveFriMmcs,\n    RecursiveInputProof,\n    Witness\u003cVal\u003cSC\u003e\u003e,\n\u003e;\n\n// Implement `RecursivePcs` for `TwoAdicFriPcs`.\nimpl\u003cSC, Dft, Comm, InputMmcs, RecursiveInputMmcs, RecursiveFriMmcs, FriMmcs\u003e\n    RecursivePcs\u003c\n        SC,\n        InputProofTargets\u003cVal\u003cSC\u003e, SC::Challenge, RecursiveInputMmcs\u003e,\n        RecursiveFriProof\u003c\n            SC,\n            RecursiveFriMmcs,\n            InputProofTargets\u003cVal\u003cSC\u003e, SC::Challenge, RecursiveInputMmcs\u003e,\n        \u003e,\n        Comm,\n        TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e,\n    \u003e for TwoAdicFriPcs\u003cVal\u003cSC\u003e, Dft, InputMmcs, FriMmcs\u003e\nwhere\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: TwoAdicField + PrimeField64,\n    InputMmcs: Mmcs\u003cVal\u003cSC\u003e\u003e,\n    FriMmcs: Mmcs\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e + ObservableCommitment,\n    RecursiveInputMmcs: RecursiveMmcs\u003cVal\u003cSC\u003e, SC::Challenge, Input = InputMmcs\u003e,\n    RecursiveFriMmcs: RecursiveExtensionMmcs\u003cVal\u003cSC\u003e, SC::Challenge, Input = FriMmcs\u003e,\n    RecursiveFriMmcs::Commitment: ObservableCommitment,\n    SC::Challenger: GrindingChallenger + CanObserve\u003cFriMmcs::Commitment\u003e,\n{\n    type VerifierParams = FriVerifierParams;\n    type RecursiveProof = RecursiveFriProof\u003c\n        SC,\n        RecursiveFriMmcs,\n        InputProofTargets\u003cVal\u003cSC\u003e, SC::Challenge, RecursiveInputMmcs\u003e,\n    \u003e;\n\n    /// Observes all opened values and derives PCS-specific challenges.\n    fn get_challenges_circuit\u003cconst WIDTH: usize, const RATE: usize\u003e(\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        challenger: \u0026mut CircuitChallenger\u003cWIDTH, RATE\u003e,\n        fri_proof: \u0026RecursiveFriProof\u003c\n            SC,\n            RecursiveFriMmcs,\n            InputProofTargets\u003cVal\u003cSC\u003e, SC::Challenge, RecursiveInputMmcs\u003e,\n        \u003e,\n        _opened_values: \u0026OpenedValuesTargetsWithLookups\u003cSC\u003e,\n        params: \u0026Self::VerifierParams,\n    ) -\u003e Result\u003cVec\u003cTarget\u003e, CircuitBuilderError\u003e\n    where\n        Val\u003cSC\u003e: PrimeField64,\n        SC::Challenge: ExtensionField\u003cVal\u003cSC\u003e\u003e,\n    {\n        // NOTE: Opened values must be observed by the caller BEFORE calling this function.\n        // For batch-STARK, the caller must observe in per-instance order to match native.\n        // For single-STARK, the caller can use opened_values.observe() directly.\n\n        // Sample FRI alpha (for batch opening reduction) - extension field\n        let fri_alpha = challenger.sample_ext(circuit);\n\n        // Sample FRI betas: one per commit phase\n        // For each FRI commitment, observe it and sample beta\n        let mut betas = Vec::with_capacity(fri_proof.commit_phase_commits.len());\n        for (commit, pow) in fri_proof\n            .commit_phase_commits\n            .iter()\n            .zip(fri_proof.commit_pow_witnesses.iter())\n        {\n            let commit_targets = commit.to_observation_targets();\n            challenger.observe_slice(circuit, \u0026commit_targets);\n            // Check commit-phase PoW witness.\n            challenger.check_pow_witness(circuit, params.commit_pow_bits, pow.witness)?;\n            // Sample beta - extension field\n            let beta = challenger.sample_ext(circuit);\n            betas.push(beta);\n        }\n\n        // Observe final polynomial coefficients (extension field values)\n        challenger.observe_ext_slice(circuit, \u0026fri_proof.final_poly);\n\n        // Bind the variable-arity schedule into the transcript before query grinding,\n        // matching the native FRI verifier in Plonky3.\n        for \u0026log_arity in \u0026fri_proof.log_arities {\n            let log_arity_target =\n                circuit.alloc_const(SC::Challenge::from_usize(log_arity), \"FRI log_arity\");\n            challenger.observe(circuit, log_arity_target);\n        }\n\n        // Check query PoW witness.\n        challenger.check_pow_witness(\n            circuit,\n            params.query_pow_bits,\n            fri_proof.pow_witness.witness,\n        )?;\n\n        // Query indices are sampled in-circuit by verify_circuit from the challenger\n        // (which is left in the correct state here) to ensure soundness.\n        let mut challenges = Vec::with_capacity(1 + betas.len());\n        challenges.push(fri_alpha);\n        challenges.extend(betas);\n        Ok(challenges)\n    }\n\n    fn verify_circuit\u003cconst WIDTH: usize, const RATE: usize\u003e(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        challenges: \u0026[Target],\n        challenger: \u0026mut CircuitChallenger\u003cWIDTH, RATE\u003e,\n        commitments_with_opening_points: \u0026ComsWithOpeningsTargets\u003c\n            Comm,\n            TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e,\n        \u003e,\n        opening_proof: \u0026Self::RecursiveProof,\n        params: \u0026Self::VerifierParams,\n    ) -\u003e Result\u003cVec\u003cNonPrimitiveOpId\u003e, VerificationError\u003e {\n        let FriVerifierParams {\n            log_blowup,\n            log_final_poly_len,\n            commit_pow_bits: _,\n            query_pow_bits: _,\n            permutation_config,\n        } = *params;\n        let num_betas = opening_proof.commit_phase_commits.len();\n        let num_queries = opening_proof.query_proofs.len();\n\n        let alpha = challenges[0];\n        let betas = \u0026challenges[1..1 + num_betas];\n\n        let total_log_reduction: usize = opening_proof.log_arities.iter().sum();\n        let log_max_height = total_log_reduction + log_final_poly_len + log_blowup;\n\n        if log_max_height \u003e MAX_QUERY_INDEX_BITS {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"log_max_height {log_max_height} exceeds MAX_QUERY_INDEX_BITS {MAX_QUERY_INDEX_BITS}\"\n            )));\n        }\n\n        let index_bits_per_query: Vec\u003cVec\u003cTarget\u003e\u003e = (0..num_queries)\n            .map(|_| challenger.sample_bits(circuit, log_max_height))\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n        verify_fri_circuit(\n            circuit,\n            opening_proof,\n            alpha,\n            betas,\n            \u0026index_bits_per_query,\n            commitments_with_opening_points,\n            log_blowup,\n            permutation_config,\n        )\n    }\n\n    fn selectors_at_point_circuit(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        domain: \u0026TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e,\n        point: \u0026Target,\n    ) -\u003e RecursiveLagrangeSelectors {\n        // Constants that we will need.\n        let shift_inv =\n            circuit.alloc_const(SC::Challenge::from(domain.shift_inverse()), \"shift_inv\");\n        let one = circuit.alloc_const(SC::Challenge::from(Val::\u003cSC\u003e::ONE), \"1\");\n        let subgroup_gen_inv = circuit.alloc_const(\n            SC::Challenge::from(domain.subgroup_generator().inverse()),\n            \"subgroup_gen_inv\",\n        );\n\n        // Unshifted and z_h\n        let unshifted_point = circuit.alloc_mul(shift_inv, *point, \"unshifted_point\");\n        let us_exp = circuit.exp_power_of_2(unshifted_point, domain.log_size());\n        let z_h = circuit.alloc_sub(us_exp, one, \"z_h\");\n\n        // Denominators\n        let us_minus_one = circuit.alloc_sub(unshifted_point, one, \"us_minus_one\");\n        let us_minus_gen_inv =\n            circuit.alloc_sub(unshifted_point, subgroup_gen_inv, \"us_minus_gen_inv\");\n\n        // Selectors\n        let is_first_row = circuit.alloc_div(z_h, us_minus_one, \"is_first_row\");\n        let is_last_row = circuit.alloc_div(z_h, us_minus_gen_inv, \"is_last_row\");\n        let is_transition = us_minus_gen_inv;\n        let inv_vanishing = circuit.alloc_div(one, z_h, \"inv_vanishing\");\n\n        let row_selectors = RowSelectorsTargets {\n            is_first_row,\n            is_last_row,\n            is_transition,\n        };\n        RecursiveLagrangeSelectors {\n            row_selectors,\n            inv_vanishing,\n        }\n    }\n\n    fn create_disjoint_domain(\n        \u0026self,\n        trace_domain: TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e,\n        degree: usize,\n    ) -\u003e TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e {\n        trace_domain.create_disjoint_domain(degree)\n    }\n\n    fn split_domains(\n        \u0026self,\n        trace_domain: \u0026TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e,\n        degree: usize,\n    ) -\u003e Vec\u003cTwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e\u003e {\n        trace_domain.split_domains(degree)\n    }\n\n    fn log_size(\u0026self, trace_domain: \u0026TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e) -\u003e usize {\n        trace_domain.log_size()\n    }\n\n    fn first_point(\u0026self, trace_domain: \u0026TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e) -\u003e SC::Challenge {\n        trace_domain.first_point().into()\n    }\n}\n","traces":[{"line":56,"address":[4670610,4670479,4669232],"length":1,"stats":{"Line":8}},{"line":57,"address":[2079481,2079560],"length":1,"stats":{"Line":20}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[4670640,4670661,4669358],"length":1,"stats":{"Line":28}},{"line":63,"address":[5474917],"length":1,"stats":{"Line":8}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[2921969,2923198,2923184],"length":1,"stats":{"Line":26}},{"line":69,"address":[2922015],"length":1,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[2080885,2079871,2080864],"length":1,"stats":{"Line":26}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[4153120,4153053],"length":1,"stats":{"Line":17}},{"line":78,"address":[2223724],"length":1,"stats":{"Line":8}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[4670768,4669933],"length":1,"stats":{"Line":17}},{"line":82,"address":[2080942],"length":1,"stats":{"Line":9}},{"line":83,"address":[5692381],"length":1,"stats":{"Line":8}},{"line":84,"address":[2080968,2081056,2081066],"length":1,"stats":{"Line":26}},{"line":85,"address":[5692405],"length":1,"stats":{"Line":8}},{"line":94,"address":[],"length":0,"stats":{"Line":9}},{"line":99,"address":[5473600,5474508,5474480],"length":1,"stats":{"Line":9}},{"line":100,"address":[],"length":0,"stats":{"Line":9}},{"line":101,"address":[2920598],"length":1,"stats":{"Line":9}},{"line":102,"address":[2920606],"length":1,"stats":{"Line":9}},{"line":103,"address":[],"length":0,"stats":{"Line":9}},{"line":104,"address":[],"length":0,"stats":{"Line":8}},{"line":105,"address":[4668227],"length":1,"stats":{"Line":8}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[5474298,5473789,5474402,5473770,5473940,5474113],"length":1,"stats":{"Line":50}},{"line":110,"address":[2079232,2078477,2079267],"length":1,"stats":{"Line":26}},{"line":112,"address":[2078490],"length":1,"stats":{"Line":8}},{"line":113,"address":[5689978],"length":1,"stats":{"Line":8}},{"line":114,"address":[4669075,4668413,4669040],"length":1,"stats":{"Line":24}},{"line":117,"address":[5690083],"length":1,"stats":{"Line":8}},{"line":118,"address":[2222439],"length":1,"stats":{"Line":8}},{"line":119,"address":[2079331,2078778,2079296],"length":1,"stats":{"Line":26}},{"line":121,"address":[5690402,5690273,5690256,5690602],"length":1,"stats":{"Line":18}},{"line":122,"address":[4152176,4152169,4152242,4152309],"length":1,"stats":{"Line":18}},{"line":147,"address":[2078200,2077888,2078194],"length":1,"stats":{"Line":8}},{"line":149,"address":[4140736],"length":1,"stats":{"Line":9}},{"line":150,"address":[4667754],"length":1,"stats":{"Line":10}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[5473573,5473379,5473552],"length":1,"stats":{"Line":28}},{"line":161,"address":[4140304,4140577,4140605],"length":1,"stats":{"Line":9}},{"line":162,"address":[4150841,4150670],"length":1,"stats":{"Line":18}},{"line":165,"address":[4667399],"length":1,"stats":{"Line":9}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[4150799],"length":1,"stats":{"Line":9}},{"line":168,"address":[4667632,4667667,4667506],"length":1,"stats":{"Line":27}},{"line":201,"address":[2074289,2073600,2074295],"length":1,"stats":{"Line":9}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[4130542,4131216,4131274,4131237,4131264],"length":1,"stats":{"Line":45}},{"line":206,"address":[4662846,4662894],"length":1,"stats":{"Line":10}},{"line":207,"address":[5685205,5685112,5685692],"length":1,"stats":{"Line":27}},{"line":208,"address":[],"length":0,"stats":{"Line":17}},{"line":209,"address":[],"length":0,"stats":{"Line":7}},{"line":210,"address":[4131151],"length":1,"stats":{"Line":8}},{"line":212,"address":[5685524],"length":1,"stats":{"Line":8}},{"line":216,"address":[5685824],"length":1,"stats":{"Line":9}},{"line":217,"address":[4663635],"length":1,"stats":{"Line":10}},{"line":218,"address":[2856799],"length":1,"stats":{"Line":9}},{"line":219,"address":[2199047],"length":1,"stats":{"Line":10}},{"line":220,"address":[],"length":0,"stats":{"Line":27}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[4666903,4666909,4666496],"length":1,"stats":{"Line":10}},{"line":240,"address":[4139915],"length":1,"stats":{"Line":9}},{"line":241,"address":[5471948,5471999],"length":1,"stats":{"Line":10}},{"line":242,"address":[4140001,4140029,4139963],"length":1,"stats":{"Line":18}},{"line":243,"address":[5472068,5472125,5472025],"length":1,"stats":{"Line":19}},{"line":244,"address":[],"length":0,"stats":{"Line":9}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[5472109],"length":1,"stats":{"Line":10}},{"line":255,"address":[4665984,4666421,4666415],"length":1,"stats":{"Line":9}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[4666014],"length":1,"stats":{"Line":9}},{"line":259,"address":[5471414],"length":1,"stats":{"Line":9}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[5471436],"length":1,"stats":{"Line":9}},{"line":262,"address":[5688102,5688038],"length":1,"stats":{"Line":18}},{"line":263,"address":[4666328,4666214],"length":1,"stats":{"Line":18}},{"line":264,"address":[4139840,4139748,4139853],"length":1,"stats":{"Line":27}},{"line":266,"address":[4666244],"length":1,"stats":{"Line":9}},{"line":267,"address":[2076857],"length":1,"stats":{"Line":8}},{"line":289,"address":[2860135,2859856,2860129],"length":1,"stats":{"Line":9}},{"line":290,"address":[5466690],"length":1,"stats":{"Line":10}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[5466944,5466981,5466724],"length":1,"stats":{"Line":28}},{"line":296,"address":[2859970],"length":1,"stats":{"Line":10}},{"line":304,"address":[4138704],"length":1,"stats":{"Line":8}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":8}},{"line":307,"address":[4138748],"length":1,"stats":{"Line":8}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[2219328],"length":1,"stats":{"Line":8}},{"line":312,"address":[4149173,4148995,4149113,4149088,4149152],"length":1,"stats":{"Line":44}},{"line":313,"address":[4149010],"length":1,"stats":{"Line":8}},{"line":335,"address":[2858032],"length":1,"stats":{"Line":8}},{"line":336,"address":[5459392],"length":1,"stats":{"Line":9}},{"line":338,"address":[2075763,2075838,2075808],"length":1,"stats":{"Line":27}},{"line":351,"address":[2075520],"length":1,"stats":{"Line":9}},{"line":352,"address":[5686970],"length":1,"stats":{"Line":10}},{"line":353,"address":[5457061,5456967,5457040],"length":1,"stats":{"Line":27}},{"line":361,"address":[5456704],"length":1,"stats":{"Line":10}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[4148403,4148448],"length":1,"stats":{"Line":18}},{"line":366,"address":[4138254,4138288,4138302],"length":1,"stats":{"Line":26}},{"line":385,"address":[5686696,5686702,5686352],"length":1,"stats":{"Line":9}},{"line":386,"address":[2215139],"length":1,"stats":{"Line":10}},{"line":387,"address":[2215165],"length":1,"stats":{"Line":9}},{"line":388,"address":[5456495,5456423],"length":1,"stats":{"Line":17}},{"line":389,"address":[4664206,4664332],"length":1,"stats":{"Line":17}},{"line":398,"address":[4147776],"length":1,"stats":{"Line":8}},{"line":399,"address":[5686176],"length":1,"stats":{"Line":8}},{"line":401,"address":[5686304,5686270,5686240,5686325,5686195],"length":1,"stats":{"Line":41}},{"line":415,"address":[4111120],"length":1,"stats":{"Line":8}},{"line":417,"address":[2073502],"length":1,"stats":{"Line":9}},{"line":422,"address":[4111102,4110896,4111108],"length":1,"stats":{"Line":9}},{"line":423,"address":[4110925,4111089],"length":1,"stats":{"Line":9}},{"line":489,"address":[3851788,3851408,3851782],"length":1,"stats":{"Line":8}},{"line":490,"address":[3851459],"length":1,"stats":{"Line":10}},{"line":491,"address":[1867480],"length":1,"stats":{"Line":8}},{"line":492,"address":[1750946,1750882],"length":1,"stats":{"Line":17}},{"line":493,"address":[3338826,3338890],"length":1,"stats":{"Line":19}},{"line":496,"address":[2214075],"length":1,"stats":{"Line":9}},{"line":499,"address":[1867312],"length":1,"stats":{"Line":9}},{"line":500,"address":[],"length":0,"stats":{"Line":9}},{"line":502,"address":[2213715],"length":1,"stats":{"Line":18}},{"line":503,"address":[2855827],"length":1,"stats":{"Line":8}},{"line":550,"address":[4947840,4945840,4947272],"length":1,"stats":{"Line":8}},{"line":570,"address":[4966826],"length":1,"stats":{"Line":7}},{"line":574,"address":[4966863],"length":1,"stats":{"Line":8}},{"line":575,"address":[2319262,2318996],"length":1,"stats":{"Line":15}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[4946100],"length":1,"stats":{"Line":8}},{"line":578,"address":[4855299],"length":1,"stats":{"Line":7}},{"line":580,"address":[2747598],"length":1,"stats":{"Line":7}},{"line":581,"address":[2748546,2748633],"length":1,"stats":{"Line":15}},{"line":583,"address":[],"length":0,"stats":{"Line":8}},{"line":585,"address":[4856903],"length":1,"stats":{"Line":9}},{"line":586,"address":[4495109],"length":1,"stats":{"Line":9}},{"line":590,"address":[],"length":0,"stats":{"Line":9}},{"line":594,"address":[6543262],"length":1,"stats":{"Line":7}},{"line":595,"address":[2319644,2320292],"length":1,"stats":{"Line":14}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[4856510],"length":1,"stats":{"Line":8}},{"line":601,"address":[4968162,4967606,4967739],"length":1,"stats":{"Line":8}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[6543446],"length":1,"stats":{"Line":9}},{"line":604,"address":[4855850],"length":1,"stats":{"Line":9}},{"line":609,"address":[4946952],"length":1,"stats":{"Line":7}},{"line":610,"address":[4856179],"length":1,"stats":{"Line":8}},{"line":611,"address":[4856230],"length":1,"stats":{"Line":9}},{"line":612,"address":[4494477],"length":1,"stats":{"Line":9}},{"line":615,"address":[4493069,4493075,4491632],"length":1,"stats":{"Line":8}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[4944488],"length":1,"stats":{"Line":7}},{"line":629,"address":[4853723],"length":1,"stats":{"Line":8}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[4965407],"length":1,"stats":{"Line":7}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[4965424],"length":1,"stats":{"Line":8}},{"line":635,"address":[6541373],"length":1,"stats":{"Line":7}},{"line":637,"address":[4944606,4944671],"length":1,"stats":{"Line":8}},{"line":638,"address":[4853925,4854045,4853858],"length":1,"stats":{"Line":15}},{"line":640,"address":[4492088],"length":1,"stats":{"Line":7}},{"line":641,"address":[4944811,4944916,4944855],"length":1,"stats":{"Line":15}},{"line":643,"address":[4492227],"length":1,"stats":{"Line":8}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[6541828,6542205],"length":1,"stats":{"Line":8}},{"line":650,"address":[4944950],"length":1,"stats":{"Line":22}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[4966416],"length":1,"stats":{"Line":7}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[4968768],"length":1,"stats":{"Line":8}},{"line":672,"address":[4857095],"length":1,"stats":{"Line":7}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[4947981],"length":1,"stats":{"Line":7}},{"line":675,"address":[4948064],"length":1,"stats":{"Line":7}},{"line":676,"address":[4495384],"length":1,"stats":{"Line":8}},{"line":681,"address":[2749312],"length":1,"stats":{"Line":7}},{"line":682,"address":[2321173],"length":1,"stats":{"Line":8}},{"line":683,"address":[4948182],"length":1,"stats":{"Line":7}},{"line":686,"address":[2749431],"length":1,"stats":{"Line":7}},{"line":687,"address":[2321297],"length":1,"stats":{"Line":8}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[4857499],"length":1,"stats":{"Line":7}},{"line":692,"address":[2749557],"length":1,"stats":{"Line":8}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[4969327],"length":1,"stats":{"Line":7}},{"line":707,"address":[2318752],"length":1,"stats":{"Line":4}},{"line":712,"address":[2318798],"length":1,"stats":{"Line":4}},{"line":715,"address":[4944224],"length":1,"stats":{"Line":4}},{"line":720,"address":[4491605],"length":1,"stats":{"Line":4}},{"line":723,"address":[4495872],"length":1,"stats":{"Line":8}},{"line":724,"address":[4495897],"length":1,"stats":{"Line":8}},{"line":727,"address":[4965024],"length":1,"stats":{"Line":9}},{"line":728,"address":[2745491],"length":1,"stats":{"Line":9}}],"covered":168,"coverable":209},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","pcs","fri","verifier.rs"],"content":"#![allow(clippy::too_many_arguments)]\n#![allow(clippy::option_if_let_else)]\n\nuse alloc::collections::btree_map::BTreeMap;\nuse alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::iter;\n\nuse hashbrown::HashMap;\nuse p3_circuit::op::Poseidon2Config;\nuse p3_circuit::{CircuitBuilder, NonPrimitiveOpId};\nuse p3_field::coset::TwoAdicMultiplicativeCoset;\nuse p3_field::{BasedVectorSpace, ExtensionField, Field, PrimeField64, TwoAdicField};\nuse p3_matrix::Dimensions;\nuse p3_util::zip_eq::zip_eq;\n\nuse super::{FriProofTargets, InputProofTargets};\nuse crate::Target;\nuse crate::pcs::{verify_batch_circuit, verify_batch_circuit_from_extension_opened};\nuse crate::traits::{ComsWithOpeningsTargets, Recursive, RecursiveExtensionMmcs, RecursiveMmcs};\nuse crate::verifier::{ObservableCommitment, VerificationError};\n\n/// Pack lifted base field targets into packed extension field targets for MMCS verification.\n///\n/// Converts N targets (each representing a lifted base field element `EF([v, 0, 0, 0])`)\n/// into ceil(N / EF::DIMENSION) targets (each representing a packed extension element).\n///\n/// For `BinomialExtensionField\u003cF, D\u003e`, the packing is:\n/// `packed[i] = lifted[i*D] + lifted[i*D+1]*X + lifted[i*D+2]*X^2 + ...`\n/// where `X` is the extension basis element.\nfn pack_lifted_to_ext\u003cF, EF\u003e(builder: \u0026mut CircuitBuilder\u003cEF\u003e, lifted: \u0026[Target]) -\u003e Vec\u003cTarget\u003e\nwhere\n    F: Field,\n    EF: ExtensionField\u003cF\u003e + BasedVectorSpace\u003cF\u003e,\n{\n    if lifted.is_empty() {\n        return Vec::new();\n    }\n\n    let d = EF::DIMENSION;\n\n    // Get the extension basis elements: {1, X, X^2, ..., X^(D-1)}\n    let basis: Vec\u003cEF\u003e = (0..d)\n        .map(|i| {\n            let mut coeffs = vec![F::ZERO; d];\n            coeffs[i] = F::ONE;\n            EF::from_basis_coefficients_slice(\u0026coeffs).expect(\"valid basis element\")\n        })\n        .collect();\n\n    // Lift basis elements to circuit constants once and reuse across all chunks.\n    let basis_consts: Vec\u003cTarget\u003e = basis.iter().map(|b| builder.define_const(*b)).collect();\n\n    // Add a zero constant for padding partial chunks\n    let zero = builder.define_const(EF::ZERO);\n\n    lifted\n        .chunks(d)\n        .map(|chunk| {\n            // packed = chunk[0]*basis[0] + chunk[1]*basis[1] + ... + chunk[D-1]*basis[D-1]\n            // Since basis[0] = 1, start with chunk[0]\n            let mut packed = chunk[0];\n            for j in 1..d {\n                let val = if j \u003c chunk.len() { chunk[j] } else { zero };\n                let term = builder.mul(val, basis_consts[j]);\n                packed = builder.add(packed, term);\n            }\n            packed\n        })\n        .collect()\n}\n\n/// Per-phase configuration for the FRI fold chain.\n#[derive(Clone, Debug)]\npub struct FoldPhaseConfig {\n    pub beta: Target,\n    /// Packed extension field sibling evaluations (arity - 1 values).\n    pub siblings: Vec\u003cTarget\u003e,\n    pub roll_in: Option\u003cTarget\u003e,\n}\n\n/// Optimized one-hot computation for 2 bits.\nfn one_hot_from_two_bits\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    b0: Target,\n    b1: Target,\n) -\u003e [Target; 4] {\n    let one = builder.define_const(EF::ONE);\n    let nb0 = builder.sub(one, b0);\n    let nb1 = builder.sub(one, b1);\n\n    let h0 = builder.mul(nb0, nb1); // 00\n    let h1 = builder.mul(b0, nb1); // 01\n    let h2 = builder.mul(nb0, b1); // 10\n    let h3 = builder.mul(b0, b1); // 11\n\n    [h0, h1, h2, h3]\n}\n\n/// Optimized one-hot computation for 3 bits.\nfn one_hot_from_three_bits\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    b0: Target,\n    b1: Target,\n    b2: Target,\n) -\u003e [Target; 8] {\n    let one = builder.define_const(EF::ONE);\n    let nb0 = builder.sub(one, b0);\n    let nb1 = builder.sub(one, b1);\n    let nb2 = builder.sub(one, b2);\n\n    // Shared products for (b1, b2).\n    let t00 = builder.mul(nb1, nb2); // b1=0, b2=0\n    let t01 = builder.mul(nb1, b2); // b1=0, b2=1\n    let t10 = builder.mul(b1, nb2); // b1=1, b2=0\n    let t11 = builder.mul(b1, b2); // b1=1, b2=1\n\n    // Index j = b0 + 2*b1 + 4*b2 (little-endian).\n    let h0 = builder.mul(nb0, t00); // 0,0,0 -\u003e j=0\n    let h1 = builder.mul(b0, t00); // 1,0,0 -\u003e j=1\n    let h2 = builder.mul(nb0, t10); // 0,1,0 -\u003e j=2\n    let h3 = builder.mul(b0, t10); // 1,1,0 -\u003e j=3\n    let h4 = builder.mul(nb0, t01); // 0,0,1 -\u003e j=4\n    let h5 = builder.mul(b0, t01); // 1,0,1 -\u003e j=5\n    let h6 = builder.mul(nb0, t11); // 0,1,1 -\u003e j=6\n    let h7 = builder.mul(b0, t11); // 1,1,1 -\u003e j=7\n\n    [h0, h1, h2, h3, h4, h5, h6, h7]\n}\n\n/// Optimized one-hot computation for 4 bits, using two 2-bit one-hots.\nfn one_hot_from_four_bits\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    bits: \u0026[Target],\n) -\u003e Vec\u003cTarget\u003e {\n    debug_assert_eq!(bits.len(), 4);\n    let low = one_hot_from_two_bits(builder, bits[0], bits[1]);\n    let high = one_hot_from_two_bits(builder, bits[2], bits[3]);\n\n    let mut result = Vec::with_capacity(16);\n    for j in 0..16 {\n        let low_idx = j \u0026 3;\n        let high_idx = j \u003e\u003e 2;\n        let val = builder.mul(low[low_idx], high[high_idx]);\n        result.push(val);\n    }\n    result\n}\n\n/// Compute a one-hot encoding from `log_arity` index bits.\n/// Returns a vector of `2^log_arity` targets where `result[j] = 1` iff j matches the\n/// integer value of the input bits (little-endian).\nfn one_hot_from_bits\u003cEF: Field\u003e(builder: \u0026mut CircuitBuilder\u003cEF\u003e, bits: \u0026[Target]) -\u003e Vec\u003cTarget\u003e {\n    let log_arity = bits.len();\n    let arity = 1usize \u003c\u003c log_arity;\n\n    match log_arity {\n        0 =\u003e {\n            // Degenerate case: arity 1, always index 0.\n            vec![builder.define_const(EF::ONE)]\n        }\n        1 =\u003e {\n            // One bit: [!b0, b0]\n            let one = builder.define_const(EF::ONE);\n            let b0 = bits[0];\n            let nb0 = builder.sub(one, b0);\n            vec![nb0, b0]\n        }\n        2 =\u003e {\n            let [h0, h1, h2, h3] = one_hot_from_two_bits(builder, bits[0], bits[1]);\n            vec![h0, h1, h2, h3]\n        }\n        3 =\u003e {\n            let [h0, h1, h2, h3, h4, h5, h6, h7] =\n                one_hot_from_three_bits(builder, bits[0], bits[1], bits[2]);\n            vec![h0, h1, h2, h3, h4, h5, h6, h7]\n        }\n        4 =\u003e one_hot_from_four_bits(builder, bits),\n        _ =\u003e {\n            let one = builder.define_const(EF::ONE);\n            // Precompute negations of bits once to avoid rebuilding `1 - bit` inside the inner loop for every index j.\n            let not_bits: Vec\u003cTarget\u003e = bits.iter().map(|\u0026bit| builder.sub(one, bit)).collect();\n\n            let mut one_hot = Vec::with_capacity(arity);\n            for j in 0..arity {\n                let mut product = one;\n                for (k, \u0026bit) in bits.iter().enumerate() {\n                    if (j \u003e\u003e k) \u0026 1 == 1 {\n                        product = builder.mul(product, bit);\n                    } else {\n                        product = builder.mul(product, not_bits[k]);\n                    }\n                }\n                one_hot.push(product);\n            }\n            one_hot\n        }\n    }\n}\n\n/// Reconstruct the full evaluation row from `folded` + `siblings` using the index bits.\n///\n/// `index_in_group_bits` are the `log_arity` lowest bits of the current start_index.\n/// The native verifier does:\n///   evals[index_in_group] = folded; evals[j] = siblings[...] for j != index_in_group\n///\n/// This circuit version uses a one-hot encoding to place values correctly.\nfn reconstruct_evals\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    folded: Target,\n    siblings: \u0026[Target],\n    index_in_group_bits: \u0026[Target],\n) -\u003e Vec\u003cTarget\u003e {\n    builder.push_scope(\"fri_reconstruct_evals\");\n    let log_arity = index_in_group_bits.len();\n    let arity = 1usize \u003c\u003c log_arity;\n    debug_assert_eq!(siblings.len(), arity - 1);\n\n    let one_hot = one_hot_from_bits(builder, index_in_group_bits);\n\n    // Compute cumulative sum: cum[j] = sum(one_hot[0..=j]) ∈ {0, 1}\n    let mut cum = Vec::with_capacity(arity);\n    cum.push(one_hot[0]);\n    for j in 1..arity {\n        cum.push(builder.add(cum[j - 1], one_hot[j]));\n    }\n\n    // For each position j:\n    //   if one_hot[j] = 1: evals[j] = folded\n    //   if one_hot[j] = 0 and cum[j] = 0: evals[j] = siblings[j]     (j \u003c index_in_group)\n    //   if one_hot[j] = 0 and cum[j] = 1: evals[j] = siblings[j-1]   (j \u003e index_in_group)\n    let mut evals = Vec::with_capacity(arity);\n    for j in 0..arity {\n        let left_idx = if j \u003e 0 { j - 1 } else { 0 };\n        let right_idx = if j \u003c arity - 1 { j } else { arity - 2 };\n        let actual_sibling = builder.select(cum[j], siblings[left_idx], siblings[right_idx]);\n        let eval_j = builder.select(one_hot[j], folded, actual_sibling);\n        evals.push(eval_j);\n    }\n\n    builder.pop_scope();\n    evals\n}\n\n/// Compute the subgroup evaluation points for a single FRI fold phase.\n///\n/// Returns `(xs, subgroup_start)` where:\n/// - `xs[i] = subgroup_start * omega^{br(i)}` are the `arity` evaluation points\n///   in bit-reversed order,\n/// - `omega = two_adic_generator(log_arity)`,\n/// - `subgroup_start = two_adic_generator(log_folded_height + log_arity)^{rev(parent_index)}`.\n///\n/// When `precomputed_subgroup_start` is `Some`, the select-mul chain for\n/// `subgroup_start` is skipped and the provided value is used directly.\nfn compute_subgroup_points\u003cF, EF\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    index_bits: \u0026[Target],\n    bits_consumed: usize,\n    log_arity: usize,\n    log_folded_height: usize,\n    precomputed_subgroup_start: Option\u003cTarget\u003e,\n) -\u003e (Vec\u003cTarget\u003e, Target)\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n{\n    builder.push_scope(\"fri_compute_subgroup_points\");\n\n    let arity = 1usize \u003c\u003c log_arity;\n\n    let subgroup_start = if let Some(ss) = precomputed_subgroup_start {\n        ss\n    } else {\n        // Parent index bits start after index_in_group bits\n        let parent_offset = bits_consumed + log_arity;\n\n        // Compute subgroup_start = g_big^{reverse_bits_len(parent_index, log_folded_height)}\n        let g_big = F::two_adic_generator(log_folded_height + log_arity);\n        let one = builder.define_const(EF::ONE);\n\n        let g_big_pows: Vec\u003cTarget\u003e = if log_folded_height \u003e 0 {\n            iter::successors(Some(g_big), |\u0026prev| Some(prev.square()))\n                .take(log_folded_height)\n                .map(|p| builder.define_const(EF::from(p)))\n                .collect()\n        } else {\n            Vec::new()\n        };\n\n        let mut ss = one;\n        if log_folded_height \u003e 0 {\n            for j in 0..log_folded_height {\n                let bit = index_bits[parent_offset + log_folded_height - 1 - j];\n                let multiplier = builder.select(bit, g_big_pows[j], one);\n                ss = builder.mul(ss, multiplier);\n            }\n        }\n        ss\n    };\n\n    // Compute xs[i] = subgroup_start * omega^{br(i)}\n    let omega = F::two_adic_generator(log_arity);\n    let omega_br_consts: Vec\u003cTarget\u003e = (0..arity)\n        .map(|i| {\n            let br_i = p3_util::reverse_bits_len(i, log_arity);\n            let omega_br = omega.exp_u64(br_i as u64);\n            builder.define_const(EF::from(omega_br))\n        })\n        .collect();\n\n    let mut xs = Vec::with_capacity(arity);\n    for \u0026omega_br_const in omega_br_consts.iter() {\n        let xi = builder.mul(subgroup_start, omega_br_const);\n        xs.push(xi);\n    }\n\n    builder.pop_scope();\n    (xs, subgroup_start)\n}\n\n/// Precompute `subgroup_start` for every FRI phase within a single query.\n///\n/// All phases compute `g_i^{rev(parent_index_i)}` where\n/// `g_i = two_adic_generator(log_current_height_i)`. Because the reversed parent\n/// bits for phase `i` are a prefix of phase 0's bits, and\n/// `g_i = g_0^{2^{cumulative_bits_i}}`, we derive later phases from the\n/// intermediate of phase 0's chain:\n/// `subgroup_start_i = (g_0^{N_i})^{2^{cumulative_bits_i}}`.\nfn precompute_subgroup_starts\u003cF, EF\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    index_bits: \u0026[Target],\n    log_max_height: usize,\n    log_arities: \u0026[usize],\n    cumulative_bits: \u0026[usize],\n) -\u003e Vec\u003cTarget\u003e\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n{\n    let num_phases = log_arities.len();\n    let one = builder.define_const(EF::ONE);\n\n    // log_folded_height[i] = log_max_height - cumulative_bits[i+1]\n    let log_folded_heights: Vec\u003cusize\u003e = (0..num_phases)\n        .map(|i| log_max_height - cumulative_bits[i + 1])\n        .collect();\n\n    let max_chain_len = log_folded_heights[0];\n\n    if max_chain_len == 0 {\n        builder.pop_scope();\n        return vec![one; num_phases];\n    }\n\n    let g_0 = F::two_adic_generator(log_max_height);\n    let powers_of_g: Vec\u003c_\u003e = iter::successors(Some(g_0), |\u0026prev| Some(prev.square()))\n        .take(max_chain_len)\n        .map(|p| builder.define_const(EF::from(p)))\n        .collect();\n\n    let parent_offset_0 = cumulative_bits[1]; // = log_arities[0]\n\n    let mut capture_at: BTreeMap\u003cusize, Vec\u003cusize\u003e\u003e = BTreeMap::new();\n    for (i, \u0026lf) in log_folded_heights\n        .iter()\n        .enumerate()\n        .take(num_phases)\n        .skip(1)\n    {\n        if lf \u003e 0 {\n            capture_at.entry(lf).or_default().push(i);\n        }\n    }\n\n    let mut g_pow = one;\n    let mut result = vec![one; num_phases];\n\n    for j in 0..max_chain_len {\n        let bit = index_bits[parent_offset_0 + max_chain_len - 1 - j];\n        let multiplier = builder.select(bit, powers_of_g[j], one);\n        g_pow = builder.mul(g_pow, multiplier);\n\n        let bits_done = j + 1;\n        if let Some(phase_indices) = capture_at.get(\u0026bits_done) {\n            for \u0026phase_i in phase_indices {\n                result[phase_i] = builder.exp_power_of_2(g_pow, cumulative_bits[phase_i]);\n            }\n        }\n    }\n\n    // Phase 0: full chain, cumulative_bits[0] = 0, no squaring.\n    result[0] = g_pow;\n\n    result\n}\n\n/// Precompute and cache powers `beta^{2^k}` for all fold phases.\nfn precompute_beta_powers_per_phase\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    betas: \u0026[Target],\n    log_arities: \u0026[usize],\n) -\u003e Vec\u003cTarget\u003e {\n    builder.push_scope(\"fri_precompute_betas\");\n\n    debug_assert_eq!(betas.len(), log_arities.len());\n    let result = betas\n        .iter()\n        .zip(log_arities.iter())\n        .map(|(\u0026beta, \u0026log_arity)| builder.exp_power_of_2(beta, log_arity))\n        .collect();\n\n    builder.pop_scope();\n    result\n}\n\n/// Single arity-2 fold at a point: given (e0, e1) and evaluation point beta,\n/// returns the folded value using (e0 + e1)/2 + (e1 - e0)*beta/(2*x0).\nfn arity2_fold_at_point\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    e0: Target,\n    e1: Target,\n    beta: Target,\n    x0: Target,\n) -\u003e Target {\n    let neg_half = builder.define_const(EF::NEG_ONE * EF::ONE.halve());\n    let inv = builder.div(neg_half, x0);\n    let e1_minus_e0 = builder.sub(e1, e0);\n    let beta_minus_x0 = builder.sub(beta, x0);\n    let t = builder.mul(beta_minus_x0, e1_minus_e0);\n    let t_inv = builder.mul(t, inv);\n    builder.add(e0, t_inv)\n}\n\n/// Perform a single FRI fold phase with arbitrary arity.\n///\n/// For log_arity \u003e 1 we use k sequential arity-2 folds (beta, beta^2, ...)\n/// instead of one Lagrange interpolation, reducing batch inversions to one per step.\n///\n/// When `precomputed_evals` is `Some`, those evals are reused instead of\n/// rebuilding them via `reconstruct_evals`.\nfn fold_one_phase\u003cF, EF\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    folded: Target,\n    siblings: \u0026[Target],\n    beta: Target,\n    index_bits: \u0026[Target],\n    bits_consumed: usize,\n    log_arity: usize,\n    log_current_height: usize,\n    roll_in: Option\u003cTarget\u003e,\n    precomputed_beta_pow: Option\u003cTarget\u003e,\n    precomputed_evals: Option\u003c\u0026[Target]\u003e,\n    precomputed_subgroup_start: Option\u003cTarget\u003e,\n) -\u003e Target\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n{\n    builder.push_scope(\"fri_fold_one_phase\");\n\n    let log_folded_height = log_current_height - log_arity;\n    let index_in_group_bits = \u0026index_bits[bits_consumed..bits_consumed + log_arity];\n\n    // For arity 2, use the optimized formula\n    if log_arity == 1 {\n        let sibling = siblings[0];\n        let one = builder.define_const(EF::ONE);\n        let neg_half = builder.define_const(EF::NEG_ONE * EF::ONE.halve());\n        let sibling_is_right = builder.sub(one, index_bits[bits_consumed]);\n\n        let e0 = builder.select(sibling_is_right, folded, sibling);\n        let x0 = precomputed_subgroup_start.unwrap_or_else(|| {\n            compute_x0_from_index_bits_general::\u003cF, EF\u003e(\n                builder,\n                index_bits,\n                bits_consumed,\n                log_folded_height,\n            )\n        });\n        let inv = builder.div(neg_half, x0);\n\n        let d = builder.sub(sibling, folded);\n        let two_b = builder.add(sibling_is_right, sibling_is_right);\n        let two_b_m1 = builder.sub(two_b, one);\n        let e1_minus_e0 = builder.mul(two_b_m1, d);\n\n        let beta_minus_x0 = builder.sub(beta, x0);\n        let t = builder.mul(beta_minus_x0, e1_minus_e0);\n        let t_inv = builder.mul(t, inv);\n        let mut new_folded = builder.add(e0, t_inv);\n\n        if let Some(ro) = roll_in {\n            let beta_sq = precomputed_beta_pow.unwrap_or_else(|| builder.mul(beta, beta));\n            let add_term = builder.mul(beta_sq, ro);\n            new_folded = builder.add(new_folded, add_term);\n        }\n        builder.pop_scope();\n        return new_folded;\n    }\n\n    // General path: k sequential arity-2 folds (beta, beta^2, ...) instead of\n    // one Lagrange interpolation, matching the native optimization to reduce inversions.\n    let owned_evals;\n    let evals: \u0026[Target] = match precomputed_evals {\n        Some(e) =\u003e e,\n        None =\u003e {\n            owned_evals = reconstruct_evals(builder, folded, siblings, index_in_group_bits);\n            \u0026owned_evals\n        }\n    };\n\n    let (xs, subgroup_start) = compute_subgroup_points::\u003cF, EF\u003e(\n        builder,\n        index_bits,\n        bits_consumed,\n        log_arity,\n        log_folded_height,\n        precomputed_subgroup_start,\n    );\n\n    let mut subgroup_start_powers: Vec\u003cTarget\u003e = vec![subgroup_start];\n    for _ in 1..log_arity {\n        let prev = subgroup_start_powers.last().copied().unwrap();\n        subgroup_start_powers.push(builder.mul(prev, prev));\n    }\n\n    let omega = F::two_adic_generator(log_arity);\n    let mut data: Vec\u003cTarget\u003e = evals.to_vec();\n    let mut current_beta = beta;\n\n    for (step, ss) in subgroup_start_powers\n        .into_iter()\n        .enumerate()\n        .take(log_arity)\n    {\n        let num_pairs = data.len() / 2;\n        if step == 0 {\n            for j in 0..num_pairs {\n                data[j] = arity2_fold_at_point::\u003cEF\u003e(\n                    builder,\n                    data[2 * j],\n                    data[2 * j + 1],\n                    current_beta,\n                    xs[2 * j],\n                );\n            }\n        } else {\n            let log_domain = log_arity - step;\n            let omega_s = omega.exp_u64(1 \u003c\u003c step);\n            let omega_s_br: Vec\u003cTarget\u003e = (0..num_pairs)\n                .map(|j| {\n                    let br_2j = p3_util::reverse_bits_len(2 * j, log_domain);\n                    let c = omega_s.exp_u64(br_2j as u64);\n                    builder.define_const(EF::from(c))\n                })\n                .collect();\n            for j in 0..num_pairs {\n                let x0 = builder.mul(ss, omega_s_br[j]);\n                data[j] = arity2_fold_at_point::\u003cEF\u003e(\n                    builder,\n                    data[2 * j],\n                    data[2 * j + 1],\n                    current_beta,\n                    x0,\n                );\n            }\n        }\n        data.truncate(num_pairs);\n        if step \u003c log_arity - 1 {\n            current_beta = builder.mul(current_beta, current_beta);\n        }\n    }\n\n    let mut new_folded = data[0];\n\n    // Roll-in: folded += beta^{2^log_arity} * roll_in\n    if let Some(ro) = roll_in {\n        let beta_pow =\n            precomputed_beta_pow.unwrap_or_else(|| builder.exp_power_of_2(beta, log_arity));\n        let add_term = builder.mul(beta_pow, ro);\n        new_folded = builder.add(new_folded, add_term);\n    }\n\n    builder.pop_scope();\n    new_folded\n}\n\n/// Compute x0 for arity-2 folding from index bits (generalized for variable bits_consumed).\n///\n/// x0 = two_adic_generator(log_folded_height + 1)^{reverse_bits_len(parent_index, log_folded_height)}\nfn compute_x0_from_index_bits_general\u003cF, EF\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    index_bits: \u0026[Target],\n    bits_consumed: usize,\n    log_folded_height: usize,\n) -\u003e Target\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n{\n    let g = F::two_adic_generator(log_folded_height + 1);\n    let pows: Vec\u003cEF\u003e = iter::successors(Some(g), |\u0026prev| Some(prev.square()))\n        .take(log_folded_height)\n        .map(EF::from)\n        .collect();\n\n    // Pre-lift all powers to circuit constants once\n    let pow_consts: Vec\u003cTarget\u003e = pows.iter().map(|p| builder.define_const(*p)).collect();\n\n    let one = builder.define_const(EF::ONE);\n    let mut res = one;\n\n    let parent_offset = bits_consumed + 1;\n    let k = log_folded_height;\n\n    for j in 0..k {\n        let bit = index_bits[parent_offset + k - 1 - j];\n        let diff = builder.sub(pow_consts[j], one);\n        let diff_bit = builder.mul(diff, bit);\n        let gate = builder.add(one, diff_bit);\n        res = builder.mul(res, gate);\n    }\n\n    res\n}\n\n/// Perform the full FRI fold chain with variable arity per phase.\nfn fold_chain_circuit\u003cF, EF\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    initial_folded_eval: Target,\n    index_bits: \u0026[Target],\n    phases: \u0026[FoldPhaseConfig],\n    log_arities: \u0026[usize],\n    cumulative_bits: \u0026[usize],\n    beta_pows_per_phase: \u0026[Target],\n) -\u003e Target\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n{\n    builder.push_scope(\"fold_chain_circuit\");\n\n    let log_max_height = index_bits.len();\n\n    let subgroup_starts = precompute_subgroup_starts::\u003cF, EF\u003e(\n        builder,\n        index_bits,\n        log_max_height,\n        log_arities,\n        cumulative_bits,\n    );\n\n    let mut folded = initial_folded_eval;\n    let mut bits_consumed = 0usize;\n    let mut log_current_height = log_max_height;\n\n    for (i, phase) in phases.iter().enumerate() {\n        let log_arity = log_arities[i];\n        folded = fold_one_phase::\u003cF, EF\u003e(\n            builder,\n            folded,\n            \u0026phase.siblings,\n            phase.beta,\n            index_bits,\n            bits_consumed,\n            log_arity,\n            log_current_height,\n            phase.roll_in,\n            Some(beta_pows_per_phase[i]),\n            None,\n            Some(subgroup_starts[i]),\n        );\n        bits_consumed += log_arity;\n        log_current_height -= log_arity;\n    }\n\n    builder.pop_scope();\n    folded\n}\n\n/// Evaluate a polynomial at a point `x` using Horner's method.\n/// Given coefficients [c0, c1, c2, ...], compute `p(x) = c0 + x*(c1 + x*(c2 + ...))`.\nfn evaluate_polynomial\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    coefficients: \u0026[Target],\n    point: Target,\n) -\u003e Target {\n    builder.push_scope(\"evaluate_polynomial\");\n\n    assert!(\n        !coefficients.is_empty(),\n        \"we should have at least a constant polynomial\"\n    );\n    if coefficients.len() == 1 {\n        return coefficients[0];\n    }\n\n    let mut result = coefficients[coefficients.len() - 1];\n    for \u0026coeff in coefficients.iter().rev().skip(1) {\n        result = builder.mul(result, point);\n        result = builder.add(result, coeff);\n    }\n\n    builder.pop_scope(); // close `evaluate_polynomial` scope\n    result\n}\n\n/// Precompute powers `g^{2^j}` (as circuit constants) for a two-adic generator of the\n/// given height. The result can be shared across queries.\nfn precompute_two_adic_powers\u003cF, EF\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    log_height: usize,\n) -\u003e Vec\u003cTarget\u003e\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n{\n    builder.push_scope(\"fri_precompute_two_adic_powers\");\n\n    let g = F::two_adic_generator(log_height);\n    let result = iter::successors(Some(g), |\u0026prev| Some(prev.square()))\n        .take(log_height)\n        .map(|p| builder.define_const(EF::from(p)))\n        .collect();\n\n    builder.pop_scope();\n    result\n}\n\n/// Compute the final query point after all FRI folding rounds.\n///\n/// After consuming `total_bits_consumed` bits through all fold phases, the remaining\n/// bits form the domain index for the final polynomial evaluation.\nfn compute_final_query_point\u003cF, EF\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    index_bits: \u0026[Target],\n    log_max_height: usize,\n    total_bits_consumed: usize,\n    powers_of_g: \u0026[Target],\n) -\u003e Target\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n{\n    builder.push_scope(\"compute_final_query_point\");\n\n    let domain_index_bits: Vec\u003cTarget\u003e = index_bits[total_bits_consumed..log_max_height].to_vec();\n\n    // Pad bits and reverse\n    let mut reversed_bits = vec![builder.define_const(EF::ZERO); total_bits_consumed];\n    reversed_bits.extend(domain_index_bits.iter().rev().copied());\n\n    let one = builder.define_const(EF::ONE);\n    let mut result = one;\n    for (\u0026bit, \u0026power) in reversed_bits.iter().zip(powers_of_g.iter()) {\n        let multiplier = builder.select(bit, power, one);\n        result = builder.mul(result, multiplier);\n    }\n\n    builder.pop_scope();\n    result\n}\n\n/// Precompute evaluation points for all unique heights.\n///\n/// Runs a single select-mul chain for the tallest height's reversed index bits and derives\n/// smaller heights via `exp_power_of_2` on captured intermediates.\nfn precompute_evaluation_points\u003cF, EF\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    unique_heights_desc: \u0026[usize],\n    index_bits: \u0026[Target],\n    log_global_max_height: usize,\n) -\u003e BTreeMap\u003cusize, Target\u003e\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n{\n    builder.push_scope(\"precompute_evaluation_points\");\n\n    debug_assert!(\n        !unique_heights_desc.is_empty(),\n        \"must have at least one height\"\n    );\n    debug_assert!(\n        unique_heights_desc.windows(2).all(|w| w[0] \u003e w[1]),\n        \"heights must be sorted in strictly descending order\"\n    );\n\n    let h_max = unique_heights_desc[0];\n    let bits_reduced = log_global_max_height - h_max;\n    let rev_bits: Vec\u003cTarget\u003e = index_bits[bits_reduced..bits_reduced + h_max]\n        .iter()\n        .rev()\n        .copied()\n        .collect();\n\n    let g = F::two_adic_generator(h_max);\n    let powers_of_g: Vec\u003c_\u003e = iter::successors(Some(g), |\u0026prev| Some(prev.square()))\n        .take(h_max)\n        .map(|p| builder.define_const(EF::from(p)))\n        .collect();\n\n    let capture_set: BTreeMap\u003cusize, ()\u003e =\n        unique_heights_desc[1..].iter().map(|\u0026h| (h, ())).collect();\n\n    let one = builder.define_const(EF::ONE);\n    let generator = builder.alloc_const(EF::from(F::GENERATOR), \"coset_generator\");\n    let mut g_pow = one;\n    let mut result = BTreeMap::new();\n\n    for i in 0..h_max {\n        let multiplier = builder.select(rev_bits[i], powers_of_g[i], one);\n        g_pow = builder.mul(g_pow, multiplier);\n\n        let bits_done = i + 1;\n        if capture_set.contains_key(\u0026bits_done) {\n            let derived = builder.exp_power_of_2(g_pow, h_max - bits_done);\n            let x = builder.alloc_mul(generator, derived, \"eval_point\");\n            result.insert(bits_done, x);\n        }\n    }\n\n    let x_max = builder.alloc_mul(generator, g_pow, \"eval_point\");\n    result.insert(h_max, x_max);\n\n    builder.pop_scope(); // close `precompute_evaluation_points` scope\n    result\n}\n\n/// Compute reduced opening for a single matrix in circuit form (EF-field).\n///\n/// Uses Horner's method to evaluate the polynomial in alpha without an explicit\n/// alpha-power chain, saving one multiplication per column.\nfn compute_single_reduced_opening\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    opened_values: \u0026[Target], // Values at evaluation point x\n    point_values: \u0026[Target],  // Values at challenge point z\n    alpha_pow: Target,        // Current alpha power (for this height)\n    alpha: Target,            // Alpha challenge\n    alpha_powers_set: \u0026mut HashMap\u003cusize, Target\u003e,\n    inv_z_minus_x: Target, // 1 / (z - x), shared across matrices at same (height, z)\n) -\u003e (Target, Target) // (new_alpha_pow, reduced_opening_contrib)\n{\n    builder.push_scope(\"compute_single_reduced_opening\");\n\n    let n = opened_values.len();\n\n    if n == 0 {\n        let zero = builder.define_const(EF::ZERO);\n        builder.pop_scope();\n        return (alpha_pow, zero);\n    }\n\n    // Compute all diffs: diff[i] = p_at_z[i] - p_at_x[i]\n    let diffs: Vec\u003cTarget\u003e = opened_values\n        .iter()\n        .zip(point_values.iter())\n        .map(|(\u0026p_at_x, \u0026p_at_z)| builder.sub(p_at_z, p_at_x))\n        .collect();\n\n    // Horner's method: evaluate sum_{i=0}^{n-1} alpha^i * diff[i] as\n    //   inner = diff[n-1]\n    //   inner = inner * alpha + diff[n-2]\n    //   ...\n    //   inner = inner * alpha + diff[0]\n    let mut inner = diffs[n - 1];\n    for i in (0..n - 1).rev() {\n        let prod = builder.mul(inner, alpha);\n        inner = builder.add(prod, diffs[i]);\n    }\n\n    // reduced_opening = alpha_pow * inner * (1 / (z - x))\n    let numerator = builder.mul(alpha_pow, inner);\n    let reduced_opening = builder.mul(numerator, inv_z_minus_x);\n\n    // Advance alpha_pow by alpha^n using square-and-multiply\n    let alpha_n = if let Some(alpha_n) = alpha_powers_set.get(\u0026n) {\n        *alpha_n\n    } else {\n        let alpha_n = circuit_exp_by_constant(builder, alpha, n);\n        alpha_powers_set.insert(n, alpha_n);\n        alpha_n\n    };\n    let new_alpha_pow = builder.mul(alpha_pow, alpha_n);\n\n    builder.pop_scope();\n    (new_alpha_pow, reduced_opening)\n}\n\n/// Computes `base^n` in-circuit using square-and-multiply.\n///\n/// Cost: `floor(log2(n)) + popcount(n) - 1` multiplications.\nfn circuit_exp_by_constant\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    base: Target,\n    n: usize,\n) -\u003e Target {\n    debug_assert!(n \u003e 0);\n    if n == 1 {\n        return base;\n    }\n    let num_bits = usize::BITS - n.leading_zeros();\n    // Start from the MSB (already implicit as `base`), process remaining bits top-down.\n    let mut result = base;\n    for i in (0..num_bits - 1).rev() {\n        result = builder.mul(result, result);\n        if (n \u003e\u003e i) \u0026 1 == 1 {\n            result = builder.mul(result, base);\n        }\n    }\n    result\n}\n\n/// Compute reduced openings grouped **by height** with **per-height alpha powers**,\n/// Returns a vector of (log_height, ro) sorted by descending height, plus the MMCS op IDs.\n///\n/// Reference (Plonky3): `p3_fri::verifier::open_input`\n#[allow(clippy::type_complexity)]\nfn open_input\u003cF, EF, Comm\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    log_global_max_height: usize,\n    index_bits: \u0026[Target],\n    alpha: Target,\n    log_blowup: usize,\n    commitments_with_opening_points: \u0026ComsWithOpeningsTargets\u003cComm, TwoAdicMultiplicativeCoset\u003cF\u003e\u003e,\n    batch_opened_values: \u0026[Vec\u003cVec\u003cTarget\u003e\u003e], // Per batch -\u003e per matrix -\u003e per column\n    permutation_config: Option\u003cPoseidon2Config\u003e,\n    pre_packed_input_caps: Option\u003c\u0026[Vec\u003cVec\u003cTarget\u003e\u003e]\u003e,\n) -\u003e Result\u003c(Vec\u003c(usize, Target)\u003e, Vec\u003cNonPrimitiveOpId\u003e), VerificationError\u003e\nwhere\n    F: Field + TwoAdicField + PrimeField64,\n    EF: ExtensionField\u003cF\u003e,\n    Comm: ObservableCommitment,\n{\n    builder.push_scope(\"open_input\");\n\n    for \u0026b in index_bits {\n        builder.assert_bool(b);\n    }\n    debug_assert_eq!(\n        index_bits.len(),\n        log_global_max_height,\n        \"index_bits.len() must equal log_global_max_height\"\n    );\n\n    // Collect unique heights across all matrices and precompute evaluation points.\n    let unique_heights_desc: Vec\u003cusize\u003e = {\n        let mut heights: Vec\u003cusize\u003e = commitments_with_opening_points\n            .iter()\n            .flat_map(|(_, mats)| {\n                mats.iter()\n                    .map(|(domain, _)| domain.log_size() + log_blowup)\n            })\n            .collect();\n        heights.sort_unstable();\n        heights.dedup();\n        heights.reverse();\n        heights\n    };\n\n    let eval_points = if unique_heights_desc.is_empty() {\n        BTreeMap::new()\n    } else {\n        precompute_evaluation_points::\u003cF, EF\u003e(\n            builder,\n            \u0026unique_heights_desc,\n            index_bits,\n            log_global_max_height,\n        )\n    };\n\n    // height -\u003e (alpha_pow_for_this_height, ro_sum_for_this_height)\n    let mut reduced_openings = BTreeMap::\u003cusize, (Target, Target)\u003e::new();\n    let mut mmcs_op_ids = Vec::new();\n\n    // Process each batch\n    for (batch_idx, ((batch_commit, mats), batch_openings)) in zip_eq(\n        commitments_with_opening_points.iter(),\n        batch_opened_values.iter(),\n        VerificationError::InvalidProofShape(\n            \"Opened values and commitments count must match\".to_string(),\n        ),\n    )?\n    .enumerate()\n    {\n        // Recursive MMCS verification for this batch\n        if let Some(perm_config) = permutation_config {\n            // Use pre-packed cap if available, otherwise pack on the fly\n            let commitment_cap: Vec\u003cVec\u003cTarget\u003e\u003e = if let Some(pre_packed) = pre_packed_input_caps {\n                pre_packed[batch_idx].clone()\n            } else {\n                let lifted_commitment = batch_commit.to_observation_targets();\n                let packed_commitment_flat =\n                    pack_lifted_to_ext::\u003cF, EF\u003e(builder, \u0026lifted_commitment);\n                let rate_ext = perm_config.rate_ext();\n                packed_commitment_flat\n                    .chunks(rate_ext)\n                    .map(|c| c.to_vec())\n                    .collect()\n            };\n\n            let dimensions: Vec\u003cDimensions\u003e = mats\n                .iter()\n                .map(|(domain, _)| Dimensions {\n                    height: 1 \u003c\u003c (domain.log_size() + log_blowup),\n                    width: 0,\n                })\n                .collect();\n\n            let op_ids = verify_batch_circuit::\u003cF, EF\u003e(\n                builder,\n                perm_config,\n                \u0026commitment_cap,\n                \u0026dimensions,\n                index_bits,\n                batch_openings,\n            )\n            .map_err(|e| {\n                VerificationError::InvalidProofShape(format!(\n                    \"MMCS verification failed for batch {batch_idx}: {e:?}\"\n                ))\n            })?;\n            mmcs_op_ids.extend(op_ids);\n        }\n\n        let mut alpha_powers_set = HashMap::new();\n        let mut inv_z_minus_x_cache: HashMap\u003c(usize, Target), Target\u003e = HashMap::new();\n\n        // For each matrix in the batch\n        for (mat_idx, ((mat_domain, mat_points_and_values), mat_opening)) in zip_eq(\n            mats.iter(),\n            batch_openings.iter(),\n            VerificationError::InvalidProofShape(format!(\n                \"batch {batch_idx}: opened_values and point_values count must match\"\n            )),\n        )?\n        .enumerate()\n        {\n            let log_height = mat_domain.log_size() + log_blowup;\n\n            let x = eval_points[\u0026log_height];\n\n            // Initialize / fetch per-height (alpha_pow, ro)\n            let (alpha_pow_h, ro_h) = reduced_openings.entry(log_height).or_insert_with(|| {\n                (\n                    builder.define_const(EF::ONE),\n                    builder.define_const(EF::ZERO),\n                )\n            });\n\n            // Process each (z, ps_at_z) pair for this matrix\n            for (z, ps_at_z) in mat_points_and_values {\n                if mat_opening.len() != ps_at_z.len() {\n                    return Err(VerificationError::InvalidProofShape(format!(\n                        \"batch {batch_idx} mat {mat_idx}: opened_values columns must match point_values columns\"\n                    )));\n                }\n\n                let inv_z_minus_x =\n                    *inv_z_minus_x_cache\n                        .entry((log_height, *z))\n                        .or_insert_with(|| {\n                            let z_minus_x = builder.sub(*z, x);\n                            let one = builder.define_const(EF::ONE);\n                            builder.div(one, z_minus_x)\n                        });\n\n                let (new_alpha_pow_h, ro_contrib) = compute_single_reduced_opening(\n                    builder,\n                    mat_opening,\n                    ps_at_z,\n                    *alpha_pow_h,\n                    alpha,\n                    \u0026mut alpha_powers_set,\n                    inv_z_minus_x,\n                );\n\n                *ro_h = builder.add(*ro_h, ro_contrib);\n                *alpha_pow_h = new_alpha_pow_h;\n            }\n        }\n\n        // `reduced_openings` would have a log_height = log_blowup entry only if there was a\n        // trace matrix of height 1. In this case `f` is constant, so `(f(zeta) - f(x))/(zeta - x)`\n        // must equal `0`.\n        if let Some((_ap, ro0)) = reduced_openings.get(\u0026log_blowup) {\n            let zero = builder.define_const(EF::ZERO);\n            builder.connect(*ro0, zero);\n        }\n    }\n\n    builder.pop_scope(); // close `open_input` scope\n\n    // Into descending (height, ro) list\n    let reduced_list: Vec\u003c_\u003e = reduced_openings\n        .into_iter()\n        .rev()\n        .map(|(h, (_ap, ro))| (h, ro))\n        .collect();\n    Ok((reduced_list, mmcs_op_ids))\n}\n\n/// Verify FRI arithmetic in-circuit with optional MMCS verification.\n///\n/// Supports variable-arity FRI folding: each phase may fold by a different arity\n/// determined by `log_arities` extracted from the proof.\n///\n/// When `permutation_config` is `Some`, this function performs full recursive MMCS\n/// verification for both input batch openings and commit-phase openings.\n/// When `None`, only arithmetic verification is performed (for testing).\n///\n/// Returns the list of non-primitive operation IDs that require private data\n/// (Merkle sibling values) to be set by the runner.\n///\n/// Reference (Plonky3): `p3_fri::verifier::verify_fri`\npub fn verify_fri_circuit\u003cF, EF, RecMmcs, Inner, Witness, Comm\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    fri_proof_targets: \u0026FriProofTargets\u003cF, EF, RecMmcs, InputProofTargets\u003cF, EF, Inner\u003e, Witness\u003e,\n    alpha: Target,\n    betas: \u0026[Target],\n    index_bits_per_query: \u0026[Vec\u003cTarget\u003e],\n    commitments_with_opening_points: \u0026ComsWithOpeningsTargets\u003cComm, TwoAdicMultiplicativeCoset\u003cF\u003e\u003e,\n    log_blowup: usize,\n    permutation_config: Option\u003cPoseidon2Config\u003e,\n) -\u003e Result\u003cVec\u003cNonPrimitiveOpId\u003e, VerificationError\u003e\nwhere\n    F: Field + TwoAdicField + PrimeField64,\n    EF: ExtensionField\u003cF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n    RecMmcs::Commitment: ObservableCommitment,\n    Inner: RecursiveMmcs\u003cF, EF\u003e,\n    Witness: Recursive\u003cEF\u003e,\n    Comm: ObservableCommitment,\n{\n    builder.push_scope(\"verify_fri\");\n\n    let num_phases = betas.len();\n    let num_queries = fri_proof_targets.query_proofs.len();\n    let log_arities = \u0026fri_proof_targets.log_arities;\n\n    let total_log_reduction: usize = log_arities.iter().sum();\n\n    tracing::debug!(\n        \"verify_fri_circuit: num_phases={}, num_queries={}, log_blowup={}, log_arities={:?}\",\n        num_phases,\n        num_queries,\n        log_blowup,\n        log_arities,\n    );\n\n    // Validate shape.\n    if num_phases != fri_proof_targets.commit_phase_commits.len() {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"betas length must equal number of commit-phase commitments: expected {}, got {}\",\n            num_phases,\n            fri_proof_targets.commit_phase_commits.len()\n        )));\n    }\n\n    if num_phases != fri_proof_targets.commit_pow_witnesses.len() {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Number of commit-phase commitments must equal number of commit-phase pow witnesses: expected {}, got {}\",\n            num_phases,\n            fri_proof_targets.commit_pow_witnesses.len()\n        )));\n    }\n\n    if log_arities.len() != num_phases {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"log_arities length must equal number of phases: expected {}, got {}\",\n            num_phases,\n            log_arities.len()\n        )));\n    }\n\n    if num_queries != index_bits_per_query.len() {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"index_bits_per_query length must equal number of query proofs: expected {}, got {}\",\n            num_queries,\n            index_bits_per_query.len()\n        )));\n    }\n\n    let log_max_height = index_bits_per_query[0].len();\n    if index_bits_per_query\n        .iter()\n        .any(|v| v.len() != log_max_height)\n    {\n        return Err(VerificationError::InvalidProofShape(\n            \"all index_bits_per_query entries must have same length\".to_string(),\n        ));\n    }\n\n    if betas.is_empty() {\n        return Err(VerificationError::InvalidProofShape(\n            \"FRI must have at least one fold phase\".to_string(),\n        ));\n    }\n\n    // With variable arity: log_max_height = total_log_reduction + log_final_poly_len + log_blowup\n    let log_final_poly_len = log_max_height\n        .checked_sub(total_log_reduction)\n        .and_then(|x| x.checked_sub(log_blowup))\n        .ok_or_else(|| {\n            VerificationError::InvalidProofShape(\n                \"Invalid FRI parameters: log_max_height too small for given log_arities\"\n                    .to_string(),\n            )\n        })?;\n\n    let expected_final_poly_len = 1 \u003c\u003c log_final_poly_len;\n    let actual_final_poly_len = fri_proof_targets.final_poly.len();\n\n    if actual_final_poly_len != expected_final_poly_len {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Final polynomial length mismatch: expected 2^{log_final_poly_len} = {expected_final_poly_len}, got {actual_final_poly_len}\"\n        )));\n    }\n\n    // Precompute cumulative bits consumed after each phase.\n    // cumulative_bits[i] = sum(log_arities[0..i])\n    let mut cumulative_bits = Vec::with_capacity(num_phases + 1);\n    cumulative_bits.push(0usize);\n    for \u0026la in log_arities {\n        cumulative_bits.push(cumulative_bits.last().unwrap() + la);\n    }\n\n    // Precompute the folded height after each phase for roll-in mapping.\n    // folded_height_after[i] = log_max_height - cumulative_bits[i+1]\n    let folded_height_after: Vec\u003cusize\u003e = (0..num_phases)\n        .map(|i| log_max_height - cumulative_bits[i + 1])\n        .collect();\n\n    // Precompute shared beta powers and generator powers used across queries.\n    let beta_pows_per_phase = precompute_beta_powers_per_phase(builder, betas, log_arities);\n    let powers_of_g_final = precompute_two_adic_powers::\u003cF, EF\u003e(builder, log_max_height);\n\n    // Pre-pack commitment caps once so they can be reused across all queries.\n    // Each input batch commitment and each commit-phase commitment is packed from\n    // lifted representation to extension representation a single time.\n    let pre_packed_input_caps: Option\u003cVec\u003cVec\u003cVec\u003cTarget\u003e\u003e\u003e\u003e =\n        permutation_config.map(|perm_config| {\n            let rate_ext = perm_config.rate_ext();\n            commitments_with_opening_points\n                .iter()\n                .map(|(commit, _)| {\n                    let lifted = commit.to_observation_targets();\n                    let packed = pack_lifted_to_ext::\u003cF, EF\u003e(builder, \u0026lifted);\n                    packed.chunks(rate_ext).map(|c| c.to_vec()).collect()\n                })\n                .collect()\n        });\n\n    let pre_packed_commit_caps: Option\u003cVec\u003cVec\u003cVec\u003cTarget\u003e\u003e\u003e\u003e =\n        permutation_config.map(|perm_config| {\n            let rate_ext = perm_config.rate_ext();\n            fri_proof_targets\n                .commit_phase_commits\n                .iter()\n                .map(|commit| {\n                    let lifted = commit.to_observation_targets();\n                    let packed = pack_lifted_to_ext::\u003cF, EF\u003e(builder, \u0026lifted);\n                    packed.chunks(rate_ext).map(|c| c.to_vec()).collect()\n                })\n                .collect()\n        });\n\n    // Collect all MMCS operation IDs for private data setting\n    let mut all_mmcs_op_ids = Vec::new();\n\n    // For each query, extract opened values from proof and compute reduced openings and fold.\n    for (q, query_proof) in fri_proof_targets.query_proofs.iter().enumerate() {\n        builder.push_scope(\"verify_fri_query\");\n        let batch_opened_values: Vec\u003cVec\u003cVec\u003cTarget\u003e\u003e\u003e = query_proof\n            .input_proof\n            .iter()\n            .map(|batch| batch.opened_values.clone())\n            .collect();\n\n        // Arithmetic `open_input` to get (height, ro) descending, plus MMCS op IDs\n        let (reduced_by_height, input_mmcs_ops) = open_input::\u003cF, EF, Comm\u003e(\n            builder,\n            log_max_height,\n            \u0026index_bits_per_query[q],\n            alpha,\n            log_blowup,\n            commitments_with_opening_points,\n            \u0026batch_opened_values,\n            permutation_config,\n            pre_packed_input_caps.as_deref(),\n        )?;\n        all_mmcs_op_ids.extend(input_mmcs_ops);\n\n        if reduced_by_height.is_empty() {\n            return Err(VerificationError::InvalidProofShape(\n                \"No reduced openings; did you commit to zero polynomials?\".to_string(),\n            ));\n        }\n        if reduced_by_height[0].0 != log_max_height {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"First reduced opening must be at max height {}, got {}\",\n                log_max_height, reduced_by_height[0].0\n            )));\n        }\n        let initial_folded_eval = reduced_by_height[0].1;\n\n        // Pack sibling values for each phase (variable count per phase).\n        let sibling_values_per_phase: Vec\u003cVec\u003cTarget\u003e\u003e = query_proof\n            .commit_phase_openings\n            .iter()\n            .map(|opening| opening.sibling_values_packed(builder))\n            .collect();\n\n        if sibling_values_per_phase.len() != num_phases {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"commit_phase_openings count must match phases: expected {}, got {}\",\n                num_phases,\n                sibling_values_per_phase.len()\n            )));\n        }\n\n        // Build height-aligned roll-ins using variable-arity cumulative bits.\n        let mut roll_ins: Vec\u003cOption\u003cTarget\u003e\u003e = vec![None; num_phases];\n        for \u0026(h, ro) in reduced_by_height.iter().skip(1) {\n            // Find the phase whose folded height matches h\n            let phase_idx = folded_height_after.iter().position(|\u0026fh| fh == h);\n            if let Some(i) = phase_idx {\n                if roll_ins[i].is_some() {\n                    return Err(VerificationError::InvalidProofShape(format!(\n                        \"duplicate roll-in for phase {i} (height {h})\",\n                    )));\n                }\n                roll_ins[i] = Some(ro);\n            } else {\n                let zero = builder.define_const(EF::ZERO);\n                builder.connect(ro, zero);\n            }\n        }\n\n        // Compute the final query point using total bits consumed\n        builder.push_scope(\"compute_final_query_point\");\n        let final_query_point = compute_final_query_point::\u003cF, EF\u003e(\n            builder,\n            \u0026index_bits_per_query[q],\n            log_max_height,\n            total_log_reduction,\n            \u0026powers_of_g_final,\n        );\n        builder.pop_scope();\n\n        let final_poly_eval =\n            evaluate_polynomial(builder, \u0026fri_proof_targets.final_poly, final_query_point);\n\n        // Commit-phase MMCS verification with variable arity.\n        // When MMCS verification is active, the fold chain is computed as part of\n        // the MMCS loop (each phase calls fold_one_phase), so the final\n        // current_folded is connected directly to final_poly_eval — no separate\n        // fold_chain_circuit call is needed.\n        // When MMCS verification is not active (no Poseidon2 table), we fall back\n        // to fold_chain_circuit for the arithmetic fold constraint.\n        if let Some(perm_config) = permutation_config {\n            let subgroup_starts = precompute_subgroup_starts::\u003cF, EF\u003e(\n                builder,\n                \u0026index_bits_per_query[q],\n                log_max_height,\n                log_arities,\n                \u0026cumulative_bits,\n            );\n\n            let mut current_folded = initial_folded_eval;\n            let mut bits_consumed = 0usize;\n            let mut log_current_height = log_max_height;\n\n            for (phase_idx, (commit, _opening)) in fri_proof_targets\n                .commit_phase_commits\n                .iter()\n                .zip(query_proof.commit_phase_openings.iter())\n                .enumerate()\n            {\n                let log_arity = log_arities[phase_idx];\n                let arity = 1usize \u003c\u003c log_arity;\n                let log_folded_height = log_current_height - log_arity;\n                let siblings = \u0026sibling_values_per_phase[phase_idx];\n\n                // Skip MMCS verification for height 0 (no Merkle tree)\n                if log_folded_height == 0 {\n                    current_folded = fold_one_phase::\u003cF, EF\u003e(\n                        builder,\n                        current_folded,\n                        siblings,\n                        betas[phase_idx],\n                        \u0026index_bits_per_query[q],\n                        bits_consumed,\n                        log_arity,\n                        log_current_height,\n                        roll_ins[phase_idx],\n                        Some(beta_pows_per_phase[phase_idx]),\n                        None,\n                        Some(subgroup_starts[phase_idx]),\n                    );\n                    bits_consumed += log_arity;\n                    log_current_height = log_folded_height;\n                    continue;\n                }\n\n                builder.push_scope(\"fri_commit_phase_mmcs\");\n\n                // Build full evaluation row once; reused for both MMCS and folding.\n                let index_in_group_bits =\n                    \u0026index_bits_per_query[q][bits_consumed..bits_consumed + log_arity];\n                let evals =\n                    reconstruct_evals(builder, current_folded, siblings, index_in_group_bits);\n\n                // Use pre-packed commit-phase cap\n                let commitment_cap: Vec\u003cVec\u003cTarget\u003e\u003e =\n                    if let Some(ref pre_packed) = pre_packed_commit_caps {\n                        pre_packed[phase_idx].clone()\n                    } else {\n                        let lifted_commitment = commit.to_observation_targets();\n                        let packed_commitment_flat =\n                            pack_lifted_to_ext::\u003cF, EF\u003e(builder, \u0026lifted_commitment);\n                        let rate_ext = perm_config.rate_ext();\n                        packed_commitment_flat\n                            .chunks(rate_ext)\n                            .map(|c| c.to_vec())\n                            .collect()\n                    };\n\n                // Dimensions: width = arity, height = 2^log_folded_height\n                let folded_height = 1usize \u003c\u003c log_folded_height;\n                let dimensions = vec![Dimensions {\n                    height: folded_height,\n                    width: arity,\n                }];\n\n                // Parent index bits start after index_in_group bits\n                let parent_bit_start = bits_consumed + log_arity;\n                let parent_bit_end = (parent_bit_start + log_folded_height).min(log_max_height);\n                let zero = builder.define_const(EF::ZERO);\n\n                let mut parent_index_bits: Vec\u003cTarget\u003e =\n                    index_bits_per_query[q][parent_bit_start..parent_bit_end].to_vec();\n                while parent_index_bits.len() \u003c log_folded_height {\n                    parent_index_bits.push(zero);\n                }\n\n                let evals_for_mmcs = vec![evals.clone()];\n\n                let commit_phase_ops = verify_batch_circuit_from_extension_opened::\u003cF, EF\u003e(\n                    builder,\n                    perm_config,\n                    \u0026commitment_cap,\n                    \u0026dimensions,\n                    \u0026parent_index_bits,\n                    \u0026evals_for_mmcs,\n                )\n                .map_err(|e| {\n                    VerificationError::InvalidProofShape(format!(\n                        \"Commit-phase MMCS verification failed for query {q}, phase {phase_idx}: {e:?}\"\n                    ))\n                })?;\n                all_mmcs_op_ids.extend(commit_phase_ops);\n\n                // Fold reusing the pre-built evals and subgroup_start\n                current_folded = fold_one_phase::\u003cF, EF\u003e(\n                    builder,\n                    current_folded,\n                    siblings,\n                    betas[phase_idx],\n                    \u0026index_bits_per_query[q],\n                    bits_consumed,\n                    log_arity,\n                    log_current_height,\n                    roll_ins[phase_idx],\n                    Some(beta_pows_per_phase[phase_idx]),\n                    Some(\u0026evals),\n                    Some(subgroup_starts[phase_idx]),\n                );\n\n                bits_consumed += log_arity;\n                log_current_height = log_folded_height;\n\n                builder.pop_scope(); // close fri_commit_phase_mmcs\n            }\n\n            // The MMCS loop already computed the full fold chain; connect directly.\n            builder.connect(current_folded, final_poly_eval);\n        } else {\n            // No MMCS verification — use fold_chain_circuit for the arithmetic constraint.\n            let mut fold_phases = Vec::with_capacity(num_phases);\n            for i in 0..num_phases {\n                fold_phases.push(FoldPhaseConfig {\n                    beta: betas[i],\n                    siblings: sibling_values_per_phase[i].clone(),\n                    roll_in: roll_ins[i],\n                });\n            }\n\n            builder.push_scope(\"fri_fold_chain_no_mmcs query\");\n            let folded_eval = fold_chain_circuit::\u003cF, EF\u003e(\n                builder,\n                initial_folded_eval,\n                \u0026index_bits_per_query[q],\n                \u0026fold_phases,\n                log_arities,\n                \u0026cumulative_bits,\n                \u0026beta_pows_per_phase,\n            );\n            builder.pop_scope();\n            builder.connect(folded_eval, final_poly_eval);\n        }\n\n        builder.pop_scope(); // close verify_fri_query\n    }\n\n    builder.pop_scope();\n\n    Ok(all_mmcs_op_ids)\n}\n","traces":[{"line":32,"address":[5090600,5090032,5090594],"length":1,"stats":{"Line":4}},{"line":37,"address":[5141560],"length":1,"stats":{"Line":4}},{"line":38,"address":[3159881],"length":1,"stats":{"Line":0}},{"line":41,"address":[3738513],"length":1,"stats":{"Line":4}},{"line":44,"address":[3159802],"length":1,"stats":{"Line":4}},{"line":45,"address":[3303973,3304464,3304705,3304699],"length":1,"stats":{"Line":8}},{"line":46,"address":[3304496],"length":1,"stats":{"Line":4}},{"line":47,"address":[5142223,5142161],"length":1,"stats":{"Line":8}},{"line":48,"address":[3739178],"length":1,"stats":{"Line":4}},{"line":53,"address":[3272595,3273312,3273326,3272674],"length":1,"stats":{"Line":16}},{"line":56,"address":[5141789,5141877],"length":1,"stats":{"Line":8}},{"line":58,"address":[5141884],"length":1,"stats":{"Line":4}},{"line":59,"address":[3272849],"length":1,"stats":{"Line":4}},{"line":60,"address":[3082208,3081713],"length":1,"stats":{"Line":8}},{"line":63,"address":[3273413,3273470],"length":1,"stats":{"Line":4}},{"line":64,"address":[5090928,5090735,5090684],"length":1,"stats":{"Line":12}},{"line":65,"address":[3082395,3082371,3082527],"length":1,"stats":{"Line":8}},{"line":66,"address":[7087826],"length":1,"stats":{"Line":4}},{"line":67,"address":[3082495],"length":1,"stats":{"Line":4}},{"line":69,"address":[3082378],"length":1,"stats":{"Line":4}},{"line":84,"address":[3180224],"length":1,"stats":{"Line":1}},{"line":89,"address":[3342819],"length":1,"stats":{"Line":1}},{"line":90,"address":[3180328],"length":1,"stats":{"Line":1}},{"line":91,"address":[3293090],"length":1,"stats":{"Line":1}},{"line":93,"address":[3102010],"length":1,"stats":{"Line":1}},{"line":94,"address":[5110553],"length":1,"stats":{"Line":1}},{"line":95,"address":[3293166],"length":1,"stats":{"Line":1}},{"line":96,"address":[7107899],"length":1,"stats":{"Line":1}},{"line":98,"address":[7107936],"length":1,"stats":{"Line":1}},{"line":102,"address":[7111360],"length":1,"stats":{"Line":1}},{"line":108,"address":[5114142],"length":1,"stats":{"Line":1}},{"line":109,"address":[3762895],"length":1,"stats":{"Line":1}},{"line":110,"address":[5166332],"length":1,"stats":{"Line":1}},{"line":111,"address":[3296841],"length":1,"stats":{"Line":1}},{"line":114,"address":[7111572],"length":1,"stats":{"Line":1}},{"line":115,"address":[5166417],"length":1,"stats":{"Line":1}},{"line":116,"address":[3346734],"length":1,"stats":{"Line":1}},{"line":117,"address":[7111659],"length":1,"stats":{"Line":1}},{"line":120,"address":[3105880],"length":1,"stats":{"Line":1}},{"line":121,"address":[3346819],"length":1,"stats":{"Line":1}},{"line":122,"address":[3297040],"length":1,"stats":{"Line":1}},{"line":123,"address":[5114460],"length":1,"stats":{"Line":1}},{"line":124,"address":[7111802],"length":1,"stats":{"Line":1}},{"line":125,"address":[7111831],"length":1,"stats":{"Line":1}},{"line":126,"address":[3106052],"length":1,"stats":{"Line":1}},{"line":127,"address":[3346993],"length":1,"stats":{"Line":1}},{"line":129,"address":[3184501],"length":1,"stats":{"Line":1}},{"line":133,"address":[3181373,3181379,3180528],"length":1,"stats":{"Line":1}},{"line":137,"address":[5110712],"length":1,"stats":{"Line":1}},{"line":138,"address":[3180675,3180784],"length":1,"stats":{"Line":1}},{"line":139,"address":[3343356,3343311,3343486],"length":1,"stats":{"Line":2}},{"line":141,"address":[3102534],"length":1,"stats":{"Line":1}},{"line":142,"address":[3293648,3293750],"length":1,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[7108577,7108642],"length":1,"stats":{"Line":2}},{"line":145,"address":[3293955],"length":1,"stats":{"Line":1}},{"line":146,"address":[7108801],"length":1,"stats":{"Line":1}},{"line":148,"address":[3102781],"length":1,"stats":{"Line":1}},{"line":154,"address":[7081287,7080512,7081281],"length":1,"stats":{"Line":4}},{"line":155,"address":[3266360],"length":1,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[3075243],"length":1,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[3732605,3732856],"length":1,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[3266693],"length":1,"stats":{"Line":3}},{"line":166,"address":[3154022,3154441,3154363],"length":1,"stats":{"Line":6}},{"line":167,"address":[3733099],"length":1,"stats":{"Line":3}},{"line":168,"address":[3733186,3733118],"length":1,"stats":{"Line":6}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[3154589,3154804,3154046],"length":1,"stats":{"Line":0}},{"line":172,"address":[3154761,3154830],"length":1,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[5136911],"length":1,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[3734017,3734086],"length":1,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[3075305],"length":1,"stats":{"Line":0}},{"line":183,"address":[7083280,7080748,7083296],"length":1,"stats":{"Line":0}},{"line":185,"address":[3153870],"length":1,"stats":{"Line":0}},{"line":186,"address":[3268402,3268326],"length":1,"stats":{"Line":0}},{"line":187,"address":[3268524],"length":1,"stats":{"Line":0}},{"line":188,"address":[3155802,3155899],"length":1,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[5086627,5086559],"length":1,"stats":{"Line":0}},{"line":192,"address":[5086509,5086594],"length":1,"stats":{"Line":0}},{"line":195,"address":[3268845],"length":1,"stats":{"Line":0}},{"line":197,"address":[3734547],"length":1,"stats":{"Line":0}},{"line":209,"address":[3736761,3736921,3735088],"length":1,"stats":{"Line":4}},{"line":215,"address":[3300648],"length":1,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[5086930,5086849],"length":1,"stats":{"Line":4}},{"line":218,"address":[3156579,3156631],"length":1,"stats":{"Line":8}},{"line":220,"address":[5138555],"length":1,"stats":{"Line":4}},{"line":223,"address":[3078368],"length":1,"stats":{"Line":4}},{"line":224,"address":[7083811,7083894],"length":1,"stats":{"Line":8}},{"line":225,"address":[3735679],"length":1,"stats":{"Line":4}},{"line":226,"address":[3735848,3736775],"length":1,"stats":{"Line":8}},{"line":233,"address":[5087494],"length":1,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":8}},{"line":235,"address":[3157386,3157489,3157561],"length":1,"stats":{"Line":12}},{"line":236,"address":[7084496,7084561],"length":1,"stats":{"Line":8}},{"line":237,"address":[5088027],"length":1,"stats":{"Line":4}},{"line":238,"address":[3157946],"length":1,"stats":{"Line":4}},{"line":239,"address":[3270765],"length":1,"stats":{"Line":4}},{"line":242,"address":[3078970],"length":1,"stats":{"Line":4}},{"line":243,"address":[5087737],"length":1,"stats":{"Line":4}},{"line":256,"address":[5165597,5165591,5164032],"length":1,"stats":{"Line":1}},{"line":268,"address":[3294662],"length":1,"stats":{"Line":1}},{"line":270,"address":[3294679,3294743],"length":1,"stats":{"Line":1}},{"line":272,"address":[3182020,3182041,3181990],"length":1,"stats":{"Line":3}},{"line":273,"address":[3760754],"length":1,"stats":{"Line":1}},{"line":276,"address":[3103683,3103890,3103924],"length":1,"stats":{"Line":0}},{"line":279,"address":[3760986,3761033,3761135],"length":1,"stats":{"Line":0}},{"line":280,"address":[3761060],"length":1,"stats":{"Line":0}},{"line":282,"address":[3295143],"length":1,"stats":{"Line":0}},{"line":283,"address":[3346302,3346288,3344994],"length":1,"stats":{"Line":0}},{"line":284,"address":[3345014],"length":1,"stats":{"Line":0}},{"line":285,"address":[5164747,5166077,5166064],"length":1,"stats":{"Line":0}},{"line":288,"address":[3344972],"length":1,"stats":{"Line":0}},{"line":291,"address":[5164804],"length":1,"stats":{"Line":0}},{"line":292,"address":[3182555],"length":1,"stats":{"Line":0}},{"line":293,"address":[3295338,3295429,3296397],"length":1,"stats":{"Line":0}},{"line":294,"address":[3296095,3295561,3296291],"length":1,"stats":{"Line":0}},{"line":295,"address":[5165771,5165856],"length":1,"stats":{"Line":0}},{"line":296,"address":[3346176],"length":1,"stats":{"Line":0}},{"line":299,"address":[5112656],"length":1,"stats":{"Line":0}},{"line":303,"address":[3344628],"length":1,"stats":{"Line":1}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[5164386,5165936],"length":1,"stats":{"Line":2}},{"line":306,"address":[5114016],"length":1,"stats":{"Line":1}},{"line":307,"address":[5165990],"length":1,"stats":{"Line":1}},{"line":308,"address":[5166010],"length":1,"stats":{"Line":1}},{"line":312,"address":[7109672],"length":1,"stats":{"Line":1}},{"line":313,"address":[3295706,3295638],"length":1,"stats":{"Line":2}},{"line":314,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[3345867],"length":1,"stats":{"Line":1}},{"line":318,"address":[5113261],"length":1,"stats":{"Line":1}},{"line":319,"address":[7110621],"length":1,"stats":{"Line":1}},{"line":330,"address":[7115600,7113056,7115467],"length":1,"stats":{"Line":8}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[3348347],"length":1,"stats":{"Line":8}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":26}},{"line":349,"address":[3107697,3107623],"length":1,"stats":{"Line":18}},{"line":351,"address":[3107716],"length":1,"stats":{"Line":9}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[5170390],"length":1,"stats":{"Line":0}},{"line":356,"address":[5116199,5116152],"length":1,"stats":{"Line":19}},{"line":357,"address":[5168405,5170496,5170510],"length":1,"stats":{"Line":30}},{"line":358,"address":[7113640],"length":1,"stats":{"Line":9}},{"line":359,"address":[3109984,3107863,3109997],"length":1,"stats":{"Line":29}},{"line":362,"address":[3765178,3765117],"length":1,"stats":{"Line":9}},{"line":364,"address":[3186315],"length":1,"stats":{"Line":9}},{"line":365,"address":[3108252,3108039],"length":1,"stats":{"Line":19}},{"line":366,"address":[3108115],"length":1,"stats":{"Line":9}},{"line":367,"address":[7113966],"length":1,"stats":{"Line":10}},{"line":368,"address":[5168825],"length":1,"stats":{"Line":9}},{"line":369,"address":[5116659],"length":1,"stats":{"Line":10}},{"line":371,"address":[7114238],"length":1,"stats":{"Line":9}},{"line":372,"address":[5118125],"length":1,"stats":{"Line":8}},{"line":376,"address":[3765676],"length":1,"stats":{"Line":10}},{"line":377,"address":[3299579],"length":1,"stats":{"Line":9}},{"line":379,"address":[3186949,3186858],"length":1,"stats":{"Line":19}},{"line":380,"address":[3108908,3109117,3108718],"length":1,"stats":{"Line":18}},{"line":381,"address":[5169701,5169786],"length":1,"stats":{"Line":18}},{"line":382,"address":[5117630],"length":1,"stats":{"Line":10}},{"line":384,"address":[],"length":0,"stats":{"Line":10}},{"line":385,"address":[5169901,5169939],"length":1,"stats":{"Line":19}},{"line":386,"address":[3109374,3109654],"length":1,"stats":{"Line":16}},{"line":387,"address":[3300625],"length":1,"stats":{"Line":9}},{"line":393,"address":[3187114],"length":1,"stats":{"Line":10}},{"line":395,"address":[3299917],"length":1,"stats":{"Line":9}},{"line":399,"address":[7120431,7120437,7120016],"length":1,"stats":{"Line":9}},{"line":404,"address":[5122906],"length":1,"stats":{"Line":8}},{"line":406,"address":[3192661],"length":1,"stats":{"Line":9}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[5123052],"length":1,"stats":{"Line":9}},{"line":410,"address":[3772224,3772242,3772077],"length":1,"stats":{"Line":29}},{"line":413,"address":[3772102],"length":1,"stats":{"Line":10}},{"line":414,"address":[3772157],"length":1,"stats":{"Line":9}},{"line":419,"address":[5162160],"length":1,"stats":{"Line":1}},{"line":426,"address":[3758675],"length":1,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":1}},{"line":428,"address":[3101732],"length":1,"stats":{"Line":1}},{"line":429,"address":[3101761],"length":1,"stats":{"Line":1}},{"line":430,"address":[5162408],"length":1,"stats":{"Line":1}},{"line":431,"address":[3292911],"length":1,"stats":{"Line":1}},{"line":432,"address":[3101830],"length":1,"stats":{"Line":1}},{"line":442,"address":[3731029,3726832,3730165],"length":1,"stats":{"Line":9}},{"line":460,"address":[3148428],"length":1,"stats":{"Line":10}},{"line":462,"address":[3727266,3727189],"length":1,"stats":{"Line":8}},{"line":463,"address":[3292792,3292727,3292656],"length":1,"stats":{"Line":17}},{"line":466,"address":[5079163],"length":1,"stats":{"Line":8}},{"line":467,"address":[3296501,3296743,3292846],"length":1,"stats":{"Line":15}},{"line":468,"address":[3073939],"length":1,"stats":{"Line":7}},{"line":469,"address":[5082925],"length":1,"stats":{"Line":8}},{"line":470,"address":[3153114,3152636,3152576],"length":1,"stats":{"Line":16}},{"line":472,"address":[5134460],"length":1,"stats":{"Line":8}},{"line":473,"address":[5135136,5134519],"length":1,"stats":{"Line":8}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[5083716],"length":1,"stats":{"Line":0}},{"line":476,"address":[5135143],"length":1,"stats":{"Line":0}},{"line":477,"address":[5083727],"length":1,"stats":{"Line":0}},{"line":478,"address":[5135158],"length":1,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":8}},{"line":483,"address":[3152879],"length":1,"stats":{"Line":7}},{"line":484,"address":[7079867],"length":1,"stats":{"Line":8}},{"line":485,"address":[3731655],"length":1,"stats":{"Line":7}},{"line":486,"address":[7079921],"length":1,"stats":{"Line":8}},{"line":488,"address":[5134765],"length":1,"stats":{"Line":7}},{"line":489,"address":[5134798],"length":1,"stats":{"Line":8}},{"line":490,"address":[],"length":0,"stats":{"Line":7}},{"line":491,"address":[3074643],"length":1,"stats":{"Line":8}},{"line":493,"address":[7080046,7080117],"length":1,"stats":{"Line":10}},{"line":494,"address":[3074744,3074896,3074913],"length":1,"stats":{"Line":3}},{"line":495,"address":[3731936],"length":1,"stats":{"Line":3}},{"line":496,"address":[3297382],"length":1,"stats":{"Line":4}},{"line":498,"address":[5135041],"length":1,"stats":{"Line":8}},{"line":499,"address":[3266006],"length":1,"stats":{"Line":7}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[3070181],"length":1,"stats":{"Line":1}},{"line":506,"address":[3292862],"length":1,"stats":{"Line":1}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[3070400,3070338],"length":1,"stats":{"Line":0}},{"line":509,"address":[5130704],"length":1,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[7076094,7076164],"length":1,"stats":{"Line":2}},{"line":523,"address":[5131200,5131103],"length":1,"stats":{"Line":2}},{"line":524,"address":[],"length":0,"stats":{"Line":2}},{"line":525,"address":[7079210],"length":1,"stats":{"Line":1}},{"line":528,"address":[3071037],"length":1,"stats":{"Line":1}},{"line":529,"address":[5131329],"length":1,"stats":{"Line":1}},{"line":530,"address":[7076544],"length":1,"stats":{"Line":1}},{"line":532,"address":[5131647,5131551,5131374,5131504],"length":1,"stats":{"Line":4}},{"line":533,"address":[3293798],"length":1,"stats":{"Line":1}},{"line":534,"address":[3262457],"length":1,"stats":{"Line":1}},{"line":535,"address":[7076712],"length":1,"stats":{"Line":1}},{"line":537,"address":[5132163,5131714],"length":1,"stats":{"Line":2}},{"line":538,"address":[3263160],"length":1,"stats":{"Line":1}},{"line":539,"address":[5081995,5082686,5081003],"length":1,"stats":{"Line":3}},{"line":540,"address":[3296239],"length":1,"stats":{"Line":1}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[3264328,3264489],"length":1,"stats":{"Line":2}},{"line":543,"address":[3073349],"length":1,"stats":{"Line":1}},{"line":544,"address":[3151982],"length":1,"stats":{"Line":1}},{"line":545,"address":[3296137],"length":1,"stats":{"Line":1}},{"line":549,"address":[7077501,7077398,7077485],"length":1,"stats":{"Line":2}},{"line":550,"address":[3072089,3072053],"length":1,"stats":{"Line":2}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[3729377,3732128],"length":1,"stats":{"Line":2}},{"line":553,"address":[],"length":0,"stats":{"Line":1}},{"line":554,"address":[3297514],"length":1,"stats":{"Line":1}},{"line":555,"address":[5135278],"length":1,"stats":{"Line":1}},{"line":558,"address":[3072960,3072267,3072358],"length":1,"stats":{"Line":3}},{"line":559,"address":[3263695,3263793],"length":1,"stats":{"Line":2}},{"line":560,"address":[5081899],"length":1,"stats":{"Line":1}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":1}},{"line":563,"address":[5132976],"length":1,"stats":{"Line":1}},{"line":564,"address":[3072884],"length":1,"stats":{"Line":1}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[3151024],"length":1,"stats":{"Line":1}},{"line":570,"address":[5082268,5082147],"length":1,"stats":{"Line":2}},{"line":571,"address":[7078663],"length":1,"stats":{"Line":1}},{"line":575,"address":[5131747],"length":1,"stats":{"Line":1}},{"line":578,"address":[3071542,3071784],"length":1,"stats":{"Line":1}},{"line":579,"address":[7077146,7080288,7077040,7080292],"length":1,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[7077153],"length":1,"stats":{"Line":0}},{"line":582,"address":[3150229],"length":1,"stats":{"Line":0}},{"line":585,"address":[5080685],"length":1,"stats":{"Line":1}},{"line":586,"address":[3263002],"length":1,"stats":{"Line":1}},{"line":592,"address":[5176493,5175296,5176487],"length":1,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[3773644,3773502,3773488,3772413],"length":1,"stats":{"Line":0}},{"line":604,"address":[3305948],"length":1,"stats":{"Line":0}},{"line":605,"address":[5175497],"length":1,"stats":{"Line":0}},{"line":609,"address":[5123651,5123555,5124688,5124702],"length":1,"stats":{"Line":0}},{"line":611,"address":[5123743,5123810],"length":1,"stats":{"Line":0}},{"line":612,"address":[5175815],"length":1,"stats":{"Line":0}},{"line":614,"address":[5123824,5123887],"length":1,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[3193659,3194226,3193604],"length":1,"stats":{"Line":0}},{"line":618,"address":[3306514,3306592,3306795],"length":1,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[3194133],"length":1,"stats":{"Line":0}},{"line":621,"address":[5176423],"length":1,"stats":{"Line":0}},{"line":622,"address":[3306933],"length":1,"stats":{"Line":0}},{"line":625,"address":[7121268],"length":1,"stats":{"Line":0}},{"line":629,"address":[5088544,5090014,5090008],"length":1,"stats":{"Line":6}},{"line":642,"address":[5088813],"length":1,"stats":{"Line":6}},{"line":644,"address":[3080134],"length":1,"stats":{"Line":6}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[3737355],"length":1,"stats":{"Line":7}},{"line":655,"address":[3737362],"length":1,"stats":{"Line":6}},{"line":656,"address":[],"length":0,"stats":{"Line":7}},{"line":658,"address":[3080321,3080230,3081230],"length":1,"stats":{"Line":17}},{"line":659,"address":[7086116,7085941,7086043],"length":1,"stats":{"Line":13}},{"line":660,"address":[3738187],"length":1,"stats":{"Line":7}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":5}},{"line":663,"address":[],"length":0,"stats":{"Line":5}},{"line":664,"address":[5140976],"length":1,"stats":{"Line":6}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[3271946],"length":1,"stats":{"Line":7}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":6}},{"line":669,"address":[3080810],"length":1,"stats":{"Line":7}},{"line":670,"address":[5089582,5089656],"length":1,"stats":{"Line":6}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":13}},{"line":674,"address":[3738348,3738277],"length":1,"stats":{"Line":5}},{"line":675,"address":[5089987,5089922,5089974],"length":1,"stats":{"Line":10}},{"line":678,"address":[3271735],"length":1,"stats":{"Line":5}},{"line":679,"address":[3080574],"length":1,"stats":{"Line":6}},{"line":684,"address":[3341920],"length":1,"stats":{"Line":9}},{"line":689,"address":[3101065],"length":1,"stats":{"Line":10}},{"line":691,"address":[5161716],"length":1,"stats":{"Line":4}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[3342018],"length":1,"stats":{"Line":10}},{"line":696,"address":[3101516,3101180,3101503],"length":1,"stats":{"Line":16}},{"line":699,"address":[3101155,3101339,3101206],"length":1,"stats":{"Line":3}},{"line":700,"address":[3179616,3179720,3179834],"length":1,"stats":{"Line":3}},{"line":701,"address":[3758519],"length":1,"stats":{"Line":1}},{"line":702,"address":[3101453],"length":1,"stats":{"Line":1}},{"line":705,"address":[5162097],"length":1,"stats":{"Line":1}},{"line":706,"address":[3179846],"length":1,"stats":{"Line":1}},{"line":711,"address":[7115904,7116149,7116155],"length":1,"stats":{"Line":8}},{"line":719,"address":[7115948],"length":1,"stats":{"Line":9}},{"line":721,"address":[3110162],"length":1,"stats":{"Line":8}},{"line":722,"address":[7115989,7116176,7116190],"length":1,"stats":{"Line":28}},{"line":723,"address":[3767547],"length":1,"stats":{"Line":8}},{"line":724,"address":[7116036,7116224,7116237],"length":1,"stats":{"Line":26}},{"line":727,"address":[3301357],"length":1,"stats":{"Line":8}},{"line":728,"address":[3110307],"length":1,"stats":{"Line":9}},{"line":735,"address":[5166800,5167839,5167845],"length":1,"stats":{"Line":9}},{"line":746,"address":[5166927],"length":1,"stats":{"Line":9}},{"line":748,"address":[5114848],"length":1,"stats":{"Line":9}},{"line":751,"address":[3763704,3763604],"length":1,"stats":{"Line":21}},{"line":752,"address":[3297607,3297687],"length":1,"stats":{"Line":22}},{"line":754,"address":[3297815],"length":1,"stats":{"Line":11}},{"line":755,"address":[],"length":0,"stats":{"Line":11}},{"line":756,"address":[3185578,3185139],"length":1,"stats":{"Line":20}},{"line":757,"address":[3764390,3764296],"length":1,"stats":{"Line":20}},{"line":758,"address":[3348093],"length":1,"stats":{"Line":8}},{"line":761,"address":[7112907],"length":1,"stats":{"Line":9}},{"line":762,"address":[5115561],"length":1,"stats":{"Line":10}},{"line":769,"address":[3353379,3351392,3353385],"length":1,"stats":{"Line":9}},{"line":779,"address":[3768082],"length":1,"stats":{"Line":8}},{"line":781,"address":[3189080],"length":1,"stats":{"Line":2}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[3110748],"length":1,"stats":{"Line":8}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[3189231,3189160],"length":1,"stats":{"Line":8}},{"line":791,"address":[5119474,5119536,5119569],"length":1,"stats":{"Line":17}},{"line":792,"address":[3110904,3110974,3111057],"length":1,"stats":{"Line":17}},{"line":798,"address":[3111121,3111043],"length":1,"stats":{"Line":17}},{"line":799,"address":[5173374,5173360,5171757],"length":1,"stats":{"Line":29}},{"line":800,"address":[3302288],"length":1,"stats":{"Line":8}},{"line":801,"address":[5121072,5119855,5121085],"length":1,"stats":{"Line":27}},{"line":804,"address":[7118400,7117194,7118410],"length":1,"stats":{"Line":22}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":17}},{"line":808,"address":[5172189],"length":1,"stats":{"Line":9}},{"line":809,"address":[],"length":0,"stats":{"Line":8}},{"line":810,"address":[3302754],"length":1,"stats":{"Line":9}},{"line":812,"address":[3111665,3111740],"length":1,"stats":{"Line":17}},{"line":813,"address":[5120668,5120441],"length":1,"stats":{"Line":17}},{"line":814,"address":[3112165],"length":1,"stats":{"Line":10}},{"line":816,"address":[3112199,3112256],"length":1,"stats":{"Line":9}},{"line":817,"address":[],"length":0,"stats":{"Line":19}},{"line":818,"address":[3190665],"length":1,"stats":{"Line":5}},{"line":819,"address":[5173028],"length":1,"stats":{"Line":4}},{"line":820,"address":[5173063],"length":1,"stats":{"Line":5}},{"line":824,"address":[3769363],"length":1,"stats":{"Line":8}},{"line":825,"address":[3190317],"length":1,"stats":{"Line":9}},{"line":827,"address":[5172588],"length":1,"stats":{"Line":8}},{"line":828,"address":[3190347],"length":1,"stats":{"Line":9}},{"line":835,"address":[3112784,3114105,3114111],"length":1,"stats":{"Line":9}},{"line":845,"address":[3191299],"length":1,"stats":{"Line":9}},{"line":847,"address":[3112956],"length":1,"stats":{"Line":8}},{"line":849,"address":[3770564],"length":1,"stats":{"Line":8}},{"line":850,"address":[3354077],"length":1,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[3191617],"length":1,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":9}},{"line":859,"address":[],"length":0,"stats":{"Line":25}},{"line":867,"address":[3191644,3191740,3191490],"length":1,"stats":{"Line":26}},{"line":868,"address":[3113381,3114100],"length":1,"stats":{"Line":17}},{"line":869,"address":[5122249,5122657],"length":1,"stats":{"Line":17}},{"line":870,"address":[5122664],"length":1,"stats":{"Line":8}},{"line":874,"address":[3113653],"length":1,"stats":{"Line":9}},{"line":875,"address":[3192065],"length":1,"stats":{"Line":8}},{"line":878,"address":[5174359,5174440,5174554],"length":1,"stats":{"Line":27}},{"line":879,"address":[3192175],"length":1,"stats":{"Line":8}},{"line":881,"address":[5122465,5122529],"length":1,"stats":{"Line":18}},{"line":882,"address":[3305008],"length":1,"stats":{"Line":9}},{"line":883,"address":[3305027],"length":1,"stats":{"Line":10}},{"line":885,"address":[3354856,3354779],"length":1,"stats":{"Line":18}},{"line":887,"address":[3305055],"length":1,"stats":{"Line":10}},{"line":888,"address":[3305070],"length":1,"stats":{"Line":9}},{"line":894,"address":[3760112],"length":1,"stats":{"Line":9}},{"line":899,"address":[5111552],"length":1,"stats":{"Line":8}},{"line":900,"address":[5111588],"length":1,"stats":{"Line":9}},{"line":901,"address":[5111632],"length":1,"stats":{"Line":6}},{"line":903,"address":[3294281,3294207,3294257],"length":1,"stats":{"Line":17}},{"line":905,"address":[3760245],"length":1,"stats":{"Line":8}},{"line":906,"address":[3103161,3103194,3103235],"length":1,"stats":{"Line":24}},{"line":907,"address":[3103283],"length":1,"stats":{"Line":8}},{"line":908,"address":[3760427,3760482,3760394],"length":1,"stats":{"Line":21}},{"line":909,"address":[5111877],"length":1,"stats":{"Line":4}},{"line":912,"address":[],"length":0,"stats":{"Line":9}},{"line":920,"address":[3719184,3723191,3725857],"length":1,"stats":{"Line":10}},{"line":936,"address":[3253472],"length":1,"stats":{"Line":9}},{"line":938,"address":[3062326,3062305],"length":1,"stats":{"Line":18}},{"line":939,"address":[3277364,3284052],"length":1,"stats":{"Line":10}},{"line":941,"address":[3140899],"length":1,"stats":{"Line":10}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":948,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[3726248,3719787,3726208],"length":1,"stats":{"Line":32}},{"line":952,"address":[3291057,3290385],"length":1,"stats":{"Line":10}},{"line":953,"address":[],"length":0,"stats":{"Line":32}},{"line":956,"address":[],"length":0,"stats":{"Line":21}},{"line":957,"address":[3141207],"length":1,"stats":{"Line":10}},{"line":958,"address":[3277702,3284390],"length":1,"stats":{"Line":10}},{"line":959,"address":[7068212],"length":1,"stats":{"Line":11}},{"line":962,"address":[3141373,3141308],"length":1,"stats":{"Line":21}},{"line":963,"address":[7068455,7068362],"length":1,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[3277867,3284555],"length":1,"stats":{"Line":10}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[3063024],"length":1,"stats":{"Line":10}},{"line":975,"address":[3254289],"length":1,"stats":{"Line":9}},{"line":978,"address":[3254654,3259793,3255021,3254813],"length":1,"stats":{"Line":20}},{"line":979,"address":[],"length":0,"stats":{"Line":10}},{"line":980,"address":[5123498],"length":1,"stats":{"Line":9}},{"line":981,"address":[3141852],"length":1,"stats":{"Line":9}},{"line":982,"address":[],"length":0,"stats":{"Line":10}},{"line":985,"address":[3285430,3278742],"length":1,"stats":{"Line":9}},{"line":988,"address":[5124626,5124232],"length":1,"stats":{"Line":14}},{"line":990,"address":[3279414,3279363,3286051,3286102],"length":1,"stats":{"Line":8}},{"line":991,"address":[3143025,3142982],"length":1,"stats":{"Line":8}},{"line":993,"address":[3143010],"length":1,"stats":{"Line":0}},{"line":994,"address":[5124900,5124999],"length":1,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[3143339],"length":1,"stats":{"Line":0}},{"line":998,"address":[5073950],"length":1,"stats":{"Line":0}},{"line":999,"address":[3256160,3260672,3260725],"length":1,"stats":{"Line":0}},{"line":1003,"address":[7070050],"length":1,"stats":{"Line":4}},{"line":1005,"address":[3725904,3725872,3722326],"length":1,"stats":{"Line":12}},{"line":1006,"address":[3147877,3147797],"length":1,"stats":{"Line":4}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[3286816,3280124],"length":1,"stats":{"Line":4}},{"line":1015,"address":[5074311],"length":1,"stats":{"Line":4}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[3256546],"length":1,"stats":{"Line":4}},{"line":1019,"address":[],"length":0,"stats":{"Line":4}},{"line":1020,"address":[3147374,3147463],"length":1,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[5126076],"length":1,"stats":{"Line":4}},{"line":1027,"address":[3064444],"length":1,"stats":{"Line":9}},{"line":1028,"address":[7071489],"length":1,"stats":{"Line":10}},{"line":1031,"address":[7072185,7073997,7072026,7072393],"length":1,"stats":{"Line":20}},{"line":1032,"address":[3066192,3066116],"length":1,"stats":{"Line":21}},{"line":1033,"address":[3144735],"length":1,"stats":{"Line":10}},{"line":1034,"address":[5075401],"length":1,"stats":{"Line":11}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":11}},{"line":1040,"address":[],"length":0,"stats":{"Line":21}},{"line":1042,"address":[],"length":0,"stats":{"Line":21}},{"line":1045,"address":[3068880,3067507],"length":1,"stats":{"Line":21}},{"line":1047,"address":[3726318],"length":1,"stats":{"Line":11}},{"line":1048,"address":[5077825],"length":1,"stats":{"Line":10}},{"line":1053,"address":[],"length":0,"stats":{"Line":20}},{"line":1054,"address":[3259018],"length":1,"stats":{"Line":9}},{"line":1055,"address":[3725110,3725511],"length":1,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1060,"address":[3146531],"length":1,"stats":{"Line":9}},{"line":1061,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[3259085],"length":1,"stats":{"Line":9}},{"line":1063,"address":[],"length":0,"stats":{"Line":18}},{"line":1064,"address":[3147243],"length":1,"stats":{"Line":10}},{"line":1065,"address":[3147275],"length":1,"stats":{"Line":9}},{"line":1066,"address":[],"length":0,"stats":{"Line":10}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[3146544],"length":1,"stats":{"Line":10}},{"line":1072,"address":[3146595],"length":1,"stats":{"Line":9}},{"line":1073,"address":[3146661],"length":1,"stats":{"Line":9}},{"line":1074,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[5077300],"length":1,"stats":{"Line":11}},{"line":1080,"address":[],"length":0,"stats":{"Line":9}},{"line":1087,"address":[3145642],"length":1,"stats":{"Line":9}},{"line":1088,"address":[3067276,3067347],"length":1,"stats":{"Line":7}},{"line":1089,"address":[7072790],"length":1,"stats":{"Line":4}},{"line":1093,"address":[5073076],"length":1,"stats":{"Line":9}},{"line":1096,"address":[3142519],"length":1,"stats":{"Line":10}},{"line":1099,"address":[3068677,3064141,3068672],"length":1,"stats":{"Line":28}},{"line":1101,"address":[3142659],"length":1,"stats":{"Line":10}},{"line":1117,"address":[3739712,3752107,3755898],"length":1,"stats":{"Line":11}},{"line":1136,"address":[3305392,3321600],"length":1,"stats":{"Line":10}},{"line":1138,"address":[3082865],"length":1,"stats":{"Line":11}},{"line":1139,"address":[7088265],"length":1,"stats":{"Line":10}},{"line":1140,"address":[],"length":0,"stats":{"Line":11}},{"line":1142,"address":[3082910],"length":1,"stats":{"Line":10}},{"line":1144,"address":[],"length":0,"stats":{"Line":15}},{"line":1145,"address":[],"length":0,"stats":{"Line":0}},{"line":1146,"address":[],"length":0,"stats":{"Line":0}},{"line":1147,"address":[],"length":0,"stats":{"Line":0}},{"line":1148,"address":[],"length":0,"stats":{"Line":0}},{"line":1149,"address":[],"length":0,"stats":{"Line":0}},{"line":1153,"address":[],"length":0,"stats":{"Line":10}},{"line":1154,"address":[7089561],"length":1,"stats":{"Line":0}},{"line":1155,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[3740858],"length":1,"stats":{"Line":0}},{"line":1161,"address":[3306246,3322454],"length":1,"stats":{"Line":11}},{"line":1162,"address":[],"length":0,"stats":{"Line":0}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[7089896],"length":1,"stats":{"Line":0}},{"line":1169,"address":[3275181],"length":1,"stats":{"Line":10}},{"line":1170,"address":[5145072],"length":1,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1173,"address":[5093081],"length":1,"stats":{"Line":0}},{"line":1177,"address":[5145032],"length":1,"stats":{"Line":11}},{"line":1178,"address":[3307323,3323531],"length":1,"stats":{"Line":0}},{"line":1179,"address":[],"length":0,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":0}},{"line":1181,"address":[3163171],"length":1,"stats":{"Line":0}},{"line":1185,"address":[5093406,5093741,5093826],"length":1,"stats":{"Line":21}},{"line":1186,"address":[5093812],"length":1,"stats":{"Line":11}},{"line":1188,"address":[3085099,3098864,3098832],"length":1,"stats":{"Line":30}},{"line":1190,"address":[5093908],"length":1,"stats":{"Line":0}},{"line":1191,"address":[5145844],"length":1,"stats":{"Line":0}},{"line":1195,"address":[5093859],"length":1,"stats":{"Line":10}},{"line":1196,"address":[5094154],"length":1,"stats":{"Line":0}},{"line":1197,"address":[3324207,3307999],"length":1,"stats":{"Line":0}},{"line":1202,"address":[3085312,3085360,3085571],"length":1,"stats":{"Line":22}},{"line":1203,"address":[3742472],"length":1,"stats":{"Line":12}},{"line":1204,"address":[3177504,3177529,3163763],"length":1,"stats":{"Line":36}},{"line":1205,"address":[5094040,5108240],"length":1,"stats":{"Line":12}},{"line":1206,"address":[5108287],"length":1,"stats":{"Line":0}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1208,"address":[3177870],"length":1,"stats":{"Line":0}},{"line":1212,"address":[3276822,3276906],"length":1,"stats":{"Line":11}},{"line":1213,"address":[3308277,3324485],"length":1,"stats":{"Line":11}},{"line":1215,"address":[],"length":0,"stats":{"Line":11}},{"line":1216,"address":[5146456],"length":1,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1223,"address":[3164636,3164183,3164608],"length":1,"stats":{"Line":19}},{"line":1224,"address":[3086189],"length":1,"stats":{"Line":10}},{"line":1225,"address":[],"length":0,"stats":{"Line":9}},{"line":1226,"address":[3164865,3177081],"length":1,"stats":{"Line":20}},{"line":1231,"address":[3743611],"length":1,"stats":{"Line":10}},{"line":1232,"address":[3086495,3098913,3098896],"length":1,"stats":{"Line":28}},{"line":1236,"address":[5147317,5147194],"length":1,"stats":{"Line":19}},{"line":1237,"address":[3325447,3309239],"length":1,"stats":{"Line":11}},{"line":1242,"address":[5147423,5159520],"length":1,"stats":{"Line":13}},{"line":1243,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":4}},{"line":1245,"address":[3177370],"length":1,"stats":{"Line":4}},{"line":1246,"address":[3338225,3339921],"length":1,"stats":{"Line":4}},{"line":1247,"address":[3100442,3100131,3099245,3100080,3100448],"length":1,"stats":{"Line":12}},{"line":1248,"address":[3100149],"length":1,"stats":{"Line":4}},{"line":1249,"address":[7105972,7106058],"length":1,"stats":{"Line":8}},{"line":1250,"address":[3341733,3341600,3340618,3341398,3341680,3341653,3341466,3340686],"length":1,"stats":{"Line":16}},{"line":1252,"address":[3177413],"length":1,"stats":{"Line":4}},{"line":1255,"address":[7092722,7105600],"length":1,"stats":{"Line":14}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1257,"address":[3099992],"length":1,"stats":{"Line":4}},{"line":1258,"address":[5107963],"length":1,"stats":{"Line":4}},{"line":1259,"address":[],"length":0,"stats":{"Line":0}},{"line":1260,"address":[3290758],"length":1,"stats":{"Line":4}},{"line":1261,"address":[3100035,3100464,3100820,3100826],"length":1,"stats":{"Line":8}},{"line":1262,"address":[3178893],"length":1,"stats":{"Line":4}},{"line":1263,"address":[3178994,3178908],"length":1,"stats":{"Line":8}},{"line":1264,"address":[5161472,5160878,5160948,5161525],"length":1,"stats":{"Line":16}},{"line":1266,"address":[3290791],"length":1,"stats":{"Line":4}},{"line":1270,"address":[3278105],"length":1,"stats":{"Line":9}},{"line":1273,"address":[],"length":0,"stats":{"Line":19}},{"line":1274,"address":[3278504],"length":1,"stats":{"Line":10}},{"line":1275,"address":[7093438],"length":1,"stats":{"Line":9}},{"line":1276,"address":[],"length":0,"stats":{"Line":0}},{"line":1278,"address":[3087663,3099120,3099155],"length":1,"stats":{"Line":30}},{"line":1283,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1285,"address":[],"length":0,"stats":{"Line":9}},{"line":1286,"address":[],"length":0,"stats":{"Line":0}},{"line":1287,"address":[],"length":0,"stats":{"Line":0}},{"line":1288,"address":[],"length":0,"stats":{"Line":0}},{"line":1289,"address":[3745050],"length":1,"stats":{"Line":10}},{"line":1290,"address":[],"length":0,"stats":{"Line":0}},{"line":1291,"address":[3279129],"length":1,"stats":{"Line":9}},{"line":1293,"address":[3166953],"length":1,"stats":{"Line":9}},{"line":1295,"address":[3311209,3327417],"length":1,"stats":{"Line":9}},{"line":1296,"address":[3176805],"length":1,"stats":{"Line":0}},{"line":1297,"address":[3088694],"length":1,"stats":{"Line":0}},{"line":1300,"address":[5149405,5149329],"length":1,"stats":{"Line":19}},{"line":1301,"address":[3098082],"length":1,"stats":{"Line":0}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1303,"address":[3088779],"length":1,"stats":{"Line":0}},{"line":1306,"address":[3088745,3088832],"length":1,"stats":{"Line":19}},{"line":1309,"address":[3746001],"length":1,"stats":{"Line":9}},{"line":1310,"address":[],"length":0,"stats":{"Line":0}},{"line":1312,"address":[3099827,3088947,3099792],"length":1,"stats":{"Line":32}},{"line":1315,"address":[3089048,3088985],"length":1,"stats":{"Line":20}},{"line":1316,"address":[3097749],"length":1,"stats":{"Line":0}},{"line":1317,"address":[],"length":0,"stats":{"Line":0}},{"line":1318,"address":[],"length":0,"stats":{"Line":0}},{"line":1319,"address":[3746243,3754885],"length":1,"stats":{"Line":0}},{"line":1324,"address":[3167490],"length":1,"stats":{"Line":9}},{"line":1325,"address":[],"length":0,"stats":{"Line":19}},{"line":1327,"address":[3756320,3746600,3756330,3754175],"length":1,"stats":{"Line":18}},{"line":1328,"address":[],"length":0,"stats":{"Line":9}},{"line":1329,"address":[3754335,3754425],"length":1,"stats":{"Line":9}},{"line":1330,"address":[3754498,3754570],"length":1,"stats":{"Line":0}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1334,"address":[5106073,5105969],"length":1,"stats":{"Line":9}},{"line":1336,"address":[3754858,3754381],"length":1,"stats":{"Line":0}},{"line":1337,"address":[3288881],"length":1,"stats":{"Line":0}},{"line":1342,"address":[5150155],"length":1,"stats":{"Line":9}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1345,"address":[3089509],"length":1,"stats":{"Line":10}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1348,"address":[],"length":0,"stats":{"Line":10}},{"line":1350,"address":[3746916],"length":1,"stats":{"Line":10}},{"line":1352,"address":[3746931],"length":1,"stats":{"Line":11}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1362,"address":[5098568],"length":1,"stats":{"Line":9}},{"line":1364,"address":[],"length":0,"stats":{"Line":0}},{"line":1365,"address":[3089921,3089967],"length":1,"stats":{"Line":8}},{"line":1366,"address":[],"length":0,"stats":{"Line":0}},{"line":1367,"address":[3168507],"length":1,"stats":{"Line":4}},{"line":1368,"address":[],"length":0,"stats":{"Line":4}},{"line":1371,"address":[7096134],"length":1,"stats":{"Line":4}},{"line":1372,"address":[5098987],"length":1,"stats":{"Line":4}},{"line":1373,"address":[3090296],"length":1,"stats":{"Line":4}},{"line":1375,"address":[5151283,5150985],"length":1,"stats":{"Line":8}},{"line":1376,"address":[],"length":0,"stats":{"Line":0}},{"line":1377,"address":[5099098],"length":1,"stats":{"Line":4}},{"line":1378,"address":[],"length":0,"stats":{"Line":4}},{"line":1379,"address":[3169019],"length":1,"stats":{"Line":4}},{"line":1381,"address":[5099568,5099456],"length":1,"stats":{"Line":8}},{"line":1382,"address":[3748036,3748115],"length":1,"stats":{"Line":4}},{"line":1383,"address":[3169470,3169424,3169366],"length":1,"stats":{"Line":8}},{"line":1384,"address":[3748152,3748227],"length":1,"stats":{"Line":8}},{"line":1387,"address":[3169515],"length":1,"stats":{"Line":4}},{"line":1388,"address":[3174051],"length":1,"stats":{"Line":0}},{"line":1389,"address":[],"length":0,"stats":{"Line":0}},{"line":1390,"address":[3748276],"length":1,"stats":{"Line":0}},{"line":1391,"address":[5151811],"length":1,"stats":{"Line":0}},{"line":1392,"address":[5155844,5155780],"length":1,"stats":{"Line":0}},{"line":1393,"address":[3095208,3095151],"length":1,"stats":{"Line":0}},{"line":1394,"address":[3317892,3334100],"length":1,"stats":{"Line":0}},{"line":1395,"address":[],"length":0,"stats":{"Line":0}},{"line":1396,"address":[3317908,3334116],"length":1,"stats":{"Line":0}},{"line":1397,"address":[5156021],"length":1,"stats":{"Line":0}},{"line":1398,"address":[3173845],"length":1,"stats":{"Line":0}},{"line":1399,"address":[],"length":0,"stats":{"Line":0}},{"line":1400,"address":[5104154],"length":1,"stats":{"Line":0}},{"line":1402,"address":[5104404,5104468],"length":1,"stats":{"Line":0}},{"line":1403,"address":[5104455],"length":1,"stats":{"Line":0}},{"line":1404,"address":[],"length":0,"stats":{"Line":0}},{"line":1407,"address":[5099800],"length":1,"stats":{"Line":4}},{"line":1410,"address":[3313748,3329956],"length":1,"stats":{"Line":4}},{"line":1411,"address":[],"length":0,"stats":{"Line":0}},{"line":1412,"address":[3748589],"length":1,"stats":{"Line":4}},{"line":1413,"address":[],"length":0,"stats":{"Line":0}},{"line":1416,"address":[3282710],"length":1,"stats":{"Line":4}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1418,"address":[3314284,3330379,3330492,3314171],"length":1,"stats":{"Line":8}},{"line":1420,"address":[3314217,3330425],"length":1,"stats":{"Line":0}},{"line":1421,"address":[7097605,7097704],"length":1,"stats":{"Line":0}},{"line":1422,"address":[],"length":0,"stats":{"Line":0}},{"line":1423,"address":[3170293,3170367],"length":1,"stats":{"Line":0}},{"line":1424,"address":[3283119],"length":1,"stats":{"Line":0}},{"line":1425,"address":[7097855],"length":1,"stats":{"Line":0}},{"line":1426,"address":[3756240,3749188,3756293],"length":1,"stats":{"Line":0}},{"line":1431,"address":[3170547,3170157,3170598],"length":1,"stats":{"Line":8}},{"line":1432,"address":[3170583,3170667],"length":1,"stats":{"Line":8}},{"line":1433,"address":[],"length":0,"stats":{"Line":0}},{"line":1434,"address":[],"length":0,"stats":{"Line":0}},{"line":1438,"address":[7098225,7098297],"length":1,"stats":{"Line":4}},{"line":1439,"address":[5101212,5101122],"length":1,"stats":{"Line":8}},{"line":1440,"address":[5101286],"length":1,"stats":{"Line":4}},{"line":1442,"address":[5101322],"length":1,"stats":{"Line":4}},{"line":1443,"address":[],"length":0,"stats":{"Line":0}},{"line":1444,"address":[3750021,3749946],"length":1,"stats":{"Line":8}},{"line":1445,"address":[3173526,3171346],"length":1,"stats":{"Line":0}},{"line":1448,"address":[3284100,3284052,3286257],"length":1,"stats":{"Line":8}},{"line":1451,"address":[],"length":0,"stats":{"Line":0}},{"line":1452,"address":[],"length":0,"stats":{"Line":0}},{"line":1453,"address":[3171596],"length":1,"stats":{"Line":4}},{"line":1454,"address":[3315843,3332051],"length":1,"stats":{"Line":4}},{"line":1455,"address":[3171762],"length":1,"stats":{"Line":4}},{"line":1456,"address":[3315969,3332177],"length":1,"stats":{"Line":4}},{"line":1458,"address":[5154240,5160208,5160554],"length":1,"stats":{"Line":4}},{"line":1459,"address":[7104902,7104822],"length":1,"stats":{"Line":0}},{"line":1460,"address":[],"length":0,"stats":{"Line":0}},{"line":1463,"address":[3093903],"length":1,"stats":{"Line":4}},{"line":1466,"address":[3285802],"length":1,"stats":{"Line":4}},{"line":1467,"address":[],"length":0,"stats":{"Line":0}},{"line":1468,"address":[7099872],"length":1,"stats":{"Line":4}},{"line":1469,"address":[3094029],"length":1,"stats":{"Line":4}},{"line":1470,"address":[3094124,3094060],"length":1,"stats":{"Line":4}},{"line":1471,"address":[5154834,5154777],"length":1,"stats":{"Line":8}},{"line":1472,"address":[7100126],"length":1,"stats":{"Line":4}},{"line":1473,"address":[],"length":0,"stats":{"Line":0}},{"line":1474,"address":[3172717],"length":1,"stats":{"Line":4}},{"line":1475,"address":[5154974],"length":1,"stats":{"Line":4}},{"line":1476,"address":[3094366],"length":1,"stats":{"Line":4}},{"line":1477,"address":[5155102],"length":1,"stats":{"Line":4}},{"line":1478,"address":[5103170],"length":1,"stats":{"Line":4}},{"line":1481,"address":[5155495,5155421],"length":1,"stats":{"Line":4}},{"line":1482,"address":[3173239],"length":1,"stats":{"Line":4}},{"line":1484,"address":[3333599,3317391],"length":1,"stats":{"Line":4}},{"line":1488,"address":[7096663],"length":1,"stats":{"Line":4}},{"line":1491,"address":[5098636],"length":1,"stats":{"Line":5}},{"line":1492,"address":[3095898,3095803],"length":1,"stats":{"Line":10}},{"line":1493,"address":[],"length":0,"stats":{"Line":6}},{"line":1494,"address":[3096776,3096027,3096720],"length":1,"stats":{"Line":11}},{"line":1495,"address":[3096805,3096730],"length":1,"stats":{"Line":12}},{"line":1496,"address":[3096921,3096832],"length":1,"stats":{"Line":13}},{"line":1500,"address":[3318625,3334833],"length":1,"stats":{"Line":7}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[],"length":0,"stats":{"Line":0}},{"line":1504,"address":[3753228],"length":1,"stats":{"Line":6}},{"line":1505,"address":[3753362],"length":1,"stats":{"Line":7}},{"line":1506,"address":[3287433],"length":1,"stats":{"Line":6}},{"line":1507,"address":[3096336],"length":1,"stats":{"Line":7}},{"line":1508,"address":[3287567],"length":1,"stats":{"Line":6}},{"line":1510,"address":[3753731],"length":1,"stats":{"Line":5}},{"line":1511,"address":[5105294],"length":1,"stats":{"Line":6}},{"line":1514,"address":[3747999],"length":1,"stats":{"Line":9}},{"line":1517,"address":[5148035],"length":1,"stats":{"Line":10}},{"line":1519,"address":[3744533],"length":1,"stats":{"Line":10}}],"covered":530,"coverable":762},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","pcs","mmcs.rs"],"content":"use alloc::vec;\nuse alloc::vec::Vec;\nuse core::cmp::min;\n\nuse p3_circuit::op::{NonPrimitiveOpPrivateData, Poseidon2Config};\nuse p3_circuit::ops::poseidon2_perm::Poseidon2PermOps;\nuse p3_circuit::ops::{Poseidon2PermCall, Poseidon2PermPrivateData};\nuse p3_circuit::{CircuitBuilder, CircuitBuilderError, CircuitRunner, NonPrimitiveOpId};\nuse p3_commit::BatchOpening;\nuse p3_field::{BasedVectorSpace, ExtensionField, Field, PrimeField64, TwoAdicField};\nuse p3_fri::FriProof;\nuse p3_matrix::Dimensions;\n\nuse crate::Target;\n\n/// Hash base field coefficients using overwrite-mode sponge (matching native PaddingFreeSponge).\n///\n/// Native `PaddingFreeSponge` uses \"overwrite mode\": when absorbing a partial chunk,\n/// only the absorbed positions are overwritten; the remaining rate positions keep their\n/// values from the previous permutation output.\n///\n/// This function implements the same behavior in the circuit by:\n/// 1. Processing base coefficients in chunks of `rate` (8 for BabyBear)\n/// 2. For partial chunks, mixing absorbed values with previous output for remaining positions\n/// 3. Using proper chaining for the capacity portion\n///\n/// # Parameters\n/// - `circuit`: Circuit builder\n/// - `permutation_config`: Poseidon2 configuration\n/// - `base_coeffs`: Base field coefficient targets (in lifted representation)\n/// - `reset`: If true, starts a new hash chain (initial state = zeros)\nfn add_hash_base_coeffs_overwrite\u003cF, EF\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cEF\u003e,\n    permutation_config: \u0026Poseidon2Config,\n    base_coeffs: \u0026[Target],\n    reset: bool,\n) -\u003e Result\u003cVec\u003cTarget\u003e, CircuitBuilderError\u003e\nwhere\n    F: Field + PrimeField64,\n    EF: ExtensionField\u003cF\u003e,\n{\n    if base_coeffs.is_empty() {\n        // Return zeros for empty input (shouldn't happen in practice)\n        let zero = circuit.define_const(EF::ZERO);\n        return Ok(vec![zero, zero]);\n    }\n\n    let ext_degree = \u003cEF as BasedVectorSpace\u003cF\u003e\u003e::DIMENSION;\n    let rate = permutation_config.rate(); // Base field rate (8 for BabyBear)\n    let rate_ext = permutation_config.rate_ext(); // Extension rate (2 for D=4)\n\n    // Process in chunks of `rate` base field values\n    let num_chunks = base_coeffs.len().div_ceil(rate);\n    // Only store rate outputs (0-1) for overwrite mode chaining\n    let mut last_rate_outputs: Option\u003c[Target; 2]\u003e = None;\n    let mut final_outputs = [None, None, None, None];\n\n    for (chunk_idx, chunk) in base_coeffs.chunks(rate).enumerate() {\n        let is_first = chunk_idx == 0;\n        let is_last = chunk_idx == num_chunks - 1;\n\n        // Build inputs for this permutation\n        // Rate portion (inputs[0..rate_ext]): absorbed values with overwrite semantics\n        // Capacity portion (inputs[rate_ext..4]): None for chaining\n        let mut inputs: [Option\u003cTarget\u003e; 4] = [None; 4];\n\n        for ext_idx in 0..rate_ext {\n            let base_start = ext_idx * ext_degree;\n            let num_values_in_ext = min(ext_degree, chunk.len().saturating_sub(base_start));\n\n            if num_values_in_ext == 0 {\n                // No values for this extension position - use None for chaining\n                // This keeps the previous output (overwrite mode)\n                inputs[ext_idx] = None;\n            } else if num_values_in_ext == ext_degree {\n                // Full extension element - just recompose our values\n                let ext_coeffs: Vec\u003c_\u003e = (0..ext_degree).map(|i| chunk[base_start + i]).collect();\n                inputs[ext_idx] = Some(circuit.recompose_base_coeffs_to_ext::\u003cF\u003e(\u0026ext_coeffs)?);\n            } else {\n                // Partial extension element - mix with previous output (overwrite mode)\n                // This is the key fix: unused positions keep previous permutation output\n                let prev_coeffs: Option\u003cVec\u003cTarget\u003e\u003e = if !is_first {\n                    if let Some(ref prev_rate) = last_rate_outputs {\n                        Some(circuit.decompose_ext_to_base_coeffs::\u003cF\u003e(prev_rate[ext_idx])?)\n                    } else {\n                        None\n                    }\n                } else {\n                    None\n                };\n\n                let mut ext_coeffs = Vec::with_capacity(ext_degree);\n                for coeff_idx in 0..ext_degree {\n                    if coeff_idx \u003c num_values_in_ext {\n                        // Use our absorbed value\n                        ext_coeffs.push(chunk[base_start + coeff_idx]);\n                    } else if let Some(ref prev) = prev_coeffs {\n                        // Overwrite mode: keep previous output for this position\n                        ext_coeffs.push(prev[coeff_idx]);\n                    } else {\n                        // First permutation with new_start, use zero\n                        ext_coeffs.push(circuit.define_const(EF::ZERO));\n                    }\n                }\n\n                inputs[ext_idx] = Some(circuit.recompose_base_coeffs_to_ext::\u003cF\u003e(\u0026ext_coeffs)?);\n            }\n        }\n\n        // Capacity positions (rate_ext..4) are None for chaining from previous permutation\n\n        // Add permutation\n        // Always get rate outputs (0-1) for potential chaining; capacity outputs not needed\n        let (_, maybe_outputs) = circuit.add_poseidon2_perm(Poseidon2PermCall {\n            config: *permutation_config,\n            new_start: if is_first { reset } else { false },\n            merkle_path: false,\n            mmcs_bit: None,\n            inputs,\n            out_ctl: [true, true],     // Always expose rate outputs\n            return_all_outputs: false, // Don't need capacity outputs\n            mmcs_index_sum: None,\n        })?;\n\n        // Store rate outputs for next iteration (for overwrite mode chaining)\n        if !is_last {\n            // Only need rate outputs (0-1) for overwrite mode - capacity is handled by chaining\n            last_rate_outputs = Some([\n                maybe_outputs[0].ok_or(CircuitBuilderError::MissingOutput)?,\n                maybe_outputs[1].ok_or(CircuitBuilderError::MissingOutput)?,\n            ]);\n        }\n\n        final_outputs = maybe_outputs;\n    }\n\n    // Return rate outputs (0-1) as the hash digest\n    [final_outputs[0], final_outputs[1]]\n        .into_iter()\n        .map(|o| o.ok_or(CircuitBuilderError::MissingOutput))\n        .collect()\n}\n\n/// Hash extension field elements directly (no recompose). Use when values are already\n/// extension elements (e.g. FRI commit-phase evals). Absorbs in chunks of `rate_ext`.\nfn add_hash_extension_elements\u003cF, EF\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cEF\u003e,\n    permutation_config: \u0026Poseidon2Config,\n    ext_elements: \u0026[Target],\n    reset: bool,\n) -\u003e Result\u003cVec\u003cTarget\u003e, CircuitBuilderError\u003e\nwhere\n    F: Field + PrimeField64,\n    EF: ExtensionField\u003cF\u003e,\n{\n    let rate_ext = permutation_config.rate_ext();\n    if ext_elements.is_empty() {\n        let zero = circuit.define_const(EF::ZERO);\n        return Ok(vec![zero, zero]);\n    }\n\n    let zero = circuit.define_const(EF::ZERO);\n    let mut last_rate_outputs: Option\u003c[Target; 2]\u003e = None;\n    let mut final_outputs = [None, None, None, None];\n\n    for (i, chunk) in ext_elements.chunks(rate_ext).enumerate() {\n        let is_first = i == 0;\n        let mut inputs: [Option\u003cTarget\u003e; 4] = [None; 4];\n        for (j, \u0026t) in chunk.iter().enumerate() {\n            inputs[j] = Some(t);\n        }\n        for j in chunk.len()..rate_ext {\n            inputs[j] = Some(if is_first {\n                zero\n            } else {\n                last_rate_outputs.map(|o| o[j]).unwrap_or(zero)\n            });\n        }\n\n        let (_, maybe_outputs) = circuit.add_poseidon2_perm(Poseidon2PermCall {\n            config: *permutation_config,\n            new_start: is_first \u0026\u0026 reset,\n            merkle_path: false,\n            mmcs_bit: None,\n            inputs,\n            out_ctl: [true, true],\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })?;\n\n        if chunk.len() == rate_ext {\n            last_rate_outputs = Some([\n                maybe_outputs[0].ok_or(CircuitBuilderError::MissingOutput)?,\n                maybe_outputs[1].ok_or(CircuitBuilderError::MissingOutput)?,\n            ]);\n        }\n        final_outputs = maybe_outputs;\n    }\n\n    [final_outputs[0], final_outputs[1]]\n        .into_iter()\n        .map(|o| o.ok_or(CircuitBuilderError::MissingOutput))\n        .collect()\n}\n\n/// Recursive version of `MerkleTreeMmcs::verify_batch`. Adds a circuit that verifies an opened\n/// batch of rows with respect to a given commitment (Merkle cap).\n///\n/// - `circuit`: The circuit builder to which we add the verify_batch circuit\n/// - `commitment_cap`: The Merkle cap entries. Each inner slice has `rate_ext` packed extension\n///   targets representing one cap entry. A single-element cap (`cap_height = 0`) corresponds to\n///   the traditional single root.\n/// - `dimensions`: A vector of the dimensions of the matrices committed to.\n/// - `index_bits`: The little-endian binary decomposition of the index of a leaf in the tree.\n///   Length must equal `log2_ceil(max_height)`.\n/// - `opened_values`: A vector of matrix rows (packed extension field targets).\n///\n/// Returns the list of permutation operations requiring private data, otherwise returns an error.\n///\n/// # Merkle Cap Support\n///\n/// The Merkle cap of height `h` is the `h`-th layer from the root. A cap of height 0 is the root\n/// itself. When `cap_height \u003e 0`, the opening proof is `cap_height` elements shorter and the\n/// remaining upper index bits select the correct cap entry to verify against.\n///\n/// # Parameters\n/// - `circuit`: The circuit builder\n/// - `permutation_config`: Poseidon2 configuration\n/// - `commitment_cap`: Merkle cap entries, each with `rate_ext` packed extension targets\n/// - `dimensions`: Matrix dimensions (height used for tree structure)\n/// - `index_bits`: All Merkle path direction bits (length = `log_max_height`)\n/// - `opened_base_coeffs`: Base field coefficients per matrix (already decomposed)\npub fn verify_batch_circuit\u003cF, EF\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cEF\u003e,\n    permutation_config: Poseidon2Config,\n    commitment_cap: \u0026[Vec\u003cTarget\u003e],\n    dimensions: \u0026[Dimensions],\n    index_bits: \u0026[Target],\n    opened_base_coeffs: \u0026[Vec\u003cTarget\u003e],\n) -\u003e Result\u003cVec\u003cNonPrimitiveOpId\u003e, CircuitBuilderError\u003e\nwhere\n    F: Field + TwoAdicField + PrimeField64,\n    EF: ExtensionField\u003cF\u003e,\n{\n    use p3_circuit::ops::mmcs::add_mmcs_verify;\n    use p3_util::log2_strict_usize;\n\n    if dimensions.len() != opened_base_coeffs.len() {\n        return Err(CircuitBuilderError::WrongBatchSize {\n            expected: dimensions.len(),\n            got: opened_base_coeffs.len(),\n        });\n    }\n\n    assert!(\n        !commitment_cap.is_empty(),\n        \"commitment cap must have at least one entry\"\n    );\n\n    use core::cmp::Reverse;\n\n    use itertools::Itertools;\n\n    // Derive cap_height from commitment size: cap has 2^cap_height entries\n    let cap_height = if commitment_cap.len() == 1 {\n        0\n    } else {\n        log2_strict_usize(commitment_cap.len())\n    };\n\n    let max_height_log = index_bits.len();\n    let path_depth = max_height_log - cap_height;\n\n    // Split index_bits into path bits (for Merkle traversal) and cap index bits\n    let path_bits = \u0026index_bits[..path_depth];\n    let cap_index_bits = \u0026index_bits[path_depth..];\n\n    // Select the correct cap entry using a multiplexer\n    let selected_root = select_cap_entry(circuit, commitment_cap, cap_index_bits);\n\n    // Group matrices by height level (matching format_openings logic)\n    // Native MMCS combines all matrices at the same height THEN hashes them together\n    let mut heights_tallest_first = dimensions\n        .iter()\n        .enumerate()\n        .sorted_by_key(|(_, dims)| Reverse(dims.height))\n        .peekable();\n\n    // Build digests for path_depth levels (the Merkle path below the cap) plus one\n    // extra level for matrices whose heights match the cap level. In the native MMCS,\n    // these cap-level rows are injected after the last sibling compression.\n    let digest_levels = path_depth + 1;\n    let mut formatted_digests = vec![vec![]; digest_levels];\n    for (i, digest) in formatted_digests.iter_mut().enumerate() {\n        let curr_height = 1 \u003c\u003c (max_height_log - i);\n\n        // Collect all base coefficients from matrices at this height level\n        let all_base_coeffs: Vec\u003cTarget\u003e = heights_tallest_first\n            .peeking_take_while(|(_, dims)| dims.height.next_power_of_two() == curr_height)\n            .flat_map(|(mat_idx, _)| opened_base_coeffs[mat_idx].clone())\n            .collect();\n\n        if all_base_coeffs.is_empty() {\n            continue;\n        }\n\n        // Hash using overwrite-mode sponge (matching native PaddingFreeSponge)\n        *digest = add_hash_base_coeffs_overwrite::\u003cF, EF\u003e(\n            circuit,\n            \u0026permutation_config,\n            \u0026all_base_coeffs,\n            true,\n        )?;\n    }\n\n    let op_vals_digests = formatted_digests;\n\n    add_mmcs_verify(\n        circuit,\n        permutation_config,\n        \u0026op_vals_digests,\n        path_bits,\n        \u0026selected_root,\n    )\n}\n\n/// Like `verify_batch_circuit` but opened values are already extension elements (no decompose).\n/// Use for FRI commit-phase where evals are extension and only the challenger needs base form.\npub fn verify_batch_circuit_from_extension_opened\u003cF, EF\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cEF\u003e,\n    permutation_config: Poseidon2Config,\n    commitment_cap: \u0026[Vec\u003cTarget\u003e],\n    dimensions: \u0026[Dimensions],\n    index_bits: \u0026[Target],\n    opened_extension_values: \u0026[Vec\u003cTarget\u003e],\n) -\u003e Result\u003cVec\u003cNonPrimitiveOpId\u003e, CircuitBuilderError\u003e\nwhere\n    F: Field + TwoAdicField + PrimeField64,\n    EF: ExtensionField\u003cF\u003e,\n{\n    use core::cmp::Reverse;\n\n    use itertools::Itertools;\n    use p3_circuit::ops::mmcs::add_mmcs_verify;\n    use p3_util::log2_strict_usize;\n\n    if dimensions.len() != opened_extension_values.len() {\n        return Err(CircuitBuilderError::WrongBatchSize {\n            expected: dimensions.len(),\n            got: opened_extension_values.len(),\n        });\n    }\n\n    assert!(\n        !commitment_cap.is_empty(),\n        \"commitment cap must have at least one entry\"\n    );\n\n    let cap_height = if commitment_cap.len() == 1 {\n        0\n    } else {\n        log2_strict_usize(commitment_cap.len())\n    };\n\n    let max_height_log = index_bits.len();\n    let path_depth = max_height_log - cap_height;\n    let path_bits = \u0026index_bits[..path_depth];\n    let cap_index_bits = \u0026index_bits[path_depth..];\n\n    let selected_root = select_cap_entry(circuit, commitment_cap, cap_index_bits);\n\n    let mut heights_tallest_first = dimensions\n        .iter()\n        .enumerate()\n        .sorted_by_key(|(_, dims)| Reverse(dims.height))\n        .peekable();\n\n    let digest_levels = path_depth + 1;\n    let mut formatted_digests = vec![vec![]; digest_levels];\n    for (i, digest) in formatted_digests.iter_mut().enumerate() {\n        let curr_height = 1 \u003c\u003c (max_height_log - i);\n\n        let all_ext: Vec\u003cTarget\u003e = heights_tallest_first\n            .peeking_take_while(|(_, dims)| dims.height.next_power_of_two() == curr_height)\n            .flat_map(|(mat_idx, _)| opened_extension_values[mat_idx].clone())\n            .collect();\n\n        if all_ext.is_empty() {\n            continue;\n        }\n\n        *digest =\n            add_hash_extension_elements::\u003cF, EF\u003e(circuit, \u0026permutation_config, \u0026all_ext, true)?;\n    }\n\n    add_mmcs_verify(\n        circuit,\n        permutation_config,\n        \u0026formatted_digests,\n        path_bits,\n        \u0026selected_root,\n    )\n}\n\n/// Select one cap entry from a Merkle cap using a binary tree multiplexer.\n///\n/// For `cap_height = 0` (single entry), returns the entry directly.\n/// For `cap_height \u003e 0`, progressively halves the candidates using one index bit\n/// at each level. Each selection step computes `left + bit * (right - left)` per\n/// component, requiring only one multiplication per component per level.\n///\n/// Total cost: `rate_ext * (2^cap_height - 1)` multiplications, compared to\n/// `(cap_height + rate_ext) * 2^cap_height` for the one-hot + dot-product approach.\nfn select_cap_entry\u003cEF: Field\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cEF\u003e,\n    cap: \u0026[Vec\u003cTarget\u003e],\n    index_bits: \u0026[Target],\n) -\u003e Vec\u003cTarget\u003e {\n    if cap.len() == 1 {\n        return cap[0].clone();\n    }\n\n    debug_assert_eq!(cap.len(), 1 \u003c\u003c index_bits.len());\n\n    let rate_ext = cap[0].len();\n\n    // Binary tree selection: each bit halves the number of candidates.\n    // bit[0] (LSB) selects between adjacent pairs, bit[1] between groups of 4, etc.\n    let mut current: Vec\u003cVec\u003cTarget\u003e\u003e = cap.to_vec();\n\n    for \u0026bit in index_bits {\n        let half = current.len() / 2;\n        let mut next = Vec::with_capacity(half);\n        for i in 0..half {\n            let left = \u0026current[2 * i];\n            let right = \u0026current[2 * i + 1];\n            let mut selected = Vec::with_capacity(rate_ext);\n            for j in 0..rate_ext {\n                // left[j] + bit * (right[j] - left[j])\n                let diff = circuit.sub(right[j], left[j]);\n                let term = circuit.mul(bit, diff);\n                let val = circuit.add(left[j], term);\n                selected.push(val);\n            }\n            next.push(selected);\n        }\n        current = next;\n    }\n\n    debug_assert_eq!(current.len(), 1);\n    current.into_iter().next().unwrap()\n}\n\n/// Convert a base field Merkle proof to extension field sibling values.\n///\n/// Each sibling hash in the proof has `DIGEST_ELEMS` base field elements.\n/// These are packed into extension field elements (EF::DIMENSION base elements per extension element).\n/// The result is `rate_ext` extension field elements per sibling.\nfn convert_merkle_proof_to_siblings\u003cF, EF, const DIGEST_ELEMS: usize\u003e(\n    opening_proof: \u0026[[F; DIGEST_ELEMS]],\n) -\u003e Vec\u003c[EF; 2]\u003e\nwhere\n    F: Field,\n    EF: ExtensionField\u003cF\u003e + BasedVectorSpace\u003cF\u003e,\n{\n    opening_proof\n        .iter()\n        .map(|digest| {\n            // Pack base field elements into extension field elements\n            let ext_elements: Vec\u003cEF\u003e = digest\n                .chunks(EF::DIMENSION)\n                .map(|chunk| {\n                    EF::from_basis_coefficients_slice(chunk)\n                        .expect(\"chunk size should match extension degree\")\n                })\n                .collect();\n            // For Poseidon2 MMCS, we expect exactly 2 extension elements per sibling\n            debug_assert_eq!(\n                ext_elements.len(),\n                2,\n                \"Expected 2 extension elements per sibling, got {}\",\n                ext_elements.len()\n            );\n            [ext_elements[0], ext_elements[1]]\n        })\n        .collect()\n}\n\n/// Set private data for FRI MMCS verification operations.\n///\n/// This function extracts Merkle sibling values from a FRI proof and sets them\n/// as private data for the circuit operations returned by `verify_fri_circuit`.\n///\n/// # Parameters\n/// - `runner`: The circuit runner to set private data on\n/// - `op_ids`: Operation IDs returned by `verify_fri_circuit`\n/// - `fri_proof`: The FRI proof containing Merkle proofs\n///\n/// # Returns\n/// `Ok(())` if all private data was set successfully, or an error if there was a mismatch.\n///\n/// # Operation ID Order\n/// The `op_ids` are expected in the following order (matching `verify_fri_circuit`):\n/// 1. For each query:\n///    - Input batch MMCS ops (one per batch, each with `path_depth` siblings)\n///    - Commit-phase MMCS ops (one per phase, each with `phase_depth` siblings)\npub fn set_fri_mmcs_private_data\u003cF, EF, FriMmcs, InputMmcs, H, C, const DIGEST_ELEMS: usize\u003e(\n    runner: \u0026mut CircuitRunner\u003cEF\u003e,\n    op_ids: \u0026[NonPrimitiveOpId],\n    fri_proof: \u0026FriProof\u003cEF, FriMmcs, F, Vec\u003cBatchOpening\u003cF, InputMmcs\u003e\u003e\u003e,\n) -\u003e Result\u003c(), \u0026'static str\u003e\nwhere\n    F: Field,\n    EF: ExtensionField\u003cF\u003e + BasedVectorSpace\u003cF\u003e,\n    FriMmcs: p3_commit::Mmcs\u003cEF, Proof = Vec\u003c[F; DIGEST_ELEMS]\u003e\u003e,\n    InputMmcs: p3_commit::Mmcs\u003cF, Proof = Vec\u003c[F; DIGEST_ELEMS]\u003e\u003e,\n    H: p3_symmetric::CryptographicHasher\u003cF, [F; DIGEST_ELEMS]\u003e\n        + p3_symmetric::CryptographicHasher\u003cF::Packing, [F::Packing; DIGEST_ELEMS]\u003e\n        + Sync,\n    C: p3_symmetric::PseudoCompressionFunction\u003c[F; DIGEST_ELEMS], 2\u003e\n        + p3_symmetric::PseudoCompressionFunction\u003c[F::Packing; DIGEST_ELEMS], 2\u003e\n        + Sync,\n{\n    let mut op_idx = 0;\n\n    for query_proof in \u0026fri_proof.query_proofs {\n        // Input batch MMCS proofs\n        for batch_opening in \u0026query_proof.input_proof {\n            let siblings = convert_merkle_proof_to_siblings::\u003cF, EF, DIGEST_ELEMS\u003e(\n                \u0026batch_opening.opening_proof,\n            );\n            for sibling in siblings {\n                if op_idx \u003e= op_ids.len() {\n                    return Err(\"More siblings in proof than op_ids provided\");\n                }\n                runner\n                    .set_private_data(\n                        op_ids[op_idx],\n                        NonPrimitiveOpPrivateData::Poseidon2Perm(Poseidon2PermPrivateData {\n                            sibling,\n                        }),\n                    )\n                    .map_err(|_| \"Failed to set private data for input batch MMCS\")?;\n                op_idx += 1;\n            }\n        }\n\n        // Commit-phase MMCS proofs\n        for phase_opening in \u0026query_proof.commit_phase_openings {\n            let siblings = convert_merkle_proof_to_siblings::\u003cF, EF, DIGEST_ELEMS\u003e(\n                \u0026phase_opening.opening_proof,\n            );\n            for sibling in siblings {\n                if op_idx \u003e= op_ids.len() {\n                    return Err(\"More siblings in proof than op_ids provided\");\n                }\n                runner\n                    .set_private_data(\n                        op_ids[op_idx],\n                        NonPrimitiveOpPrivateData::Poseidon2Perm(Poseidon2PermPrivateData {\n                            sibling,\n                        }),\n                    )\n                    .map_err(|_| \"Failed to set private data for commit-phase MMCS\")?;\n                op_idx += 1;\n            }\n        }\n    }\n\n    if op_idx != op_ids.len() {\n        return Err(\"Fewer siblings in proof than op_ids provided\");\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod test {\n    use alloc::vec;\n    use alloc::vec::Vec;\n    use core::cmp::Reverse;\n\n    use itertools::Itertools;\n    use p3_baby_bear::{BabyBear, Poseidon2BabyBear, default_babybear_poseidon2_16};\n    use p3_circuit::op::Poseidon2Config;\n    use p3_circuit::ops::mmcs::{add_mmcs_verify, format_openings};\n    use p3_circuit::ops::{Poseidon2PermPrivateData, generate_poseidon2_trace};\n    use p3_circuit::{CircuitBuilder, CircuitError, NonPrimitiveOpPrivateData};\n    use p3_commit::Mmcs;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_field::{BasedVectorSpace, ExtensionField, Field, PrimeCharacteristicRing};\n    use p3_matrix::dense::{DenseMatrix, RowMajorMatrix};\n    use p3_matrix::{Dimensions, Matrix};\n    use p3_merkle_tree::MerkleTreeMmcs;\n    use p3_poseidon2_circuit_air::BabyBearD4Width16;\n    use p3_symmetric::{CryptographicHasher, PaddingFreeSponge, TruncatedPermutation};\n    use p3_util::log2_ceil_usize;\n    use rand::SeedableRng;\n    use rand::rngs::SmallRng;\n    use tracing_forest::ForestLayer;\n    use tracing_forest::util::LevelFilter;\n    use tracing_subscriber::layer::SubscriberExt;\n    use tracing_subscriber::util::SubscriberInitExt;\n    use tracing_subscriber::{EnvFilter, Registry};\n\n    use crate::pcs::verify_batch_circuit;\n\n    type F = BabyBear;\n    type CF = BinomialExtensionField\u003cF, 4\u003e;\n\n    type Perm = Poseidon2BabyBear\u003c16\u003e;\n    type MyHash = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\n    type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\n    type MyMmcs =\n        MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\n\n    fn base_digest_to_ext(digest: \u0026[F], permutation_config: Poseidon2Config) -\u003e Vec\u003cCF\u003e {\n        assert_eq!(\n            digest.len(),\n            permutation_config.rate(),\n            \"unexpected base digest length\"\n        );\n        digest\n            .chunks(\u003cCF as BasedVectorSpace\u003cF\u003e\u003e::DIMENSION)\n            .map(|chunk| {\n                let mut coeffs = [F::ZERO; 4];\n                for (i, \u0026val) in chunk.iter().enumerate() {\n                    coeffs[i] = val;\n                }\n                CF::from_basis_coefficients_slice(\u0026coeffs).expect(\"packed base digest\")\n            })\n            .collect()\n    }\n\n    fn test_all_openings(mats: Vec\u003cRowMajorMatrix\u003cF\u003e\u003e) {\n        test_all_openings_with_cap_height(mats, 0);\n    }\n\n    fn test_all_openings_with_cap_height(mats: Vec\u003cRowMajorMatrix\u003cF\u003e\u003e, cap_height: usize) {\n        let perm = default_babybear_poseidon2_16();\n        let hash = MyHash::new(perm.clone());\n        let compress = MyCompress::new(perm.clone());\n        let mmcs = MyMmcs::new(hash, compress, cap_height);\n\n        let dimensions = mats.iter().map(DenseMatrix::dimensions).collect_vec();\n\n        let mut heights_tallest_first = dimensions\n            .iter()\n            .enumerate()\n            .sorted_by_key(|(_, dims)| Reverse(dims.height))\n            .peekable();\n\n        let max_height = heights_tallest_first.peek().unwrap().1.height;\n\n        let (commit, prover_data) = mmcs.commit(mats);\n\n        let log_max_height = log2_ceil_usize(max_height);\n        for index in 0..max_height {\n            let mut builder = CircuitBuilder::\u003cCF\u003e::new();\n            let permutation_config = Poseidon2Config::BabyBearD4Width16;\n            builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n                generate_poseidon2_trace::\u003cCF, BabyBearD4Width16\u003e,\n                perm.clone(),\n            );\n\n            let batch_opening = mmcs.open_batch(index, \u0026prover_data);\n\n            let directions = (0..log_max_height)\n                .map(|k| index \u003e\u003e k \u0026 1 == 1)\n                .collect_vec();\n\n            let openings: Vec\u003cVec\u003c_\u003e\u003e = batch_opening\n                .opened_values\n                .iter()\n                .map(|opening| {\n                    (0..opening.len())\n                        .map(|_| builder.public_input())\n                        .collect_vec()\n                })\n                .collect_vec();\n\n            let directions_expr = builder.alloc_public_inputs(log_max_height, \"directions\");\n\n            // Allocate cap entries: each entry has rate_ext extension targets\n            let cap_len = commit.num_roots();\n            let rate_ext = permutation_config.rate_ext();\n            let cap_exprs: Vec\u003cVec\u003c_\u003e\u003e = (0..cap_len)\n                .map(|_| builder.alloc_public_inputs(rate_ext, \"cap entry\").to_vec())\n                .collect();\n\n            let permutation_mmcs_ops = verify_batch_circuit::\u003cF, CF\u003e(\n                \u0026mut builder,\n                permutation_config,\n                \u0026cap_exprs,\n                \u0026dimensions,\n                \u0026directions_expr,\n                \u0026openings,\n            )\n            .unwrap();\n\n            let circuit = builder.build().unwrap();\n            let mut runner = circuit.runner();\n\n            let directions_expr_vals = directions\n                .iter()\n                .map(|\u0026bit| CF::from_bool(bit))\n                .collect_vec();\n\n            let mut public_inputs: Vec\u003cCF\u003e = batch_opening\n                .opened_values\n                .iter()\n                .flat_map(|values| values.iter().map(|\u0026v| CF::from(v)))\n                .collect();\n            public_inputs.extend(directions_expr_vals.iter());\n            // Pack each cap entry to extension field and add as public inputs\n            for entry in commit.roots() {\n                let commit_ext = base_digest_to_ext(entry, permutation_config);\n                debug_assert_eq!(rate_ext, commit_ext.len());\n                public_inputs.extend(commit_ext);\n            }\n\n            runner.set_public_inputs(\u0026public_inputs).unwrap();\n\n            let siblings = batch_opening\n                .opening_proof\n                .iter()\n                .map(|digest| {\n                    digest\n                        .chunks(4)\n                        .map(CF::from_basis_coefficients_slice)\n                        .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n                        .unwrap()\n                })\n                .collect_vec();\n\n            for (\u0026op_id, sibling) in permutation_mmcs_ops.iter().zip(siblings) {\n                runner\n                    .set_private_data(\n                        op_id,\n                        NonPrimitiveOpPrivateData::Poseidon2Perm(Poseidon2PermPrivateData {\n                            sibling: sibling.try_into().unwrap(),\n                        }),\n                    )\n                    .unwrap();\n            }\n\n            let _ = runner.run().unwrap();\n        }\n    }\n\n    fn init_logger() {\n        let env_filter = EnvFilter::builder()\n            .with_default_directive(LevelFilter::INFO.into())\n            .from_env_lossy();\n\n        // Use try_init to avoid panic if logger is already initialized\n        let _ = Registry::default()\n            .with(env_filter)\n            .with(ForestLayer::default())\n            .try_init();\n    }\n\n    #[test]\n    fn commit_single_1x8() {\n        init_logger();\n        // v = [0, 1, 2, 3, 4, 5, 6, 7]\n        let v = vec![\n            F::from_u32(0),\n            F::from_u32(1),\n            F::from_u32(2),\n            F::from_u32(3),\n            F::from_u32(4),\n            F::from_u32(5),\n            F::from_u32(6),\n            F::from_u32(7),\n        ];\n\n        test_all_openings(vec![RowMajorMatrix::new_col(v)]);\n    }\n\n    #[test]\n    fn commit_single_2x2() {\n        let mat = RowMajorMatrix::new(vec![F::ZERO, F::ONE, F::TWO, F::ONE], 2);\n        test_all_openings(vec![mat]);\n    }\n\n    #[test]\n    fn commit_single_2x3() {\n        // mat = [\n        //   0 1\n        //   2 1\n        //   2 2\n        // ]\n        let mat = RowMajorMatrix::new(vec![F::ZERO, F::ONE, F::TWO, F::ONE, F::TWO, F::TWO], 2);\n        test_all_openings(vec![mat]);\n    }\n\n    #[test]\n    fn commit_mixed() {\n        // mat_1 = [\n        //   0 1\n        //   2 3\n        //   4 5\n        //   6 7\n        //   8 9\n        // ]\n        let mat_1 = RowMajorMatrix::new(\n            vec![\n                F::from_usize(0),\n                F::from_usize(1),\n                F::from_usize(2),\n                F::from_usize(3),\n                F::from_usize(4),\n                F::from_usize(5),\n                F::from_usize(6),\n                F::from_usize(7),\n                F::from_usize(8),\n                F::from_usize(9),\n            ],\n            2,\n        );\n        // mat_2 = [\n        //   10 11 12\n        //   13 14 15\n        //   16 17 18\n        // ]\n        let mat_2 = RowMajorMatrix::new(\n            vec![\n                F::from_usize(10),\n                F::from_usize(11),\n                F::from_usize(12),\n                F::from_usize(13),\n                F::from_usize(14),\n                F::from_usize(15),\n                F::from_usize(16),\n                F::from_usize(17),\n                F::from_usize(18),\n            ],\n            3,\n        );\n        test_all_openings(vec![mat_1, mat_2]);\n    }\n\n    #[test]\n    fn commit_either_order() {\n        let mut rng = SmallRng::seed_from_u64(1);\n        let input_1 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 5, 8);\n        let input_2 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 3, 16);\n\n        test_all_openings(vec![input_1.clone(), input_2.clone()]);\n        test_all_openings(vec![input_2, input_1]);\n    }\n\n    /// Test with batch STARK's exact height configuration: [512, 8, 4, 128, 4]\n    /// This replicates the multi-instance batch STARK trace commitment structure.\n    #[test]\n    fn commit_batch_stark_heights() {\n        init_logger();\n        let mut rng = SmallRng::seed_from_u64(42);\n\n        // Heights matching batch STARK degree_bits [7, 1, 0, 5, 0] with log_blowup=2\n        // heights = [2^(7+2), 2^(1+2), 2^(0+2), 2^(5+2), 2^(0+2)] = [512, 8, 4, 128, 4]\n        // Widths matching trace batch: [1, 1, 1, 12, 3]\n        let mat_0 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 512, 1);\n        let mat_1 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 8, 1);\n        let mat_2 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 4, 1);\n        let mat_3 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 128, 12);\n        let mat_4 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 4, 3);\n\n        test_all_openings(vec![mat_0, mat_1, mat_2, mat_3, mat_4]);\n    }\n\n    /// Test with multiple matrices at the same height (4) - potential edge case\n    #[test]\n    fn commit_same_height_matrices() {\n        init_logger();\n        let mut rng = SmallRng::seed_from_u64(123);\n\n        // Two matrices with same height should be combined at the same level\n        let mat_0 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 8, 4);\n        let mat_1 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 4, 2);\n        let mat_2 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 4, 3);\n\n        test_all_openings(vec![mat_0, mat_1, mat_2]);\n    }\n\n    #[test]\n    fn commit_with_cap_height_1() {\n        init_logger();\n        let mut rng = SmallRng::seed_from_u64(99);\n        let mat = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 8, 3);\n        test_all_openings_with_cap_height(vec![mat], 1);\n    }\n\n    #[test]\n    fn commit_with_cap_height_2() {\n        init_logger();\n        let mut rng = SmallRng::seed_from_u64(99);\n        let mat_0 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 16, 2);\n        let mat_1 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 4, 3);\n        test_all_openings_with_cap_height(vec![mat_0, mat_1], 2);\n    }\n\n    #[test]\n    fn commit_batch_stark_with_cap_height() {\n        init_logger();\n        let mut rng = SmallRng::seed_from_u64(42);\n        let mat_0 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 512, 1);\n        let mat_1 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 8, 1);\n        let mat_2 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 4, 1);\n        let mat_3 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 128, 12);\n        let mat_4 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 4, 3);\n        test_all_openings_with_cap_height(vec![mat_0, mat_1, mat_2, mat_3, mat_4], 2);\n    }\n\n    #[test]\n    fn lifted_verify_with_cap_height() {\n        init_logger();\n        let mut rng = SmallRng::seed_from_u64(99);\n        let mat = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 8, 3);\n        test_lifted_openings_with_cap_height(vec![mat], 1);\n    }\n\n    #[test]\n    fn verify_tampered_proof_fails() {\n        let mut rng = SmallRng::seed_from_u64(1);\n        let perm = Perm::new_from_rng_128(\u0026mut rng);\n        let hash = MyHash::new(perm.clone());\n        let compress = MyCompress::new(perm);\n        let mmcs = MyMmcs::new(hash.clone(), compress, 0);\n\n        // 4 8x1 matrixes, 4 8x2 matrixes\n        let mut mats = (0..4)\n            .map(|_| RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 8, 1))\n            .collect_vec();\n        let large_mat_dims = (0..4).map(|_| Dimensions {\n            height: 8,\n            width: 1,\n        });\n        mats.extend((0..4).map(|_| RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 8, 2)));\n        let small_mat_dims = (0..4).map(|_| Dimensions {\n            height: 8,\n            width: 2,\n        });\n        let dimensions = \u0026large_mat_dims.chain(small_mat_dims).collect_vec();\n\n        let (commit, prover_data) = mmcs.commit(mats);\n\n        let mut builder = CircuitBuilder::\u003cCF\u003e::new();\n        let permutation_config = Poseidon2Config::BabyBearD4Width16;\n        let perm = default_babybear_poseidon2_16();\n        builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n            generate_poseidon2_trace::\u003cCF, BabyBearD4Width16\u003e,\n            perm,\n        );\n\n        // open the 3rd row of each matrix, mess with proof, and verify\n        let index = 3;\n        let path_depth = 3;\n        let mut batch_opening = mmcs.open_batch(index, \u0026prover_data);\n        batch_opening.opening_proof[0][0] += F::ONE;\n\n        let openings_digests = batch_opening\n            .opened_values\n            .iter()\n            .zip(dimensions)\n            .chunk_by(|(_, dimensions)| dimensions.height)\n            .into_iter()\n            .map(|(_, group)| hash.hash_iter(group.flat_map(|(x, _)| x.clone())))\n            .collect_vec();\n        let dimensions = dimensions\n            .iter()\n            .chunk_by(|dimensions| dimensions.height)\n            .into_iter()\n            .map(|(height, _)| Dimensions { width: 0, height })\n            .collect_vec();\n\n        let openings = openings_digests\n            .iter()\n            .map(|mat_hash| {\n                mat_hash\n                    .iter()\n                    .map(|_| builder.public_input())\n                    .collect_vec()\n            })\n            .collect_vec();\n        let openings =\n            format_openings(\u0026openings, \u0026dimensions, path_depth, permutation_config).unwrap();\n        let directions_expr = builder.alloc_public_inputs(path_depth, \"directions\");\n        let root_exprs = builder.alloc_public_inputs(permutation_config.rate_ext(), \"root\");\n\n        let permutation_mmcs_ops = add_mmcs_verify(\n            \u0026mut builder,\n            permutation_config,\n            \u0026openings,\n            \u0026directions_expr,\n            \u0026root_exprs,\n        )\n        .unwrap();\n        let circuit = builder.build().unwrap();\n        let root_widx0 = circuit.expr_to_widx[\u0026root_exprs[0]];\n        let mut runner = circuit.runner();\n\n        let directions = (0..path_depth)\n            .map(|k| CF::from_bool(index \u003e\u003e k \u0026 1 == 1))\n            .collect_vec();\n\n        let mut public_inputs = vec![];\n        public_inputs.extend(\n            openings_digests\n                .iter()\n                .flat_map(|digest| digest.map(CF::from)),\n        );\n        public_inputs.extend(directions.iter());\n        // For cap_height=0, commit has 1 entry\n        let commit_entry = \u0026commit.roots()[0];\n        let commit_ext = base_digest_to_ext(commit_entry, permutation_config);\n        debug_assert_eq!(permutation_config.rate_ext(), commit_ext.len());\n        public_inputs.extend(commit_ext);\n\n        runner.set_public_inputs(\u0026public_inputs).unwrap();\n\n        let siblings = batch_opening\n            .opening_proof\n            .iter()\n            .map(|digest| {\n                digest\n                    .chunks(4)\n                    .map(CF::from_basis_coefficients_slice)\n                    .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n                    .unwrap()\n            })\n            .collect_vec();\n\n        for (\u0026op_id, sibling) in permutation_mmcs_ops.iter().zip(siblings) {\n            let sibling: [CF; 2] = sibling.try_into().unwrap();\n            runner\n                .set_private_data(\n                    op_id,\n                    NonPrimitiveOpPrivateData::Poseidon2Perm(Poseidon2PermPrivateData { sibling }),\n                )\n                .unwrap();\n        }\n\n        // When we run the runner and the MMCS trace is generated, it will be checked that\n        // the root computed by the MmcsVerify gate does not match the one given as input.\n        let result = runner.run();\n\n        match result {\n            Err(CircuitError::WitnessConflict { witness_id, .. }) =\u003e {\n                assert_eq!(witness_id, root_widx0, \"expected root witness mismatch\");\n            }\n            _ =\u003e panic!(\"The test was suppose to fail with a root mismatch!\"),\n        }\n    }\n\n    /// Test MMCS verification using lifted representation (like FRI verifier does).\n    /// This tests that `pack_lifted_to_ext` + `verify_batch_circuit` produces correct results.\n    ///\n    /// The FRI verifier stores opened values as \"lifted\" targets (one ext target per base field value,\n    /// where the ext value is `[base_val, 0, 0, 0]`), then packs them before MMCS verification.\n    #[test]\n    fn verify_batch_with_lifted_representation() {\n        init_logger();\n\n        let perm = default_babybear_poseidon2_16();\n        let hash = MyHash::new(perm.clone());\n        let compress = MyCompress::new(perm.clone());\n        let mmcs = MyMmcs::new(hash, compress, 0);\n\n        // Create a small matrix (similar to small FRI proofs)\n        let mat = RowMajorMatrix::new(\n            vec![\n                F::from_u32(1),\n                F::from_u32(2),\n                F::from_u32(3),\n                F::from_u32(4),\n                F::from_u32(5),\n                F::from_u32(6),\n                F::from_u32(7),\n                F::from_u32(8),\n            ],\n            4, // 2 rows, 4 columns\n        );\n\n        let dimensions = vec![mat.dimensions()];\n        let max_height = mat.height();\n        let log_max_height = log2_ceil_usize(max_height);\n\n        let (commit, prover_data) = mmcs.commit(vec![mat]);\n\n        for index in 0..max_height {\n            let mut builder = CircuitBuilder::\u003cCF\u003e::new();\n            let permutation_config = Poseidon2Config::BabyBearD4Width16;\n            builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n                generate_poseidon2_trace::\u003cCF, BabyBearD4Width16\u003e,\n                perm.clone(),\n            );\n\n            let batch_opening = mmcs.open_batch(index, \u0026prover_data);\n\n            let directions = (0..log_max_height)\n                .map(|k| index \u003e\u003e k \u0026 1 == 1)\n                .collect_vec();\n\n            let lifted_openings: Vec\u003cVec\u003c_\u003e\u003e = batch_opening\n                .opened_values\n                .iter()\n                .map(|values| values.iter().map(|_| builder.public_input()).collect_vec())\n                .collect();\n\n            let directions_expr = builder.alloc_public_inputs(log_max_height, \"directions\");\n\n            // Allocate cap entries as LIFTED targets, then pack\n            let cap_len = commit.num_roots();\n            let mut cap_exprs = Vec::with_capacity(cap_len);\n            for _ in 0..cap_len {\n                let lifted: Vec\u003c_\u003e = (0..permutation_config.rate())\n                    .map(|_| builder.public_input())\n                    .collect();\n                let packed = pack_lifted_targets::\u003cF, CF\u003e(\u0026mut builder, \u0026lifted);\n                cap_exprs.push(packed);\n            }\n\n            let _permutation_mmcs_ops = verify_batch_circuit::\u003cF, CF\u003e(\n                \u0026mut builder,\n                permutation_config,\n                \u0026cap_exprs,\n                \u0026dimensions,\n                \u0026directions_expr,\n                \u0026lifted_openings,\n            )\n            .unwrap();\n\n            let circuit = builder.build().unwrap();\n            let mut runner = circuit.runner();\n\n            // Set public inputs using LIFTED representation\n            let mut public_inputs: Vec\u003cCF\u003e = batch_opening\n                .opened_values\n                .iter()\n                .flat_map(|values| values.iter().map(|\u0026v| CF::from(v)))\n                .collect();\n\n            // Then: direction bits\n            public_inputs.extend(directions.iter().map(|\u0026bit| CF::from_bool(bit)));\n\n            // Then: lifted cap entries (one EF per base field digest element per entry)\n            for entry in commit.roots() {\n                public_inputs.extend(entry.iter().map(|\u0026v| CF::from(v)));\n            }\n\n            runner.set_public_inputs(\u0026public_inputs).unwrap();\n\n            // Set private data for siblings\n            let siblings = batch_opening\n                .opening_proof\n                .iter()\n                .map(|digest| {\n                    digest\n                        .chunks(4)\n                        .map(CF::from_basis_coefficients_slice)\n                        .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n                        .unwrap()\n                })\n                .collect_vec();\n\n            for (\u0026op_id, sibling) in _permutation_mmcs_ops.iter().zip(siblings) {\n                runner\n                    .set_private_data(\n                        op_id,\n                        NonPrimitiveOpPrivateData::Poseidon2Perm(Poseidon2PermPrivateData {\n                            sibling: sibling.try_into().unwrap(),\n                        }),\n                    )\n                    .unwrap();\n            }\n\n            let result = runner.run();\n            assert!(\n                result.is_ok(),\n                \"MMCS verification with lifted representation failed at index {}: {:?}\",\n                index,\n                result.err()\n            );\n        }\n    }\n\n    /// Helper function to pack lifted targets into extension targets.\n    /// Mimics `pack_lifted_to_ext` from FRI verifier.\n    fn pack_lifted_targets\u003cBF, EF\u003e(\n        builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n        lifted: \u0026[crate::Target],\n    ) -\u003e Vec\u003ccrate::Target\u003e\n    where\n        BF: Field,\n        EF: ExtensionField\u003cBF\u003e + BasedVectorSpace\u003cBF\u003e,\n    {\n        if lifted.is_empty() {\n            return Vec::new();\n        }\n\n        let d = EF::DIMENSION;\n        let basis: Vec\u003cEF\u003e = (0..d)\n            .map(|i| {\n                let mut coeffs = vec![BF::ZERO; d];\n                coeffs[i] = BF::ONE;\n                EF::from_basis_coefficients_slice(\u0026coeffs).expect(\"valid basis\")\n            })\n            .collect();\n\n        lifted\n            .chunks(d)\n            .map(|chunk| {\n                let mut acc = builder.define_const(EF::ZERO);\n                for (i, \u0026target) in chunk.iter().enumerate() {\n                    let basis_const = builder.define_const(basis[i]);\n                    acc = builder.mul_add(target, basis_const, acc);\n                }\n                acc\n            })\n            .collect()\n    }\n\n    /// Test helper that runs MMCS verification using lifted representation for various matrix configs.\n    fn test_lifted_openings(mats: Vec\u003cRowMajorMatrix\u003cF\u003e\u003e) {\n        test_lifted_openings_with_cap_height(mats, 0);\n    }\n\n    fn test_lifted_openings_with_cap_height(mats: Vec\u003cRowMajorMatrix\u003cF\u003e\u003e, cap_height: usize) {\n        let perm = default_babybear_poseidon2_16();\n        let hash = MyHash::new(perm.clone());\n        let compress = MyCompress::new(perm.clone());\n        let mmcs = MyMmcs::new(hash, compress, cap_height);\n\n        let dimensions = mats.iter().map(DenseMatrix::dimensions).collect_vec();\n\n        let mut heights_tallest_first = dimensions\n            .iter()\n            .enumerate()\n            .sorted_by_key(|(_, dims)| Reverse(dims.height))\n            .peekable();\n\n        let max_height = heights_tallest_first.peek().unwrap().1.height;\n\n        let (commit, prover_data) = mmcs.commit(mats);\n\n        let log_max_height = log2_ceil_usize(max_height);\n        for index in 0..max_height {\n            let mut builder = CircuitBuilder::\u003cCF\u003e::new();\n            let permutation_config = Poseidon2Config::BabyBearD4Width16;\n            builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n                generate_poseidon2_trace::\u003cCF, BabyBearD4Width16\u003e,\n                perm.clone(),\n            );\n\n            let batch_opening = mmcs.open_batch(index, \u0026prover_data);\n\n            let directions = (0..log_max_height)\n                .map(|k| index \u003e\u003e k \u0026 1 == 1)\n                .collect_vec();\n\n            let lifted_openings: Vec\u003cVec\u003c_\u003e\u003e = batch_opening\n                .opened_values\n                .iter()\n                .map(|values| values.iter().map(|_| builder.public_input()).collect_vec())\n                .collect();\n\n            let directions_expr = builder.alloc_public_inputs(log_max_height, \"directions\");\n\n            // Allocate cap entries as LIFTED, then pack\n            let cap_len = commit.num_roots();\n            let mut cap_exprs = Vec::with_capacity(cap_len);\n            for _ in 0..cap_len {\n                let lifted: Vec\u003c_\u003e = (0..permutation_config.rate())\n                    .map(|_| builder.public_input())\n                    .collect();\n                let packed = pack_lifted_targets::\u003cF, CF\u003e(\u0026mut builder, \u0026lifted);\n                cap_exprs.push(packed);\n            }\n\n            let permutation_mmcs_ops = verify_batch_circuit::\u003cF, CF\u003e(\n                \u0026mut builder,\n                permutation_config,\n                \u0026cap_exprs,\n                \u0026dimensions,\n                \u0026directions_expr,\n                \u0026lifted_openings,\n            )\n            .unwrap();\n\n            let circuit = builder.build().unwrap();\n            let mut runner = circuit.runner();\n\n            // Set public inputs using LIFTED representation\n            let mut public_inputs: Vec\u003cCF\u003e = batch_opening\n                .opened_values\n                .iter()\n                .flat_map(|values| values.iter().map(|\u0026v| CF::from(v)))\n                .collect();\n\n            public_inputs.extend(directions.iter().map(|\u0026bit| CF::from_bool(bit)));\n\n            // Lifted cap entries\n            for entry in commit.roots() {\n                public_inputs.extend(entry.iter().map(|\u0026v| CF::from(v)));\n            }\n\n            runner.set_public_inputs(\u0026public_inputs).unwrap();\n\n            // Set private data for siblings\n            let siblings = batch_opening\n                .opening_proof\n                .iter()\n                .map(|digest| {\n                    digest\n                        .chunks(4)\n                        .map(CF::from_basis_coefficients_slice)\n                        .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n                        .unwrap()\n                })\n                .collect_vec();\n\n            for (\u0026op_id, sibling) in permutation_mmcs_ops.iter().zip(siblings) {\n                runner\n                    .set_private_data(\n                        op_id,\n                        NonPrimitiveOpPrivateData::Poseidon2Perm(Poseidon2PermPrivateData {\n                            sibling: sibling.try_into().unwrap(),\n                        }),\n                    )\n                    .unwrap();\n            }\n\n            let _ = runner.run().unwrap();\n        }\n    }\n\n    /// Test with very small matrix (height=2, minimal Merkle tree depth=1)\n    #[test]\n    fn lifted_verify_small_2x4() {\n        init_logger();\n        let mat = RowMajorMatrix::new(\n            (0..8).map(|i| F::from_u32(i as u32)).collect_vec(),\n            4, // 2 rows, 4 columns\n        );\n        test_lifted_openings(vec![mat]);\n    }\n\n    /// Test with non-power-of-4 width (tests truncation)\n    #[test]\n    fn lifted_verify_small_2x5() {\n        init_logger();\n        let mat = RowMajorMatrix::new(\n            (0..10).map(|i| F::from_u32(i as u32)).collect_vec(),\n            5, // 2 rows, 5 columns\n        );\n        test_lifted_openings(vec![mat]);\n    }\n\n    /// Test with multiple matrices at different heights (like FRI batches)\n    #[test]\n    fn lifted_verify_multi_height() {\n        init_logger();\n        // Two matrices: 8 rows and 4 rows (different heights)\n        let mat1 = RowMajorMatrix::new(\n            (0..16).map(|i| F::from_u32(i as u32)).collect_vec(),\n            2, // 8 rows, 2 columns\n        );\n        let mat2 = RowMajorMatrix::new(\n            (20..32).map(|i| F::from_u32(i as u32)).collect_vec(),\n            3, // 4 rows, 3 columns\n        );\n        test_lifted_openings(vec![mat1, mat2]);\n    }\n\n    /// Test with matrices at same height (combined at same level)\n    #[test]\n    fn lifted_verify_same_height() {\n        init_logger();\n        // Two matrices with same height\n        let mat1 = RowMajorMatrix::new(\n            (0..8).map(|i| F::from_u32(i as u32)).collect_vec(),\n            2, // 4 rows, 2 columns\n        );\n        let mat2 = RowMajorMatrix::new(\n            (10..22).map(|i| F::from_u32(i as u32)).collect_vec(),\n            3, // 4 rows, 3 columns\n        );\n        test_lifted_openings(vec![mat1, mat2]);\n    }\n\n    /// Test with very small column widths (1 column) - edge case from recursive_fibonacci -n 1\n    /// This tests base_widths=[1, 1, 1, 3, 3] configuration\n    ///\n    /// This test verifies that `verify_batch_circuit` correctly handles non-aligned\n    /// base field widths by using overwrite-mode hashing (matching native PaddingFreeSponge).\n    #[test]\n    fn lifted_verify_single_column_matrices() {\n        init_logger();\n        // Simulate batch 0 from fibonacci -n 1: base_widths=[1, 1, 1, 3, 3], 5 matrices\n        // With log_max_height=3, so 8 rows for the tallest matrix\n        let mat0 = RowMajorMatrix::new(\n            (0..8).map(|i| F::from_u32(i as u32)).collect_vec(),\n            1, // 8 rows, 1 column\n        );\n        let mat1 = RowMajorMatrix::new(\n            (10..18).map(|i| F::from_u32(i as u32)).collect_vec(),\n            1, // 8 rows, 1 column\n        );\n        let mat2 = RowMajorMatrix::new(\n            (20..28).map(|i| F::from_u32(i as u32)).collect_vec(),\n            1, // 8 rows, 1 column\n        );\n        let mat3 = RowMajorMatrix::new(\n            (30..54).map(|i| F::from_u32(i as u32)).collect_vec(),\n            3, // 8 rows, 3 columns\n        );\n        let mat4 = RowMajorMatrix::new(\n            (60..84).map(|i| F::from_u32(i as u32)).collect_vec(),\n            3, // 8 rows, 3 columns\n        );\n        test_lifted_openings(vec![mat0, mat1, mat2, mat3, mat4]);\n    }\n\n    /// Test with mixed heights matching fibonacci -n 1's batch 0 (with log_blowup applied)\n    /// This specifically tests the height grouping logic\n    #[test]\n    fn lifted_verify_fibonacci_batch0_config() {\n        init_logger();\n        // From fibonacci -n 1: batch 0 has 5 matrices with base_widths=[1, 1, 1, 3, 3]\n        // heights depend on domain sizes and log_blowup\n        // Let's test with different heights to trigger height grouping\n        let mat0 = RowMajorMatrix::new(\n            (0..8).map(|i| F::from_u32(i as u32)).collect_vec(),\n            1, // 8 rows, 1 column\n        );\n        let mat1 = RowMajorMatrix::new(\n            (10..14).map(|i| F::from_u32(i as u32)).collect_vec(),\n            1, // 4 rows, 1 column\n        );\n        let mat2 = RowMajorMatrix::new(\n            (20..24).map(|i| F::from_u32(i as u32)).collect_vec(),\n            1, // 4 rows, 1 column\n        );\n        let mat3 = RowMajorMatrix::new(\n            (30..54).map(|i| F::from_u32(i as u32)).collect_vec(),\n            3, // 8 rows, 3 columns\n        );\n        let mat4 = RowMajorMatrix::new(\n            (60..72).map(|i| F::from_u32(i as u32)).collect_vec(),\n            3, // 4 rows, 3 columns\n        );\n        test_lifted_openings(vec![mat0, mat1, mat2, mat3, mat4]);\n    }\n}\n","traces":[{"line":32,"address":[5319210,5315152,5319216],"length":1,"stats":{"Line":5}},{"line":42,"address":[3055216],"length":1,"stats":{"Line":5}},{"line":44,"address":[3317741],"length":1,"stats":{"Line":0}},{"line":45,"address":[2532102,2536096],"length":1,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":5}},{"line":49,"address":[4865889],"length":1,"stats":{"Line":5}},{"line":50,"address":[3055285],"length":1,"stats":{"Line":5}},{"line":53,"address":[4121822],"length":1,"stats":{"Line":5}},{"line":55,"address":[6678642],"length":1,"stats":{"Line":5}},{"line":56,"address":[],"length":0,"stats":{"Line":5}},{"line":58,"address":[2532144,2533473,2531909],"length":1,"stats":{"Line":16}},{"line":59,"address":[5315896],"length":1,"stats":{"Line":5}},{"line":60,"address":[4122557,4122316,4122497],"length":1,"stats":{"Line":12}},{"line":65,"address":[4866699],"length":1,"stats":{"Line":6}},{"line":67,"address":[2208194,2208220],"length":1,"stats":{"Line":12}},{"line":68,"address":[3319569,3319628,3318416],"length":1,"stats":{"Line":12}},{"line":69,"address":[3319577],"length":1,"stats":{"Line":8}},{"line":71,"address":[3057476,3059576],"length":1,"stats":{"Line":11}},{"line":74,"address":[3321733,3321702,3319665],"length":1,"stats":{"Line":10}},{"line":75,"address":[2533986],"length":1,"stats":{"Line":6}},{"line":77,"address":[4642352,4642371,4640148],"length":1,"stats":{"Line":12}},{"line":78,"address":[2209683,2211215,2211521],"length":1,"stats":{"Line":8}},{"line":82,"address":[4640298,4640119],"length":1,"stats":{"Line":10}},{"line":83,"address":[2209751,2209802,2209703],"length":1,"stats":{"Line":6}},{"line":84,"address":[5317857,5317909],"length":1,"stats":{"Line":6}},{"line":86,"address":[2209784],"length":1,"stats":{"Line":0}},{"line":89,"address":[4640280],"length":1,"stats":{"Line":5}},{"line":92,"address":[5318195],"length":1,"stats":{"Line":5}},{"line":93,"address":[5318242,5318323],"length":1,"stats":{"Line":10}},{"line":94,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[2535321,2535496],"length":1,"stats":{"Line":10}},{"line":97,"address":[6682150,6682060],"length":1,"stats":{"Line":8}},{"line":99,"address":[5318991,5319053],"length":1,"stats":{"Line":6}},{"line":102,"address":[4125430,4125380],"length":1,"stats":{"Line":10}},{"line":106,"address":[2210732,2210378],"length":1,"stats":{"Line":5}},{"line":114,"address":[3056701,3056451],"length":1,"stats":{"Line":6}},{"line":115,"address":[4866957],"length":1,"stats":{"Line":5}},{"line":116,"address":[5316390],"length":1,"stats":{"Line":5}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[3318515],"length":1,"stats":{"Line":6}},{"line":120,"address":[2208451],"length":1,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":8}},{"line":128,"address":[4867973],"length":1,"stats":{"Line":3}},{"line":129,"address":[3319174,3319009],"length":1,"stats":{"Line":3}},{"line":130,"address":[4639712],"length":1,"stats":{"Line":3}},{"line":134,"address":[3056961],"length":1,"stats":{"Line":6}},{"line":138,"address":[4638462],"length":1,"stats":{"Line":6}},{"line":140,"address":[],"length":0,"stats":{"Line":18}},{"line":146,"address":[5312336],"length":1,"stats":{"Line":4}},{"line":156,"address":[4863009],"length":1,"stats":{"Line":4}},{"line":157,"address":[4863050],"length":1,"stats":{"Line":4}},{"line":158,"address":[2529170],"length":1,"stats":{"Line":0}},{"line":159,"address":[4637368,4635352],"length":1,"stats":{"Line":0}},{"line":162,"address":[2528876],"length":1,"stats":{"Line":4}},{"line":163,"address":[4863146],"length":1,"stats":{"Line":4}},{"line":164,"address":[],"length":0,"stats":{"Line":4}},{"line":166,"address":[3052815,3054102,3052589],"length":1,"stats":{"Line":12}},{"line":167,"address":[2204941],"length":1,"stats":{"Line":4}},{"line":168,"address":[4863585],"length":1,"stats":{"Line":4}},{"line":169,"address":[4637335,4635743],"length":1,"stats":{"Line":8}},{"line":170,"address":[4863999,4865381,4865409],"length":1,"stats":{"Line":8}},{"line":172,"address":[3315531,3316845],"length":1,"stats":{"Line":4}},{"line":173,"address":[3315617,3316850,3316793],"length":1,"stats":{"Line":0}},{"line":174,"address":[2531090],"length":1,"stats":{"Line":0}},{"line":176,"address":[2531480,2531013,2531456],"length":1,"stats":{"Line":0}},{"line":180,"address":[2530318,2530068],"length":1,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[3053540],"length":1,"stats":{"Line":4}},{"line":186,"address":[4120092],"length":1,"stats":{"Line":4}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[2530481,2531008],"length":1,"stats":{"Line":8}},{"line":192,"address":[3054489],"length":1,"stats":{"Line":4}},{"line":193,"address":[2530555],"length":1,"stats":{"Line":4}},{"line":194,"address":[3054298],"length":1,"stats":{"Line":4}},{"line":197,"address":[2206054],"length":1,"stats":{"Line":4}},{"line":200,"address":[5313044],"length":1,"stats":{"Line":4}},{"line":202,"address":[4635633,4637504,4637548],"length":1,"stats":{"Line":12}},{"line":233,"address":[4632382,4629904,4631560],"length":1,"stats":{"Line":6}},{"line":248,"address":[4116271],"length":1,"stats":{"Line":6}},{"line":249,"address":[5307679],"length":1,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[6675966],"length":1,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":6}},{"line":266,"address":[],"length":0,"stats":{"Line":6}},{"line":268,"address":[5307786],"length":1,"stats":{"Line":1}},{"line":271,"address":[4116477],"length":1,"stats":{"Line":6}},{"line":272,"address":[4116485,4116786],"length":1,"stats":{"Line":6}},{"line":275,"address":[3309972],"length":1,"stats":{"Line":6}},{"line":276,"address":[6676196],"length":1,"stats":{"Line":6}},{"line":279,"address":[4630550],"length":1,"stats":{"Line":6}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[4862682,4862672,4860970],"length":1,"stats":{"Line":13}},{"line":292,"address":[],"length":0,"stats":{"Line":5}},{"line":293,"address":[2526860,2526951],"length":1,"stats":{"Line":10}},{"line":294,"address":[],"length":0,"stats":{"Line":11}},{"line":295,"address":[2202883,2203219,2203304],"length":1,"stats":{"Line":12}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[2204067,2203287,2204048],"length":1,"stats":{"Line":18}},{"line":300,"address":[2528592,2528630,2527791],"length":1,"stats":{"Line":18}},{"line":303,"address":[4117941,4118000],"length":1,"stats":{"Line":11}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[5309664,5309731,5309389,5309522],"length":1,"stats":{"Line":11}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[5309310],"length":1,"stats":{"Line":5}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":5}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[3310876],"length":1,"stats":{"Line":5}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[5308881],"length":1,"stats":{"Line":5}},{"line":329,"address":[4128805,4126416,4128811],"length":1,"stats":{"Line":4}},{"line":347,"address":[3060207],"length":1,"stats":{"Line":4}},{"line":348,"address":[3060263],"length":1,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[3060228],"length":1,"stats":{"Line":4}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[3060318],"length":1,"stats":{"Line":4}},{"line":360,"address":[4871025],"length":1,"stats":{"Line":4}},{"line":362,"address":[3060370],"length":1,"stats":{"Line":0}},{"line":365,"address":[2536885],"length":1,"stats":{"Line":4}},{"line":366,"address":[3060413,3060666],"length":1,"stats":{"Line":4}},{"line":367,"address":[2212492],"length":1,"stats":{"Line":4}},{"line":368,"address":[],"length":0,"stats":{"Line":4}},{"line":370,"address":[3060622],"length":1,"stats":{"Line":4}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[4872992,4871410,4873002],"length":1,"stats":{"Line":4}},{"line":378,"address":[5321787,5321736],"length":1,"stats":{"Line":4}},{"line":379,"address":[4644260,4644351],"length":1,"stats":{"Line":8}},{"line":380,"address":[5321886,5321962],"length":1,"stats":{"Line":8}},{"line":381,"address":[2213556,2213641,2213314],"length":1,"stats":{"Line":8}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[2538088,2539011,2538992],"length":1,"stats":{"Line":12}},{"line":385,"address":[],"length":0,"stats":{"Line":12}},{"line":388,"address":[4128257,4128198],"length":1,"stats":{"Line":8}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[2214145,2214161,2214228],"length":1,"stats":{"Line":8}},{"line":393,"address":[4872431,4872510,4872820],"length":1,"stats":{"Line":8}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[2537811],"length":1,"stats":{"Line":4}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[3061376],"length":1,"stats":{"Line":4}},{"line":414,"address":[4629816,4628535,4627536],"length":1,"stats":{"Line":6}},{"line":419,"address":[4627639],"length":1,"stats":{"Line":6}},{"line":420,"address":[4860138,4857917],"length":1,"stats":{"Line":11}},{"line":423,"address":[3307253,3307301],"length":1,"stats":{"Line":2}},{"line":425,"address":[],"length":0,"stats":{"Line":1}},{"line":429,"address":[5305412],"length":1,"stats":{"Line":1}},{"line":431,"address":[2524146,2524041,2525119],"length":1,"stats":{"Line":3}},{"line":432,"address":[],"length":0,"stats":{"Line":2}},{"line":433,"address":[4628578],"length":1,"stats":{"Line":1}},{"line":434,"address":[2200337,2200249,2201211],"length":1,"stats":{"Line":3}},{"line":435,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[4629118],"length":1,"stats":{"Line":1}},{"line":437,"address":[2525343],"length":1,"stats":{"Line":1}},{"line":438,"address":[4115506,4115430],"length":1,"stats":{"Line":2}},{"line":440,"address":[2201231,2201121],"length":1,"stats":{"Line":2}},{"line":441,"address":[3049296],"length":1,"stats":{"Line":1}},{"line":442,"address":[4859974],"length":1,"stats":{"Line":1}},{"line":443,"address":[4629764],"length":1,"stats":{"Line":1}},{"line":445,"address":[4859770],"length":1,"stats":{"Line":1}},{"line":447,"address":[3308460,3308405],"length":1,"stats":{"Line":1}},{"line":450,"address":[5305702],"length":1,"stats":{"Line":1}},{"line":451,"address":[4858782,4858546],"length":1,"stats":{"Line":1}},{"line":459,"address":[5320080],"length":1,"stats":{"Line":3}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[5320176,5320141,5320766,5320772],"length":1,"stats":{"Line":6}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[5320222],"length":1,"stats":{"Line":3}},{"line":472,"address":[],"length":0,"stats":{"Line":6}},{"line":473,"address":[],"length":0,"stats":{"Line":3}},{"line":474,"address":[3322902],"length":1,"stats":{"Line":3}},{"line":476,"address":[4642775],"length":1,"stats":{"Line":3}},{"line":478,"address":[],"length":0,"stats":{"Line":3}},{"line":479,"address":[3322353,3322407],"length":1,"stats":{"Line":6}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[5320623,5320440],"length":1,"stats":{"Line":6}},{"line":507,"address":[4632640,4634099,4634105],"length":1,"stats":{"Line":3}},{"line":524,"address":[3312290],"length":1,"stats":{"Line":3}},{"line":526,"address":[],"length":0,"stats":{"Line":6}},{"line":528,"address":[],"length":0,"stats":{"Line":6}},{"line":530,"address":[4633013],"length":1,"stats":{"Line":3}},{"line":532,"address":[],"length":0,"stats":{"Line":12}},{"line":533,"address":[4634265],"length":1,"stats":{"Line":3}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":3}},{"line":538,"address":[],"length":0,"stats":{"Line":6}},{"line":539,"address":[4634382],"length":1,"stats":{"Line":3}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[3314180,3314384,3314079,3314385],"length":1,"stats":{"Line":3}},{"line":544,"address":[],"length":0,"stats":{"Line":3}},{"line":549,"address":[4633184,4633209],"length":1,"stats":{"Line":6}},{"line":551,"address":[5310769],"length":1,"stats":{"Line":3}},{"line":553,"address":[],"length":0,"stats":{"Line":9}},{"line":554,"address":[4633589],"length":1,"stats":{"Line":3}},{"line":555,"address":[5311138],"length":1,"stats":{"Line":0}},{"line":557,"address":[5311553,5311349,5311455],"length":1,"stats":{"Line":3}},{"line":559,"address":[5311191,5311294,5311115],"length":1,"stats":{"Line":6}},{"line":560,"address":[5311194],"length":1,"stats":{"Line":3}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":3}},{"line":565,"address":[5311522,5311479],"length":1,"stats":{"Line":3}},{"line":570,"address":[3312434],"length":1,"stats":{"Line":3}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":3}}],"covered":169,"coverable":220},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","pcs","mod.rs"],"content":"//! Polynomial Commitment Scheme (PCS) implementations for recursive verification.\n\npub mod fri;\npub mod mmcs;\n\npub use fri::{\n    BatchOpeningTargets, CommitPhaseProofStepTargets, FriProofTargets, FriVerifierParams,\n    HashProofTargets, InputProofTargets, MAX_QUERY_INDEX_BITS, MerkleCapTargets, QueryProofTargets,\n    RecExtensionValMmcs, RecValMmcs, TwoAdicFriProofTargets, Witness, verify_fri_circuit,\n};\npub use mmcs::{\n    set_fri_mmcs_private_data, verify_batch_circuit, verify_batch_circuit_from_extension_opened,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","prelude.rs"],"content":"//! Prelude module for common imports.\n//!\n//! This module re-exports the most commonly used items from the crate,\n//! allowing users to write:\n//!\n//! ```ignore\n//! use p3_recursion::prelude::*;\n//! ```\n//!\n//! Instead of importing each item individually.\n\npub use crate::Target;\npub use crate::challenger::CircuitChallenger;\npub use crate::generation::{GenerationError, PcsGeneration, generate_challenges};\npub use crate::pcs::fri::{FriVerifierParams, MAX_QUERY_INDEX_BITS};\npub use crate::public_inputs::{\n    CommitmentOpening, FriVerifierInputs, PublicInputBuilder, StarkVerifierInputs,\n    StarkVerifierInputsBuilder,\n};\npub use crate::traits::{\n    ComsWithOpeningsTargets, Recursive, RecursiveAir, RecursiveChallenger, RecursiveExtensionMmcs,\n    RecursiveMmcs, RecursivePcs,\n};\npub use crate::types::{\n    CommitmentTargets, OpenedValuesTargets, ProofTargets, RecursiveLagrangeSelectors,\n    StarkChallenges,\n};\npub use crate::verifier::{ObservableCommitment, VerificationError, verify_p3_uni_proof_circuit};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","public_inputs.rs"],"content":"//! This module provides type-safe builders and helper functions\n//! for constructing public inputs for recursive verification circuits.\n\nuse alloc::vec::Vec;\n\nuse p3_batch_stark::{BatchProof, CommonData};\nuse p3_circuit::CircuitBuilder;\nuse p3_commit::Pcs;\nuse p3_field::{BasedVectorSpace, Field, PrimeField64};\nuse p3_uni_stark::{Proof, StarkGenericConfig, Val};\n\nuse crate::pcs::MAX_QUERY_INDEX_BITS;\nuse crate::traits::Recursive;\nuse crate::{BatchProofTargets, CommonDataTargets, ProofTargets};\n\n/// Builder for constructing a flat public input vector in a canonical order.\n///\n/// This type accumulates field elements in insertion order.\n///\n/// **NOTE:** The caller is responsible for calling the methods in the same logical\n/// order in which the circuit allocated its public input targets.\n///\n/// The key invariant is:\n///\n/// - The order of calls to this builder must match the order in which the\n///   circuit created its public input targets.\n///\n/// If this invariant is broken, the verifier circuit will read incorrect\n/// values and verification will fail, even if the proof is valid.\n///\n/// # Typical usage\n///\n/// ```ignore\n/// let inputs = PublicInputBuilder::new()\n///     .add_proof_values(proof_values)\n///     .add_challenge(alpha)\n///     .add_challenges(betas)\n///     .build();\n/// ```\n#[derive(Default)]\npub struct PublicInputBuilder\u003cF: Field\u003e {\n    /// Accumulated public input values in exact insertion order.\n    inputs: Vec\u003cF\u003e,\n}\n\nimpl\u003cF: Field\u003e PublicInputBuilder\u003cF\u003e {\n    /// Creates a new empty builder with no accumulated inputs.\n    ///\n    /// The internal vector starts empty and grows as values are added.\n    pub const fn new() -\u003e Self {\n        Self { inputs: Vec::new() }\n    }\n\n    /// Appends a sequence of proof-related values.\n    ///\n    /// These values are usually extracted from a proof or commitment structure.\n    /// They may represent commitments, opened evaluations, FRI data, and\n    /// other components that must appear as public inputs.\n    ///\n    /// # Parameters\n    /// - `values`: An iterable collection of field elements to append.\n    ///\n    /// # Returns\n    /// A mutable reference to `self` for method chaining.\n    pub fn add_proof_values(\u0026mut self, values: impl IntoIterator\u003cItem = F\u003e) -\u003e \u0026mut Self {\n        // Append all provided values at the end of the internal buffer.\n        self.inputs.extend(values);\n        self\n    }\n\n    /// Appends a single challenge value.\n    ///\n    /// Challenges are random-looking values produced by Fiat–Shamir\n    /// procedure on the verifier side.\n    ///\n    /// # Parameters\n    /// - `challenge`: The challenge field element to append.\n    ///\n    /// # Returns\n    /// A mutable reference to `self` for method chaining.\n    pub fn add_challenge(\u0026mut self, challenge: F) -\u003e \u0026mut Self {\n        // Push one challenge at the end of the buffer.\n        self.inputs.push(challenge);\n        self\n    }\n\n    /// Appends a sequence of challenge values.\n    ///\n    /// The order of the iterator is preserved in the public input vector.\n    ///\n    /// # Parameters\n    /// - `challenges`: An iterable collection of challenge elements.\n    ///\n    /// # Returns\n    /// A mutable reference to `self` for method chaining.\n    pub fn add_challenges(\u0026mut self, challenges: impl IntoIterator\u003cItem = F\u003e) -\u003e \u0026mut Self {\n        self.inputs.extend(challenges);\n        self\n    }\n\n    /// Appends the bit decomposition of a query index.\n    ///\n    /// A FRI query index is decomposed into its binary representation.\n    ///\n    /// The bits are stored in little-endian order:\n    /// - bit 0 (least significant bit) comes first.\n    ///\n    /// More precisely, for an integer index `i` we append bits:\n    ///\n    /// ```text\n    ///     i = Σ(j=0 to k-1) b_j · 2^j\n    /// ```\n    ///\n    /// where b_j ∈ {0, 1} and k = `MAX_QUERY_INDEX_BITS`.\n    ///\n    /// # Parameters\n    /// - `index`: The query index as a field element.\n    ///\n    /// # Returns\n    /// A mutable reference to `self` for method chaining.\n    pub fn add_query_index(\u0026mut self, index: F) -\u003e \u0026mut Self\n    where\n        F: PrimeField64,\n    {\n        // Interpret the field element as a canonical 64-bit integer.\n        let index_usize = index.as_canonical_u64() as usize;\n\n        // For each bit position k in [0, MAX_QUERY_INDEX_BITS):\n        for k in 0..MAX_QUERY_INDEX_BITS {\n            // Extract bit k: shift right by k, then mask with 1.\n            let bit = if (index_usize \u003e\u003e k) \u0026 1 == 1 {\n                F::ONE\n            } else {\n                F::ZERO\n            };\n            // Append the bit as a field element (0 or 1).\n            self.inputs.push(bit);\n        }\n\n        self\n    }\n\n    /// Appends pre-decomposed query index bits.\n    ///\n    /// Use this when the bit decomposition has already been performed elsewhere.\n    ///\n    /// The bits must be given in little-endian order (LSB first), and each bit\n    /// should be encoded as field element 0 or 1.\n    ///\n    /// **WARNING**: The number of bits should be \u003c= `MAX_QUERY_INDEX_BITS`.\n    ///\n    /// # Parameters\n    /// - `bits`: An iterable collection of bit elements (each 0 or 1).\n    ///\n    /// # Returns\n    /// A mutable reference to `self` for method chaining.\n    pub fn add_query_index_bits(\u0026mut self, bits: impl IntoIterator\u003cItem = F\u003e) -\u003e \u0026mut Self {\n        // Simply append the provided bits without modification.\n        self.inputs.extend(bits);\n        self\n    }\n\n    /// Returns the current number of accumulated inputs.\n    ///\n    /// This is the length of the internal `inputs` vector.\n    pub const fn len(\u0026self) -\u003e usize {\n        self.inputs.len()\n    }\n\n    /// Returns `true` if no inputs have been added yet.\n    ///\n    /// This is equivalent to `self.len() == 0`.\n    pub const fn is_empty(\u0026self) -\u003e bool {\n        self.inputs.is_empty()\n    }\n\n    /// Consumes the builder and returns the final public input vector.\n    ///\n    /// The returned vector contains all accumulated values in insertion order.\n    ///\n    /// No further modifications can be made through this builder.\n    pub fn build(self) -\u003e Vec\u003cF\u003e {\n        self.inputs\n    }\n}\n\n/// Opening data for a single polynomial commitment.\n///\n/// In a polynomial commitment scheme, a commitment binds to a polynomial.\n///\n/// An opening provides evidence that the committed polynomial evaluates to\n/// specific values at specific points.\n#[derive(Clone, Debug)]\npub struct CommitmentOpening\u003cF: Field\u003e {\n    /// The commitment value in the field representation used by the circuit.\n    pub commitment: F,\n\n    /// Opened evaluation points and their corresponding values.\n    ///\n    /// Each entry is a pair `(z, v)` where:\n    /// - `z` is an evaluation point,\n    /// - `v` is the vector of polynomial values at `z`.\n    pub opened_points: Vec\u003c(F, Vec\u003cF\u003e)\u003e,\n}\n\n/// Helper structure for constructing public inputs for FRI-only circuits.\npub struct FriVerifierInputs\u003cF: Field\u003e {\n    /// Field values extracted from the FRI proof.\n    pub fri_proof_values: Vec\u003cF\u003e,\n\n    /// The batching challenge α used to combine multiple polynomials.\n    ///\n    /// For polynomials p_i(x), the combined polynomial is:\n    ///\n    /// ```text\n    ///     p_comb(x) = Σ_i α^i · p_i(x)\n    /// ```\n    pub alpha: F,\n\n    /// FRI folding challenges.\n    ///\n    /// In each FRI round, the polynomial is folded using a challenge β:\n    ///\n    /// ```text\n    ///     p'(x) = p_even(x) + β · p_odd(x)\n    /// ```\n    pub betas: Vec\u003cF\u003e,\n\n    /// Query index bits for each query, in little-endian order.\n    ///\n    /// Each inner vector:\n    /// - has length `MAX_QUERY_INDEX_BITS`,\n    /// - encodes one query index as bits 0 or 1.\n    pub query_index_bits: Vec\u003cVec\u003cF\u003e\u003e,\n\n    /// Commitment openings for all committed polynomials involved in FRI.\n    pub commitment_openings: Vec\u003cCommitmentOpening\u003cF\u003e\u003e,\n}\n\nimpl\u003cF: Field\u003e FriVerifierInputs\u003cF\u003e {\n    /// Flattens all FRI-related data into a single public input vector.\n    ///\n    /// # Canonical input order\n    /// 1. FRI proof values,\n    /// 2. Batching challenge α,\n    /// 3. FRI folding challenges β,\n    /// 4. Query index bits for each query,\n    /// 5. Commitment openings:\n    ///    - Commitment,\n    ///    - For each opening: `(z, f(z))` values.\n    ///\n    /// # Returns\n    /// A vector of field elements ready for circuit execution.\n    pub fn build(self) -\u003e Vec\u003cF\u003e {\n        // Start from an empty builder.\n        let mut builder = PublicInputBuilder::new();\n\n        // 1. Add all values extracted from the FRI proof structure.\n        builder.add_proof_values(self.fri_proof_values);\n\n        // 2. Add the α challenge for polynomial batching.\n        builder.add_challenge(self.alpha);\n\n        // 3. Add all β challenges for FRI folding.\n        builder.add_challenges(self.betas);\n\n        // 4. Add query index bits for each query.\n        for bits in self.query_index_bits {\n            // Verify that the bit length is \u003c= MAX_QUERY_INDEX_BITS.\n            debug_assert!(\n                bits.len() \u003c= MAX_QUERY_INDEX_BITS,\n                \"query index bit length exceeds limit\"\n            );\n            builder.add_query_index_bits(bits);\n        }\n\n        // 5. Add commitment openings in a fixed layout.\n        for opening in self.commitment_openings {\n            // First add the commitment value itself.\n            builder.add_challenge(opening.commitment);\n\n            // Then, for each opened point, add (z, values at z).\n            for (z, values) in opening.opened_points {\n                builder.add_challenge(z);\n                builder.add_proof_values(values);\n            }\n        }\n\n        // Return the flattened public input vector.\n        builder.build()\n    }\n}\n\n/// Helper structure for constructing public inputs for full STARK verification.\n///\n/// The output is a vector of extension field elements fed to a verifier circuit.\npub struct StarkVerifierInputs\u003cF, EF\u003e\nwhere\n    F: Field + PrimeField64,\n    EF: Field + BasedVectorSpace\u003cF\u003e + From\u003cF\u003e,\n{\n    /// Public input values for the AIR being verified, in the base field.\n    ///\n    /// These encode the statement being proven.\n    pub air_public_values: Vec\u003cF\u003e,\n\n    /// Values extracted from the proof in the extension field.\n    ///\n    /// These encodings usually include:\n    /// - trace commitments,\n    /// - opened values,\n    /// - FRI-related data.\n    pub proof_values: Vec\u003cEF\u003e,\n\n    /// Values extracted from the preprocessed commitment, if present.\n    ///\n    /// These are also in the extension field.\n    pub preprocessed: Vec\u003cEF\u003e,\n\n    /// All Fiat–Shamir challenges used by the verifier.\n    ///\n    /// This typically includes:\n    /// - batching challenge,\n    /// - evaluation points for openings,\n    /// - FRI folding challenges,\n    /// - query indices.\n    pub challenges: Vec\u003cEF\u003e,\n\n    /// Number of FRI queries in the proof.\n    pub num_queries: usize,\n}\n\nimpl\u003cF, EF\u003e StarkVerifierInputs\u003cF, EF\u003e\nwhere\n    F: Field + PrimeField64,\n    EF: Field + BasedVectorSpace\u003cF\u003e + From\u003cF\u003e,\n{\n    /// Flattens all STARK-related data into a single public input vector.\n    ///\n    /// # Canonical input order\n    /// 1. AIR public values,\n    /// 2. Proof values,\n    /// 3. Preprocessed commitment values.\n    ///\n    /// # Returns\n    /// A vector of extension field elements ready for circuit execution.\n    pub fn build(self) -\u003e Vec\u003cEF\u003e {\n        // Use a builder over extension field elements.\n        let mut builder = PublicInputBuilder::new();\n\n        // 1. Lift AIR public values from base field to extension field.\n        builder.add_proof_values(self.air_public_values.iter().map(|\u0026v| v.into()));\n\n        // 2. Add proof values (already in extension field).\n        builder.add_proof_values(self.proof_values);\n\n        // 3. Add preprocessed commitment values.\n        builder.add_proof_values(self.preprocessed);\n\n        builder.build()\n    }\n}\n\n/// Constructs public inputs for a batch (multi-instance) STARK verification circuit.\n///\n/// Batch verification proves several AIR instances at once.\n/// All instances share the same challenges, but each instance has its own AIR public values.\n///\n/// # Parameters\n/// - `air_public_values`: For each instance, its AIR public values in `F`.\n/// - `proof_values`: Values extracted from the batch proof in `EF`.\n/// - `common_data`: Common data values.\n///\n/// # Returns\n/// A vector of extension field elements suitable for a batch verifier circuit.\npub fn construct_batch_stark_verifier_inputs\u003cF, EF\u003e(\n    air_public_values: \u0026[Vec\u003cF\u003e],\n    proof_values: \u0026[EF],\n    common_data: \u0026[EF],\n) -\u003e Vec\u003cEF\u003e\nwhere\n    F: Field + PrimeField64,\n    EF: Field + BasedVectorSpace\u003cF\u003e + From\u003cF\u003e,\n{\n    // Builder over extension field elements.\n    let mut builder = PublicInputBuilder::new();\n\n    // Add public values for each AIR instance, lifting from F to EF.\n    for instance_pv in air_public_values {\n        builder.add_proof_values(instance_pv.iter().map(|\u0026v| v.into()));\n    }\n\n    // Add proof values (already in extension field).\n    builder.add_proof_values(proof_values.iter().copied());\n\n    // Add common_data values.\n    builder.add_proof_values(common_data.iter().copied());\n\n    builder.build()\n}\n\n/// Two-phase builder for single-instance STARK verification circuits.\n///\n/// This builder ties together:\n/// 1. Circuit construction phase:\n///    - allocate public input targets in the circuit,\n///    - record their structure inside this builder.\n/// 2. Execution phase:\n///    - pack concrete values into a public input vector in exactly the same\n///      order as the allocation order.\n///\n/// The central invariant is that target allocation and value packing are\n/// perfectly aligned in both order and shape.\n///\n/// # Usage Pattern\n///\n/// ```ignore\n/// // Phase 1: Circuit building\n/// let mut circuit = CircuitBuilder::new();\n/// let verifier = StarkVerifierInputsBuilder::allocate(\u0026mut circuit, \u0026proof, pis.len());\n/// verify_circuit(config, air, \u0026mut circuit, \u0026verifier.proof_targets, \u0026verifier.air_public_targets, ...)?;\n/// let built_circuit = circuit.build()?;\n///\n/// // Phase 2: Execution\n/// let public_inputs = verifier.pack_values(\u0026pis, \u0026proof, \u0026None);\n/// runner.set_public_inputs(\u0026public_inputs)?;\n/// ```\npub struct StarkVerifierInputsBuilder\u003cSC, Comm, OpeningProof\u003e\nwhere\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e,\n    OpeningProof:\n        Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n{\n    /// Public input targets for the AIR public values.\n    ///\n    /// The element at index `i` corresponds to the `i`-th AIR public value.\n    pub air_public_targets: Vec\u003ccrate::Target\u003e,\n\n    /// Targets representing the entire proof structure.\n    ///\n    /// This includes trace commitments, opened evaluations, and FRI data.\n    pub proof_targets: ProofTargets\u003cSC, Comm, OpeningProof\u003e,\n\n    /// Target representation of the preprocessed commitment, if present.\n    ///\n    /// `None` when the AIR has no preprocessed columns.\n    pub preprocessed_commit: Option\u003cComm\u003e,\n}\n\n/// Type alias for the commitment type inside a STARK configuration.\n///\n/// This extracts the commitment type of the PCS used by the configuration.\ntype Com\u003cSC\u003e = \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\n    \u003cSC as StarkGenericConfig\u003e::Challenger,\n\u003e\u003e::Commitment;\n\nimpl\u003cSC, Comm, OpeningProof\u003e StarkVerifierInputsBuilder\u003cSC, Comm, OpeningProof\u003e\nwhere\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e,\n    OpeningProof:\n        Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n{\n    /// Allocates all public input targets during circuit construction.\n    ///\n    /// This method only inspects the *shape* of the proof and preprocessed\n    /// commitment. It does not depend on any concrete values.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder in which targets are allocated.\n    /// - `proof`: A reference proof used solely to determine the target shape.\n    /// - `preprocessed_commit`: Optional reference preprocessed commitment.\n    /// - `num_air_public_inputs`: Number of AIR public inputs.\n    ///\n    /// # Returns\n    /// A `StarkVerifierInputsBuilder` that remembers the allocation layout.\n    pub fn allocate(\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        proof: \u0026Proof\u003cSC\u003e,\n        preprocessed_commit: Option\u003c\u0026Com\u003cSC\u003e\u003e,\n        num_air_public_inputs: usize,\n    ) -\u003e Self {\n        // Allocate public input targets for the AIR public values.\n        //\n        // These targets come first in the overall public input ordering.\n        let air_public_targets = (0..num_air_public_inputs)\n            .map(|_| circuit.public_input())\n            .collect();\n\n        // Allocate targets for all proof components based on the reference proof.\n        let proof_targets = ProofTargets::new(circuit, proof);\n\n        // Allocate targets for the preprocessed commitment if it exists.\n        //\n        // The commitment wrapper knows how to mirror the structure as targets.\n        let preprocessed_commit = preprocessed_commit\n            .as_ref()\n            .map(|prep_comm| Comm::new(circuit, prep_comm));\n\n        Self {\n            air_public_targets,\n            proof_targets,\n            preprocessed_commit,\n        }\n    }\n\n    /// Packs concrete values into public inputs in the canonical order.\n    ///\n    /// This must be called in the execution phase, after proof data is known.\n    ///\n    /// The output vector is consistent with the target allocation order used in `allocate`.\n    ///\n    /// # Parameters\n    /// - `air_public_values`: AIR public values in the base field.\n    /// - `proof`: Actual proof whose values are extracted.\n    /// - `preprocessed_commit`: Actual preprocessed commitment, if any.\n    ///\n    /// # Returns\n    /// A public input vector ready to be passed to the verifier circuit.\n    pub fn pack_values(\n        \u0026self,\n        air_public_values: \u0026[Val\u003cSC\u003e],\n        proof: \u0026Proof\u003cSC\u003e,\n        preprocessed_commit: \u0026Option\u003cCom\u003cSC\u003e\u003e,\n    ) -\u003e Vec\u003cSC::Challenge\u003e\n    where\n        Val\u003cSC\u003e: PrimeField64,\n        SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e + From\u003cVal\u003cSC\u003e\u003e,\n    {\n        // Extract extension-field values from the proof structure.\n        //\n        // The internal order is compatible with the way the proof targets were created.\n        let proof_values = ProofTargets::\u003cSC, Comm, OpeningProof\u003e::get_values(proof);\n\n        // Extract values from the preprocessed commitment, if it exists.\n        //\n        // If there is no preprocessed commitment, use an empty vector.\n        let preprocessed = preprocessed_commit\n            .as_ref()\n            .map_or_else(Vec::new, |prep_comm| Comm::get_values(prep_comm));\n\n        // Combine all components into a single public input vector.\n        StarkVerifierInputs {\n            air_public_values: air_public_values.to_vec(),\n            proof_values: proof_values.to_vec(),\n            preprocessed: preprocessed.to_vec(),\n            challenges: Vec::new(),\n            num_queries: 0,\n        }\n        .build()\n    }\n}\n\n/// Two-phase builder for batch (multi-instance) STARK verification circuits.\n///\n/// This is the batch analogue of the single-instance inputs builder.\n///\n/// It manages:\n/// - per-instance AIR public input targets,\n/// - batch proof targets,\n///\n/// and later packs concrete values into a flat public input vector.\npub struct BatchStarkVerifierInputsBuilder\u003cSC, Comm, OpeningProof\u003e\nwhere\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e,\n    OpeningProof:\n        Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n{\n    /// Per-instance public input targets.\n    ///\n    /// `air_public_targets[i]` is the list of public input targets for instance `i`.\n    pub air_public_targets: Vec\u003cVec\u003ccrate::Target\u003e\u003e,\n\n    /// Targets representing the batch proof structure.\n    ///\n    /// This includes all commitments and openings for all instances.\n    pub proof_targets: BatchProofTargets\u003cSC, Comm, OpeningProof\u003e,\n    /// Allocated common data targets (if any).\n    pub common_data: CommonDataTargets\u003cSC, Comm\u003e,\n}\n\nimpl\u003cSC, Comm, OpeningProof\u003e BatchStarkVerifierInputsBuilder\u003cSC, Comm, OpeningProof\u003e\nwhere\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e,\n    OpeningProof:\n        Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n{\n    /// Allocates public input targets for batch verification.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder into which targets are allocated.\n    /// - `proof`: Reference batch proof used only for its structure.\n    /// - `air_public_counts`: Number of public inputs per AIR instance.\n    ///\n    /// # Panics\n    /// Panics if `air_public_counts.len()` does not match the number of instances in the batch proof.\n    pub fn allocate(\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        proof: \u0026BatchProof\u003cSC\u003e,\n        common_data: \u0026CommonData\u003cSC\u003e,\n        air_public_counts: \u0026[usize],\n    ) -\u003e Self {\n        // Ensure we have one public count per instance.\n        assert_eq!(\n            air_public_counts.len(),\n            proof.opened_values.instances.len(),\n            \"public input count must match number of instances\"\n        );\n\n        // For each instance, allocate `count` public input targets.\n        let air_public_targets = air_public_counts\n            .iter()\n            .map(|\u0026count| (0..count).map(|_| circuit.public_input()).collect())\n            .collect();\n\n        // Allocate targets for the batch proof structure, based on the reference proof.\n        let proof_targets = BatchProofTargets::new(circuit, proof);\n\n        let common_data = CommonDataTargets::\u003cSC, Comm\u003e::new(circuit, common_data);\n\n        Self {\n            air_public_targets,\n            proof_targets,\n            common_data,\n        }\n    }\n\n    /// Packs concrete values into public inputs for batch verification.\n    ///\n    /// # Parameters\n    /// - `air_public_values`: AIR public values for each instance.\n    /// - `proof`: Actual batch proof.\n    /// - `common`: Common data for the batch proof.\n    ///\n    /// # Returns\n    /// A flattened public input vector ready for the batch verifier circuit.\n    pub fn pack_values(\n        \u0026self,\n        air_public_values: \u0026[Vec\u003cVal\u003cSC\u003e\u003e],\n        proof: \u0026BatchProof\u003cSC\u003e,\n        common: \u0026CommonData\u003cSC\u003e,\n    ) -\u003e Vec\u003cSC::Challenge\u003e\n    where\n        Val\u003cSC\u003e: PrimeField64,\n        SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e + From\u003cVal\u003cSC\u003e\u003e,\n    {\n        // Extract extension-field values from the batch proof structure.\n        //\n        // The internal order matches the structure used when targets were created.\n        let common_data = CommonDataTargets::\u003cSC, Comm\u003e::get_values(common);\n        let proof_values = BatchProofTargets::\u003cSC, Comm, OpeningProof\u003e::get_values(proof);\n\n        // Combine AIR public values and proof values into a single public input vector.\n        construct_batch_stark_verifier_inputs(air_public_values, \u0026proof_values, \u0026common_data)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n    use proptest::prelude::*;\n\n    use super::*;\n\n    #[test]\n    fn test_public_input_builder() {\n        let mut builder = PublicInputBuilder::\u003cBabyBear\u003e::new();\n\n        // Initially empty.\n        assert_eq!(builder.len(), 0);\n        assert!(builder.is_empty());\n\n        // Add various values.\n        builder\n            .add_proof_values([BabyBear::from_u32(1), BabyBear::from_u32(2)])\n            .add_challenge(BabyBear::from_u32(3))\n            .add_challenges([BabyBear::from_u32(4), BabyBear::from_u32(5)]);\n\n        // Verify accumulated count.\n        assert_eq!(builder.len(), 5);\n        assert!(!builder.is_empty());\n\n        // Build and verify contents.\n        let inputs = builder.build();\n        assert_eq!(inputs.len(), 5);\n        assert_eq!(inputs[0], BabyBear::from_u32(1));\n        assert_eq!(inputs[4], BabyBear::from_u32(5));\n    }\n\n    #[test]\n    fn test_query_index_bit_decomposition() {\n        let mut builder = PublicInputBuilder::\u003cBabyBear\u003e::new();\n\n        // Index 5 = 0b101 in binary.\n        builder.add_query_index(BabyBear::from_u32(5));\n\n        let inputs = builder.build();\n\n        // Should have exactly MAX_QUERY_INDEX_BITS bits.\n        assert_eq!(inputs.len(), MAX_QUERY_INDEX_BITS);\n\n        // Verify little-endian bit pattern: 101 means bits are [1, 0, 1, 0, 0, ...].\n        assert_eq!(inputs[0], BabyBear::ONE); // bit 0 (LSB)\n        assert_eq!(inputs[1], BabyBear::ZERO); // bit 1\n        assert_eq!(inputs[2], BabyBear::ONE); // bit 2\n\n        // Remaining bits should all be zero.\n        for \u0026bit in \u0026inputs[3..] {\n            assert_eq!(bit, BabyBear::ZERO);\n        }\n    }\n\n    /// Strategy for generating random BabyBear field elements.\n    fn field_element() -\u003e impl Strategy\u003cValue = BabyBear\u003e {\n        any::\u003cu32\u003e().prop_map(BabyBear::from_u32)\n    }\n\n    proptest! {\n        #[test]\n        fn build_preserves_order(vals in prop::collection::vec(field_element(), 1..20)) {\n            let mut builder = PublicInputBuilder::\u003cBabyBear\u003e::new();\n            builder.add_proof_values(vals.clone());\n\n            let result = builder.build();\n\n            // Length must match.\n            prop_assert_eq!(result.len(), vals.len());\n\n            // Each element must be in the same position.\n            for (i, \u0026val) in vals.iter().enumerate() {\n                prop_assert_eq!(result[i], val);\n            }\n        }\n\n        #[test]\n        fn chaining_preserves_order(\n            vals1 in prop::collection::vec(field_element(), 1..10),\n            challenge in field_element(),\n            vals2 in prop::collection::vec(field_element(), 1..10)\n        ) {\n            let mut builder = PublicInputBuilder::\u003cBabyBear\u003e::new();\n\n            // Chain multiple additions.\n            builder\n                .add_proof_values(vals1.clone())\n                .add_challenge(challenge)\n                .add_challenges(vals2.clone());\n\n            let result = builder.build();\n\n            // Verify total length.\n            let expected_len = vals1.len() + 1 + vals2.len();\n            prop_assert_eq!(result.len(), expected_len);\n\n            // Verify vals1 appears first, in order.\n            for (i, \u0026val) in vals1.iter().enumerate() {\n                prop_assert_eq!(result[i], val, \"vals1 order\");\n            }\n\n            // Verify challenge appears after vals1.\n            prop_assert_eq!(result[vals1.len()], challenge, \"challenge position\");\n\n            // Verify vals2 appears after challenge, in order.\n            for (i, \u0026val) in vals2.iter().enumerate() {\n                prop_assert_eq!(result[vals1.len() + 1 + i], val, \"vals2 order\");\n            }\n        }\n    }\n}\n","traces":[{"line":50,"address":[2743488],"length":1,"stats":{"Line":10}},{"line":51,"address":[4625581],"length":1,"stats":{"Line":10}},{"line":65,"address":[6361760,6361696],"length":1,"stats":{"Line":20}},{"line":67,"address":[5400664,5400616],"length":1,"stats":{"Line":19}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[2689440],"length":1,"stats":{"Line":3}},{"line":97,"address":[2689453],"length":1,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[6361488],"length":1,"stats":{"Line":1}},{"line":126,"address":[6361506],"length":1,"stats":{"Line":1}},{"line":129,"address":[6361526,6361551],"length":1,"stats":{"Line":2}},{"line":131,"address":[6361666,6361598,6361626],"length":1,"stats":{"Line":3}},{"line":132,"address":[6361668],"length":1,"stats":{"Line":1}},{"line":134,"address":[6361658],"length":1,"stats":{"Line":1}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[6361957],"length":1,"stats":{"Line":1}},{"line":182,"address":[3671488],"length":1,"stats":{"Line":9}},{"line":183,"address":[4128387],"length":1,"stats":{"Line":9}},{"line":254,"address":[2689019,2687440,2689340],"length":1,"stats":{"Line":1}},{"line":256,"address":[],"length":0,"stats":{"Line":1}},{"line":259,"address":[2687616],"length":1,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":1}},{"line":265,"address":[2687740],"length":1,"stats":{"Line":1}},{"line":268,"address":[2689222,2687979,2687797],"length":1,"stats":{"Line":3}},{"line":270,"address":[2689095,2689194],"length":1,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":278,"address":[2688886,2688099,2688281],"length":1,"stats":{"Line":3}},{"line":280,"address":[2688374],"length":1,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":3}},{"line":284,"address":[2688827],"length":1,"stats":{"Line":1}},{"line":285,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[2688433],"length":1,"stats":{"Line":1}},{"line":347,"address":[4128921,4128416],"length":1,"stats":{"Line":4}},{"line":349,"address":[2890630],"length":1,"stats":{"Line":4}},{"line":352,"address":[4128536,4128609,4129040,4129062],"length":1,"stats":{"Line":12}},{"line":355,"address":[4128678],"length":1,"stats":{"Line":4}},{"line":358,"address":[3671830],"length":1,"stats":{"Line":4}},{"line":360,"address":[],"length":0,"stats":{"Line":4}},{"line":376,"address":[4625664,4626373,4626401],"length":1,"stats":{"Line":4}},{"line":386,"address":[4625791],"length":1,"stats":{"Line":4}},{"line":389,"address":[2891548,2891468],"length":1,"stats":{"Line":8}},{"line":390,"address":[4626012,4626416,4626299,4626438],"length":1,"stats":{"Line":8}},{"line":394,"address":[2891680],"length":1,"stats":{"Line":4}},{"line":397,"address":[],"length":0,"stats":{"Line":4}},{"line":399,"address":[2891842],"length":1,"stats":{"Line":4}},{"line":485,"address":[5211011,5210560,5211017],"length":1,"stats":{"Line":4}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":8}},{"line":499,"address":[],"length":0,"stats":{"Line":4}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[3673166,3673424,3673445],"length":1,"stats":{"Line":8}},{"line":528,"address":[2892112,2892766,2892760],"length":1,"stats":{"Line":4}},{"line":541,"address":[5209914],"length":1,"stats":{"Line":4}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":8}},{"line":552,"address":[3672384],"length":1,"stats":{"Line":4}},{"line":553,"address":[],"length":0,"stats":{"Line":8}},{"line":554,"address":[2892434,2892506],"length":1,"stats":{"Line":8}},{"line":555,"address":[4129513],"length":1,"stats":{"Line":4}},{"line":613,"address":[4626848,4627406,4627400],"length":1,"stats":{"Line":4}},{"line":620,"address":[2744877],"length":1,"stats":{"Line":5}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[4627087,4627504,4627424,4627448,4627518],"length":1,"stats":{"Line":13}},{"line":633,"address":[],"length":0,"stats":{"Line":5}},{"line":635,"address":[5402306],"length":1,"stats":{"Line":4}},{"line":653,"address":[2893718,2893724,2893376],"length":1,"stats":{"Line":4}},{"line":666,"address":[],"length":0,"stats":{"Line":4}},{"line":667,"address":[4626588],"length":1,"stats":{"Line":5}},{"line":670,"address":[2744639,2744560],"length":1,"stats":{"Line":8}}],"covered":69,"coverable":84},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","recursion.rs"],"content":"//! Unified recursion API: one entry point to prove the next layer over a uni-stark or batch-stark proof.\n\nuse alloc::rc::Rc;\nuse alloc::string::ToString;\nuse alloc::vec::Vec;\n\nuse p3_air::SymbolicExpression;\nuse p3_batch_stark::{CommonData, ProverData};\nuse p3_circuit::tables::Traces;\nuse p3_circuit::utils::ColumnsTargets;\nuse p3_circuit::{Circuit, CircuitBuilder, CircuitRunner, NonPrimitiveOpId};\nuse p3_circuit_prover::common::{NonPrimitiveConfig, get_airs_and_degrees_with_prep};\nuse p3_circuit_prover::config::StarkField;\nuse p3_circuit_prover::field_params::ExtractBinomialW;\nuse p3_circuit_prover::{\n    AirVariant, BatchStarkProof, BatchStarkProver, CircuitProverData, ConstraintProfile,\n    TablePacking,\n};\nuse p3_commit::Pcs;\nuse p3_field::extension::BinomiallyExtendable;\nuse p3_field::{BasedVectorSpace, ExtensionField, Field, PrimeField64};\nuse p3_lookup::logup::LogUpGadget;\nuse p3_lookup::lookup_traits::{Lookup, LookupData, LookupGadget};\nuse p3_uni_stark::{Proof, StarkGenericConfig, Val};\nuse tracing::instrument;\n\nuse crate::Target;\nuse crate::ops::Poseidon2Config;\nuse crate::traits::{LookupMetadata, RecursiveAir};\nuse crate::types::RecursiveLagrangeSelectors;\nuse crate::verifier::VerificationError;\n\nfn proof_shape_err(e: \u0026impl ToString) -\u003e VerificationError {\n    VerificationError::InvalidProofShape(e.to_string())\n}\n\n/// Cached prover data and prover for aggregation when the same verification circuit is reused per level.\n/// Pass `Some(\u0026mut None)` on the first aggregation at a given level; the slot is filled after the\n/// first proof and reused for subsequent pairs to avoid ~100ms of clone/from_airs_and_degrees/prover creation.\npub struct AggregationPrepCache\u003cSC: StarkGenericConfig + 'static\u003e {\n    pub circuit_prover_data: Rc\u003cCircuitProverData\u003cSC\u003e\u003e,\n    pub prover: BatchStarkProver\u003cSC\u003e,\n}\n\n/// Input to one recursion step: either a uni-stark proof or a batch-stark proof (with common data).\npub enum RecursionInput\u003c'a, SC, A\u003e\nwhere\n    SC: StarkGenericConfig,\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n{\n    /// A single-instance STARK proof (e.g. from p3-uni-stark) plus its AIR and public inputs.\n    UniStark {\n        proof: \u0026'a Proof\u003cSC\u003e,\n        air: \u0026'a A,\n        public_inputs: Vec\u003cVal\u003cSC\u003e\u003e,\n        preprocessed_commit: Option\u003c\u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment\u003e,\n    },\n    /// A batch STARK proof (e.g. from p3-batch-stark / circuit-prover) plus common data and per-table public inputs.\n    BatchStark {\n        proof: \u0026'a BatchStarkProof\u003cSC\u003e,\n        common_data: \u0026'a CommonData\u003cSC\u003e,\n        table_public_inputs: Vec\u003cVec\u003cVal\u003cSC\u003e\u003e\u003e,\n    },\n}\n\n/// Output of one recursion step: the next-layer batch proof and its prover data (for chaining or verification).\npub struct RecursionOutput\u003cSC\u003e(pub BatchStarkProof\u003cSC\u003e, pub Rc\u003cCircuitProverData\u003cSC\u003e\u003e)\nwhere\n    SC: StarkGenericConfig;\n\nimpl\u003cSC\u003e RecursionOutput\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    /// Convert this output into a `RecursionInput::BatchStark` for the next recursion layer.\n    /// The type parameter `A` is only used for the recursion input type; use `BatchOnly` when\n    /// chaining batch-to-batch (see [`BatchOnly`]).\n    pub fn into_recursion_input\u003cA\u003e(\u0026self) -\u003e RecursionInput\u003c'_, SC, A\u003e\n    where\n        A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    {\n        let num_tables = self.0.proof.opened_values.instances.len();\n        RecursionInput::BatchStark {\n            proof: \u0026self.0,\n            common_data: self.1.common_data(),\n            table_public_inputs: alloc::vec![alloc::vec![]; num_tables],\n        }\n    }\n}\n\n/// Result of building a verifier circuit: holds enough to pack public inputs and set private data.\npub trait VerifierCircuitResult\u003cSC, A\u003e\nwhere\n    SC: StarkGenericConfig,\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n{\n    /// Pack the public inputs for the verifier circuit from the previous recursion input.\n    fn pack_public_inputs(\n        \u0026self,\n        prev: \u0026RecursionInput\u003c'_, SC, A\u003e,\n    ) -\u003e Result\u003cVec\u003cSC::Challenge\u003e, VerificationError\u003e\n    where\n        Val\u003cSC\u003e: PrimeField64,\n        SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e + From\u003cVal\u003cSC\u003e\u003e;\n\n    /// Operation IDs that require private data (e.g. Merkle paths) for the circuit runner.\n    fn op_ids(\u0026self) -\u003e \u0026[NonPrimitiveOpId];\n}\n\n/// PCS-specific backend for building verifier circuits and setting private data.\npub trait PcsRecursionBackend\u003cSC, A\u003e\nwhere\n    SC: StarkGenericConfig,\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n{\n    /// Opaque verifier result returned by `build_verifier_circuit`.\n    type VerifierResult: VerifierCircuitResult\u003cSC, A\u003e;\n\n    /// Prepare the circuit before building the verifier (e.g. enable Poseidon2). Called before `build_verifier_circuit`.\n    fn prepare_circuit(\n        \u0026self,\n        config: \u0026SC,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    ) -\u003e Result\u003c(), VerificationError\u003e;\n\n    /// Build the verifier circuit for the given recursion input; add constraints to `circuit`.\n    fn build_verifier_circuit(\n        \u0026self,\n        prev: \u0026RecursionInput\u003c'_, SC, A\u003e,\n        config: \u0026SC,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    ) -\u003e Result\u003cSelf::VerifierResult, VerificationError\u003e;\n\n    /// Set PCS-specific private data (e.g. FRI Merkle paths) on the runner.\n    fn set_private_data(\n        \u0026self,\n        config: \u0026SC,\n        runner: \u0026mut CircuitRunner\u003cSC::Challenge\u003e,\n        op_ids: \u0026[NonPrimitiveOpId],\n        prev: \u0026RecursionInput\u003c'_, SC, A\u003e,\n    ) -\u003e Result\u003c(), \u0026'static str\u003e;\n\n    /// If the backend uses Poseidon2 in the circuit (e.g. for MMCS), return its config for `get_airs_and_degrees_with_prep`.\n    fn poseidon2_config_for_circuit(\u0026self) -\u003e Option\u003cPoseidon2Config\u003e {\n        None\n    }\n}\n\n/// Parameters for the shared recursion pipeline (table packing, optional overrides).\n#[derive(Clone, Debug)]\npub struct ProveNextLayerParams {\n    pub table_packing: TablePacking,\n    pub use_poseidon2_in_circuit: bool,\n    /// Constraint profile controlling which AIR variants are used for this layer.\n    pub constraint_profile: ConstraintProfile,\n}\n\nimpl Default for ProveNextLayerParams {\n    fn default() -\u003e Self {\n        Self {\n            table_packing: TablePacking::new(3, 1, 4),\n            use_poseidon2_in_circuit: true,\n            constraint_profile: ConstraintProfile::Standard,\n        }\n    }\n}\n\n/// Marker type for batch-only recursion input. Use with [`RecursionOutput::into_recursion_input`]\n/// when chaining batch-to-batch layers (e.g. `output.into_recursion_input::\u003cBatchOnly\u003e()`).\n#[derive(Debug)]\npub struct BatchOnly;\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, LG: LookupGadget\u003e RecursiveAir\u003cF, EF, LG\u003e for BatchOnly {\n    fn width(\u0026self) -\u003e usize {\n        0\n    }\n\n    fn eval_folded_circuit(\n        \u0026self,\n        builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n        _sels: \u0026RecursiveLagrangeSelectors,\n        _alpha: \u0026Target,\n        _lookup_metadata: \u0026LookupMetadata\u003c'_, F\u003e,\n        _columns: ColumnsTargets\u003c'_\u003e,\n        _lookup_gadget: \u0026LG,\n    ) -\u003e Target {\n        builder.define_const(EF::ZERO)\n    }\n\n    fn get_log_num_quotient_chunks(\n        \u0026self,\n        _preprocessed_width: usize,\n        _num_public_values: usize,\n        _contexts: \u0026[Lookup\u003cF\u003e],\n        _lookup_data: \u0026[LookupData\u003cusize\u003e],\n        _is_zk: usize,\n        _lookup_gadget: \u0026LG,\n    ) -\u003e usize {\n        0\n    }\n}\n\n/// Build a verifier circuit for a recursion layer.\n#[instrument(skip_all)]\nfn build_next_layer_circuit\u003cSC, A, B\u003e(\n    prev: \u0026RecursionInput\u003c'_, SC, A\u003e,\n    config: \u0026SC,\n    backend: \u0026B,\n) -\u003e Result\u003c(Circuit\u003cSC::Challenge\u003e, B::VerifierResult), VerificationError\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync + Clone + 'static,\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    B: PcsRecursionBackend\u003cSC, A\u003e,\n    Val\u003cSC\u003e: PrimeField64 + StarkField + BinomiallyExtendable\u003c4\u003e,\n    SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e\n        + From\u003cVal\u003cSC\u003e\u003e\n        + ExtensionField\u003cVal\u003cSC\u003e\u003e\n        + ExtractBinomialW\u003cVal\u003cSC\u003e\u003e,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    let mut circuit_builder = CircuitBuilder::new();\n    // Enable Poseidon2\n    backend.prepare_circuit(config, \u0026mut circuit_builder)?;\n\n    // Build verifier constraints.\n    let verifier_result = backend.build_verifier_circuit(prev, config, \u0026mut circuit_builder)?;\n    let verification_circuit = circuit_builder\n        .build()\n        .map_err(VerificationError::CircuitBuilder)?;\n\n    Ok((verification_circuit, verifier_result))\n}\n\n/// Prove one recursion layer: build a verifier circuit for `prev`, run it, and prove it with batch STARK.\n#[instrument(skip_all)]\npub fn prove_next_layer\u003cSC, A, B, const D: usize\u003e(\n    prev: \u0026RecursionInput\u003c'_, SC, A\u003e,\n    verification_circuit: Circuit\u003cSC::Challenge\u003e,\n    verifier_result: \u0026B::VerifierResult,\n    config: \u0026SC,\n    backend: \u0026B,\n    params: \u0026ProveNextLayerParams,\n) -\u003e Result\u003cRecursionOutput\u003cSC\u003e, VerificationError\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync + Clone + 'static,\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    B: PcsRecursionBackend\u003cSC, A\u003e,\n    Val\u003cSC\u003e: PrimeField64 + StarkField + BinomiallyExtendable\u003c4\u003e,\n    SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e\n        + From\u003cVal\u003cSC\u003e\u003e\n        + ExtensionField\u003cVal\u003cSC\u003e\u003e\n        + ExtractBinomialW\u003cVal\u003cSC\u003e\u003e,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    let non_primitive = backend\n        .poseidon2_config_for_circuit()\n        .map(|c| alloc::vec![NonPrimitiveConfig::Poseidon2(c)]);\n    let non_primitive_ref = non_primitive.as_deref();\n\n    let (airs_degrees, preprocessed_columns) = {\n        get_airs_and_degrees_with_prep::\u003cSC, SC::Challenge, D\u003e(\n            \u0026verification_circuit,\n            params.table_packing,\n            non_primitive_ref,\n            params.constraint_profile,\n        )\n        .map_err(VerificationError::Circuit)?\n    };\n\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003c_\u003e) = airs_degrees.into_iter().unzip();\n\n    let traces = {\n        let public_inputs = verifier_result.pack_public_inputs(prev)?;\n        let mut runner = verification_circuit.runner();\n        runner\n            .set_public_inputs(\u0026public_inputs)\n            .map_err(VerificationError::Circuit)?;\n\n        backend\n            .set_private_data(config, \u0026mut runner, verifier_result.op_ids(), prev)\n            .map_err(|e| proof_shape_err(\u0026e))?;\n\n        runner.run().map_err(VerificationError::Circuit)?\n    };\n\n    let circuit_prover_data = {\n        let prover_data = ProverData::from_airs_and_degrees(config, \u0026mut airs, \u0026degrees);\n        CircuitProverData::new(prover_data, preprocessed_columns)\n    };\n\n    let mut prover = BatchStarkProver::new(config.clone())\n        .with_table_packing(params.table_packing)\n        .with_alu_variant(match params.constraint_profile {\n            ConstraintProfile::Standard =\u003e AirVariant::Baseline,\n            ConstraintProfile::RecursionOptimized =\u003e AirVariant::Optimized,\n        });\n    if let Some(cfg) = backend.poseidon2_config_for_circuit() {\n        prover.register_poseidon2_table(cfg);\n    }\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .map_err(|e| proof_shape_err(\u0026e.to_string()))?;\n\n    Ok(RecursionOutput(proof, Rc::new(circuit_prover_data)))\n}\n\n/// Convenience method to build and prove a recursion layer.\n///\n/// In production environments, consider using [`prove_next_layer`] directly for better performance.\n///\n/// # Example\n///\n/// ```ignore\n/// let (verification_circuit, verifier_result) = build_next_layer_circuit::\u003cSC, A, B\u003e(prev, config, backend)?;\n/// let out = prove_next_layer::\u003cSC, A, B, D\u003e(prev, verification_circuit, verifier_result, config, backend, params);\n/// ```\npub fn build_and_prove_next_layer\u003cSC, A, B, const D: usize\u003e(\n    prev: \u0026RecursionInput\u003c'_, SC, A\u003e,\n    config: \u0026SC,\n    backend: \u0026B,\n    params: \u0026ProveNextLayerParams,\n) -\u003e Result\u003cRecursionOutput\u003cSC\u003e, VerificationError\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync + Clone + 'static,\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    B: PcsRecursionBackend\u003cSC, A\u003e,\n    Val\u003cSC\u003e: PrimeField64 + StarkField + BinomiallyExtendable\u003c4\u003e,\n    SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e\n        + From\u003cVal\u003cSC\u003e\u003e\n        + ExtensionField\u003cVal\u003cSC\u003e\u003e\n        + ExtractBinomialW\u003cVal\u003cSC\u003e\u003e,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    let (verification_circuit, verifier_result) =\n        build_next_layer_circuit::\u003cSC, A, B\u003e(prev, config, backend)?;\n\n    prove_next_layer::\u003cSC, A, B, D\u003e(\n        prev,\n        verification_circuit,\n        \u0026verifier_result,\n        config,\n        backend,\n        params,\n    )\n}\n\n/// Build a 2-to-1 aggregation layer verifier circuit.\n///\n/// The two inputs may be different `RecursionInput` variants (e.g. one `UniStark` left\n/// and one `BatchStark` right) or identical ones.\n#[instrument(skip_all)]\n#[allow(clippy::type_complexity)]\nfn build_aggregation_layer_circuit\u003cSC, A1, A2, B, const D: usize\u003e(\n    left: \u0026RecursionInput\u003c'_, SC, A1\u003e,\n    right: \u0026RecursionInput\u003c'_, SC, A2\u003e,\n    config: \u0026SC,\n    backend: \u0026B,\n) -\u003e Result\u003c\n    (\n        Circuit\u003cSC::Challenge\u003e,\n        (\n            \u003cB as PcsRecursionBackend\u003cSC, A1\u003e\u003e::VerifierResult, // left\n            \u003cB as PcsRecursionBackend\u003cSC, A2\u003e\u003e::VerifierResult, // right\n        ),\n    ),\n    VerificationError,\n\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync + Clone + 'static,\n    A1: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    A2: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    B: PcsRecursionBackend\u003cSC, A1\u003e + PcsRecursionBackend\u003cSC, A2\u003e,\n    Val\u003cSC\u003e: PrimeField64 + StarkField + BinomiallyExtendable\u003c4\u003e,\n    SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e\n        + From\u003cVal\u003cSC\u003e\u003e\n        + ExtensionField\u003cVal\u003cSC\u003e\u003e\n        + ExtractBinomialW\u003cVal\u003cSC\u003e\u003e,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    let mut circuit_builder = CircuitBuilder::new();\n\n    // Enable Poseidon2 once — shared by both verifications.\n    \u003cB as PcsRecursionBackend\u003cSC, A1\u003e\u003e::prepare_circuit(backend, config, \u0026mut circuit_builder)?;\n    \u003cB as PcsRecursionBackend\u003cSC, A2\u003e\u003e::prepare_circuit(backend, config, \u0026mut circuit_builder)?;\n\n    // Build left verifier constraints.\n    let left_result = backend.build_verifier_circuit(left, config, \u0026mut circuit_builder)?;\n    // Build right verifier constraints into the same builder.\n    let right_result = backend.build_verifier_circuit(right, config, \u0026mut circuit_builder)?;\n\n    let verification_circuit = circuit_builder\n        .build()\n        .map_err(VerificationError::CircuitBuilder)?;\n\n    Ok((verification_circuit, (left_result, right_result)))\n}\n\nfn run_aggregation_verification_circuit\u003cSC, A1, A2, B\u003e(\n    left: \u0026RecursionInput\u003c'_, SC, A1\u003e,\n    right: \u0026RecursionInput\u003c'_, SC, A2\u003e,\n    left_result: \u0026\u003cB as PcsRecursionBackend\u003cSC, A1\u003e\u003e::VerifierResult,\n    right_result: \u0026\u003cB as PcsRecursionBackend\u003cSC, A2\u003e\u003e::VerifierResult,\n    verification_circuit: \u0026Circuit\u003cSC::Challenge\u003e,\n    config: \u0026SC,\n    backend: \u0026B,\n) -\u003e Result\u003cTraces\u003cSC::Challenge\u003e, VerificationError\u003e\nwhere\n    SC: StarkGenericConfig,\n    A1: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    A2: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    B: PcsRecursionBackend\u003cSC, A1\u003e + PcsRecursionBackend\u003cSC, A2\u003e,\n    Val\u003cSC\u003e: PrimeField64,\n{\n    let mut public_inputs = left_result.pack_public_inputs(left)?;\n    public_inputs.extend(right_result.pack_public_inputs(right)?);\n\n    let mut runner = verification_circuit.clone().runner();\n    runner\n        .set_public_inputs(\u0026public_inputs)\n        .map_err(VerificationError::Circuit)?;\n\n    \u003cB as PcsRecursionBackend\u003cSC, A1\u003e\u003e::set_private_data(\n        backend,\n        config,\n        \u0026mut runner,\n        left_result.op_ids(),\n        left,\n    )\n    .map_err(|e| proof_shape_err(\u0026e.to_string()))?;\n\n    \u003cB as PcsRecursionBackend\u003cSC, A2\u003e\u003e::set_private_data(\n        backend,\n        config,\n        \u0026mut runner,\n        right_result.op_ids(),\n        right,\n    )\n    .map_err(|e| proof_shape_err(\u0026e.to_string()))?;\n\n    runner.run().map_err(VerificationError::Circuit)\n}\n\n/// Prove a 2-to-1 aggregation layer: build verifier circuits for both `left` and `right`\n/// in a single circuit, run it, and produce one aggregated batch STARK proof.\n///\n/// When proving multiple pairs with the same verification circuit (e.g. all pairs at one level),\n/// pass `prep_cache: Some(\u0026mut None)` on the first call; the slot is filled and can be passed\n/// again for subsequent pairs to skip [`get_airs_and_degrees_with_prep`].\n///\n/// The two inputs may be different `RecursionInput` variants (e.g. one `UniStark` left\n/// and one `BatchStark` right) or identical ones.\n#[instrument(skip_all)]\n#[allow(clippy::too_many_arguments)]\npub fn prove_aggregation_layer\u003cSC, A1, A2, B, const D: usize\u003e(\n    left: \u0026RecursionInput\u003c'_, SC, A1\u003e,\n    right: \u0026RecursionInput\u003c'_, SC, A2\u003e,\n    left_result: \u0026\u003cB as PcsRecursionBackend\u003cSC, A1\u003e\u003e::VerifierResult,\n    right_result: \u0026\u003cB as PcsRecursionBackend\u003cSC, A2\u003e\u003e::VerifierResult,\n    verification_circuit: \u0026Circuit\u003cSC::Challenge\u003e,\n    config: \u0026SC,\n    backend: \u0026B,\n    params: \u0026ProveNextLayerParams,\n    mut prep_cache: Option\u003c\u0026mut Option\u003cAggregationPrepCache\u003cSC\u003e\u003e\u003e,\n) -\u003e Result\u003cRecursionOutput\u003cSC\u003e, VerificationError\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync + Clone + 'static,\n    A1: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    A2: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    B: PcsRecursionBackend\u003cSC, A1\u003e + PcsRecursionBackend\u003cSC, A2\u003e,\n    Val\u003cSC\u003e: PrimeField64 + StarkField + BinomiallyExtendable\u003c4\u003e,\n    SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e\n        + From\u003cVal\u003cSC\u003e\u003e\n        + ExtensionField\u003cVal\u003cSC\u003e\u003e\n        + ExtractBinomialW\u003cVal\u003cSC\u003e\u003e,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    if let Some(ref mut cache_slot) = prep_cache\n        \u0026\u0026 let Some(cached) = cache_slot.as_ref()\n    {\n        let traces = run_aggregation_verification_circuit(\n            left,\n            right,\n            left_result,\n            right_result,\n            verification_circuit,\n            config,\n            backend,\n        )?;\n        let proof = cached\n            .prover\n            .prove_all_tables(\u0026traces, \u0026cached.circuit_prover_data)\n            .map_err(|e| proof_shape_err(\u0026e.to_string()))?;\n        return Ok(RecursionOutput(\n            proof,\n            Rc::clone(\u0026cached.circuit_prover_data),\n        ));\n    }\n\n    let non_primitive = \u003cB as PcsRecursionBackend\u003cSC, A1\u003e\u003e::poseidon2_config_for_circuit(backend)\n        .map(|c| alloc::vec![NonPrimitiveConfig::Poseidon2(c)]);\n    let (airs_degrees, preprocessed_columns) = {\n        get_airs_and_degrees_with_prep::\u003cSC, SC::Challenge, D\u003e(\n            verification_circuit,\n            params.table_packing,\n            non_primitive.as_deref(),\n            params.constraint_profile,\n        )\n        .map_err(VerificationError::Circuit)?\n    };\n\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003c_\u003e) = airs_degrees.into_iter().unzip();\n\n    let traces = run_aggregation_verification_circuit(\n        left,\n        right,\n        left_result,\n        right_result,\n        verification_circuit,\n        config,\n        backend,\n    )?;\n\n    let circuit_prover_data = {\n        let prover_data = ProverData::from_airs_and_degrees(config, \u0026mut airs, \u0026degrees);\n        CircuitProverData::new(prover_data, preprocessed_columns)\n    };\n\n    let mut prover = BatchStarkProver::new(config.clone())\n        .with_table_packing(params.table_packing)\n        .with_alu_variant(match params.constraint_profile {\n            ConstraintProfile::Standard =\u003e AirVariant::Baseline,\n            ConstraintProfile::RecursionOptimized =\u003e AirVariant::Optimized,\n        });\n    if let Some(cfg) = \u003cB as PcsRecursionBackend\u003cSC, A1\u003e\u003e::poseidon2_config_for_circuit(backend) {\n        prover.register_poseidon2_table(cfg);\n    }\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .map_err(|e| proof_shape_err(\u0026e.to_string()))?;\n\n    if let Some(ref mut cache_slot) = prep_cache {\n        let circuit_prover_data_rc = Rc::new(circuit_prover_data);\n        **cache_slot = Some(AggregationPrepCache {\n            circuit_prover_data: Rc::clone(\u0026circuit_prover_data_rc),\n            prover,\n        });\n        Ok(RecursionOutput(proof, circuit_prover_data_rc))\n    } else {\n        Ok(RecursionOutput(proof, Rc::new(circuit_prover_data)))\n    }\n}\n\n/// Convenience method to build and prove a 2-to-1 aggregation layer.\n///\n/// The two inputs may be different `RecursionInput` variants (e.g. one `UniStark` left\n/// and one `BatchStark` right) or identical ones.\n///\n/// In production environments, consider using [`prove_aggregation_layer`] directly for better performance.\n///\n/// # Example\n///\n/// ```ignore\n/// let (verification_circuit, (left_result, right_result)) = build_aggregation_layer_circuit::\u003cSC, A1, A2, B, D\u003e(left, right, config, backend)?;\n/// let out = prove_aggregation_layer::\u003cSC, A1, A2, B, D\u003e(..., params, None);\n/// ```\npub fn build_and_prove_aggregation_layer\u003cSC, A1, A2, B, const D: usize\u003e(\n    left: \u0026RecursionInput\u003c'_, SC, A1\u003e,\n    right: \u0026RecursionInput\u003c'_, SC, A2\u003e,\n    config: \u0026SC,\n    backend: \u0026B,\n    params: \u0026ProveNextLayerParams,\n    prep_cache: Option\u003c\u0026mut Option\u003cAggregationPrepCache\u003cSC\u003e\u003e\u003e,\n) -\u003e Result\u003cRecursionOutput\u003cSC\u003e, VerificationError\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync + Clone + 'static,\n    A1: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    A2: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    B: PcsRecursionBackend\u003cSC, A1\u003e + PcsRecursionBackend\u003cSC, A2\u003e,\n    Val\u003cSC\u003e: PrimeField64 + StarkField + BinomiallyExtendable\u003c4\u003e,\n    SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e\n        + From\u003cVal\u003cSC\u003e\u003e\n        + ExtensionField\u003cVal\u003cSC\u003e\u003e\n        + ExtractBinomialW\u003cVal\u003cSC\u003e\u003e,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    let (verification_circuit, (left_result, right_result)) =\n        build_aggregation_layer_circuit::\u003cSC, A1, A2, B, D\u003e(left, right, config, backend)?;\n\n    prove_aggregation_layer::\u003cSC, A1, A2, B, D\u003e(\n        left,\n        right,\n        \u0026left_result,\n        \u0026right_result,\n        \u0026verification_circuit,\n        config,\n        backend,\n        params,\n        prep_cache,\n    )\n}\n","traces":[{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[8647648],"length":1,"stats":{"Line":0}},{"line":161,"address":[4162430],"length":1,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":150},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","air.rs"],"content":"//! Trait for recursive AIR constraint evaluation.\n\nuse alloc::vec::Vec;\n\nuse hashbrown::HashMap;\nuse p3_air::Air;\nuse p3_batch_stark::symbolic::{get_log_num_quotient_chunks, get_symbolic_constraints};\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::utils::{ColumnsTargets, symbolic_to_circuit_base, symbolic_to_circuit_ext};\nuse p3_field::{ExtensionField, Field};\nuse p3_lookup::lookup_traits::{Lookup, LookupData, LookupGadget};\nuse p3_uni_stark::{Entry, SymbolicAirBuilder, SymbolicExpression, SymbolicVariable};\n\nuse crate::Target;\nuse crate::types::RecursiveLagrangeSelectors;\n\n/// Structure holding lookup verification data:\n///\n/// - `contexts`: Slice of lookup contexts used in the AIR.\n/// - `lookup_data`: Slice of lookup data for global lookups.\npub struct LookupMetadata\u003c'a, F: Field\u003e {\n    pub contexts: \u0026'a [Lookup\u003cF\u003e],\n    pub lookup_data: \u0026'a [LookupData\u003cusize\u003e],\n}\n/// Trait for evaluating AIR constraints within a recursive verification circuit.\n///\n/// This trait provides methods for computing constraint evaluations over circuit targets\n/// rather than concrete field values.\npub trait RecursiveAir\u003cF: Field, EF: ExtensionField\u003cF\u003e, LG: LookupGadget\u003e {\n    /// Returns the number of columns in the AIR's execution trace.\n    ///\n    /// This corresponds to the width of the trace matrix.\n    fn width(\u0026self) -\u003e usize;\n\n    /// Evaluate all AIR constraints and fold them into a single target.\n    ///\n    /// This method:\n    /// 1. Retrieves all symbolic constraints from the AIR\n    /// 2. Converts them to circuit targets\n    /// 3. Folds them using powers of alpha: acc = acc * alpha + constraint\n    ///\n    /// # Parameters\n    /// - `builder`: Circuit builder for creating operations\n    /// - `sels`: Row selectors and vanishing inverse for constraint evaluation\n    /// - `alpha`: Challenge used for folding constraints\n    /// - `contexts`: Lookup contexts used in the AIR\n    /// - `lookup_data`: Data for global lookups\n    /// - `columns`: Trace columns (local, next) and public values\n    /// - `lookup_gadget`: Gadget for handling lookups in the circuit\n    ///\n    /// # Returns\n    /// A single target representing the folded constraint evaluation\n    fn eval_folded_circuit(\n        \u0026self,\n        builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n        sels: \u0026RecursiveLagrangeSelectors,\n        alpha: \u0026Target,\n        lookup_metadata: \u0026LookupMetadata\u003c'_, F\u003e,\n        columns: ColumnsTargets\u003c'_\u003e,\n        lookup_gadget: \u0026LG,\n    ) -\u003e Target;\n\n    /// Compute the log of the quotient polynomial degree.\n    ///\n    /// The quotient polynomial is formed by dividing the constraint polynomial\n    /// by the vanishing polynomial. Its degree depends on:\n    /// - The maximum constraint degree\n    /// - Number of public values\n    /// - Whether ZK randomization is used\n    ///\n    /// # Parameters\n    /// - `num_public_values`: Number of public input values\n    /// - `is_zk`: Whether ZK mode is enabled (0 or 1)\n    ///\n    /// # Returns\n    /// Log₂ of the number of quotient chunks\n    fn get_log_num_quotient_chunks(\n        \u0026self,\n        preprocessed_width: usize,\n        num_public_values: usize,\n        contexts: \u0026[Lookup\u003cF\u003e],\n        lookup_data: \u0026[LookupData\u003cusize\u003e],\n        is_zk: usize,\n        lookup_gadget: \u0026LG,\n    ) -\u003e usize;\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, A, LG: LookupGadget\u003e RecursiveAir\u003cF, EF, LG\u003e for A\nwhere\n    A: Air\u003cSymbolicAirBuilder\u003cF, EF\u003e\u003e,\n    SymbolicExpression\u003cEF\u003e: From\u003cSymbolicExpression\u003cF\u003e\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        Self::width(self)\n    }\n\n    fn eval_folded_circuit(\n        \u0026self,\n        builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n        sels: \u0026RecursiveLagrangeSelectors,\n        alpha: \u0026Target,\n        lookup_metadata: \u0026LookupMetadata\u003c'_, F\u003e,\n        columns: ColumnsTargets\u003c'_\u003e,\n        lookup_gadget: \u0026LG,\n    ) -\u003e Target {\n        builder.push_scope(\"eval_folded_circuit\");\n\n        let LookupMetadata {\n            contexts,\n            lookup_data,\n        } = lookup_metadata;\n\n        let ld_expected = lookup_data\n            .iter()\n            .map(|ld| LookupData {\n                name: ld.name.clone(),\n                aux_idx: ld.aux_idx,\n                expected_cumulated: SymbolicExpression::Variable(SymbolicVariable::new(\n                    Entry::Public,\n                    ld.expected_cumulated,\n                )),\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let num_preprocessed = columns.local_prep_values.len();\n        // Get symbolic constraints from the AIR\n        let (base_symbolic_constraints, extension_symbolic_constraints) = get_symbolic_constraints(\n            self,\n            num_preprocessed,\n            columns.public_values.len(),\n            contexts,\n            \u0026ld_expected,\n            lookup_gadget,\n        );\n\n        // Fold all constraints: result = c₀ + α·c₁ + α²·c₂ + ...\n        //\n        // Converting directly the tree SymbolicExpression\u003cF\u003e → SymbolicExpression\u003cEF\u003e\n        // destroys Arc-based sub-expression sharing and causes exponential blowup.\n        // Instead, we lift F → EF constants directly.\n        //\n        // Additionally, the cache is shared across all constraint calls to reuse circuit\n        // operations for sub-expressions shared between different constraints.\n        let mut acc = builder.define_const(EF::ZERO);\n        let mut base_cache = HashMap::new();\n        for s_c in \u0026base_symbolic_constraints {\n            let mul_prev = builder.mul(acc, *alpha);\n            let constraints = symbolic_to_circuit_base(\n                sels.row_selectors,\n                \u0026columns,\n                s_c,\n                builder,\n                \u0026mut base_cache,\n            );\n            acc = builder.add(mul_prev, constraints);\n        }\n\n        let mut ext_cache = HashMap::new();\n        for s_c in \u0026extension_symbolic_constraints {\n            let mul_prev = builder.mul(acc, *alpha);\n            let constraints =\n                symbolic_to_circuit_ext(sels.row_selectors, \u0026columns, s_c, builder, \u0026mut ext_cache);\n            acc = builder.add(mul_prev, constraints);\n        }\n\n        builder.pop_scope();\n        acc\n    }\n\n    fn get_log_num_quotient_chunks(\n        \u0026self,\n        preprocessed_width: usize,\n        num_public_values: usize,\n        contexts: \u0026[Lookup\u003cF\u003e],\n        lookup_data: \u0026[LookupData\u003cusize\u003e],\n        is_zk: usize,\n        lookup_gadget: \u0026LG,\n    ) -\u003e usize\n    where\n        F: Field,\n        EF: ExtensionField\u003cF\u003e,\n        SymbolicExpression\u003cEF\u003e: From\u003cSymbolicExpression\u003cF\u003e\u003e,\n        LG: LookupGadget,\n    {\n        let ld_dummy_expected = lookup_data\n            .iter()\n            .map(|ld| LookupData {\n                name: ld.name.clone(),\n                aux_idx: ld.aux_idx,\n                expected_cumulated: SymbolicExpression::Variable(SymbolicVariable::new(\n                    Entry::Public,\n                    ld.expected_cumulated,\n                )),\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        get_log_num_quotient_chunks(\n            self,\n            preprocessed_width,\n            num_public_values,\n            contexts,\n            \u0026ld_dummy_expected,\n            is_zk,\n            lookup_gadget,\n        )\n    }\n}\n","traces":[{"line":93,"address":[3474816],"length":1,"stats":{"Line":13}},{"line":94,"address":[3123733],"length":1,"stats":{"Line":15}},{"line":97,"address":[1797309,1797453,1795968,1798813,1797472,1798957],"length":1,"stats":{"Line":15}},{"line":106,"address":[3473066],"length":1,"stats":{"Line":15}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[5472979],"length":1,"stats":{"Line":15}},{"line":110,"address":[1760443],"length":1,"stats":{"Line":14}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[1898042,1896538],"length":1,"stats":{"Line":13}},{"line":115,"address":[6337124,6336864,6337130,6337050],"length":1,"stats":{"Line":19}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[5586110],"length":1,"stats":{"Line":3}},{"line":118,"address":[4562261,4562324],"length":1,"stats":{"Line":7}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[3399799],"length":1,"stats":{"Line":4}},{"line":125,"address":[3122098],"length":1,"stats":{"Line":14}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[4631510],"length":1,"stats":{"Line":13}},{"line":131,"address":[3122130],"length":1,"stats":{"Line":14}},{"line":132,"address":[5348393],"length":1,"stats":{"Line":13}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[3122461,3122381],"length":1,"stats":{"Line":27}},{"line":145,"address":[3473564],"length":1,"stats":{"Line":14}},{"line":146,"address":[1761768,1760906,1760970],"length":1,"stats":{"Line":39}},{"line":147,"address":[5473648,5474229],"length":1,"stats":{"Line":24}},{"line":149,"address":[1761675],"length":1,"stats":{"Line":11}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":12}},{"line":158,"address":[2265391],"length":1,"stats":{"Line":14}},{"line":159,"address":[1796813,1797304,1796880,1798317,1798384,1798808],"length":1,"stats":{"Line":33}},{"line":160,"address":[5473878,5474085],"length":1,"stats":{"Line":8}},{"line":161,"address":[4632491],"length":1,"stats":{"Line":3}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[3474275],"length":1,"stats":{"Line":3}},{"line":166,"address":[4312037],"length":1,"stats":{"Line":14}},{"line":167,"address":[7274684],"length":1,"stats":{"Line":14}},{"line":170,"address":[7275453,7275459,7275120],"length":1,"stats":{"Line":10}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[5349766],"length":1,"stats":{"Line":17}},{"line":188,"address":[3862859],"length":1,"stats":{"Line":4}},{"line":189,"address":[4751134,4750846],"length":1,"stats":{"Line":4}},{"line":190,"address":[5586484,5586421],"length":1,"stats":{"Line":8}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[6337223],"length":1,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[3474645],"length":1,"stats":{"Line":9}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}}],"covered":36,"coverable":55},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","challenger.rs"],"content":"//! Trait for recursive Fiat-Shamir challenger operations within circuits.\n//!\n//! This module provides the [`RecursiveChallenger`] trait which mirrors the native\n//! Plonky3 `DuplexChallenger` API. The trait supports both base field and extension\n//! field operations to ensure exact transcript compatibility.\n\nuse alloc::vec::Vec;\n\nuse p3_circuit::{CircuitBuilder, CircuitBuilderError};\nuse p3_field::{ExtensionField, PrimeField64};\n\nuse crate::Target;\n\n/// Trait for performing Fiat-Shamir transformations within a circuit.\n///\n/// This trait mirrors the native Plonky3 `DuplexChallenger` API:\n/// - `observe` / `sample` operate on base field elements\n/// - `observe_ext` / `sample_ext` operate on extension field elements\n///\n/// The circuit challenger maintains state as coefficient-level targets to ensure\n/// exact transcript compatibility with the native challenger, including correct\n/// handling of partial absorbs.\n///\n/// # Type Parameters\n/// - `BF`: The base prime field\n/// - `EF`: The extension field over `BF`\npub trait RecursiveChallenger\u003cBF: PrimeField64, EF: ExtensionField\u003cBF\u003e\u003e {\n    // ========================================================================\n    // Base field operations (match native DuplexChallenger's observe/sample)\n    // ========================================================================\n\n    /// Observe a base field element in the Fiat-Shamir transcript.\n    ///\n    /// Matches the native `DuplexChallenger::observe` behavior exactly.\n    /// The value is pushed to the input buffer and duplexing occurs when\n    /// the buffer reaches RATE elements.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `value`: A target representing a base field element (embedded in EF)\n    fn observe(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e, value: Target);\n\n    /// Observe multiple base field elements.\n    fn observe_slice(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e, values: \u0026[Target]) {\n        for \u0026value in values {\n            self.observe(circuit, value);\n        }\n    }\n\n    /// Sample a base field element from the sponge.\n    ///\n    /// Matches the native `DuplexChallenger::sample` behavior exactly.\n    /// If there are pending inputs or the output buffer is empty, duplexing\n    /// occurs first.\n    ///\n    /// # Returns\n    /// A target representing a base field element (embedded in EF)\n    fn sample(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e) -\u003e Target;\n\n    // ========================================================================\n    // Extension field operations (match native observe_algebra_element/sample_algebra_element)\n    // ========================================================================\n\n    /// Observe an extension field element in the Fiat-Shamir transcript.\n    ///\n    /// Matches the native `FieldChallenger::observe_algebra_element` behavior.\n    /// Decomposes the extension element to D base coefficients and observes each.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `value`: A target representing an extension field element\n    fn observe_ext(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e, value: Target);\n\n    /// Observe multiple extension field elements.\n    fn observe_ext_slice(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e, values: \u0026[Target]) {\n        for \u0026value in values {\n            self.observe_ext(circuit, value);\n        }\n    }\n\n    /// Sample an extension field element from the sponge.\n    ///\n    /// Matches the native `FieldChallenger::sample_algebra_element` behavior.\n    /// Samples D base field elements and recomposes them into an extension element.\n    ///\n    /// # Returns\n    /// A target representing an extension field element\n    fn sample_ext(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e) -\u003e Target;\n\n    /// Sample multiple extension field challenges.\n    fn sample_ext_vec(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e, count: usize) -\u003e Vec\u003cTarget\u003e {\n        (0..count).map(|_| self.sample_ext(circuit)).collect()\n    }\n\n    // ========================================================================\n    // Bit operations (for PoW and query indices)\n    // ========================================================================\n\n    /// Sample bits from a base field element.\n    ///\n    /// Samples a base field element and decomposes it to bits.\n    /// This is used for sampling query indices in FRI.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `num_bits`: Number of bits to return\n    ///\n    /// # Returns\n    /// Vector of `num_bits` bits as targets (each in {0, 1})\n    fn sample_bits(\n        \u0026mut self,\n        circuit: \u0026mut CircuitBuilder\u003cEF\u003e,\n        num_bits: usize,\n    ) -\u003e Result\u003cVec\u003cTarget\u003e, CircuitBuilderError\u003e;\n\n    /// Verify a proof-of-work witness.\n    ///\n    /// Observes the witness as a base field element, samples a challenge,\n    /// decomposes it to bits, and verifies that the first `witness_bits` bits\n    /// are all zero.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `witness_bits`: Number of leading bits that must be zero\n    /// - `witness`: The proof-of-work witness target (base field element)\n    fn check_pow_witness(\n        \u0026mut self,\n        circuit: \u0026mut CircuitBuilder\u003cEF\u003e,\n        witness_bits: usize,\n        witness: Target,\n    ) -\u003e Result\u003c(), CircuitBuilderError\u003e;\n\n    /// Clear the challenger state.\n    ///\n    /// Resets the internal sponge state and buffers.\n    fn clear(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cEF\u003e);\n}\n","traces":[{"line":44,"address":[4333520],"length":1,"stats":{"Line":8}},{"line":45,"address":[4010604,4010619],"length":1,"stats":{"Line":16}},{"line":46,"address":[],"length":0,"stats":{"Line":8}},{"line":75,"address":[4333680],"length":1,"stats":{"Line":7}},{"line":76,"address":[2789212,2789227],"length":1,"stats":{"Line":15}},{"line":77,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":8},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","mmcs.rs"],"content":"//! Traits for recursive MMCS operations.\n\nuse p3_commit::Mmcs;\nuse p3_field::{ExtensionField, Field};\n\nuse super::Recursive;\n\n/// Trait for the recursive version of an MMCS operating over the base field.\n///\n/// Associates a non-recursive MMCS with its recursive commitment and proof types.\n/// This is used for commitments to trace polynomials (which are over the base field).\npub trait RecursiveMmcs\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e {\n    /// The non-recursive MMCS type this corresponds to.\n    type Input: Mmcs\u003cF\u003e;\n\n    /// The recursive commitment type (targets representing the commitment).\n    ///\n    /// Must implement `Recursive` with `Input` being the commitment type from `Self::Input`.\n    type Commitment: Recursive\u003cEF, Input = \u003cSelf::Input as Mmcs\u003cF\u003e\u003e::Commitment\u003e;\n\n    /// The recursive proof type (targets representing the opening proof).\n    ///\n    /// Must implement `Recursive` with `Input` being the proof type from `Self::Input`.\n    type Proof: Recursive\u003cEF, Input = \u003cSelf::Input as Mmcs\u003cF\u003e\u003e::Proof\u003e;\n}\n\n/// Trait for the recursive version of an MMCS operating over the extension field.\n///\n/// Associates a non-recursive MMCS with its recursive commitment and proof types.\n/// This is used for commitments to quotient polynomials and FRI layers\n/// (which are over the extension field).\npub trait RecursiveExtensionMmcs\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e {\n    /// The non-recursive MMCS type this corresponds to.\n    type Input: Mmcs\u003cEF\u003e;\n\n    /// The recursive commitment type (targets representing the commitment).\n    ///\n    /// Must implement `Recursive` with `Input` being the commitment type from `Self::Input`.\n    type Commitment: Recursive\u003cEF, Input = \u003cSelf::Input as Mmcs\u003cEF\u003e\u003e::Commitment\u003e;\n\n    /// The recursive proof type (targets representing the opening proof).\n    ///\n    /// Must implement `Recursive` with `Input` being the proof type from `Self::Input`.\n    type Proof: Recursive\u003cEF, Input = \u003cSelf::Input as Mmcs\u003cEF\u003e\u003e::Proof\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","mod.rs"],"content":"//! Core trait definitions for recursive verification.\n\nmod air;\nmod challenger;\nmod mmcs;\nmod pcs;\nmod recursive;\n\npub use air::{LookupMetadata, RecursiveAir};\npub use challenger::RecursiveChallenger;\npub use mmcs::{RecursiveExtensionMmcs, RecursiveMmcs};\npub use pcs::{ComsWithOpeningsTargets, RecursivePcs};\npub use recursive::{Recursive, RecursiveLookupGadget};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","pcs.rs"],"content":"//! Trait for recursive Polynomial Commitment Scheme (PCS) operations.\n\nuse alloc::vec::Vec;\n\nuse p3_circuit::{CircuitBuilder, CircuitBuilderError, NonPrimitiveOpId};\nuse p3_uni_stark::StarkGenericConfig;\n\nuse super::Recursive;\nuse crate::types::{OpenedValuesTargetsWithLookups, RecursiveLagrangeSelectors};\nuse crate::verifier::VerificationError;\nuse crate::{CircuitChallenger, Target};\n\n/// Type alias for commitments with their opening points.\n///\n/// Each entry is:\n/// - A commitment (Comm)\n/// - A list of (Domain, Vec\u003c(point, opened_values)\u003e) tuples\npub type ComsWithOpeningsTargets\u003cComm, Domain\u003e =\n    [(Comm, Vec\u003c(Domain, Vec\u003c(Target, Vec\u003cTarget\u003e)\u003e)\u003e)];\n\n/// Trait for recursive polynomial commitment scheme verification.\n///\n/// This trait provides the interface for verifying polynomial openings within\n/// a recursive circuit.\npub trait RecursivePcs\u003c\n    SC: StarkGenericConfig,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    Domain,\n\u003e\n{\n    /// PCS-specific verifier parameters (e.g., FRI parameters).\n    type VerifierParams;\n\n    /// Recursive proof type (may differ from OpeningProof for some schemes).\n    type RecursiveProof;\n\n    /// Generate PCS-specific challenges (e.g., FRI beta challenges, query indices).\n    ///\n    /// This method observes the opened values and opening proof, then samples\n    /// challenges needed for verification. For FRI, this includes:\n    /// - Beta challenges for each folding round\n    /// - Query indices for spot-checking\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `challenger`: Running Fiat-Shamir challenger state\n    /// - `proof_targets`: Proof structure with commitments and opening proof\n    /// - `opened_values`: All opened values at evaluation points\n    /// - `params`: PCS-specific verifier parameters\n    ///\n    /// # Returns\n    /// Vector of challenge targets (ordering depends on PCS scheme)\n    fn get_challenges_circuit\u003cconst WIDTH: usize, const RATE: usize\u003e(\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        challenger: \u0026mut CircuitChallenger\u003cWIDTH, RATE\u003e,\n        proof_targets: \u0026OpeningProof,\n        opened_values: \u0026OpenedValuesTargetsWithLookups\u003cSC\u003e,\n        params: \u0026Self::VerifierParams,\n    ) -\u003e Result\u003cVec\u003cTarget\u003e, CircuitBuilderError\u003e;\n\n    /// Verify the polynomial commitment opening proof in-circuit.\n    ///\n    /// This method checks that the claimed opened values are consistent with\n    /// the commitments, using the opening proof and challenges.\n    ///\n    /// Query indices (e.g., for FRI) are sampled in-circuit from the challenger\n    /// to ensure soundness—they must be derived from the transcript, not passed in.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `challenges`: PCS challenges (from `get_challenges_circuit`), excluding query indices\n    /// - `challenger`: Challenger in state ready to sample query indices (after check_pow_witness)\n    /// - `commitments_with_opening_points`: All commitments and their opening points\n    /// - `opening_proof`: The opening proof targets\n    /// - `params`: PCS-specific verifier parameters\n    ///\n    /// # Returns\n    /// `Ok(Vec\u003cNonPrimitiveOpId\u003e)` containing operation IDs that require private data\n    /// (e.g., Merkle sibling values for MMCS verification). The caller must set\n    /// private data for these operations before running the circuit.\n    /// `Err` if there was a structural error in the proof.\n    fn verify_circuit\u003cconst WIDTH: usize, const RATE: usize\u003e(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        challenges: \u0026[Target],\n        challenger: \u0026mut CircuitChallenger\u003cWIDTH, RATE\u003e,\n        commitments_with_opening_points: \u0026ComsWithOpeningsTargets\u003cComm, Domain\u003e,\n        opening_proof: \u0026OpeningProof,\n        params: \u0026Self::VerifierParams,\n    ) -\u003e Result\u003cVec\u003cNonPrimitiveOpId\u003e, VerificationError\u003e;\n\n    /// Compute Lagrange selector values at a point within the circuit.\n    ///\n    /// Evaluates row selector polynomials (is_first_row, is_last_row, is_transition)\n    /// and computes the vanishing polynomial inverse at the given point.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `domain`: The domain over which the polynomials are defined\n    /// - `point`: The evaluation point\n    ///\n    /// # Returns\n    /// Row selectors and vanishing inverse at the point\n    fn selectors_at_point_circuit(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        domain: \u0026Domain,\n        point: \u0026Target,\n    ) -\u003e RecursiveLagrangeSelectors;\n\n    /// Create a disjoint domain for the quotient polynomial.\n    ///\n    /// The quotient domain must be:\n    /// - Large enough to hold the quotient polynomial\n    /// - Disjoint from the trace domain (to avoid division by zero)\n    ///\n    /// # Parameters\n    /// - `trace_domain`: The trace polynomial domain\n    /// - `degree`: The quotient polynomial degree\n    ///\n    /// # Returns\n    /// A disjoint domain of appropriate size\n    fn create_disjoint_domain(\u0026self, trace_domain: Domain, degree: usize) -\u003e Domain;\n\n    /// Split a domain into subdomains for quotient chunks.\n    ///\n    /// When the quotient polynomial is too large, it's split into chunks\n    /// committed separately. This method computes the subdomain for each chunk.\n    ///\n    /// # Parameters\n    /// - `trace_domain`: The trace polynomial domain\n    /// - `degree`: The quotient polynomial degree\n    ///\n    /// # Returns\n    /// Vector of subdomains (one per chunk)\n    fn split_domains(\u0026self, trace_domain: \u0026Domain, degree: usize) -\u003e Vec\u003cDomain\u003e;\n\n    /// Return log₂ of the domain size.\n    ///\n    /// # Parameters\n    /// - `trace_domain`: The domain\n    ///\n    /// # Returns\n    /// Log₂ of the domain size\n    fn log_size(\u0026self, trace_domain: \u0026Domain) -\u003e usize;\n\n    /// Return the domain size.\n    ///\n    /// # Parameters\n    /// - `trace_domain`: The domain\n    ///\n    /// # Returns\n    /// The domain size (power of 2)\n    fn size(\u0026self, trace_domain: \u0026Domain) -\u003e usize {\n        1 \u003c\u003c self.log_size(trace_domain)\n    }\n\n    /// Return the first point in the domain.\n    ///\n    /// For a multiplicative coset, this is the coset offset.\n    ///\n    /// # Parameters\n    /// - `trace_domain`: The domain\n    ///\n    /// # Returns\n    /// The first domain point\n    fn first_point(\u0026self, trace_domain: \u0026Domain) -\u003e SC::Challenge;\n}\n","traces":[{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":4}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","recursive.rs"],"content":"use alloc::vec;\nuse alloc::vec::Vec;\n\nuse p3_circuit::CircuitBuilder;\nuse p3_field::Field;\nuse p3_lookup::logup::LogUpGadget;\nuse p3_lookup::lookup_traits::LookupGadget;\n\nuse crate::Target;\n\n/// Trait for converting a non-recursive type into its circuit representation.\n///\n/// Types implementing this trait can be used in recursive verification circuits.\n/// The trait handles allocation of circuit targets and extraction of field element values.\npub trait Recursive\u003cF: Field\u003e {\n    /// The non-recursive type associated with this recursive type.\n    type Input;\n\n    /// Creates a new instance of the recursive type by allocating targets in the circuit.\n    ///\n    /// This method should allocate all necessary public/private inputs and return\n    /// a structure containing the allocated targets.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder to allocate targets in\n    /// - `input`: The non-recursive input (used only for structure, not values)\n    fn new(circuit: \u0026mut CircuitBuilder\u003cF\u003e, input: \u0026Self::Input) -\u003e Self;\n\n    /// Extracts private field element values from the input.\n    ///\n    /// Values returned here will be used to populate private inputs during execution.\n    /// Default implementation returns an empty vector (no private inputs).\n    ///\n    /// # Parameters\n    /// - `input`: The non-recursive input to extract private values from\n    fn get_private_values(_input: \u0026Self::Input) -\u003e Vec\u003cF\u003e {\n        vec![]\n    }\n\n    /// Extracts public field element values from the input.\n    ///\n    /// Values returned here will be used to populate public inputs during execution.\n    /// The order must match the order in which targets were allocated in `new()`.\n    ///\n    /// # Parameters\n    /// - `input`: The non-recursive input to extract public values from\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cF\u003e;\n}\n\npub trait RecursiveLookupGadget\u003cF: Field\u003e: LookupGadget {\n    fn verify_global_final_value_circuit(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cF\u003e,\n        all_expected_cumulative: \u0026[Target],\n    );\n}\n\nimpl\u003cF: Field\u003e RecursiveLookupGadget\u003cF\u003e for LogUpGadget {\n    fn verify_global_final_value_circuit(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cF\u003e,\n        all_expected_cumulative: \u0026[Target],\n    ) {\n        let mut final_cumulative = circuit.define_const(F::ZERO);\n        for a_e_c in all_expected_cumulative {\n            final_cumulative = circuit.add(final_cumulative, *a_e_c);\n        }\n\n        circuit.assert_zero(final_cumulative);\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[4201216],"length":1,"stats":{"Line":5}},{"line":64,"address":[4201266],"length":1,"stats":{"Line":3}},{"line":65,"address":[4201314,4201403],"length":1,"stats":{"Line":10}},{"line":66,"address":[4201388],"length":1,"stats":{"Line":3}},{"line":69,"address":[4201410],"length":1,"stats":{"Line":3}}],"covered":5,"coverable":7},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","types","challenges.rs"],"content":"//! Challenge target structures for STARK verification circuits.\n\nuse alloc::vec;\nuse alloc::vec::Vec;\n\nuse p3_circuit::CircuitBuilder;\nuse p3_field::{ExtensionField, PrimeCharacteristicRing, PrimeField64};\nuse p3_uni_stark::{StarkGenericConfig, Val};\n\nuse crate::Target;\nuse crate::traits::{Recursive, RecursiveChallenger};\nuse crate::types::ProofTargets;\nuse crate::verifier::ObservableCommitment;\n\n/// Base STARK challenges (independent of PCS choice).\n#[derive(Debug, Clone)]\npub struct StarkChallenges {\n    /// Alpha: challenge for folding all constraint polynomials\n    pub alpha: Target,\n    /// Zeta: out-of-domain evaluation point\n    pub zeta: Target,\n    /// Zeta next: evaluation point for next row (zeta * g in the trace domain)\n    pub zeta_next: Target,\n}\n\n/// Parameters for STARK challenge allocation that match native challenger behavior.\npub struct StarkChallengeParams\u003c'a, SC: StarkGenericConfig, Comm\u003e {\n    /// Log₂ of trace domain size\n    pub degree_bits: usize,\n    /// is_zk flag (0 or 1)\n    pub is_zk: usize,\n    /// Width of preprocessed trace (0 if none)\n    pub preprocessed_width: usize,\n    /// Preprocessed commitment targets (if preprocessed_width \u003e 0)\n    pub preprocessed_commit: \u0026'a Option\u003cComm\u003e,\n    /// Generator of the init trace domain (for computing zeta_next = zeta * generator)\n    pub trace_domain_generator: SC::Challenge,\n}\n\nimpl StarkChallenges {\n    /// Allocate base STARK challenge targets using Fiat-Shamir transform.\n    ///\n    /// This method follows the exact native DuplexChallenger protocol ordering:\n    /// 1. Observe degree_bits\n    /// 2. Observe degree_bits - is_zk (init trace domain log size)\n    /// 3. Observe preprocessed_width\n    /// 4. Observe trace commitment\n    /// 5. If preprocessed_width \u003e 0: observe preprocessed commitment\n    /// 6. Observe public values\n    /// 7. Sample alpha\n    /// 8. Observe quotient commitment\n    /// 9. If ZK mode: observe random commitment\n    /// 10. Sample zeta\n    /// 11. Compute zeta_next = zeta * trace_domain_generator (NOT sampled!)\n    ///\n    /// The challenger state is mutated and can be used for further PCS challenge sampling.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder\n    /// - `challenger`: Fiat-Shamir challenger (will be mutated)\n    /// - `proof_targets`: Proof structure with commitments\n    /// - `public_values`: AIR public input values\n    /// - `params`: Challenge parameters matching native behavior\n    ///\n    /// # Returns\n    /// The three base STARK challenges\n    pub fn allocate\u003cSC, Comm, OpeningProof\u003e(\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        challenger: \u0026mut impl RecursiveChallenger\u003cVal\u003cSC\u003e, SC::Challenge\u003e,\n        proof_targets: \u0026ProofTargets\u003cSC, Comm, OpeningProof\u003e,\n        public_values: \u0026[Target],\n        params: \u0026StarkChallengeParams\u003c'_, SC, Comm\u003e,\n    ) -\u003e Self\n    where\n        SC: StarkGenericConfig,\n        Val\u003cSC\u003e: PrimeField64,\n        SC::Challenge: ExtensionField\u003cVal\u003cSC\u003e\u003e + PrimeCharacteristicRing,\n        Comm: Recursive\u003cSC::Challenge\u003e + ObservableCommitment,\n        OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    {\n        // Extract commitment targets from proof\n        let trace_comm_targets = proof_targets\n            .commitments_targets\n            .trace_targets\n            .to_observation_targets();\n        let quotient_comm_targets = proof_targets\n            .commitments_targets\n            .quotient_chunks_targets\n            .to_observation_targets();\n        let random_comm_targets = proof_targets\n            .commitments_targets\n            .random_commit\n            .as_ref()\n            .map(|c| c.to_observation_targets());\n        let preprocessed_comm_targets = params\n            .preprocessed_commit\n            .as_ref()\n            .map(|c| c.to_observation_targets());\n\n        // 1. Observe degree_bits (base field element)\n        let degree_bits_target =\n            circuit.alloc_const(SC::Challenge::from_usize(params.degree_bits), \"degree bits\");\n        challenger.observe(circuit, degree_bits_target);\n\n        // 2. Observe degree_bits - is_zk (init trace domain log size, base field element)\n        let init_trace_log_size = params.degree_bits.saturating_sub(params.is_zk);\n        let init_trace_log_size_target = circuit.alloc_const(\n            SC::Challenge::from_usize(init_trace_log_size),\n            \"init trace log size\",\n        );\n        challenger.observe(circuit, init_trace_log_size_target);\n\n        // 3. Observe preprocessed_width (base field element)\n        let preprocessed_width_target = circuit.alloc_const(\n            SC::Challenge::from_usize(params.preprocessed_width),\n            \"preprocessed width\",\n        );\n        challenger.observe(circuit, preprocessed_width_target);\n\n        // 4. Observe trace commitment (base field elements)\n        challenger.observe_slice(circuit, \u0026trace_comm_targets);\n\n        // 5. If preprocessed_width \u003e 0: observe preprocessed commitment\n        if params.preprocessed_width \u003e 0\n            \u0026\u0026 let Some(prep_comm) = \u0026preprocessed_comm_targets\n        {\n            challenger.observe_slice(circuit, prep_comm);\n        }\n\n        // 6. Observe public values (base field elements)\n        challenger.observe_slice(circuit, public_values);\n\n        // 7. Sample alpha challenge (extension field element)\n        let alpha = challenger.sample_ext(circuit);\n\n        // 8. Observe quotient chunks commitment (base field elements)\n        challenger.observe_slice(circuit, \u0026quotient_comm_targets);\n\n        // 9. Observe random commitment if in ZK mode\n        if let Some(random_comm) = random_comm_targets {\n            challenger.observe_slice(circuit, \u0026random_comm);\n        }\n\n        // 10. Sample zeta (extension field element)\n        let zeta = challenger.sample_ext(circuit);\n\n        // 11. Compute zeta_next = zeta * trace_domain_generator (NOT sampled!)\n        // This matches native behavior: zeta_next = init_trace_domain.next_point(zeta)\n        let generator_const = circuit.define_const(params.trace_domain_generator);\n        let zeta_next = circuit.mul(zeta, generator_const);\n\n        Self {\n            alpha,\n            zeta,\n            zeta_next,\n        }\n    }\n\n    /// Convert to flat vector: [alpha, zeta, zeta_next]\n    pub fn to_vec(\u0026self) -\u003e Vec\u003cTarget\u003e {\n        vec![self.alpha, self.zeta, self.zeta_next]\n    }\n\n    /// Get the alpha challenge (for constraint folding).\n    pub const fn alpha(\u0026self) -\u003e Target {\n        self.alpha\n    }\n\n    /// Get the zeta challenge (OOD evaluation point).\n    pub const fn zeta(\u0026self) -\u003e Target {\n        self.zeta\n    }\n\n    /// Get the zeta_next challenge (next row evaluation point).\n    pub const fn zeta_next(\u0026self) -\u003e Target {\n        self.zeta_next\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_circuit::ExprId;\n\n    use super::*;\n\n    #[test]\n    fn test_stark_challenges_to_vec() {\n        let alpha = ExprId(1);\n        let zeta = ExprId(2);\n        let zeta_next = ExprId(3);\n        let challenges = StarkChallenges {\n            alpha,\n            zeta,\n            zeta_next,\n        };\n\n        let vec = challenges.to_vec();\n        assert_eq!(vec.len(), 3);\n        assert_eq!(vec[0], alpha);\n        assert_eq!(vec[1], zeta);\n        assert_eq!(vec[2], zeta_next);\n    }\n}\n","traces":[{"line":67,"address":[2787328,2788659,2788900],"length":1,"stats":{"Line":4}},{"line":82,"address":[3838530],"length":1,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[4695263],"length":1,"stats":{"Line":4}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[3838630],"length":1,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[2788960,2788976,2787628],"length":1,"stats":{"Line":4}},{"line":95,"address":[3838723],"length":1,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[4696720,4696704,4695533],"length":1,"stats":{"Line":8}},{"line":101,"address":[3838896,3838832],"length":1,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[2787882],"length":1,"stats":{"Line":4}},{"line":106,"address":[5937657],"length":1,"stats":{"Line":5}},{"line":107,"address":[2787953],"length":1,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[3839083],"length":1,"stats":{"Line":4}},{"line":114,"address":[5937813],"length":1,"stats":{"Line":4}},{"line":115,"address":[5937786],"length":1,"stats":{"Line":4}},{"line":118,"address":[5937871],"length":1,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[2788184],"length":1,"stats":{"Line":4}},{"line":125,"address":[4696028],"length":1,"stats":{"Line":2}},{"line":127,"address":[2788283],"length":1,"stats":{"Line":2}},{"line":131,"address":[3839295],"length":1,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[5938144],"length":1,"stats":{"Line":4}},{"line":140,"address":[2788434],"length":1,"stats":{"Line":4}},{"line":141,"address":[5938279,5938393],"length":1,"stats":{"Line":0}},{"line":145,"address":[5938312,5938445],"length":1,"stats":{"Line":8}},{"line":149,"address":[5938452],"length":1,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":160,"address":[2099888],"length":1,"stats":{"Line":5}},{"line":161,"address":[8695351,8695501],"length":1,"stats":{"Line":5}},{"line":165,"address":[4145568],"length":1,"stats":{"Line":0}},{"line":166,"address":[8630805],"length":1,"stats":{"Line":0}},{"line":170,"address":[2099856],"length":1,"stats":{"Line":0}},{"line":171,"address":[6508181],"length":1,"stats":{"Line":0}},{"line":175,"address":[4145776],"length":1,"stats":{"Line":0}},{"line":176,"address":[6508405],"length":1,"stats":{"Line":0}}],"covered":29,"coverable":44},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","types","mod.rs"],"content":"//! Core type definitions for recursive verification.\n\nmod challenges;\nmod proof;\nmod selectors;\n\npub use challenges::{StarkChallengeParams, StarkChallenges};\npub use proof::{\n    BatchProofTargets, CommitmentTargets, CommonDataTargets, OpenedValuesTargets,\n    OpenedValuesTargetsWithLookups, ProofTargets,\n};\npub use selectors::RecursiveLagrangeSelectors;\n\n/// Canonical circuit target type used across recursive components.\n///\n/// This is an alias representing a node in the circuit expression graph.\npub type Target = p3_circuit::ExprId;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","types","proof.rs"],"content":"//! Target structures for STARK proofs in recursive circuits.\n\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::marker::PhantomData;\n\nuse p3_batch_stark::common::PreprocessedInstanceMeta;\nuse p3_batch_stark::proof::OpenedValuesWithLookups;\nuse p3_batch_stark::{BatchCommitments, BatchOpenedValues, BatchProof, CommonData};\nuse p3_circuit::CircuitBuilder;\nuse p3_commit::Pcs;\nuse p3_field::{ExtensionField, Field, PrimeField64};\nuse p3_lookup::lookup_traits::{Lookup, LookupData};\nuse p3_uni_stark::{OpenedValues, Proof, StarkGenericConfig, Val};\n\nuse crate::Target;\nuse crate::traits::{Recursive, RecursiveChallenger};\n\n/// Structure representing all the targets necessary for an input proof.\n///\n/// This contains the circuit representation of a STARK proof, with all\n/// commitments, opened values, and the opening proof as targets.\n#[derive(Clone)]\npub struct ProofTargets\u003c\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n\u003e {\n    /// Commitments to trace, quotient chunks, and optional random polynomial\n    pub commitments_targets: CommitmentTargets\u003cSC::Challenge, Comm\u003e,\n    /// Opened values at evaluation points (zeta, zeta_next)\n    pub opened_values_targets: OpenedValuesTargets\u003cSC\u003e,\n    /// PCS opening proof\n    pub opening_proof: OpeningProof,\n    /// Log₂ of the trace domain size\n    pub degree_bits: usize,\n}\n\n/// Structure representing all the targets necessary for a batch-STARK input proof.\n///\n/// This contains the circuit representation of a STARK proof, with all\n/// commitments, opened values, and the opening proof as targets.\n#[derive(Clone)]\npub struct BatchProofTargets\u003c\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n\u003e {\n    /// Commitments to trace, quotient chunks, and optional random polynomial\n    pub commitments_targets: CommitmentTargets\u003cSC::Challenge, Comm\u003e,\n    pub flattened_opened_values_targets: OpenedValuesTargetsWithLookups\u003cSC\u003e,\n    /// Opened values at evaluation points (zeta, zeta_next)\n    pub opened_values_targets: BatchOpenedValuesTargets\u003cSC\u003e,\n    /// PCS opening proof\n    pub opening_proof: OpeningProof,\n    /// Data necessary to verify the global lookup arguments across all instances\n    /// We need both the `Target` (so that the values can be used in the circuit) and the offset within the public values,\n    /// so we can compute the constraint evaluations using the associated symbolic expression\n    pub global_lookup_data: Vec\u003cVec\u003cLookupData\u003cTarget\u003e\u003e\u003e,\n    /// Log₂ of the trace domain size for all instances in a batch-STARK proof\n    pub degree_bits: Vec\u003cusize\u003e,\n}\n\n/// Target structure for STARK commitments.\n#[derive(Clone)]\npub struct CommitmentTargets\u003cF: Field, Comm: Recursive\u003cF\u003e\u003e {\n    /// Commitment to the trace polynomial\n    pub trace_targets: Comm,\n    /// Commitment to all permutation polynomials.\n    pub permutation_targets: Option\u003cComm\u003e,\n    /// Commitment to the quotient polynomial chunks\n    pub quotient_chunks_targets: Comm,\n    /// Optional commitment to random polynomial (ZK mode)\n    pub random_commit: Option\u003cComm\u003e,\n    pub _phantom: PhantomData\u003cF\u003e,\n}\n\n/// Target structure for opened polynomial values.\npub struct OpenedValuesTargets\u003cSC: StarkGenericConfig\u003e {\n    /// Trace values at point zeta\n    pub trace_local_targets: Vec\u003cTarget\u003e,\n    /// Trace values at point zeta * g (next row)\n    pub trace_next_targets: Vec\u003cTarget\u003e,\n    /// Optional preprocessed values at point zeta\n    pub preprocessed_local_targets: Option\u003cVec\u003cTarget\u003e\u003e,\n    /// Optional preprocessed values at point zeta * g (next row)\n    pub preprocessed_next_targets: Option\u003cVec\u003cTarget\u003e\u003e,\n    /// Quotient chunk values at zeta\n    pub quotient_chunks_targets: Vec\u003cVec\u003cTarget\u003e\u003e,\n    /// Optional random polynomial values (ZK mode)\n    pub random_targets: Option\u003cVec\u003cTarget\u003e\u003e,\n    pub _phantom: PhantomData\u003cSC\u003e,\n}\n\nimpl\u003cSC\u003e Clone for OpenedValuesTargets\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            trace_local_targets: self.trace_local_targets.clone(),\n            trace_next_targets: self.trace_next_targets.clone(),\n            preprocessed_local_targets: self.preprocessed_local_targets.clone(),\n            preprocessed_next_targets: self.preprocessed_next_targets.clone(),\n            quotient_chunks_targets: self.quotient_chunks_targets.clone(),\n            random_targets: self.random_targets.clone(),\n            _phantom: PhantomData,\n        }\n    }\n}\n\n/// Target structure for opened polynomial values, including lookups.\n#[derive(Clone)]\npub struct OpenedValuesTargetsWithLookups\u003cSC: StarkGenericConfig\u003e {\n    /// Targets for opened values without lookups.\n    pub opened_values_no_lookups: OpenedValuesTargets\u003cSC\u003e,\n    /// Targets for opened lookup values at point zeta.\n    pub permutation_local_targets: Vec\u003cTarget\u003e,\n    /// Targets for opened lookup values at point zeta * g (next row).\n    pub permutation_next_targets: Vec\u003cTarget\u003e,\n}\n\n/// Target structure for opened values for all instances in a batch-STARK proof.\n#[derive(Clone)]\npub struct BatchOpenedValuesTargets\u003cSC: StarkGenericConfig\u003e {\n    /// Opened values for each instance, in the same order as provided to the prover.\n    pub instances: Vec\u003cOpenedValuesTargetsWithLookups\u003cSC\u003e\u003e,\n}\n\n/// Structure which holds the targets and metadata for existing global preprocessed data.\npub struct GlobalPreprocessedTargets\u003cComm\u003e {\n    /// Global commitment targets for all preprocessed columns, over all instances.\n    pub commitment: Comm,\n    /// Per-instance metadata for preprocessed traces.\n    pub instances: PreprocessedInstanceMetas,\n    /// Mapping from preprocessed matrix index to the corresponding instance index.\n    pub matrix_to_instance: Vec\u003cusize\u003e,\n}\n\n/// Structure which holds per-instance metadata for preprocessed traces\npub struct PreprocessedInstanceMetas {\n    /// Vector of optional per-instance metadata\n    pub instances: Vec\u003cOption\u003cPreprocessedInstanceMeta\u003e\u003e,\n}\n\n/// Target structure which holds the common data shared between prover and verifier.\npub struct CommonDataTargets\u003cSC: StarkGenericConfig, Comm\u003e {\n    /// Preprocessed verifier data targets.\n    pub preprocessed: Option\u003cGlobalPreprocessedTargets\u003cComm\u003e\u003e,\n    /// Lookup data\n    pub lookups: Vec\u003cVec\u003cLookup\u003cVal\u003cSC\u003e\u003e\u003e\u003e,\n}\n\nimpl\u003cSC: StarkGenericConfig, Comm\u003e Recursive\u003cSC::Challenge\u003e for CommonDataTargets\u003cSC, Comm\u003e\nwhere\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e,\n{\n    type Input = CommonData\u003cSC\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e, input: \u0026Self::Input) -\u003e Self {\n        let preprocessed = input\n            .preprocessed\n            .as_ref()\n            .map(|prep| GlobalPreprocessedTargets {\n                commitment: Comm::new(circuit, \u0026prep.commitment),\n                instances: PreprocessedInstanceMetas {\n                    instances: prep.instances.clone(),\n                },\n                matrix_to_instance: prep.matrix_to_instance.clone(),\n            });\n\n        Self {\n            preprocessed,\n            lookups: input.lookups.clone(),\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cSC::Challenge\u003e {\n        let mut values = vec![];\n        if let Some(prep) = \u0026input.preprocessed {\n            values.extend(Comm::get_values(\u0026prep.commitment));\n        }\n\n        // Lookups are given symbolically, so we don't need to extract concrete values here.\n        values\n    }\n}\n\nimpl\u003cSC: StarkGenericConfig\u003e OpenedValuesTargetsWithLookups\u003cSC\u003e {\n    /// Observe all opened values in the Fiat-Shamir transcript.\n    ///\n    /// This method absorbs all opened values into the challenger state,\n    /// which is necessary before sampling PCS challenges.\n    ///\n    /// The opened values are extension field elements, so we use observe_ext_slice.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder\n    /// - `challenger`: Running challenger state\n    pub fn observe\u003cBF, EF\u003e(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cEF\u003e,\n        challenger: \u0026mut impl RecursiveChallenger\u003cBF, EF\u003e,\n    ) where\n        BF: PrimeField64,\n        EF: ExtensionField\u003cBF\u003e,\n    {\n        // Observe random values if in ZK mode (extension field elements)\n        if let Some(random_vals) = \u0026self.opened_values_no_lookups.random_targets {\n            challenger.observe_ext_slice(circuit, random_vals);\n        }\n\n        // Observe trace values at zeta and zeta_next (extension field elements)\n        challenger.observe_ext_slice(circuit, \u0026self.opened_values_no_lookups.trace_local_targets);\n        challenger.observe_ext_slice(circuit, \u0026self.opened_values_no_lookups.trace_next_targets);\n\n        // Observe quotient chunk values (extension field elements)\n        for chunk_values in \u0026self.opened_values_no_lookups.quotient_chunks_targets {\n            challenger.observe_ext_slice(circuit, chunk_values);\n        }\n\n        if let Some(preprocessed_local_targets) =\n            \u0026self.opened_values_no_lookups.preprocessed_local_targets\n        {\n            challenger.observe_ext_slice(circuit, preprocessed_local_targets);\n        }\n        if let Some(preprocessed_next_targets) =\n            \u0026self.opened_values_no_lookups.preprocessed_next_targets\n        {\n            challenger.observe_ext_slice(circuit, preprocessed_next_targets);\n        }\n        if !self.permutation_local_targets.is_empty() {\n            challenger.observe_ext_slice(circuit, \u0026self.permutation_local_targets);\n        }\n        if !self.permutation_next_targets.is_empty() {\n            challenger.observe_ext_slice(circuit, \u0026self.permutation_next_targets);\n        }\n    }\n}\n\nimpl\u003c\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n\u003e Recursive\u003cSC::Challenge\u003e for ProofTargets\u003cSC, Comm, OpeningProof\u003e\n{\n    type Input = Proof\u003cSC\u003e;\n\n    /// Allocates the necessary circuit targets for storing the proof's public data.\n    fn new(circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e, input: \u0026Self::Input) -\u003e Self {\n        let commitments_no_lookups = BatchCommitments {\n            main: input.commitments.trace.clone(),\n            permutation: None,\n            quotient_chunks: input.commitments.quotient_chunks.clone(),\n            random: input.commitments.random.clone(),\n        };\n        let commitments_targets = CommitmentTargets::new(circuit, \u0026commitments_no_lookups);\n        let opened_values_targets = OpenedValuesTargets::new(circuit, \u0026input.opened_values);\n        let opening_proof = OpeningProof::new(circuit, \u0026input.opening_proof);\n\n        Self {\n            commitments_targets,\n            opened_values_targets,\n            opening_proof,\n            degree_bits: input.degree_bits,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cSC::Challenge\u003e {\n        let Proof {\n            commitments,\n            opened_values,\n            opening_proof,\n            degree_bits: _,\n        } = input;\n\n        let commitments_no_lookups = BatchCommitments {\n            main: commitments.trace.clone(),\n            permutation: None,\n            quotient_chunks: commitments.quotient_chunks.clone(),\n            random: commitments.random.clone(),\n        };\n        CommitmentTargets::\u003cSC::Challenge, Comm\u003e::get_values(\u0026commitments_no_lookups)\n            .into_iter()\n            .chain(OpenedValuesTargets::\u003cSC\u003e::get_values(opened_values))\n            .chain(OpeningProof::get_values(opening_proof))\n            .collect()\n    }\n}\n\nimpl\u003c\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n\u003e Recursive\u003cSC::Challenge\u003e for BatchProofTargets\u003cSC, Comm, OpeningProof\u003e\n{\n    type Input = BatchProof\u003cSC\u003e;\n\n    /// Allocates the necessary circuit targets for storing the proof's public data.\n    fn new(circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e, input: \u0026Self::Input) -\u003e Self {\n        // Flattened opened values are ordered as:\n        // 1. All `trace_local` rows per instance (instance 0 .. N)\n        // 2. All `trace_next` rows per instance (instance 0 .. N)\n        // 3. Quotient chunks for each instance in commit order\n        let num_instances = input.opened_values.instances.len();\n        let mut aggregated_trace_local = Vec::with_capacity(num_instances);\n        let mut aggregated_trace_next = Vec::with_capacity(num_instances);\n        let mut aggregated_permutation_local = Vec::with_capacity(num_instances);\n        let mut aggregated_permutation_next = Vec::with_capacity(num_instances);\n        let mut aggregated_preprocessed_local = Vec::with_capacity(num_instances);\n        let mut aggregated_preprocessed_next = Vec::with_capacity(num_instances);\n        let mut aggregated_quotient_chunks = Vec::with_capacity(num_instances);\n\n        let commitments_targets = CommitmentTargets::new(circuit, \u0026input.commitments);\n        let opened_values_targets = BatchOpenedValuesTargets::new(circuit, \u0026input.opened_values);\n        let opening_proof = OpeningProof::new(circuit, \u0026input.opening_proof);\n        let global_lookup_data = input\n            .global_lookup_data\n            .iter()\n            .map(|instance_data| {\n                instance_data\n                    .iter()\n                    .map(|ld| {\n                        let target = circuit.alloc_public_input(\"global lookup data\");\n                        LookupData {\n                            name: ld.name.clone(),\n                            aux_idx: ld.aux_idx,\n                            expected_cumulated: target,\n                        }\n                    })\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        for instance in \u0026opened_values_targets.instances {\n            aggregated_trace_local.extend(\u0026instance.opened_values_no_lookups.trace_local_targets);\n            aggregated_trace_next.extend(\u0026instance.opened_values_no_lookups.trace_next_targets);\n            if let Some(prep_local) = \u0026instance.opened_values_no_lookups.preprocessed_local_targets\n            {\n                aggregated_preprocessed_local.extend(prep_local);\n            }\n            if let Some(prep_next) = \u0026instance.opened_values_no_lookups.preprocessed_next_targets {\n                aggregated_preprocessed_next.extend(prep_next);\n            }\n            aggregated_permutation_local.extend(\u0026instance.permutation_local_targets);\n            aggregated_permutation_next.extend(\u0026instance.permutation_next_targets);\n            for chunk in \u0026instance.opened_values_no_lookups.quotient_chunks_targets {\n                aggregated_quotient_chunks.push(chunk.clone());\n            }\n        }\n\n        let flattened_opened_values_targets = OpenedValuesTargetsWithLookups {\n            opened_values_no_lookups: OpenedValuesTargets {\n                trace_local_targets: aggregated_trace_local,\n                trace_next_targets: aggregated_trace_next,\n                preprocessed_local_targets: if aggregated_preprocessed_local.is_empty() {\n                    None\n                } else {\n                    Some(aggregated_preprocessed_local)\n                },\n                preprocessed_next_targets: if aggregated_preprocessed_next.is_empty() {\n                    None\n                } else {\n                    Some(aggregated_preprocessed_next)\n                },\n                quotient_chunks_targets: aggregated_quotient_chunks,\n                random_targets: None, // Batch proofs do not have random values\n                _phantom: PhantomData,\n            },\n            permutation_local_targets: aggregated_permutation_local,\n            permutation_next_targets: aggregated_permutation_next,\n        };\n\n        Self {\n            commitments_targets,\n            opened_values_targets,\n            flattened_opened_values_targets,\n            opening_proof,\n            global_lookup_data,\n            degree_bits: input.degree_bits.clone(),\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cSC::Challenge\u003e {\n        let BatchProof {\n            commitments,\n            opened_values,\n            opening_proof,\n            global_lookup_data,\n            degree_bits: _,\n        } = input;\n\n        CommitmentTargets::\u003cSC::Challenge, Comm\u003e::get_values(commitments)\n            .into_iter()\n            .chain(BatchOpenedValuesTargets::\u003cSC\u003e::get_values(opened_values))\n            .chain(OpeningProof::get_values(opening_proof))\n            .chain(\n                global_lookup_data\n                    .iter()\n                    .flatten()\n                    .map(|ld| ld.expected_cumulated),\n            )\n            .collect()\n    }\n}\n\nimpl\u003cF: Field, Comm\u003e Recursive\u003cF\u003e for CommitmentTargets\u003cF, Comm\u003e\nwhere\n    Comm: Recursive\u003cF\u003e,\n{\n    type Input = BatchCommitments\u003cComm::Input\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let trace_targets = Comm::new(circuit, \u0026input.main);\n        let permutation_targets = input\n            .permutation\n            .as_ref()\n            .map(|perm| Comm::new(circuit, perm));\n        let quotient_chunks_targets = Comm::new(circuit, \u0026input.quotient_chunks);\n\n        Self {\n            trace_targets,\n            permutation_targets,\n            quotient_chunks_targets,\n            random_commit: None, // ZK is not supported in batch proofs yet\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cF\u003e {\n        let BatchCommitments {\n            main,\n            permutation,\n            quotient_chunks,\n            random,\n        } = input;\n\n        let mut values = vec![];\n        values.extend(Comm::get_values(main));\n        if let Some(permutation) = permutation {\n            values.extend(Comm::get_values(permutation));\n        }\n        values.extend(Comm::get_values(quotient_chunks));\n\n        if let Some(random) = random {\n            values.extend(Comm::get_values(random));\n        }\n\n        values\n    }\n}\n\nimpl\u003cSC: StarkGenericConfig\u003e Recursive\u003cSC::Challenge\u003e for OpenedValuesTargets\u003cSC\u003e {\n    type Input = OpenedValues\u003cSC::Challenge\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e, input: \u0026Self::Input) -\u003e Self {\n        let trace_local_len = input.trace_local.len();\n        let trace_local_targets =\n            circuit.alloc_public_inputs(trace_local_len, \"trace local values\");\n\n        let trace_next_len = input.trace_next.len();\n        let trace_next_targets = circuit.alloc_public_inputs(trace_next_len, \"trace next values\");\n\n        let preprocessed_local_targets = input\n            .preprocessed_local\n            .as_ref()\n            .map(|prep| circuit.alloc_public_inputs(prep.len(), \"local preprocessed values\"));\n        let preprocessed_next_targets = input\n            .preprocessed_next\n            .as_ref()\n            .map(|prep| circuit.alloc_public_inputs(prep.len(), \"local preprocessed values\"));\n\n        let quotient_chunks_len = input.quotient_chunks.len();\n        let mut quotient_chunks_targets = Vec::with_capacity(quotient_chunks_len);\n        for quotient_chunk in input.quotient_chunks.iter() {\n            let quotient_chunks_cols_len = quotient_chunk.len();\n            let quotient_col =\n                circuit.alloc_public_inputs(quotient_chunks_cols_len, \"quotient chunk columns\");\n            quotient_chunks_targets.push(quotient_col);\n        }\n\n        let random_targets = input\n            .random\n            .as_ref()\n            .map(|random| circuit.alloc_public_inputs(random.len(), \"random values (ZK mode)\"));\n\n        Self {\n            trace_local_targets,\n            trace_next_targets,\n            preprocessed_local_targets,\n            preprocessed_next_targets,\n            quotient_chunks_targets,\n            random_targets,\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cSC::Challenge\u003e {\n        let OpenedValues {\n            trace_local,\n            trace_next,\n            preprocessed_local,\n            preprocessed_next,\n            quotient_chunks,\n            random,\n        } = input;\n\n        let mut values = vec![];\n        values.extend(trace_local);\n        values.extend(trace_next);\n        if let Some(preprocessed_local) = preprocessed_local {\n            values.extend(preprocessed_local);\n        }\n        if let Some(preprocessed_next) = preprocessed_next {\n            values.extend(preprocessed_next);\n        }\n        for chunk in quotient_chunks {\n            values.extend(chunk);\n        }\n        if let Some(random) = random {\n            values.extend(random);\n        }\n\n        values\n    }\n}\n\nimpl\u003cSC: StarkGenericConfig\u003e Recursive\u003cSC::Challenge\u003e for OpenedValuesTargetsWithLookups\u003cSC\u003e {\n    type Input = OpenedValuesWithLookups\u003cSC::Challenge\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e, input: \u0026Self::Input) -\u003e Self {\n        let opened_values_no_lookups = OpenedValuesTargets::new(circuit, \u0026input.base_opened_values);\n\n        let permutation_local_targets = circuit.alloc_public_inputs(\n            input.permutation_local.len(),\n            \"permutation local opened values\",\n        );\n        let permutation_next_targets = circuit.alloc_public_inputs(\n            input.permutation_next.len(),\n            \"permutation next opened values\",\n        );\n\n        Self {\n            opened_values_no_lookups,\n            permutation_local_targets,\n            permutation_next_targets,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cSC::Challenge\u003e {\n        let OpenedValuesWithLookups {\n            base_opened_values,\n            permutation_local,\n            permutation_next,\n        } = input;\n\n        let mut values = vec![];\n        values.extend(OpenedValuesTargets::\u003cSC\u003e::get_values(base_opened_values));\n        values.extend(permutation_local);\n        values.extend(permutation_next);\n        values\n    }\n}\n\nimpl\u003cSC: StarkGenericConfig\u003e Recursive\u003cSC::Challenge\u003e for BatchOpenedValuesTargets\u003cSC\u003e {\n    type Input = BatchOpenedValues\u003cSC::Challenge\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e, input: \u0026Self::Input) -\u003e Self {\n        let instances = input\n            .instances\n            .iter()\n            .map(|instance| OpenedValuesTargetsWithLookups::new(circuit, instance))\n            .collect();\n\n        Self { instances }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cSC::Challenge\u003e {\n        let mut values = vec![];\n        for instance in \u0026input.instances {\n            values.extend(OpenedValuesTargetsWithLookups::\u003cSC\u003e::get_values(instance));\n        }\n        values\n    }\n}\n","traces":[{"line":99,"address":[3016713,3016707,3016160],"length":1,"stats":{"Line":4}},{"line":101,"address":[3016189],"length":1,"stats":{"Line":4}},{"line":102,"address":[4910858],"length":1,"stats":{"Line":4}},{"line":103,"address":[5050005],"length":1,"stats":{"Line":4}},{"line":104,"address":[5050064],"length":1,"stats":{"Line":4}},{"line":105,"address":[3016391],"length":1,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[3342655,3342384,3342661],"length":1,"stats":{"Line":5}},{"line":164,"address":[3201443],"length":1,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[5102041,5102556,5102272,5102462,5102550],"length":1,"stats":{"Line":14}},{"line":168,"address":[3342727],"length":1,"stats":{"Line":5}},{"line":169,"address":[],"length":0,"stats":{"Line":5}},{"line":170,"address":[2955217],"length":1,"stats":{"Line":4}},{"line":172,"address":[5102399],"length":1,"stats":{"Line":4}},{"line":177,"address":[5102121],"length":1,"stats":{"Line":4}},{"line":181,"address":[3201168,3201362,3201368],"length":1,"stats":{"Line":5}},{"line":182,"address":[],"length":0,"stats":{"Line":5}},{"line":183,"address":[3342199],"length":1,"stats":{"Line":5}},{"line":184,"address":[3201267,3201353],"length":1,"stats":{"Line":10}},{"line":188,"address":[3201284],"length":1,"stats":{"Line":5}},{"line":203,"address":[4948544],"length":1,"stats":{"Line":4}},{"line":212,"address":[4948590],"length":1,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[2894574],"length":1,"stats":{"Line":4}},{"line":218,"address":[2547364],"length":1,"stats":{"Line":4}},{"line":221,"address":[2894654,2894676],"length":1,"stats":{"Line":8}},{"line":222,"address":[4807477],"length":1,"stats":{"Line":4}},{"line":225,"address":[2894818],"length":1,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[2894839],"length":1,"stats":{"Line":2}},{"line":230,"address":[2547666],"length":1,"stats":{"Line":4}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[2894935],"length":1,"stats":{"Line":2}},{"line":235,"address":[2894973],"length":1,"stats":{"Line":4}},{"line":236,"address":[4807730],"length":1,"stats":{"Line":0}},{"line":238,"address":[4807775],"length":1,"stats":{"Line":4}},{"line":239,"address":[4949172],"length":1,"stats":{"Line":0}},{"line":253,"address":[4818738,4818032,4818732],"length":1,"stats":{"Line":4}},{"line":255,"address":[2564091],"length":1,"stats":{"Line":4}},{"line":257,"address":[4976919],"length":1,"stats":{"Line":4}},{"line":258,"address":[4818183],"length":1,"stats":{"Line":4}},{"line":260,"address":[2564364],"length":1,"stats":{"Line":4}},{"line":261,"address":[4977218],"length":1,"stats":{"Line":4}},{"line":262,"address":[4977284],"length":1,"stats":{"Line":4}},{"line":268,"address":[2957549],"length":1,"stats":{"Line":4}},{"line":272,"address":[2563997,2563248,2563973],"length":1,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[2563294],"length":1,"stats":{"Line":4}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[2563322],"length":1,"stats":{"Line":4}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[4817352],"length":1,"stats":{"Line":4}},{"line":283,"address":[4817380],"length":1,"stats":{"Line":4}},{"line":284,"address":[4976244],"length":1,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":12}},{"line":288,"address":[4976508,4976787,4976585,4976515],"length":1,"stats":{"Line":8}},{"line":289,"address":[2956765,2956841,2956907,2956772],"length":1,"stats":{"Line":8}},{"line":303,"address":[2961363,2962074,2958416],"length":1,"stats":{"Line":4}},{"line":308,"address":[3203490],"length":1,"stats":{"Line":5}},{"line":309,"address":[],"length":0,"stats":{"Line":4}},{"line":310,"address":[],"length":0,"stats":{"Line":9}},{"line":311,"address":[5104302,5104355],"length":1,"stats":{"Line":9}},{"line":312,"address":[5104371,5104424],"length":1,"stats":{"Line":9}},{"line":313,"address":[3344856,3344909],"length":1,"stats":{"Line":9}},{"line":314,"address":[5104509,5104562],"length":1,"stats":{"Line":9}},{"line":315,"address":[3344994,3345055],"length":1,"stats":{"Line":9}},{"line":317,"address":[5104716,5104655],"length":1,"stats":{"Line":9}},{"line":318,"address":[3204148,3204221],"length":1,"stats":{"Line":9}},{"line":319,"address":[],"length":0,"stats":{"Line":9}},{"line":320,"address":[3345294],"length":1,"stats":{"Line":5}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[5104999,5107696],"length":1,"stats":{"Line":9}},{"line":324,"address":[],"length":0,"stats":{"Line":4}},{"line":325,"address":[2962163],"length":1,"stats":{"Line":5}},{"line":326,"address":[3348224,3348176],"length":1,"stats":{"Line":7}},{"line":327,"address":[2962253],"length":1,"stats":{"Line":4}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":329,"address":[3207294],"length":1,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":4}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[3348194],"length":1,"stats":{"Line":5}},{"line":338,"address":[5105045,5105113],"length":1,"stats":{"Line":9}},{"line":339,"address":[5105222],"length":1,"stats":{"Line":5}},{"line":340,"address":[3347459],"length":1,"stats":{"Line":4}},{"line":341,"address":[],"length":0,"stats":{"Line":5}},{"line":343,"address":[],"length":0,"stats":{"Line":9}},{"line":345,"address":[5107145,5107199],"length":1,"stats":{"Line":9}},{"line":346,"address":[5107249,5107215],"length":1,"stats":{"Line":9}},{"line":348,"address":[5107227],"length":1,"stats":{"Line":4}},{"line":349,"address":[],"length":0,"stats":{"Line":5}},{"line":350,"address":[5107283],"length":1,"stats":{"Line":4}},{"line":351,"address":[5107414],"length":1,"stats":{"Line":5}},{"line":356,"address":[3346176],"length":1,"stats":{"Line":4}},{"line":383,"address":[3205913],"length":1,"stats":{"Line":5}},{"line":387,"address":[],"length":0,"stats":{"Line":5}},{"line":388,"address":[3202745],"length":1,"stats":{"Line":4}},{"line":389,"address":[3202769],"length":1,"stats":{"Line":4}},{"line":390,"address":[3343769],"length":1,"stats":{"Line":4}},{"line":391,"address":[5103373],"length":1,"stats":{"Line":4}},{"line":392,"address":[2957809],"length":1,"stats":{"Line":4}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[5103829,5103428,5103636,5103520],"length":1,"stats":{"Line":16}},{"line":398,"address":[],"length":0,"stats":{"Line":9}},{"line":399,"address":[2958359,2958084,2958004,2958011],"length":1,"stats":{"Line":8}},{"line":401,"address":[],"length":0,"stats":{"Line":4}},{"line":402,"address":[2958180],"length":1,"stats":{"Line":4}},{"line":403,"address":[],"length":0,"stats":{"Line":4}},{"line":404,"address":[3344397,3344238,3344384],"length":1,"stats":{"Line":10}},{"line":416,"address":[2912218,2912224,2911792],"length":1,"stats":{"Line":7}},{"line":417,"address":[],"length":0,"stats":{"Line":8}},{"line":418,"address":[2911849],"length":1,"stats":{"Line":8}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[4981648,4981324,4981669],"length":1,"stats":{"Line":15}},{"line":422,"address":[2911932],"length":1,"stats":{"Line":7}},{"line":433,"address":[4952468,4952474,4952032],"length":1,"stats":{"Line":7}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":7}},{"line":436,"address":[2551942],"length":1,"stats":{"Line":7}},{"line":437,"address":[4952090],"length":1,"stats":{"Line":7}},{"line":438,"address":[4980830],"length":1,"stats":{"Line":7}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[2911444],"length":1,"stats":{"Line":8}},{"line":442,"address":[4808137,4808083],"length":1,"stats":{"Line":16}},{"line":443,"address":[3333589],"length":1,"stats":{"Line":8}},{"line":444,"address":[2911575,2911612],"length":1,"stats":{"Line":8}},{"line":446,"address":[],"length":0,"stats":{"Line":15}},{"line":448,"address":[3196606],"length":1,"stats":{"Line":7}},{"line":449,"address":[2911763,2911699],"length":1,"stats":{"Line":0}},{"line":452,"address":[4981124],"length":1,"stats":{"Line":8}},{"line":459,"address":[],"length":0,"stats":{"Line":8}},{"line":460,"address":[],"length":0,"stats":{"Line":7}},{"line":461,"address":[3199086],"length":1,"stats":{"Line":8}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":15}},{"line":465,"address":[3199204],"length":1,"stats":{"Line":7}},{"line":467,"address":[3199240],"length":1,"stats":{"Line":8}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":20}},{"line":471,"address":[3340325],"length":1,"stats":{"Line":8}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[3341626,3341584,3340396],"length":1,"stats":{"Line":20}},{"line":476,"address":[],"length":0,"stats":{"Line":15}},{"line":477,"address":[3340485],"length":1,"stats":{"Line":8}},{"line":478,"address":[],"length":0,"stats":{"Line":15}},{"line":479,"address":[],"length":0,"stats":{"Line":15}},{"line":480,"address":[],"length":0,"stats":{"Line":7}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":8}},{"line":485,"address":[],"length":0,"stats":{"Line":7}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[5101210,5101168,5100359],"length":1,"stats":{"Line":8}},{"line":501,"address":[2561540,2560944,2561546],"length":1,"stats":{"Line":7}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[3339406],"length":1,"stats":{"Line":7}},{"line":504,"address":[4814982],"length":1,"stats":{"Line":7}},{"line":505,"address":[4815002],"length":1,"stats":{"Line":7}},{"line":506,"address":[],"length":0,"stats":{"Line":7}},{"line":507,"address":[4973842],"length":1,"stats":{"Line":7}},{"line":508,"address":[5099078],"length":1,"stats":{"Line":7}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":7}},{"line":512,"address":[5099120],"length":1,"stats":{"Line":7}},{"line":513,"address":[4973966],"length":1,"stats":{"Line":7}},{"line":514,"address":[3339602],"length":1,"stats":{"Line":7}},{"line":515,"address":[4815266,4815220],"length":1,"stats":{"Line":12}},{"line":517,"address":[],"length":0,"stats":{"Line":13}},{"line":518,"address":[3339747,3339718],"length":1,"stats":{"Line":12}},{"line":520,"address":[],"length":0,"stats":{"Line":14}},{"line":521,"address":[],"length":0,"stats":{"Line":14}},{"line":523,"address":[5099448],"length":1,"stats":{"Line":7}},{"line":524,"address":[2561482,2561533],"length":1,"stats":{"Line":0}},{"line":527,"address":[2952363],"length":1,"stats":{"Line":7}},{"line":534,"address":[3343687,3343693,3343232],"length":1,"stats":{"Line":5}},{"line":535,"address":[2955760],"length":1,"stats":{"Line":4}},{"line":537,"address":[3202364],"length":1,"stats":{"Line":5}},{"line":538,"address":[3202298],"length":1,"stats":{"Line":4}},{"line":541,"address":[3202465],"length":1,"stats":{"Line":5}},{"line":542,"address":[2955869],"length":1,"stats":{"Line":4}},{"line":553,"address":[3202219,3202000,3202225],"length":1,"stats":{"Line":4}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":4}},{"line":556,"address":[5102607],"length":1,"stats":{"Line":4}},{"line":557,"address":[],"length":0,"stats":{"Line":4}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":4}},{"line":561,"address":[2955607,2955559],"length":1,"stats":{"Line":8}},{"line":562,"address":[2955624],"length":1,"stats":{"Line":4}},{"line":563,"address":[5102745],"length":1,"stats":{"Line":4}},{"line":564,"address":[2955657],"length":1,"stats":{"Line":4}},{"line":571,"address":[5101552],"length":1,"stats":{"Line":4}},{"line":572,"address":[2954490],"length":1,"stats":{"Line":5}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":13}},{"line":581,"address":[5101524,5101530,5101264],"length":1,"stats":{"Line":4}},{"line":582,"address":[3341712],"length":1,"stats":{"Line":4}},{"line":583,"address":[3200794,3200730],"length":1,"stats":{"Line":8}},{"line":584,"address":[3341928,3341867],"length":1,"stats":{"Line":8}},{"line":586,"address":[3341884],"length":1,"stats":{"Line":4}}],"covered":174,"coverable":201},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","types","selectors.rs"],"content":"//! Lagrange selector structures for constraint evaluation.\n\nuse p3_circuit::utils::RowSelectorsTargets;\n\nuse crate::Target;\n\n/// Circuit version of Lagrange selectors for AIR constraint evaluation.\n#[derive(Clone, Debug)]\npub struct RecursiveLagrangeSelectors {\n    /// Row selector targets (is_first_row, is_last_row, is_transition)\n    pub row_selectors: RowSelectorsTargets,\n    /// Inverse of the vanishing polynomial: 1 / Z_H(point)\n    ///\n    /// The vanishing polynomial Z_H(x) = x^n - 1 for a domain of size n.\n    /// This inverse is used to compute the quotient polynomial evaluation.\n    pub inv_vanishing: Target,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","batch_stark.rs"],"content":"#![allow(clippy::upper_case_acronyms)]\n\nuse alloc::string::{String, ToString};\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\n\nuse hashbrown::HashMap;\nuse p3_air::{Air as P3Air, AirBuilder, BaseAir as P3BaseAir};\nuse p3_batch_stark::CommonData;\nuse p3_circuit::op::NonPrimitiveOpType;\nuse p3_circuit::utils::ColumnsTargets;\nuse p3_circuit::{CircuitBuilder, NonPrimitiveOpId};\nuse p3_circuit_prover::air::{AluAir, ConstAir, PublicAir, WitnessAir};\nuse p3_circuit_prover::batch_stark_prover::{AirVariant, PrimitiveTable, RowCounts};\nuse p3_circuit_prover::{\n    BABY_BEAR_MODULUS, KOALA_BEAR_MODULUS, Poseidon2AirWrapperInner,\n    poseidon2_verifier_air_from_config,\n};\nuse p3_commit::{Pcs, PolynomialSpace};\nuse p3_field::{BasedVectorSpace, ExtensionField, Field, PrimeCharacteristicRing, PrimeField64};\nuse p3_lookup::lookup_traits::{Kind, Lookup, LookupData, LookupGadget};\nuse p3_uni_stark::{StarkGenericConfig, SymbolicExpression, Val};\n\nuse super::{ObservableCommitment, VerificationError, recompose_quotient_from_chunks_circuit};\nuse crate::challenger::CircuitChallenger;\nuse crate::ops::Poseidon2Config;\nuse crate::traits::{\n    LookupMetadata, Recursive, RecursiveAir, RecursiveChallenger, RecursiveLookupGadget,\n    RecursivePcs,\n};\nuse crate::types::{\n    BatchProofTargets, CommonDataTargets, OpenedValuesTargets, OpenedValuesTargetsWithLookups,\n};\nuse crate::{BatchStarkVerifierInputsBuilder, Target};\n\n/// Type alias for PCS verifier parameters.\npub type PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e =\n    \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as RecursivePcs\u003c\n        SC,\n        InputProof,\n        OpeningProof,\n        Comm,\n        \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\n            \u003cSC as StarkGenericConfig\u003e::Challenge,\n            \u003cSC as StarkGenericConfig\u003e::Challenger,\n        \u003e\u003e::Domain,\n    \u003e\u003e::VerifierParams;\n\n// TODO(Robin): Remove with dynamic dispatch\n/// Wrapper enum for heterogeneous circuit table AIRs used by circuit-prover tables.\npub enum CircuitTablesAir\u003cF: Field, const D: usize\u003e {\n    Witness(WitnessAir\u003cF, D\u003e),\n    Const(ConstAir\u003cF, D\u003e),\n    Public(PublicAir\u003cF, D\u003e),\n    Alu(AluAir\u003cF, D\u003e),\n    Poseidon2(Poseidon2AirWrapperInner),\n}\n\nimpl\u003cF: Field, const D: usize\u003e P3BaseAir\u003cF\u003e for CircuitTablesAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        match self {\n            Self::Witness(a) =\u003e P3BaseAir::width(a),\n            Self::Const(a) =\u003e P3BaseAir::width(a),\n            Self::Public(a) =\u003e P3BaseAir::width(a),\n            Self::Alu(a) =\u003e P3BaseAir::width(a),\n            Self::Poseidon2(a) =\u003e a.width(),\n        }\n    }\n}\n\nimpl\u003cF, EF, const D: usize\u003e P3Air\u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e\u003e\n    for CircuitTablesAir\u003cF, D\u003e\nwhere\n    F: Field + PrimeField64,\n    EF: ExtensionField\u003cF\u003e,\n    SymbolicExpression\u003cEF\u003e: From\u003cSymbolicExpression\u003cF\u003e\u003e,\n{\n    fn eval(\u0026self, builder: \u0026mut p3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e) {\n        match self {\n            Self::Witness(a) =\u003e P3Air::eval(a, builder),\n            Self::Const(a) =\u003e P3Air::eval(a, builder),\n            Self::Public(a) =\u003e P3Air::eval(a, builder),\n            Self::Alu(a) =\u003e P3Air::eval(a, builder),\n            Self::Poseidon2(inner) =\u003e P3Air::eval(inner, builder),\n        }\n    }\n\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        match self {\n            Self::Witness(a) =\u003e {\n                P3Air::\u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e\u003e::add_lookup_columns(a)\n            }\n            Self::Const(a) =\u003e {\n                P3Air::\u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e\u003e::add_lookup_columns(a)\n            }\n            Self::Public(a) =\u003e {\n                P3Air::\u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e\u003e::add_lookup_columns(a)\n            }\n            Self::Alu(a) =\u003e P3Air::\u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e\u003e::add_lookup_columns(a),\n            Self::Poseidon2(inner) =\u003e {\n                P3Air::\u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e\u003e::add_lookup_columns(inner)\n            }\n        }\n    }\n\n    #[allow(clippy::missing_transmute_annotations)]\n    fn get_lookups(\n        \u0026mut self,\n    ) -\u003e Vec\u003c\n        p3_lookup::lookup_traits::Lookup\u003c\n            \u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e as AirBuilder\u003e::F,\n        \u003e,\n    \u003e {\n        match self {\n            Self::Witness(a) =\u003e P3Air::\u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e\u003e::get_lookups(a),\n            Self::Const(a) =\u003e P3Air::\u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e\u003e::get_lookups(a),\n            Self::Public(a) =\u003e P3Air::\u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e\u003e::get_lookups(a),\n            Self::Alu(a) =\u003e P3Air::\u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e\u003e::get_lookups(a),\n            Self::Poseidon2(inner) =\u003e {\n                P3Air::\u003cp3_uni_stark::SymbolicAirBuilder\u003cF, EF\u003e\u003e::get_lookups(inner)\n            }\n        }\n    }\n}\n\n/// Create an AluAir with the appropriate constructor based on TRACE_D.\n///\n/// For D=1 (base field), uses `AluAir::new()`.\n/// For D\u003e1 (extension field), uses `AluAir::new_binomial()` with the W parameter\n/// extracted from the challenge field type.\nfn create_alu_air\u003cF, EF, const TRACE_D: usize\u003e(num_ops: usize, lanes: usize) -\u003e AluAir\u003cF, TRACE_D\u003e\nwhere\n    F: Field + PrimeCharacteristicRing,\n    EF: ExtensionField\u003cF\u003e,\n{\n    if TRACE_D == 1 {\n        AluAir::\u003cF, TRACE_D\u003e::new(num_ops, lanes)\n    } else {\n        // For D \u003e 1, extract W from the extension field\n        // BinomialExtensionField\u003cF, D\u003e has W as the constant such that x^D = W\n        let w = extract_binomial_w::\u003cF, EF\u003e();\n        AluAir::\u003cF, TRACE_D\u003e::new_binomial(num_ops, lanes, w)\n    }\n}\n\n/// Extract the binomial parameter W from an extension field type.\n///\n/// For BinomialExtensionField\u003cF, D\u003e, this returns F::W.\n/// Panics if called on a non-extension field.\nfn extract_binomial_w\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e() -\u003e F {\n    // The extension field dimension tells us the degree\n    let d = EF::DIMENSION;\n\n    // For common cases, we know the W values:\n    // BabyBear: x^4 = 11 (W = 11)\n    // KoalaBear: x^4 = 3 (W = 3)\n    // These are the standard Plonky3 values.\n    //\n    // We use a runtime check based on the field characteristic to determine W.\n    // This is a workaround since we can't easily extract W from the type at runtime.\n\n    if d == 4 {\n        // Check which field we're using based on the modulus\n        let baby_bear_mod = F::from_u64(BABY_BEAR_MODULUS);\n        let koala_bear_mod = F::from_u64(KOALA_BEAR_MODULUS);\n\n        if baby_bear_mod == F::ZERO {\n            // BabyBear: W = 11\n            F::from_u64(11)\n        } else if koala_bear_mod == F::ZERO {\n            // KoalaBear: W = 3\n            F::from_u64(3)\n        } else {\n            // Goldilocks or other - try W = 7 (common for some fields)\n            // This is a fallback; proper implementation would use BinomiallyExtendable trait\n            F::from_u64(7)\n        }\n    } else {\n        panic!(\"Unsupported extension degree: {d}. Only D=1 and D=4 are supported.\")\n    }\n}\n\n/// Build and attach a recursive verifier circuit for a circuit-prover [`BatchStarkProof`].\n///\n/// This reconstructs the circuit table AIRs from the proof metadata (rows + packing) so callers\n/// don't need to pass `circuit_airs` explicitly. Returns the allocated input builder to pack\n/// public inputs afterwards.\n#[allow(clippy::type_complexity)]\npub fn verify_p3_batch_proof_circuit\u003c\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e + Clone\n        + ObservableCommitment,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n    LG: RecursiveLookupGadget\u003cSC::Challenge\u003e,\n    const WIDTH: usize,\n    const RATE: usize,\n    const TRACE_D: usize,\n\u003e(\n    config: \u0026SC,\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    proof: \u0026p3_circuit_prover::batch_stark_prover::BatchStarkProof\u003cSC\u003e,\n    pcs_params: \u0026PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e,\n    common_data: \u0026CommonData\u003cSC\u003e,\n    lookup_gadget: \u0026LG,\n    poseidon2_config: Poseidon2Config,\n) -\u003e Result\u003c\n    (\n        BatchStarkVerifierInputsBuilder\u003cSC, Comm, OpeningProof\u003e,\n        Vec\u003cNonPrimitiveOpId\u003e,\n    ),\n    VerificationError,\n\u003e\nwhere\n    \u003cSC as StarkGenericConfig\u003e::Pcs: RecursivePcs\u003c\n            SC,\n            InputProof,\n            OpeningProof,\n            Comm,\n            \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain,\n        \u003e,\n    Val\u003cSC\u003e: PrimeField64,\n    SC::Challenge: ExtensionField\u003cVal\u003cSC\u003e\u003e + PrimeCharacteristicRing,\n    \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain: Clone,\n    SymbolicExpression\u003cSC::Challenge\u003e: From\u003cSymbolicExpression\u003cVal\u003cSC\u003e\u003e\u003e,\n{\n    assert_eq!(proof.ext_degree, TRACE_D, \"trace extension degree mismatch\");\n    let rows: RowCounts = proof.rows;\n    let packing = proof.table_packing;\n    let witness_lanes = packing.witness_lanes();\n    let public_lanes = packing.public_lanes();\n    let alu_lanes = packing.alu_lanes();\n\n    // Create AluAir with appropriate constructor based on TRACE_D and the stored\n    // primitive ALU variant used during proving.\n    // For now both variants share the same AIR type; this hook allows us to swap\n    // in a different ALU AIR in the future based on `proof.alu_variant`.\n    let alu_air = match proof.alu_variant {\n        AirVariant::Baseline | AirVariant::Optimized =\u003e {\n            create_alu_air::\u003cVal\u003cSC\u003e, SC::Challenge, TRACE_D\u003e(rows[PrimitiveTable::Alu], alu_lanes)\n        }\n    };\n\n    let mut circuit_airs: Vec\u003cCircuitTablesAir\u003cVal\u003cSC\u003e, TRACE_D\u003e\u003e = vec![\n        CircuitTablesAir::Witness(WitnessAir::\u003cVal\u003cSC\u003e, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Witness],\n            witness_lanes,\n        )),\n        CircuitTablesAir::Const(ConstAir::\u003cVal\u003cSC\u003e, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Const],\n        )),\n        CircuitTablesAir::Public(PublicAir::\u003cVal\u003cSC\u003e, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Public],\n            public_lanes,\n        )),\n        CircuitTablesAir::Alu(alu_air),\n    ];\n\n    // Add non-primitive AIRs (e.g., Poseidon2) from the proof manifest.\n    for entry in \u0026proof.non_primitives {\n        match entry.op_type {\n            NonPrimitiveOpType::Poseidon2Perm(config) =\u003e {\n                circuit_airs.push(CircuitTablesAir::Poseidon2(\n                    poseidon2_verifier_air_from_config(config),\n                ));\n            }\n            NonPrimitiveOpType::Unconstrained =\u003e {\n                // Unconstrained operations don't produce a separate AIR table.\n            }\n        }\n    }\n\n    // TODO: public values are empty for all circuit tables for now.\n    let air_public_counts = vec![0usize; proof.proof.opened_values.instances.len()];\n    let verifier_inputs = BatchStarkVerifierInputsBuilder::\u003cSC, Comm, OpeningProof\u003e::allocate(\n        circuit,\n        \u0026proof.proof,\n        common_data,\n        \u0026air_public_counts,\n    );\n\n    let common = \u0026verifier_inputs.common_data;\n\n    let mmcs_op_ids = verify_batch_circuit::\u003c\n        CircuitTablesAir\u003cVal\u003cSC\u003e, TRACE_D\u003e,\n        SC,\n        Comm,\n        InputProof,\n        OpeningProof,\n        LG,\n        WIDTH,\n        RATE,\n    \u003e(\n        config,\n        \u0026circuit_airs,\n        circuit,\n        \u0026verifier_inputs.proof_targets,\n        \u0026verifier_inputs.air_public_targets,\n        pcs_params,\n        common,\n        lookup_gadget,\n        poseidon2_config,\n    )?;\n\n    Ok((verifier_inputs, mmcs_op_ids))\n}\n\n/// Verify a batch-STARK proof inside a recursive circuit.\n///\n/// # Returns\n/// `Ok(Vec\u003cNonPrimitiveOpId\u003e)` containing operation IDs that require private data\n/// (e.g., Merkle sibling values for MMCS verification). The caller must set\n/// private data for these operations before running the circuit.\n/// `Err` if there was a structural error.\n#[allow(clippy::too_many_arguments)]\npub fn verify_batch_circuit\u003c\n    A,\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e + Clone\n        + ObservableCommitment,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    LG: RecursiveLookupGadget\u003cSC::Challenge\u003e,\n    const WIDTH: usize,\n    const RATE: usize,\n\u003e(\n    config: \u0026SC,\n    airs: \u0026[A],\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    proof_targets: \u0026BatchProofTargets\u003cSC, Comm, OpeningProof\u003e,\n    public_values: \u0026[Vec\u003cTarget\u003e],\n    pcs_params: \u0026PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e,\n    common: \u0026CommonDataTargets\u003cSC, Comm\u003e,\n    lookup_gadget: \u0026LG,\n    poseidon2_config: crate::ops::Poseidon2Config,\n) -\u003e Result\u003cVec\u003cNonPrimitiveOpId\u003e, VerificationError\u003e\nwhere\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LG\u003e,\n    \u003cSC as StarkGenericConfig\u003e::Pcs: RecursivePcs\u003c\n            SC,\n            InputProof,\n            OpeningProof,\n            Comm,\n            \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain,\n        \u003e,\n    Val\u003cSC\u003e: PrimeField64,\n    SC::Challenge: ExtensionField\u003cVal\u003cSC\u003e\u003e + PrimeCharacteristicRing,\n    \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain: Clone,\n{\n    let BatchProofTargets {\n        commitments_targets,\n        flattened_opened_values_targets: flattened,\n        opened_values_targets,\n        opening_proof,\n        global_lookup_data,\n        degree_bits,\n    } = proof_targets;\n    let instances = \u0026opened_values_targets.instances;\n\n    //TODO: Add support for ZK mode.\n    debug_assert_eq!(config.is_zk(), 0, \"batch recursion assumes non-ZK\");\n    if airs.is_empty() {\n        return Err(VerificationError::InvalidProofShape(\n            \"batch-STARK verification requires at least one instance\".to_string(),\n        ));\n    }\n\n    if airs.len() != instances.len()\n        || airs.len() != public_values.len()\n        || airs.len() != proof_targets.degree_bits.len()\n    {\n        return Err(VerificationError::InvalidProofShape(\n            \"Mismatch between number of AIRs, instances, public values, or degree bits\".to_string(),\n        ));\n    }\n\n    let all_lookups = \u0026common.lookups;\n\n    let pcs = config.pcs();\n\n    if commitments_targets.random_commit.is_some() {\n        return Err(VerificationError::InvalidProofShape(\n            \"Batch-STARK verifier does not support random commitments\".to_string(),\n        ));\n    }\n\n    let n_instances = airs.len();\n\n    // Pre-compute per-instance quotient degrees and preprocessed widths, and validate proof shape.\n    let mut preprocessed_widths = Vec::with_capacity(airs.len());\n    let mut log_quotient_degrees = Vec::with_capacity(n_instances);\n    let mut quotient_degrees = Vec::with_capacity(n_instances);\n    for (i, ((air, instance), public_vals)) in airs\n        .iter()\n        .zip(instances.iter())\n        .zip(public_values)\n        .enumerate()\n    {\n        let OpenedValuesTargets {\n            trace_local_targets,\n            trace_next_targets,\n            preprocessed_local_targets,\n            preprocessed_next_targets,\n            quotient_chunks_targets,\n            ..\n        } = \u0026instance.opened_values_no_lookups;\n\n        let pre_w = common\n            .preprocessed\n            .as_ref()\n            .and_then(|g| g.instances.instances[i].as_ref().map(|m| m.width))\n            .unwrap_or(0);\n        preprocessed_widths.push(pre_w);\n\n        let local_prep_len = preprocessed_local_targets.as_ref().map_or(0, |v| v.len());\n        let next_prep_len = preprocessed_next_targets.as_ref().map_or(0, |v| v.len());\n        if local_prep_len != pre_w || next_prep_len != pre_w {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"Instance has incorrect preprocessed width: expected {pre_w}, got {local_prep_len} / {next_prep_len}\"\n            )));\n        }\n        let air_width = A::width(air);\n        if trace_local_targets.len() != air_width || trace_next_targets.len() != air_width {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"Instance has incorrect trace width: expected {}, got {} / {}\",\n                air_width,\n                trace_local_targets.len(),\n                trace_next_targets.len()\n            )));\n        }\n\n        let log_qd = A::get_log_num_quotient_chunks(\n            air,\n            pre_w,\n            public_vals.len() + global_lookup_data[i].len(), // The expected cumulated values are also public inputs.\n            \u0026all_lookups[i],\n            \u0026lookup_data_to_pv_index(\u0026global_lookup_data[i], public_vals.len()),\n            config.is_zk(),\n            lookup_gadget,\n        );\n        let quotient_degree = 1 \u003c\u003c (log_qd + config.is_zk());\n\n        if quotient_chunks_targets.len() != quotient_degree {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"Instance quotient chunk count mismatch: expected {}, got {}\",\n                quotient_degree,\n                quotient_chunks_targets.len()\n            )));\n        }\n\n        if quotient_chunks_targets\n            .iter()\n            .any(|chunk| chunk.len() != SC::Challenge::DIMENSION)\n        {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"Invalid quotient chunk length: expected {}\",\n                SC::Challenge::DIMENSION\n            )));\n        }\n\n        log_quotient_degrees.push(log_qd);\n        quotient_degrees.push(quotient_degree);\n    }\n\n    // Challenger initialisation mirrors the native batch-STARK verifier transcript.\n    // Native uses observe_base_as_algebra_element which decomposes to D coefficients,\n    // so we use observe_ext to match.\n    let mut challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new(poseidon2_config);\n    let inst_count_target = circuit.alloc_const(\n        SC::Challenge::from_usize(n_instances),\n        \"number of instances\",\n    );\n    challenger.observe_ext(circuit, inst_count_target);\n\n    for ((\u0026ext_db, quotient_degree), air) in degree_bits\n        .iter()\n        .zip(quotient_degrees.iter())\n        .zip(airs.iter())\n    {\n        let base_db = ext_db.checked_sub(config.is_zk()).ok_or_else(|| {\n            VerificationError::InvalidProofShape(\n                \"Extended degree bits smaller than ZK adjustment\".to_string(),\n            )\n        })?;\n        let base_db_target =\n            circuit.alloc_const(SC::Challenge::from_usize(base_db), \"base degree bits\");\n        let ext_db_target =\n            circuit.alloc_const(SC::Challenge::from_usize(ext_db), \"extended degree bits\");\n        let width_target =\n            circuit.alloc_const(SC::Challenge::from_usize(A::width(air)), \"air width\");\n        let quotient_chunks_target = circuit.alloc_const(\n            SC::Challenge::from_usize(*quotient_degree),\n            \"quotient chunk count\",\n        );\n\n        // Native uses observe_base_as_algebra_element (via observe_instance_binding),\n        // so we use observe_ext to match by decomposing to D base coefficients.\n        challenger.observe_ext(circuit, ext_db_target);\n        challenger.observe_ext(circuit, base_db_target);\n        challenger.observe_ext(circuit, width_target);\n        challenger.observe_ext(circuit, quotient_chunks_target);\n    }\n\n    challenger.observe_slice(\n        circuit,\n        \u0026commitments_targets.trace_targets.to_observation_targets(),\n    );\n    for pv in public_values {\n        challenger.observe_slice(circuit, pv);\n    }\n\n    // Observe preprocessed widths for each instance. If a global\n    // preprocessed commitment exists, observe it once.\n    // Native uses observe_base_as_algebra_element, so we use observe_ext.\n    for \u0026pre_w in preprocessed_widths.iter() {\n        let pre_w_target =\n            circuit.alloc_const(SC::Challenge::from_usize(pre_w), \"preprocessed width\");\n        challenger.observe_ext(circuit, pre_w_target);\n    }\n    if let Some(global) = \u0026common.preprocessed {\n        challenger.observe_slice(circuit, \u0026global.commitment.to_observation_targets());\n    }\n\n    // Validate shape of the lookup commitment.\n    let is_lookup = proof_targets\n        .commitments_targets\n        .permutation_targets\n        .is_some();\n    if is_lookup != all_lookups.iter().any(|c| !c.is_empty()) {\n        return Err(VerificationError::InvalidProofShape(\n            \"Mismatch between lookup commitment and lookup data\".to_string(),\n        ));\n    }\n\n    // Fetch lookups and sample their challenges.\n    let challenges_per_instance = get_perm_challenges::\u003cSC, WIDTH, RATE, LG\u003e(\n        circuit,\n        \u0026mut challenger,\n        all_lookups,\n        lookup_gadget,\n    );\n\n    // Then, observe the permutation tables, if any.\n    if is_lookup {\n        challenger.observe_slice(\n            circuit,\n            \u0026commitments_targets\n                .permutation_targets\n                .clone()\n                .expect(\"We checked that the commitment exists\")\n                .to_observation_targets(),\n        );\n    }\n\n    // Sample alpha challenge (extension field element)\n    let alpha = challenger.sample_ext(circuit);\n\n    challenger.observe_slice(\n        circuit,\n        \u0026commitments_targets\n            .quotient_chunks_targets\n            .to_observation_targets(),\n    );\n    // Sample zeta challenge (extension field element)\n    let zeta = challenger.sample_ext(circuit);\n\n    // Build per-instance domains.\n    let mut trace_domains = Vec::with_capacity(n_instances);\n    let mut ext_trace_domains = Vec::with_capacity(n_instances);\n    for \u0026ext_db in degree_bits {\n        let base_db = ext_db - config.is_zk();\n        trace_domains.push(pcs.natural_domain_for_degree(1 \u003c\u003c base_db));\n        ext_trace_domains.push(pcs.natural_domain_for_degree(1 \u003c\u003c ext_db));\n    }\n\n    // Collect commitments with opening points for PCS verification.\n    // We have, in the typical lookup case, up to four rounds:\n    // trace, quotient, optional preprocessed, and optional permutation.\n    let mut coms_to_verify = Vec::with_capacity(4);\n\n    let trace_round: Vec\u003c_\u003e = ext_trace_domains\n        .iter()\n        .zip(instances.iter())\n        .map(|(ext_dom, inst)| {\n            let first_point = pcs.first_point(ext_dom);\n            let next_point = ext_dom.next_point(first_point).ok_or_else(|| {\n                VerificationError::InvalidProofShape(\n                    \"Trace domain does not provide next point\".to_string(),\n                )\n            })?;\n            let generator = next_point * first_point.inverse();\n            let generator_const = circuit.define_const(generator);\n            let zeta_next = circuit.mul(zeta, generator_const);\n            Ok((\n                *ext_dom,\n                vec![\n                    (\n                        zeta,\n                        inst.opened_values_no_lookups.trace_local_targets.clone(),\n                    ),\n                    (\n                        zeta_next,\n                        inst.opened_values_no_lookups.trace_next_targets.clone(),\n                    ),\n                ],\n            ))\n        })\n        .collect::\u003cResult\u003c_, VerificationError\u003e\u003e()?;\n    coms_to_verify.push((commitments_targets.trace_targets.clone(), trace_round));\n\n    let quotient_domains: Vec\u003cVec\u003c_\u003e\u003e = degree_bits\n        .iter()\n        .zip(ext_trace_domains.iter())\n        .zip(log_quotient_degrees.iter())\n        .map(|((\u0026ext_db, ext_dom), \u0026log_qd)| {\n            let base_db = ext_db - config.is_zk();\n            let q_domain = ext_dom.create_disjoint_domain(1 \u003c\u003c (base_db + log_qd + config.is_zk()));\n            q_domain.split_domains(1 \u003c\u003c (log_qd + config.is_zk()))\n        })\n        .collect();\n\n    let mut quotient_round =\n        Vec::with_capacity(quotient_domains.iter().map(|domains| domains.len()).sum());\n    for (domains, inst) in quotient_domains.iter().zip(instances.iter()) {\n        if domains.len() != inst.opened_values_no_lookups.quotient_chunks_targets.len() {\n            return Err(VerificationError::InvalidProofShape(\n                \"Quotient chunk count mismatch across domains\".to_string(),\n            ));\n        }\n        for (domain, values) in domains\n            .iter()\n            .zip(inst.opened_values_no_lookups.quotient_chunks_targets.iter())\n        {\n            quotient_round.push((*domain, vec![(zeta, values.clone())]));\n        }\n    }\n    coms_to_verify.push((\n        commitments_targets.quotient_chunks_targets.clone(),\n        quotient_round,\n    ));\n\n    if let Some(global) = \u0026common.preprocessed {\n        let mut pre_round = Vec::with_capacity(global.matrix_to_instance.len());\n\n        for (matrix_index, \u0026inst_idx) in global.matrix_to_instance.iter().enumerate() {\n            let pre_w = preprocessed_widths[inst_idx];\n            if pre_w == 0 {\n                return Err(VerificationError::InvalidProofShape(\n                    \"Instance has preprocessed columns with zero width\".to_string(),\n                ));\n            }\n\n            let inst = \u0026instances[inst_idx];\n            let local = inst\n                .opened_values_no_lookups\n                .preprocessed_local_targets\n                .as_ref()\n                .ok_or_else(|| {\n                    VerificationError::InvalidProofShape(\n                        \"Missing preprocessed local columns\".to_string(),\n                    )\n                })?;\n            let next = inst\n                .opened_values_no_lookups\n                .preprocessed_next_targets\n                .as_ref()\n                .ok_or_else(|| {\n                    VerificationError::InvalidProofShape(\n                        \"Missing preprocessed next columns\".to_string(),\n                    )\n                })?;\n            // Validate that the preprocessed data's base degree matches what we expect.\n            let ext_db = degree_bits[inst_idx];\n            let expected_base_db = ext_db - config.is_zk();\n\n            let meta = global.instances.instances[inst_idx]\n                .as_ref()\n                .ok_or_else(|| {\n                    VerificationError::InvalidProofShape(\n                        \"Missing preprocessed instance metadata\".to_string(),\n                    )\n                })?;\n            if meta.matrix_index != matrix_index || meta.degree_bits != expected_base_db {\n                return Err(VerificationError::InvalidProofShape(\n                    \"Preprocessed instance metadata mismatch\".to_string(),\n                ));\n            }\n\n            // Compute base preprocessed domain (matching prover in generation.rs)\n            let pre_domain = pcs.natural_domain_for_degree(1 \u003c\u003c meta.degree_bits);\n\n            // Use extended trace domain for zeta_next computation (same generator)\n            let ext_dom = \u0026ext_trace_domains[inst_idx];\n            let first_point = pcs.first_point(ext_dom);\n            let next_point = ext_dom.next_point(first_point).ok_or_else(|| {\n                VerificationError::InvalidProofShape(\n                    \"Preprocessed domain does not provide next point\".to_string(),\n                )\n            })?;\n            let generator = next_point * first_point.inverse();\n            let generator_const = circuit.define_const(generator);\n            let zeta_next = circuit.mul(zeta, generator_const);\n\n            pre_round.push((\n                pre_domain,\n                vec![(zeta, local.clone()), (zeta_next, next.clone())],\n            ));\n        }\n\n        coms_to_verify.push((global.commitment.clone(), pre_round));\n    }\n\n    if is_lookup {\n        let permutation_commit = commitments_targets\n            .permutation_targets\n            .clone()\n            .expect(\"We checked that the commitment exists\");\n\n        let mut permutation_round = Vec::with_capacity(ext_trace_domains.len());\n\n        for (i, ext_dom) in ext_trace_domains.iter().enumerate() {\n            let inst = \u0026instances[i];\n            let permutation_local = \u0026inst.permutation_local_targets;\n            let permutation_next = \u0026inst.permutation_next_targets;\n\n            if permutation_local.len() != permutation_next.len() {\n                return Err(VerificationError::InvalidProofShape(\n                    \"Mismatch between the lengths of permutation local and next opened values\"\n                        .to_string(),\n                ));\n            }\n\n            if !permutation_local.is_empty() {\n                let first_point = pcs.first_point(ext_dom);\n                let next_point = ext_dom.next_point(first_point).ok_or_else(|| {\n                    VerificationError::InvalidProofShape(\n                        \"Trace domain does not provide next point\".to_string(),\n                    )\n                })?;\n                let generator = next_point * first_point.inverse();\n                let generator_const = circuit.define_const(generator);\n                let zeta_next = circuit.mul(zeta, generator_const);\n\n                permutation_round.push((\n                    *ext_dom,\n                    vec![\n                        (zeta, permutation_local.clone()),\n                        (zeta_next, permutation_next.clone()),\n                    ],\n                ));\n            }\n        }\n\n        coms_to_verify.push((permutation_commit, permutation_round));\n    }\n\n    // Observe opened values in the correct order (matching native).\n    // Native observes per-instance: trace_local, trace_next, then quotient chunks,\n    // then preprocessed, then permutation.\n    // The flattened structure has the wrong order, so we observe from instances directly.\n    observe_opened_values_circuit::\u003cSC, WIDTH, RATE\u003e(\n        circuit,\n        \u0026mut challenger,\n        instances,\n        \u0026quotient_degrees,\n    );\n\n    let pcs_challenges = SC::Pcs::get_challenges_circuit::\u003cWIDTH, RATE\u003e(\n        circuit,\n        \u0026mut challenger,\n        \u0026proof_targets.opening_proof,\n        flattened,\n        pcs_params,\n    )?;\n\n    let mmcs_op_ids = pcs.verify_circuit::\u003cWIDTH, RATE\u003e(\n        circuit,\n        \u0026pcs_challenges,\n        \u0026mut challenger,\n        \u0026coms_to_verify,\n        opening_proof,\n        pcs_params,\n    )?;\n\n    // Verify AIR constraints per instance.\n    for i in 0..n_instances {\n        let air = \u0026airs[i];\n        let inst = \u0026instances[i];\n        let trace_domain = \u0026trace_domains[i];\n        let public_vals = \u0026public_values[i];\n        let domains = \u0026quotient_domains[i];\n\n        let quotient = recompose_quotient_from_chunks_circuit::\u003cSC, _, _, _, _\u003e(\n            circuit,\n            domains,\n            \u0026inst.opened_values_no_lookups.quotient_chunks_targets,\n            zeta,\n            pcs,\n        );\n\n        // Recompose permutation openings from base-flattened columns into extension field columns.\n        // The permutation commitment is a base-flattened matrix with `width = aux_width * DIMENSION`.\n        // For constraint evaluation, we need an extension field matrix with width `aux_width``.\n        let aux_width = all_lookups[i]\n            .iter()\n            .flat_map(|ctx| ctx.columns.iter().cloned())\n            .max()\n            .map(|m| m + 1)\n            .unwrap_or(0);\n\n        let recompose = |circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n                         flat: \u0026[Target]|\n         -\u003e Vec\u003cTarget\u003e {\n            if aux_width == 0 {\n                return vec![];\n            }\n            let ext_degree = SC::Challenge::DIMENSION;\n            debug_assert!(\n                flat.len() == aux_width * ext_degree,\n                \"flattened permutation opening length ({}) must equal aux_width ({}) * DIMENSION ({})\",\n                flat.len(),\n                aux_width,\n                ext_degree\n            );\n            // Chunk the flattened coefficients into groups of size `dim`.\n            // Each chunk represents the coefficients of one extension field element.\n            flat.chunks_exact(ext_degree)\n                .map(|coeffs| {\n                    let mut sum = circuit.define_const(SC::Challenge::ZERO);\n                    // Dot product: sum(coeff_j * basis_j)\n                    coeffs.iter().enumerate().for_each(|(j, \u0026coeff)| {\n                        let e_i = circuit.define_const(\n                            SC::Challenge::ith_basis_element(j)\n                                .expect(\"Basis element should exist\"),\n                        );\n                        let m = circuit.mul(coeff, e_i);\n                        sum = circuit.add(sum, m);\n                    });\n                    sum\n                })\n                .collect()\n        };\n\n        let local_permutation_values = recompose(circuit, \u0026inst.permutation_local_targets);\n        let next_permutation_values = recompose(circuit, \u0026inst.permutation_next_targets);\n\n        let local_prep_values = match inst\n            .opened_values_no_lookups\n            .preprocessed_local_targets\n            .as_ref()\n        {\n            Some(v) =\u003e v.as_slice(),\n            None =\u003e \u0026[],\n        };\n        let next_prep_values = match inst\n            .opened_values_no_lookups\n            .preprocessed_next_targets\n            .as_ref()\n        {\n            Some(v) =\u003e v.as_slice(),\n            None =\u003e \u0026[],\n        };\n\n        // Add the expected cumulated values to the public values, so that we can use them in the constraints.\n        let mut public_vals_with_expected_cumulated = public_vals.clone();\n        public_vals_with_expected_cumulated\n            .extend(global_lookup_data[i].iter().map(|ld| ld.expected_cumulated));\n        let sels = pcs.selectors_at_point_circuit(circuit, trace_domain, \u0026zeta);\n        let columns_targets = ColumnsTargets {\n            challenges: \u0026challenges_per_instance[i],\n            public_values: \u0026public_vals_with_expected_cumulated,\n            permutation_local_values: \u0026local_permutation_values,\n            permutation_next_values: \u0026next_permutation_values,\n            local_prep_values,\n            next_prep_values,\n            local_values: \u0026inst.opened_values_no_lookups.trace_local_targets,\n            next_values: \u0026inst.opened_values_no_lookups.trace_next_targets,\n        };\n\n        let lookup_metadata = LookupMetadata {\n            contexts: \u0026all_lookups[i],\n            lookup_data: \u0026lookup_data_to_pv_index(\u0026global_lookup_data[i], public_vals.len()),\n        };\n        let folded_constraints = air.eval_folded_circuit(\n            circuit,\n            \u0026sels,\n            \u0026alpha,\n            \u0026lookup_metadata,\n            columns_targets,\n            lookup_gadget,\n        );\n\n        let folded_mul = circuit.mul(folded_constraints, sels.inv_vanishing);\n        circuit.connect(folded_mul, quotient);\n\n        // Check that the global lookup cumulative values accumulate to the expected value.\n        let mut global_cumulative = HashMap::\u003c\u0026String, Vec\u003c_\u003e\u003e::new();\n        for data in global_lookup_data.iter().flatten() {\n            global_cumulative\n                .entry(\u0026data.name)\n                .or_default()\n                .push(data.expected_cumulated);\n        }\n\n        for all_expected_cumulative in global_cumulative.values() {\n            lookup_gadget.verify_global_final_value_circuit(circuit, all_expected_cumulative);\n        }\n    }\n\n    Ok(mmcs_op_ids)\n}\n\npub(crate) fn get_perm_challenges\u003c\n    SC: StarkGenericConfig,\n    const WIDTH: usize,\n    const RATE: usize,\n    LG: LookupGadget,\n\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    challenger: \u0026mut CircuitChallenger\u003cWIDTH, RATE\u003e,\n    all_lookups: \u0026[Vec\u003cLookup\u003cVal\u003cSC\u003e\u003e\u003e],\n    lookup_gadget: \u0026LG,\n) -\u003e Vec\u003cVec\u003cTarget\u003e\u003e\nwhere\n    Val\u003cSC\u003e: PrimeField64,\n    SC::Challenge: ExtensionField\u003cVal\u003cSC\u003e\u003e,\n{\n    let num_challenges_per_lookup = lookup_gadget.num_challenges();\n    let approx_global_names: usize = all_lookups.iter().map(|contexts| contexts.len()).sum();\n    let mut global_perm_challenges = HashMap::with_capacity(approx_global_names);\n\n    all_lookups\n        .iter()\n        .map(|contexts| {\n            // Pre-allocate for the instance's challenges.\n            let num_challenges = contexts.len() * num_challenges_per_lookup;\n            let mut instance_challenges = Vec::with_capacity(num_challenges);\n\n            for context in contexts {\n                match \u0026context.kind {\n                    Kind::Global(name) =\u003e {\n                        // Get or create the global challenges (extension field elements).\n                        let challenges: \u0026mut Vec\u003cTarget\u003e =\n                            global_perm_challenges.entry(name).or_insert_with(|| {\n                                (0..num_challenges_per_lookup)\n                                    .map(|_| challenger.sample_ext(circuit))\n                                    .collect()\n                            });\n                        instance_challenges.extend_from_slice(challenges);\n                    }\n                    Kind::Local =\u003e {\n                        // Local challenges are extension field elements.\n                        instance_challenges.extend(\n                            (0..num_challenges_per_lookup).map(|_| challenger.sample_ext(circuit)),\n                        );\n                    }\n                }\n            }\n            instance_challenges\n        })\n        .collect()\n}\n\nfn lookup_data_to_pv_index(\n    global_lookup_data: \u0026[LookupData\u003cTarget\u003e],\n    public_values_len: usize,\n) -\u003e Vec\u003cLookupData\u003cusize\u003e\u003e {\n    global_lookup_data\n        .iter()\n        .enumerate()\n        .map(|(index, ld)| LookupData {\n            name: ld.name.clone(),\n            aux_idx: ld.aux_idx,\n            expected_cumulated: public_values_len + index,\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n}\n\n/// Observe opened values in the circuit in the correct order to match native.\n///\n/// Native observes opened values in this order:\n/// 1. Trace round: for each instance, observe trace_local then trace_next\n/// 2. Quotient round: for each instance, for each chunk, observe quotient\n/// 3. Preprocessed round: for each instance, observe prep_local then prep_next\n/// 4. Permutation round: for each instance, observe perm_local then perm_next\nfn observe_opened_values_circuit\u003cSC, const WIDTH: usize, const RATE: usize\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    challenger: \u0026mut CircuitChallenger\u003cWIDTH, RATE\u003e,\n    instances: \u0026[OpenedValuesTargetsWithLookups\u003cSC\u003e],\n    quotient_degrees: \u0026[usize],\n) where\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: PrimeField64,\n    SC::Challenge: ExtensionField\u003cVal\u003cSC\u003e\u003e,\n{\n    // 1. Trace round: for each instance, observe trace_local then trace_next\n    for inst in instances {\n        challenger.observe_ext_slice(circuit, \u0026inst.opened_values_no_lookups.trace_local_targets);\n        challenger.observe_ext_slice(circuit, \u0026inst.opened_values_no_lookups.trace_next_targets);\n    }\n\n    // 2. Quotient round: for each instance, for each chunk, observe quotient\n    for (inst, \u0026qd) in instances.iter().zip(quotient_degrees.iter()) {\n        for chunk_values in inst\n            .opened_values_no_lookups\n            .quotient_chunks_targets\n            .iter()\n            .take(qd)\n        {\n            challenger.observe_ext_slice(circuit, chunk_values);\n        }\n    }\n\n    // 3. Preprocessed round: for each instance, observe prep_local then prep_next\n    for inst in instances {\n        if let Some(prep_local) = \u0026inst.opened_values_no_lookups.preprocessed_local_targets {\n            challenger.observe_ext_slice(circuit, prep_local);\n        }\n        if let Some(prep_next) = \u0026inst.opened_values_no_lookups.preprocessed_next_targets {\n            challenger.observe_ext_slice(circuit, prep_next);\n        }\n    }\n\n    // 4. Permutation round: for each instance, observe perm_local then perm_next\n    for inst in instances {\n        if !inst.permutation_local_targets.is_empty() {\n            challenger.observe_ext_slice(circuit, \u0026inst.permutation_local_targets);\n        }\n        if !inst.permutation_next_targets.is_empty() {\n            challenger.observe_ext_slice(circuit, \u0026inst.permutation_next_targets);\n        }\n    }\n}\n","traces":[{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":5}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[4084213],"length":1,"stats":{"Line":3}},{"line":64,"address":[7062590],"length":1,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[3371304],"length":1,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[4127831],"length":1,"stats":{"Line":5}},{"line":82,"address":[7171825],"length":1,"stats":{"Line":5}},{"line":83,"address":[7171851],"length":1,"stats":{"Line":5}},{"line":84,"address":[7171873],"length":1,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[4092672],"length":1,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[7121887],"length":1,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[7121904],"length":1,"stats":{"Line":0}},{"line":152,"address":[3325620],"length":1,"stats":{"Line":0}},{"line":162,"address":[3325629],"length":1,"stats":{"Line":0}},{"line":164,"address":[4092839],"length":1,"stats":{"Line":0}},{"line":165,"address":[3325733],"length":1,"stats":{"Line":0}},{"line":167,"address":[4092867],"length":1,"stats":{"Line":0}},{"line":169,"address":[7122091],"length":1,"stats":{"Line":0}},{"line":170,"address":[7122062],"length":1,"stats":{"Line":0}},{"line":172,"address":[3325835],"length":1,"stats":{"Line":0}},{"line":176,"address":[3325819],"length":1,"stats":{"Line":0}},{"line":179,"address":[7121925],"length":1,"stats":{"Line":0}},{"line":189,"address":[3358401,3355264,3358275],"length":1,"stats":{"Line":4}},{"line":230,"address":[],"length":0,"stats":{"Line":3}},{"line":231,"address":[4122654],"length":1,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":3}},{"line":233,"address":[7151974],"length":1,"stats":{"Line":4}},{"line":234,"address":[3355748],"length":1,"stats":{"Line":3}},{"line":235,"address":[4122962],"length":1,"stats":{"Line":3}},{"line":241,"address":[7152267],"length":1,"stats":{"Line":3}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":247,"address":[3356693,3358396,3356153,3356037,3356101,3356348,3356519],"length":1,"stats":{"Line":10}},{"line":248,"address":[7152532],"length":1,"stats":{"Line":3}},{"line":249,"address":[3356109,3356201],"length":1,"stats":{"Line":7}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[7152719],"length":1,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":7}},{"line":255,"address":[4123698],"length":1,"stats":{"Line":3}},{"line":256,"address":[],"length":0,"stats":{"Line":7}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[3356633],"length":1,"stats":{"Line":4}},{"line":263,"address":[4124165,4124251],"length":1,"stats":{"Line":7}},{"line":264,"address":[7153561],"length":1,"stats":{"Line":0}},{"line":265,"address":[3358293],"length":1,"stats":{"Line":0}},{"line":266,"address":[3358334],"length":1,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[7153597],"length":1,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":4}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[3357485],"length":1,"stats":{"Line":3}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[7153894],"length":1,"stats":{"Line":4}},{"line":301,"address":[4124715],"length":1,"stats":{"Line":3}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[3358065],"length":1,"stats":{"Line":5}},{"line":319,"address":[3884855,3861552,3865005],"length":1,"stats":{"Line":6}},{"line":356,"address":[3327384],"length":1,"stats":{"Line":4}},{"line":357,"address":[4094544],"length":1,"stats":{"Line":5}},{"line":358,"address":[4094552],"length":1,"stats":{"Line":4}},{"line":359,"address":[3861919],"length":1,"stats":{"Line":5}},{"line":360,"address":[],"length":0,"stats":{"Line":4}},{"line":361,"address":[],"length":0,"stats":{"Line":5}},{"line":362,"address":[4094653],"length":1,"stats":{"Line":4}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":5}},{"line":367,"address":[3327563],"length":1,"stats":{"Line":4}},{"line":368,"address":[3327701],"length":1,"stats":{"Line":5}},{"line":369,"address":[7124067],"length":1,"stats":{"Line":0}},{"line":370,"address":[3327745],"length":1,"stats":{"Line":0}},{"line":374,"address":[3862182],"length":1,"stats":{"Line":4}},{"line":375,"address":[7124172],"length":1,"stats":{"Line":5}},{"line":376,"address":[3862482],"length":1,"stats":{"Line":4}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[7124177],"length":1,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":5}},{"line":385,"address":[4095194],"length":1,"stats":{"Line":4}},{"line":387,"address":[7124393],"length":1,"stats":{"Line":5}},{"line":388,"address":[3328204],"length":1,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":4}},{"line":396,"address":[],"length":0,"stats":{"Line":5}},{"line":397,"address":[4095281],"length":1,"stats":{"Line":4}},{"line":398,"address":[4095473],"length":1,"stats":{"Line":5}},{"line":399,"address":[4095828],"length":1,"stats":{"Line":4}},{"line":400,"address":[3862881],"length":1,"stats":{"Line":4}},{"line":401,"address":[3328521],"length":1,"stats":{"Line":5}},{"line":402,"address":[4095782],"length":1,"stats":{"Line":4}},{"line":403,"address":[],"length":0,"stats":{"Line":5}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[3863359],"length":1,"stats":{"Line":6}},{"line":407,"address":[3863367],"length":1,"stats":{"Line":4}},{"line":408,"address":[3863390],"length":1,"stats":{"Line":5}},{"line":409,"address":[3863413],"length":1,"stats":{"Line":4}},{"line":410,"address":[4096092],"length":1,"stats":{"Line":6}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[4114766,4096112],"length":1,"stats":{"Line":8}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[3882038,3886400,3887904,3887909,3886425],"length":1,"stats":{"Line":26}},{"line":419,"address":[],"length":0,"stats":{"Line":6}},{"line":421,"address":[3887177,3882151,3887168],"length":1,"stats":{"Line":14}},{"line":422,"address":[7147008,7147017,7144066],"length":1,"stats":{"Line":16}},{"line":423,"address":[3882275],"length":1,"stats":{"Line":4}},{"line":424,"address":[4117192,4114977],"length":1,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[7144246],"length":1,"stats":{"Line":6}},{"line":429,"address":[3882436,3882526],"length":1,"stats":{"Line":10}},{"line":430,"address":[3884188],"length":1,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[3348038,3349685],"length":1,"stats":{"Line":0}},{"line":434,"address":[3884155],"length":1,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[4115202,4115351],"length":1,"stats":{"Line":6}},{"line":442,"address":[3348201,3348260],"length":1,"stats":{"Line":10}},{"line":443,"address":[3882785],"length":1,"stats":{"Line":4}},{"line":444,"address":[4115717],"length":1,"stats":{"Line":5}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":5}},{"line":449,"address":[],"length":0,"stats":{"Line":10}},{"line":450,"address":[4116510],"length":1,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[4116090,4116494],"length":1,"stats":{"Line":0}},{"line":457,"address":[3883532,3883493,3883401],"length":1,"stats":{"Line":15}},{"line":459,"address":[7145366,7147344,7147369],"length":1,"stats":{"Line":15}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[4116204],"length":1,"stats":{"Line":4}},{"line":468,"address":[7145448],"length":1,"stats":{"Line":6}},{"line":474,"address":[4096141],"length":1,"stats":{"Line":4}},{"line":475,"address":[3863574],"length":1,"stats":{"Line":4}},{"line":476,"address":[],"length":0,"stats":{"Line":6}},{"line":479,"address":[3329174],"length":1,"stats":{"Line":4}},{"line":481,"address":[],"length":0,"stats":{"Line":10}},{"line":482,"address":[3329228],"length":1,"stats":{"Line":5}},{"line":483,"address":[7125586],"length":1,"stats":{"Line":5}},{"line":484,"address":[7125715],"length":1,"stats":{"Line":5}},{"line":486,"address":[3881995,3864136,3884976,3881209,3881415],"length":1,"stats":{"Line":10}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[3881544],"length":1,"stats":{"Line":5}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[7143472],"length":1,"stats":{"Line":5}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[3881694],"length":1,"stats":{"Line":5}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":7}},{"line":498,"address":[3347334],"length":1,"stats":{"Line":5}},{"line":504,"address":[],"length":0,"stats":{"Line":5}},{"line":505,"address":[3881923],"length":1,"stats":{"Line":4}},{"line":506,"address":[3881953],"length":1,"stats":{"Line":6}},{"line":507,"address":[3347521],"length":1,"stats":{"Line":4}},{"line":510,"address":[3864284],"length":1,"stats":{"Line":5}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":6}},{"line":514,"address":[4096982],"length":1,"stats":{"Line":5}},{"line":515,"address":[3881181,3864467],"length":1,"stats":{"Line":12}},{"line":521,"address":[7126328],"length":1,"stats":{"Line":7}},{"line":522,"address":[],"length":0,"stats":{"Line":14}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[7142986],"length":1,"stats":{"Line":7}},{"line":526,"address":[],"length":0,"stats":{"Line":7}},{"line":527,"address":[3864833,3864877],"length":1,"stats":{"Line":12}},{"line":531,"address":[7126675,7126853],"length":1,"stats":{"Line":12}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[3885193,3885168,3865035],"length":1,"stats":{"Line":14}},{"line":536,"address":[3880976],"length":1,"stats":{"Line":1}},{"line":537,"address":[7127034],"length":1,"stats":{"Line":1}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[3330720],"length":1,"stats":{"Line":5}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[4097955],"length":1,"stats":{"Line":5}},{"line":551,"address":[7127442],"length":1,"stats":{"Line":3}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[7127346,7127177],"length":1,"stats":{"Line":8}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[3330894],"length":1,"stats":{"Line":3}},{"line":556,"address":[4098061],"length":1,"stats":{"Line":4}},{"line":557,"address":[],"length":0,"stats":{"Line":3}},{"line":562,"address":[3330857,3331206],"length":1,"stats":{"Line":9}},{"line":564,"address":[3331339],"length":1,"stats":{"Line":5}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[7127535,7127508],"length":1,"stats":{"Line":8}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":5}},{"line":571,"address":[],"length":0,"stats":{"Line":4}},{"line":574,"address":[3865889],"length":1,"stats":{"Line":5}},{"line":575,"address":[3331448],"length":1,"stats":{"Line":4}},{"line":576,"address":[4098623,4098699],"length":1,"stats":{"Line":12}},{"line":577,"address":[3880758,3880715,3866168],"length":1,"stats":{"Line":12}},{"line":578,"address":[3880750,3880795],"length":1,"stats":{"Line":12}},{"line":579,"address":[4113530],"length":1,"stats":{"Line":6}},{"line":585,"address":[3331735],"length":1,"stats":{"Line":6}},{"line":587,"address":[4113292,4098870,4099375,4099239],"length":1,"stats":{"Line":12}},{"line":589,"address":[3866356],"length":1,"stats":{"Line":6}},{"line":590,"address":[3885272,3885216,3866481,3886309,3886303],"length":1,"stats":{"Line":18}},{"line":591,"address":[],"length":0,"stats":{"Line":6}},{"line":592,"address":[7149920,7147482,7147625],"length":1,"stats":{"Line":6}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[3888078],"length":1,"stats":{"Line":0}},{"line":597,"address":[4118880],"length":1,"stats":{"Line":6}},{"line":598,"address":[],"length":0,"stats":{"Line":6}},{"line":599,"address":[3885635],"length":1,"stats":{"Line":6}},{"line":600,"address":[4119499],"length":1,"stats":{"Line":6}},{"line":601,"address":[7147846],"length":1,"stats":{"Line":6}},{"line":602,"address":[],"length":0,"stats":{"Line":12}},{"line":604,"address":[3351493],"length":1,"stats":{"Line":6}},{"line":605,"address":[3351503],"length":1,"stats":{"Line":6}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[7148010],"length":1,"stats":{"Line":6}},{"line":615,"address":[7128743,7128791],"length":1,"stats":{"Line":12}},{"line":617,"address":[7128926],"length":1,"stats":{"Line":6}},{"line":619,"address":[],"length":0,"stats":{"Line":6}},{"line":620,"address":[3332854],"length":1,"stats":{"Line":6}},{"line":621,"address":[4117931,4100103,4117904],"length":1,"stats":{"Line":18}},{"line":622,"address":[7149370,7149438],"length":1,"stats":{"Line":6}},{"line":623,"address":[3887711,3887568,3887532],"length":1,"stats":{"Line":12}},{"line":624,"address":[3887728,3887793,3887678],"length":1,"stats":{"Line":12}},{"line":628,"address":[],"length":0,"stats":{"Line":18}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[3867776,3867696],"length":1,"stats":{"Line":9}},{"line":631,"address":[3333675,3345087],"length":1,"stats":{"Line":9}},{"line":632,"address":[3345986],"length":1,"stats":{"Line":0}},{"line":633,"address":[3879620],"length":1,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":9}},{"line":637,"address":[4112324],"length":1,"stats":{"Line":5}},{"line":638,"address":[3879729],"length":1,"stats":{"Line":4}},{"line":640,"address":[],"length":0,"stats":{"Line":4}},{"line":643,"address":[],"length":0,"stats":{"Line":5}},{"line":644,"address":[7129996],"length":1,"stats":{"Line":5}},{"line":645,"address":[],"length":0,"stats":{"Line":4}},{"line":648,"address":[3869014,3868319],"length":1,"stats":{"Line":9}},{"line":649,"address":[3868383,3868438],"length":1,"stats":{"Line":10}},{"line":651,"address":[3868461,3868545],"length":1,"stats":{"Line":9}},{"line":652,"address":[],"length":0,"stats":{"Line":9}},{"line":653,"address":[3869038],"length":1,"stats":{"Line":4}},{"line":654,"address":[3337254],"length":1,"stats":{"Line":0}},{"line":655,"address":[7130913],"length":1,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":9}},{"line":660,"address":[3869322,3869186,3869128,3871708],"length":1,"stats":{"Line":10}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[7130998,7146736],"length":1,"stats":{"Line":4}},{"line":665,"address":[4117726],"length":1,"stats":{"Line":0}},{"line":666,"address":[7146750],"length":1,"stats":{"Line":0}},{"line":669,"address":[3335053,3337242,3335189,3334995],"length":1,"stats":{"Line":8}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[3335030,3352112],"length":1,"stats":{"Line":5}},{"line":674,"address":[3887854],"length":1,"stats":{"Line":0}},{"line":675,"address":[7149118],"length":1,"stats":{"Line":0}},{"line":679,"address":[3869798],"length":1,"stats":{"Line":5}},{"line":680,"address":[7131690,7131798],"length":1,"stats":{"Line":4}},{"line":682,"address":[3335473,3337240,3335717,3335581],"length":1,"stats":{"Line":10}},{"line":684,"address":[7131857,7147072],"length":1,"stats":{"Line":4}},{"line":685,"address":[3887038],"length":1,"stats":{"Line":0}},{"line":686,"address":[3352718],"length":1,"stats":{"Line":0}},{"line":689,"address":[4102974],"length":1,"stats":{"Line":4}},{"line":690,"address":[7133457],"length":1,"stats":{"Line":0}},{"line":691,"address":[3870345],"length":1,"stats":{"Line":0}},{"line":696,"address":[4103039],"length":1,"stats":{"Line":5}},{"line":699,"address":[],"length":0,"stats":{"Line":4}},{"line":700,"address":[],"length":0,"stats":{"Line":5}},{"line":701,"address":[3871590,3870548,3885072,3870762],"length":1,"stats":{"Line":4}},{"line":702,"address":[3352894],"length":1,"stats":{"Line":0}},{"line":703,"address":[4119694],"length":1,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":5}},{"line":707,"address":[7132800],"length":1,"stats":{"Line":4}},{"line":708,"address":[3871021],"length":1,"stats":{"Line":5}},{"line":710,"address":[3337045],"length":1,"stats":{"Line":5}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[7132905,7133424],"length":1,"stats":{"Line":4}},{"line":716,"address":[3868872],"length":1,"stats":{"Line":4}},{"line":719,"address":[3333945,3338154],"length":1,"stats":{"Line":8}},{"line":720,"address":[7133733],"length":1,"stats":{"Line":4}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[7133810,7133882],"length":1,"stats":{"Line":7}},{"line":727,"address":[],"length":0,"stats":{"Line":7}},{"line":728,"address":[4110732,4105066],"length":1,"stats":{"Line":7}},{"line":729,"address":[3343620],"length":1,"stats":{"Line":3}},{"line":730,"address":[3878108],"length":1,"stats":{"Line":4}},{"line":732,"address":[7139971],"length":1,"stats":{"Line":3}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[4110869],"length":1,"stats":{"Line":0}},{"line":739,"address":[7140038,7140093],"length":1,"stats":{"Line":7}},{"line":740,"address":[3343820],"length":1,"stats":{"Line":4}},{"line":741,"address":[3878297,3879358,3887200,3878511],"length":1,"stats":{"Line":3}},{"line":742,"address":[3887246],"length":1,"stats":{"Line":0}},{"line":743,"address":[3887214],"length":1,"stats":{"Line":0}},{"line":746,"address":[3344186],"length":1,"stats":{"Line":4}},{"line":747,"address":[4111368],"length":1,"stats":{"Line":3}},{"line":748,"address":[3878770],"length":1,"stats":{"Line":4}},{"line":750,"address":[],"length":0,"stats":{"Line":4}},{"line":751,"address":[4111471],"length":1,"stats":{"Line":3}},{"line":752,"address":[7141198,7140679,7140949,7140858,7140745],"length":1,"stats":{"Line":7}},{"line":753,"address":[4111531,4111598],"length":1,"stats":{"Line":7}},{"line":754,"address":[4111707,4111644],"length":1,"stats":{"Line":7}},{"line":760,"address":[],"length":0,"stats":{"Line":3}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":4}},{"line":771,"address":[3338199],"length":1,"stats":{"Line":5}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[4105429],"length":1,"stats":{"Line":4}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[3339013,3338820],"length":1,"stats":{"Line":4}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[3873090],"length":1,"stats":{"Line":6}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[3873197],"length":1,"stats":{"Line":5}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[3339190,3339277],"length":1,"stats":{"Line":9}},{"line":793,"address":[3339406,3339724,3339788],"length":1,"stats":{"Line":9}},{"line":794,"address":[4106870,4106945],"length":1,"stats":{"Line":8}},{"line":795,"address":[3339833],"length":1,"stats":{"Line":5}},{"line":796,"address":[4107106,4107015],"length":1,"stats":{"Line":5}},{"line":797,"address":[],"length":0,"stats":{"Line":9}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[3874485],"length":1,"stats":{"Line":4}},{"line":802,"address":[7136389],"length":1,"stats":{"Line":5}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[3340467,3340219],"length":1,"stats":{"Line":10}},{"line":812,"address":[3352569,3340335,3352544],"length":1,"stats":{"Line":13}},{"line":814,"address":[3886336,3886348,3874851],"length":1,"stats":{"Line":11}},{"line":817,"address":[3874945,3886480],"length":1,"stats":{"Line":8}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[7148693],"length":1,"stats":{"Line":5}},{"line":821,"address":[3350535],"length":1,"stats":{"Line":1}},{"line":823,"address":[4120163],"length":1,"stats":{"Line":3}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[7149016],"length":1,"stats":{"Line":4}},{"line":834,"address":[3353552,3350838],"length":1,"stats":{"Line":7}},{"line":835,"address":[],"length":0,"stats":{"Line":4}},{"line":837,"address":[7149845,7150016,7150040],"length":1,"stats":{"Line":10}},{"line":838,"address":[4120855,4120912],"length":1,"stats":{"Line":7}},{"line":839,"address":[4120863],"length":1,"stats":{"Line":4}},{"line":840,"address":[7150073],"length":1,"stats":{"Line":3}},{"line":842,"address":[7150137],"length":1,"stats":{"Line":3}},{"line":843,"address":[7150156],"length":1,"stats":{"Line":4}},{"line":845,"address":[4120686],"length":1,"stats":{"Line":3}},{"line":850,"address":[3874953],"length":1,"stats":{"Line":5}},{"line":851,"address":[4107744,4107842],"length":1,"stats":{"Line":9}},{"line":853,"address":[3875263,3875334],"length":1,"stats":{"Line":10}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[4107925],"length":1,"stats":{"Line":4}},{"line":858,"address":[3875480,3875373],"length":1,"stats":{"Line":9}},{"line":859,"address":[],"length":0,"stats":{"Line":1}},{"line":861,"address":[],"length":0,"stats":{"Line":8}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[3875449],"length":1,"stats":{"Line":5}},{"line":866,"address":[],"length":0,"stats":{"Line":9}},{"line":867,"address":[3341122],"length":1,"stats":{"Line":1}},{"line":871,"address":[],"length":0,"stats":{"Line":5}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[3341298,3341224,3352944,3352954],"length":1,"stats":{"Line":16}},{"line":874,"address":[3875936],"length":1,"stats":{"Line":4}},{"line":876,"address":[3341489],"length":1,"stats":{"Line":5}},{"line":877,"address":[7137893],"length":1,"stats":{"Line":4}},{"line":878,"address":[4108773],"length":1,"stats":{"Line":5}},{"line":879,"address":[],"length":0,"stats":{"Line":4}},{"line":882,"address":[7138146],"length":1,"stats":{"Line":5}},{"line":883,"address":[],"length":0,"stats":{"Line":4}},{"line":887,"address":[4109325],"length":1,"stats":{"Line":5}},{"line":888,"address":[7138609],"length":1,"stats":{"Line":4}},{"line":890,"address":[3342620],"length":1,"stats":{"Line":6}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[3342822],"length":1,"stats":{"Line":5}},{"line":900,"address":[3877334],"length":1,"stats":{"Line":5}},{"line":903,"address":[3342887],"length":1,"stats":{"Line":5}},{"line":904,"address":[4110022,4110101],"length":1,"stats":{"Line":10}},{"line":905,"address":[],"length":0,"stats":{"Line":4}},{"line":906,"address":[7139497],"length":1,"stats":{"Line":4}},{"line":908,"address":[7139865],"length":1,"stats":{"Line":4}},{"line":911,"address":[3877682],"length":1,"stats":{"Line":4}},{"line":912,"address":[7139665,7139814],"length":1,"stats":{"Line":8}},{"line":916,"address":[3873892],"length":1,"stats":{"Line":4}},{"line":919,"address":[4092992,4093338,4093344],"length":1,"stats":{"Line":4}},{"line":934,"address":[3860425],"length":1,"stats":{"Line":5}},{"line":935,"address":[3326864,3325985,3326889],"length":1,"stats":{"Line":13}},{"line":936,"address":[7122316],"length":1,"stats":{"Line":5}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[3326830,3326240,3326836,3326121],"length":1,"stats":{"Line":9}},{"line":942,"address":[],"length":0,"stats":{"Line":6}},{"line":943,"address":[3860847],"length":1,"stats":{"Line":6}},{"line":945,"address":[3326426,3326345],"length":1,"stats":{"Line":12}},{"line":946,"address":[3326516],"length":1,"stats":{"Line":5}},{"line":947,"address":[],"length":0,"stats":{"Line":5}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":15}},{"line":951,"address":[],"length":0,"stats":{"Line":5}},{"line":952,"address":[3861504,3861444,3861521],"length":1,"stats":{"Line":13}},{"line":953,"address":[],"length":0,"stats":{"Line":3}},{"line":955,"address":[4093956],"length":1,"stats":{"Line":4}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[3861207],"length":1,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[4093741],"length":1,"stats":{"Line":4}},{"line":970,"address":[2100096],"length":1,"stats":{"Line":5}},{"line":977,"address":[6362339,6362236,6362096,6362150,6362041,6362333],"length":1,"stats":{"Line":17}},{"line":978,"address":[6508608],"length":1,"stats":{"Line":4}},{"line":979,"address":[6895338],"length":1,"stats":{"Line":4}},{"line":980,"address":[2100323,2100406],"length":1,"stats":{"Line":4}},{"line":992,"address":[7150192],"length":1,"stats":{"Line":4}},{"line":1003,"address":[4121154,4121133],"length":1,"stats":{"Line":9}},{"line":1004,"address":[7150427],"length":1,"stats":{"Line":5}},{"line":1005,"address":[4121271],"length":1,"stats":{"Line":4}},{"line":1009,"address":[4121448,4121335],"length":1,"stats":{"Line":9}},{"line":1010,"address":[7150752,7150793,7151462],"length":1,"stats":{"Line":18}},{"line":1011,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":6}},{"line":1014,"address":[4121580],"length":1,"stats":{"Line":6}},{"line":1016,"address":[4122334],"length":1,"stats":{"Line":6}},{"line":1021,"address":[3354563,3354584],"length":1,"stats":{"Line":12}},{"line":1022,"address":[3889121,3889448],"length":1,"stats":{"Line":12}},{"line":1023,"address":[3354992],"length":1,"stats":{"Line":6}},{"line":1025,"address":[4122156],"length":1,"stats":{"Line":6}},{"line":1026,"address":[],"length":0,"stats":{"Line":6}},{"line":1031,"address":[7151068,7151047],"length":1,"stats":{"Line":10}},{"line":1032,"address":[3889285],"length":1,"stats":{"Line":4}},{"line":1033,"address":[3354852],"length":1,"stats":{"Line":4}},{"line":1035,"address":[3889367],"length":1,"stats":{"Line":5}},{"line":1036,"address":[3889392],"length":1,"stats":{"Line":3}}],"covered":318,"coverable":481},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","errors.rs"],"content":"//! Error types for recursive verification.\n\nuse alloc::string::String;\n\nuse p3_circuit::{CircuitBuilderError, CircuitError};\nuse thiserror::Error;\n\nuse crate::generation::GenerationError;\n\n/// Errors that can occur during recursive STARK verification.\n#[derive(Debug, Error)]\npub enum VerificationError {\n    /// The proof structure is invalid (wrong dimensions, missing data, etc.)\n    #[error(\"Invalid proof shape: {0}\")]\n    InvalidProofShape(String),\n\n    /// ZK randomization is inconsistent (random commitment exists but no opened values)\n    #[error(\"Missing random opened values for existing random commitment\")]\n    RandomizationError,\n\n    /// Error from the circuit execution layer\n    #[error(\"Circuit error: {0}\")]\n    Circuit(#[from] CircuitError),\n\n    /// Error from the circuit builder layer\n    #[error(\"Circuit builder error: {0}\")]\n    CircuitBuilder(#[from] CircuitBuilderError),\n\n    /// Error from challenge generation\n    #[error(\"Generation error: {0}\")]\n    Generation(#[from] GenerationError),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","mod.rs"],"content":"//! STARK verification within recursive circuits.\n\nmod batch_stark;\nmod errors;\nmod observable;\nmod quotient;\nmod stark;\n\npub use batch_stark::{\n    CircuitTablesAir, PcsVerifierParams, verify_batch_circuit, verify_p3_batch_proof_circuit,\n};\npub use errors::VerificationError;\npub use observable::ObservableCommitment;\npub use quotient::recompose_quotient_from_chunks_circuit;\npub use stark::verify_p3_uni_proof_circuit;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","observable.rs"],"content":"use alloc::vec;\nuse alloc::vec::Vec;\n\nuse crate::Target;\n\n/// Trait for extracting commitment targets for Fiat-Shamir observation.\n///\n/// This trait allows commitments to be observed in the Fiat-Shamir transcript\n/// without the verifier needing to know the specific commitment structure.\npub trait ObservableCommitment {\n    /// Extract the targets that should be observed in the Fiat-Shamir transcript.\n    ///\n    /// These targets represent the commitment in a form suitable for hashing\n    /// into the challenger state.\n    ///\n    /// # Returns\n    /// A vector of targets representing the commitment\n    fn to_observation_targets(\u0026self) -\u003e Vec\u003cTarget\u003e;\n}\n\n/// Implementation for a single target (used in tests where commitment is a placeholder).\nimpl ObservableCommitment for Target {\n    fn to_observation_targets(\u0026self) -\u003e Vec\u003cTarget\u003e {\n        vec![*self]\n    }\n}\n","traces":[{"line":23,"address":[4609472],"length":1,"stats":{"Line":0}},{"line":24,"address":[4609617,4609496],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","quotient.rs"],"content":"//! Quotient polynomial recomposition for recursive STARK verification.\n\nuse alloc::vec::Vec;\n\nuse itertools::Itertools;\nuse p3_circuit::CircuitBuilder;\nuse p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing};\nuse p3_uni_stark::StarkGenericConfig;\n\nuse crate::Target;\nuse crate::traits::{Recursive, RecursivePcs};\n\n/// Reconstructs the quotient polynomial evaluation `Q(ζ)` from opened chunks.\n///\n/// # Mathematical Background\n///\n/// When the quotient polynomial `Q(X)` is split into chunks `Q_i(X)` over disjoint domains\n/// `D_i`, we reconstruct `Q(ζ)` at an out-of-domain point using:\n///\n/// ```text\n/// Q(ζ) = ∑_i Q_i(·) · L_i(ζ)\n/// ```\n///\n/// where `L_i(ζ)` is the Lagrange interpolation coefficient:\n///\n/// ```text\n/// L_i(ζ) = ∏_{j≠i} [Z_j(ζ) / Z_j(g_i)]\n/// ```\n///\n/// Here:\n/// - `Z_j(X) = (X/g_j)^|D_j| - 1` is the vanishing polynomial for domain `D_j`\n/// - `g_i` is the first point (generator) of domain `D_i`\n/// - `Q_i(·)` is evaluated in the extension field basis\n///\n/// # Optimization: Constant Pre-computation\n///\n/// The critical insight is that `Z_j(g_i)` values are **field constants** that can be computed\n/// outside the circuit! This allows us to restructure the computation as:\n///\n/// ```text\n/// L_i(ζ) = [∏_j Z_j(ζ) / Z_i(ζ)] · [1 / ∏_{j≠i} Z_j(g_i)]\n///          └─────────────────────┘   └────────────────────┘\n///            computed in-circuit      pre-computed constant\n/// ```\n///\n/// This transforms the denominator from O(N^2) in-circuit operations to O(N^2) native field\n/// operations.\n///\n/// # Arguments\n///\n/// * `circuit` - The circuit builder for adding verification constraints.\n/// * `quotient_chunks_domains` - Domains `[D_0, ..., D_{n-1}]` for each chunk.\n/// * `quotient_chunks` - Coefficient vectors for each chunk in extension field basis.\n/// * `zeta` - The out-of-domain evaluation point `ζ`.\n/// * `pcs` - The polynomial commitment scheme providing domain operations.\n///\n/// # Returns\n///\n/// A `Target` representing the circuit variable for `Q(ζ)`.\npub fn recompose_quotient_from_chunks_circuit\u003c\n    SC: StarkGenericConfig,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    Domain: Copy,\n\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    quotient_chunks_domains: \u0026[Domain],\n    quotient_chunks: \u0026[Vec\u003cTarget\u003e],\n    zeta: Target,\n    pcs: \u0026SC::Pcs,\n) -\u003e Target\nwhere\n    SC::Pcs: RecursivePcs\u003cSC, InputProof, OpeningProof, Comm, Domain\u003e,\n    SC::Challenge: PrimeCharacteristicRing,\n{\n    // Compute the Lagrange interpolation coefficients.\n    let zps = compute_quotient_chunk_products::\u003cSC, _, _, _, _\u003e(\n        circuit,\n        quotient_chunks_domains,\n        zeta,\n        pcs,\n    );\n\n    // Combine chunk evaluations with their interpolation coefficients.\n    compute_quotient_evaluation::\u003cSC\u003e(circuit, quotient_chunks, \u0026zps)\n}\n\n/// Computes a vanishing polynomial evaluation as a **native field operation** (outside the circuit).\n///\n/// This helper function evaluates `Z_H(point) = (point/g)^|H| - 1` for a domain `H` as a\n/// regular field computation, producing a constant that can be embedded in the circuit.\n///\n/// # Explainer\n///\n/// When computing Lagrange interpolation coefficients `L_i(ζ) = ∏_{j≠i} [Z_j(ζ) / Z_j(g_i)]`,\n/// the denominator terms `Z_j(g_i)` are **field constants** (not dependent on witness values).\n/// By computing them natively, we:\n///\n/// 1. **Eliminate circuit operations**: No constraints needed for these evaluations\n/// 2. **Reduce proof size**: Fewer gates and witness elements\n/// 3. **Improve verification time**: Fewer operations to verify\n///\n/// This single optimization transforms O(N^2·log|D|) circuit operations into O(N^2·log|D|)\n/// native operations that are \"free\" from the circuit's perspective.\n///\n/// # Mathematical Formula\n///\n/// For a multiplicative coset `H = {g, gω, ..., gω^(n-1)}`:\n///\n/// ```text\n/// Z_H(point) = (point/g)^n - 1\n/// ```\n///\n/// where `n = |H|` and `g` is the coset generator.\n///\n/// # Arguments\n///\n/// * `pcs` - PCS providing domain metadata (generator and size).\n/// * `domain` - The domain `H` for which to compute the vanishing polynomial.\n/// * `point` - The evaluation point.\n///\n/// # Returns\n///\n/// The field element `Z_H(point)`.\nfn vanishing_poly_at_point_native\u003c\n    SC: StarkGenericConfig,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    Domain,\n\u003e(\n    pcs: \u0026SC::Pcs,\n    domain: \u0026Domain,\n    point: SC::Challenge,\n) -\u003e SC::Challenge\nwhere\n    SC::Pcs: RecursivePcs\u003cSC, InputProof, OpeningProof, Comm, Domain\u003e,\n{\n    // Normalize: compute point/g where g is the coset generator\n    let normalized = point * pcs.first_point(domain).inverse();\n\n    // Exponentiate: compute (point/g)^n where n = 2^(log_size)\n    let power = normalized.exp_power_of_2(pcs.log_size(domain));\n\n    // Subtract: Z_H(point) = (point/g)^n - 1\n    power - SC::Challenge::ONE\n}\n\n/// Computes Lagrange interpolation coefficients with O(N) in-circuit complexity.\n///\n/// This function computes the product terms needed for Lagrange interpolation:\n///\n/// ```text\n/// L_i(ζ) = [∏_j Z_j(ζ) / Z_i(ζ)] · [1 / ∏_{j≠i} Z_j(g_i)]\n/// ```\n///\n/// We split this into two parts:\n/// 1. **In-circuit numerator**: `∏_j Z_j(ζ) / Z_i(ζ)` - computed using total product\n/// 2. **Pre-computed denominator**: `1 / ∏_{j≠i} Z_j(g_i)` - computed as native field constant\n///\n/// # Arguments\n///\n/// * `circuit` - The circuit builder.\n/// * `quotient_chunks_domains` - All quotient chunk domains.\n/// * `zeta` - The out-of-domain evaluation point.\n/// * `pcs` - The polynomial commitment scheme.\n///\n/// # Returns\n///\n/// A vector `[L_0(ζ), L_1(ζ), ..., L_{n-1}(ζ)]` of Lagrange interpolation coefficients.\nfn compute_quotient_chunk_products\u003c\n    SC: StarkGenericConfig,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    Domain: Copy,\n\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    quotient_chunks_domains: \u0026[Domain],\n    zeta: Target,\n    pcs: \u0026SC::Pcs,\n) -\u003e Vec\u003cTarget\u003e\nwhere\n    SC::Pcs: RecursivePcs\u003cSC, InputProof, OpeningProof, Comm, Domain\u003e,\n    SC::Challenge: PrimeCharacteristicRing,\n{\n    if quotient_chunks_domains.is_empty() {\n        return Vec::new();\n    }\n\n    // Phase 1: In-circuit computation of numerators\n\n    // Compute Z_j(ζ) for all domains j in-circuit.\n    //\n    // This is the only place we evaluate vanishing polynomials at ζ in the circuit.\n    // Cost: O(N·log|D|) constraints\n    let vp_zeta_values = quotient_chunks_domains\n        .iter()\n        .map(|\u0026domain| {\n            vanishing_poly_at_point_circuit::\u003cSC, _, _, _, _\u003e(pcs, \u0026domain, zeta, circuit)\n        })\n        .collect_vec();\n\n    // Compute the total product ∏_j Z_j(ζ).\n    //\n    // Cost: O(N) multiplications\n    let total_vp_zeta_product = circuit.mul_many(\u0026vp_zeta_values);\n\n    // Phase 2: Native pre-computation of denominator constants\n\n    // Pre-compute the denominator constants ∏_{j≠i} Z_j(g_i) OUTSIDE the circuit.\n    //\n    // Why this works: g_i (first points) are public constants, so Z_j(g_i) are constants.\n    // We compute them as native field operations and embed them as circuit constants.\n    //\n    // Cost: O(N^2·log|D|) native field operations (no circuit cost!)\n    let den_constants = quotient_chunks_domains\n        .iter()\n        .enumerate()\n        .map(|(i, \u0026domain_i)| {\n            let fp_i = pcs.first_point(\u0026domain_i);\n            quotient_chunks_domains\n                    .iter()\n                    .enumerate()\n                    .filter(|\u0026(j, _)| j != i)\n                    .fold(SC::Challenge::ONE, |acc, (_, \u0026domain_j)| {\n                        // Compute Z_j(g_i) natively (no circuit operations!)\n                        acc * vanishing_poly_at_point_native::\u003c\n                            SC,\n                            InputProof,\n                            OpeningProof,\n                            Comm,\n                            Domain,\n                        \u003e(pcs, \u0026domain_j, fp_i)\n                    })\n        })\n        .collect_vec();\n\n    // Phase 3: In-circuit combination\n\n    // Pre-lift all denominator constants once before the loop\n    let den_targets: Vec\u003c_\u003e = den_constants\n        .iter()\n        .map(|\u0026c| circuit.define_const(c))\n        .collect();\n\n    // For each chunk i, compute L_i(ζ) = [∏_j Z_j(ζ) / Z_i(ζ)] / den_i\n    //\n    // Cost: O(N) divisions (2 divisions per chunk)\n    vp_zeta_values\n        .iter()\n        .enumerate()\n        .map(|(i, \u0026vp_zeta_i)| {\n            // Numerator: (∏_j Z_j(ζ)) / Z_i(ζ)\n            //\n            // Reuse the total product and divide by the i-th vanishing polynomial\n            let num = circuit.div(total_vp_zeta_product, vp_zeta_i);\n\n            // Denominator: Pre-computed constant ∏_{j≠i} Z_j(g_i)\n            //\n            // Simply embed the constant into the circuit (no computation!)\n            let den = den_targets[i];\n\n            // Final Lagrange coefficient: L_i(ζ) = numerator / denominator\n            circuit.div(num, den)\n        })\n        .collect()\n}\n\n/// Computes the quotient polynomial evaluation.\n///\n/// Given chunk coefficients and Lagrange interpolation coefficients, this computes:\n///\n/// ```text\n/// Q(ζ) = ∑_i Q_i(·) · L_i(ζ)\n/// ```\n///\n/// where each `Q_i(·)` is evaluated from its extension field basis representation:\n///\n/// ```text\n/// Q_i(·) = ∑_j e_j · chunk_i[j]\n/// ```\n///\n/// # Arguments\n///\n/// * `circuit` - The circuit builder.\n/// * `opened_quotient_chunks` - Coefficient vectors in extension field basis.\n/// * `zps` - Lagrange interpolation coefficients `[L_0(ζ), ..., L_{n-1}(ζ)]`.\n///\n/// # Returns\n///\n/// A `Target` representing `Q(ζ)`.\nfn compute_quotient_evaluation\u003cSC: StarkGenericConfig\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    opened_quotient_chunks: \u0026[Vec\u003cTarget\u003e],\n    zps: \u0026[Target],\n) -\u003e Target\nwhere\n    SC::Challenge: PrimeCharacteristicRing,\n{\n    // Get the extension field degree.\n    let d = SC::Challenge::DIMENSION;\n\n    // Handle edge cases: empty chunks or trivial extension\n    if d == 0 || opened_quotient_chunks.is_empty() {\n        return circuit.define_const(SC::Challenge::ZERO);\n    }\n\n    // Phase 1: Pre-compute extension field basis elements\n\n    // Compute the basis elements [e_0, e_1, ..., e_{d-1}] once and reuse for all chunks.\n    //\n    // Cost: O(d) - done once\n    let basis_targets: Vec\u003c_\u003e = (0..d)\n        .map(|i| {\n            let basis_elem =\n                SC::Challenge::ith_basis_element(i).expect(\"Basis index should be in range [0, d)\");\n            circuit.define_const(basis_elem)\n        })\n        .collect();\n\n    // Phase 2: Evaluate each chunk polynomial using inner product\n\n    // For each chunk, compute Q_i = ∑_j e_j · chunk_i[j] using inner product.\n    //\n    // Cost: O(n·d) multiply-adds\n    let chunk_evals = opened_quotient_chunks\n        .iter()\n        .map(|chunk| {\n            // Validate chunk length in debug builds\n            debug_assert_eq!(\n                chunk.len(),\n                d,\n                \"Chunk length must match field extension degree\"\n            );\n\n            // Compute Q_i = \u003cchunk, basis\u003e = ∑_j chunk[j] · e_j\n            circuit.inner_product(chunk, \u0026basis_targets)\n        })\n        .collect_vec();\n\n    // Phase 3: Combine chunk evaluations with Lagrange coefficients\n\n    // Compute the final sum Q(ζ) = ∑_i Q_i · L_i(ζ) using inner product.\n    //\n    // Cost: O(n) multiply-adds\n    circuit.inner_product(\u0026chunk_evals, zps)\n}\n\n/// Computes a vanishing polynomial evaluation **in-circuit**.\n///\n/// This function adds circuit constraints to compute `Z_H(point) = (point/g)^n - 1`\n/// for a domain `H`, where the result is a circuit variable (not a constant).\n///\n/// # Mathematical Formula\n///\n/// For a multiplicative coset `H = {g, gω, ..., gω^(n-1)}`:\n///\n/// ```text\n/// Z_H(point) = (point/g)^n - 1\n/// ```\n///\n/// where `n = |H|` and `g` is the coset generator.\n///\n/// # Arguments\n///\n/// * `pcs` - PCS providing domain metadata.\n/// * `domain` - The domain `H`.\n/// * `point` - The evaluation point (a circuit variable).\n/// * `circuit` - The circuit builder.\n///\n/// # Returns\n///\n/// A `Target` representing `Z_H(point)` in the circuit.\nfn vanishing_poly_at_point_circuit\u003c\n    SC: StarkGenericConfig,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    Domain,\n\u003e(\n    pcs: \u0026SC::Pcs,\n    domain: \u0026Domain,\n    point: Target,\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n) -\u003e Target\nwhere\n    SC::Pcs: RecursivePcs\u003cSC, InputProof, OpeningProof, Comm, Domain\u003e,\n{\n    // Normalize: compute point/g where g is the coset generator\n    //\n    // Cost: 1 multiplication constraint\n    let inv = circuit.define_const(pcs.first_point(domain).inverse());\n    let mul = circuit.mul(point, inv);\n\n    // Exponentiate: compute (point/g)^n where n = 2^(log_size)\n    //\n    // Cost: log_2(n) squaring constraints\n    let exp = circuit.exp_power_of_2(mul, pcs.log_size(domain));\n\n    // Subtract: Z_H(point) = (point/g)^n - 1\n    //\n    // Cost: 1 subtraction constraint\n    let one = circuit.define_const(SC::Challenge::ONE);\n    circuit.sub(exp, one)\n}\n","traces":[{"line":60,"address":[4488224,4488230,4488000],"length":1,"stats":{"Line":7}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[3066174,3066094],"length":1,"stats":{"Line":15}},{"line":126,"address":[3063808],"length":1,"stats":{"Line":6}},{"line":141,"address":[4843529],"length":1,"stats":{"Line":7}},{"line":144,"address":[3063928],"length":1,"stats":{"Line":6}},{"line":147,"address":[2548916],"length":1,"stats":{"Line":7}},{"line":172,"address":[2549008,2549973,2549967],"length":1,"stats":{"Line":8}},{"line":188,"address":[],"length":0,"stats":{"Line":7}},{"line":189,"address":[7620083],"length":1,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[7620800,7620817,7619972],"length":1,"stats":{"Line":23}},{"line":201,"address":[4818626],"length":1,"stats":{"Line":7}},{"line":208,"address":[3335083,3334986],"length":1,"stats":{"Line":18}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[7621118,7620256,7621072],"length":1,"stats":{"Line":27}},{"line":222,"address":[4487252],"length":1,"stats":{"Line":9}},{"line":223,"address":[4487334,4487275],"length":1,"stats":{"Line":15}},{"line":224,"address":[7621171],"length":1,"stats":{"Line":9}},{"line":225,"address":[7621179],"length":1,"stats":{"Line":8}},{"line":226,"address":[2550389,2550666,2550656],"length":1,"stats":{"Line":22}},{"line":227,"address":[],"length":0,"stats":{"Line":28}},{"line":229,"address":[4487662],"length":1,"stats":{"Line":7}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[4845302],"length":1,"stats":{"Line":6}},{"line":243,"address":[4817814],"length":1,"stats":{"Line":7}},{"line":245,"address":[4487486,4486708,4487472],"length":1,"stats":{"Line":23}},{"line":251,"address":[4844410],"length":1,"stats":{"Line":7}},{"line":254,"address":[4844944,4844975,4844529],"length":1,"stats":{"Line":23}},{"line":258,"address":[],"length":0,"stats":{"Line":7}},{"line":263,"address":[2550217],"length":1,"stats":{"Line":8}},{"line":266,"address":[],"length":0,"stats":{"Line":7}},{"line":294,"address":[7619210,7618672,7619204],"length":1,"stats":{"Line":8}},{"line":303,"address":[7618744],"length":1,"stats":{"Line":7}},{"line":306,"address":[],"length":0,"stats":{"Line":8}},{"line":307,"address":[3333715],"length":1,"stats":{"Line":0}},{"line":315,"address":[4842764],"length":1,"stats":{"Line":7}},{"line":316,"address":[4816832,4816462],"length":1,"stats":{"Line":15}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[4816862],"length":1,"stats":{"Line":8}},{"line":319,"address":[4816906],"length":1,"stats":{"Line":7}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[7618974,7619232],"length":1,"stats":{"Line":15}},{"line":332,"address":[4816980],"length":1,"stats":{"Line":7}},{"line":333,"address":[4816965],"length":1,"stats":{"Line":8}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[7619380],"length":1,"stats":{"Line":8}},{"line":348,"address":[3063297,3063383],"length":1,"stats":{"Line":15}},{"line":376,"address":[7621488],"length":1,"stats":{"Line":7}},{"line":394,"address":[],"length":0,"stats":{"Line":9}},{"line":395,"address":[3336524],"length":1,"stats":{"Line":7}},{"line":400,"address":[4845539],"length":1,"stats":{"Line":7}},{"line":405,"address":[4845577],"length":1,"stats":{"Line":9}},{"line":406,"address":[3065958],"length":1,"stats":{"Line":9}}],"covered":45,"coverable":62},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","stark.rs"],"content":"use alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\n\nuse itertools::Itertools;\nuse p3_circuit::utils::ColumnsTargets;\nuse p3_circuit::{CircuitBuilder, CircuitBuilderError, NonPrimitiveOpId};\nuse p3_commit::{Pcs, PolynomialSpace};\nuse p3_field::{BasedVectorSpace, ExtensionField, Field, PrimeCharacteristicRing, PrimeField64};\nuse p3_lookup::logup::LogUpGadget;\nuse p3_uni_stark::{StarkGenericConfig, Val};\n\nuse super::{ObservableCommitment, VerificationError, recompose_quotient_from_chunks_circuit};\nuse crate::Target;\nuse crate::challenger::CircuitChallenger;\nuse crate::ops::Poseidon2Config;\nuse crate::traits::{LookupMetadata, Recursive, RecursiveAir, RecursivePcs};\nuse crate::types::{\n    CommitmentTargets, OpenedValuesTargets, OpenedValuesTargetsWithLookups, ProofTargets,\n    StarkChallengeParams, StarkChallenges,\n};\n\n/// Type alias for PCS verifier parameters.\ntype PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e =\n    \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as RecursivePcs\u003c\n        SC,\n        InputProof,\n        OpeningProof,\n        Comm,\n        \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\n            \u003cSC as StarkGenericConfig\u003e::Challenge,\n            \u003cSC as StarkGenericConfig\u003e::Challenger,\n        \u003e\u003e::Domain,\n    \u003e\u003e::VerifierParams;\n\ntype PcsDomain\u003cSC\u003e = \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\n    \u003cSC as StarkGenericConfig\u003e::Challenger,\n\u003e\u003e::Domain;\n\n/// Verifies a STARK proof within a circuit.\n///\n/// This function adds constraints to the circuit builder that verify a STARK proof.\n///\n/// # Parameters\n/// - `config`: STARK configuration including PCS and challenger\n/// - `air`: The Algebraic Intermediate Representation defining the computation\n/// - `circuit`: Circuit builder to add verification constraints to\n/// - `proof_targets`: Recursive representation of the proof\n/// - `public_values`: Public input targets\n/// - `pcs_params`: PCS-specific verifier parameters (e.g. FRI's log blowup / final poly size)\n///\n/// # Returns\n/// `Ok(Vec\u003cNonPrimitiveOpId\u003e)` containing operation IDs that require private data\n/// (e.g., Merkle sibling values for MMCS verification). The caller must set\n/// private data for these operations before running the circuit.\n/// `Err` if there was a structural error.\n#[allow(clippy::too_many_arguments)]\npub fn verify_p3_uni_proof_circuit\u003c\n    A,\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e + Clone\n        + ObservableCommitment,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    const WIDTH: usize,\n    const RATE: usize,\n\u003e(\n    config: \u0026SC,\n    air: \u0026A,\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    proof_targets: \u0026ProofTargets\u003cSC, Comm, OpeningProof\u003e,\n    public_values: \u0026[Target],\n    preprocessed_commit: \u0026Option\u003cComm\u003e,\n    pcs_params: \u0026PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e,\n    poseidon2_config: Poseidon2Config,\n) -\u003e Result\u003cVec\u003cNonPrimitiveOpId\u003e, VerificationError\u003e\nwhere\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    \u003cSC as StarkGenericConfig\u003e::Pcs: RecursivePcs\u003c\n            SC,\n            InputProof,\n            OpeningProof,\n            Comm,\n            \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain,\n        \u003e,\n    Val\u003cSC\u003e: PrimeField64,\n    SC::Challenge: ExtensionField\u003cVal\u003cSC\u003e\u003e + PrimeCharacteristicRing,\n{\n    let ProofTargets {\n        commitments_targets:\n            CommitmentTargets {\n                trace_targets,\n                quotient_chunks_targets,\n                random_commit,\n                ..\n            },\n        opened_values_targets,\n        opening_proof,\n        degree_bits,\n    } = proof_targets;\n\n    let OpenedValuesTargets {\n        trace_local_targets: opened_trace_local_targets,\n        trace_next_targets: opened_trace_next_targets,\n        preprocessed_local_targets: opt_opened_preprocessed_local_targets,\n        preprocessed_next_targets: opt_opened_preprocessed_next_targets,\n        quotient_chunks_targets: opened_quotient_chunks_targets,\n        random_targets: opened_random,\n        ..\n    } = opened_values_targets;\n\n    let degree = 1 \u003c\u003c degree_bits;\n    let lookup_gadget = LogUpGadget {};\n    let preprocessed_width = opt_opened_preprocessed_local_targets\n        .as_ref()\n        .map_or(0, |p| p.len());\n\n    // Lookups are not supported for recursive single STARK verification.\n    let log_quotient_degree = A::get_log_num_quotient_chunks(\n        air,\n        preprocessed_width,\n        public_values.len(),\n        \u0026[],\n        \u0026[],\n        config.is_zk(),\n        \u0026lookup_gadget,\n    );\n    let quotient_degree = 1 \u003c\u003c (log_quotient_degree + config.is_zk());\n\n    let pcs = config.pcs();\n    let trace_domain = pcs.natural_domain_for_degree(degree);\n    let init_trace_domain = pcs.natural_domain_for_degree(degree \u003e\u003e (config.is_zk()));\n\n    let quotient_domain =\n        pcs.create_disjoint_domain(trace_domain, 1 \u003c\u003c (degree_bits + log_quotient_degree));\n    let quotient_chunks_domains = pcs.split_domains(\u0026quotient_domain, quotient_degree);\n\n    let randomized_quotient_chunks_domains = quotient_chunks_domains\n        .iter()\n        .map(|domain| pcs.natural_domain_for_degree(pcs.size(domain) \u003c\u003c (config.is_zk())))\n        .collect_vec();\n\n    // Generate all challenges (alpha, zeta, zeta_next, PCS challenges)\n    let (challenge_targets, mut challenger) =\n        get_circuit_challenges::\u003cA, SC, Comm, InputProof, OpeningProof, WIDTH, RATE\u003e(\n            air,\n            config,\n            proof_targets,\n            public_values,\n            preprocessed_width,\n            preprocessed_commit,\n            \u0026init_trace_domain,\n            circuit,\n            pcs_params,\n            poseidon2_config,\n        )?;\n\n    // Validate ZK randomization consistency\n    if (opened_random.is_some() != SC::Pcs::ZK) || (random_commit.is_some() != SC::Pcs::ZK) {\n        return Err(VerificationError::RandomizationError);\n    }\n\n    // Validate proof shape\n    validate_proof_shape::\u003cA, SC, Comm\u003e(\n        air,\n        opened_values_targets,\n        preprocessed_width,\n        preprocessed_commit,\n        quotient_degree,\n    )?;\n\n    let alpha = challenge_targets[0];\n    let zeta = challenge_targets[1];\n    let zeta_next = challenge_targets[2];\n\n    // Prepare commitments with their opening points for PCS verification\n    let mut coms_to_verify = if let Some(r_commit) = \u0026random_commit {\n        let random_values = opened_random\n            .as_ref()\n            .ok_or(VerificationError::RandomizationError)?;\n        vec![(\n            r_commit.clone(),\n            vec![(trace_domain, vec![(zeta, random_values.clone())])],\n        )]\n    } else {\n        vec![]\n    };\n\n    coms_to_verify.extend(vec![\n        (\n            trace_targets.clone(),\n            vec![(\n                trace_domain,\n                vec![\n                    (zeta, opened_trace_local_targets.clone()),\n                    (zeta_next, opened_trace_next_targets.clone()),\n                ],\n            )],\n        ),\n        (\n            quotient_chunks_targets.clone(),\n            // Check the commitment on the randomized domains\n            {\n                if randomized_quotient_chunks_domains.len() != opened_quotient_chunks_targets.len()\n                {\n                    return Err(VerificationError::InvalidProofShape(\n                        \"Randomized quotient chunks length mismatch\".to_string(),\n                    ));\n                }\n                randomized_quotient_chunks_domains\n                    .iter()\n                    .zip(opened_quotient_chunks_targets)\n                    .map(|(domain, values)| (*domain, vec![(zeta, values.clone())]))\n                    .collect_vec()\n            },\n        ),\n    ]);\n\n    // Add preprocessed commitment verification if present\n    if preprocessed_width \u003e 0 {\n        coms_to_verify.push((\n            preprocessed_commit\n                .clone()\n                .expect(\"We checked in validate_proof_shape that the commit exists\"),\n            vec![(\n                trace_domain,\n                vec![\n                    (zeta, opt_opened_preprocessed_local_targets.clone().unwrap()),\n                    (\n                        zeta_next,\n                        opt_opened_preprocessed_next_targets.clone().unwrap(),\n                    ),\n                ],\n            )],\n        ));\n    }\n\n    // Verify polynomial openings using PCS\n    let mmcs_op_ids = pcs.verify_circuit::\u003cWIDTH, RATE\u003e(\n        circuit,\n        \u0026challenge_targets[3..], // PCS challenges (after alpha, zeta, zeta_next)\n        \u0026mut challenger,\n        \u0026coms_to_verify,\n        opening_proof,\n        pcs_params,\n    )?;\n\n    // Compute quotient polynomial evaluation from chunks\n    let quotient = recompose_quotient_from_chunks_circuit::\u003c\n        SC,\n        InputProof,\n        OpeningProof,\n        Comm,\n        PcsDomain\u003cSC\u003e,\n    \u003e(\n        circuit,\n        \u0026quotient_chunks_domains,\n        opened_quotient_chunks_targets,\n        zeta,\n        pcs,\n    );\n\n    // Evaluate AIR constraints at out-of-domain point\n    // Note that lookups are not supported for recursive single STARK verification.\n    let sels = pcs.selectors_at_point_circuit(circuit, \u0026init_trace_domain, \u0026zeta);\n    let columns_targets = ColumnsTargets {\n        challenges: \u0026[],\n        public_values,\n        permutation_local_values: \u0026[],\n        permutation_next_values: \u0026[],\n        local_prep_values: opt_opened_preprocessed_local_targets\n            .as_ref()\n            .map_or(\u0026[], |p| p),\n        next_prep_values: opt_opened_preprocessed_next_targets\n            .as_ref()\n            .map_or(\u0026[], |p| p),\n        local_values: opened_trace_local_targets,\n        next_values: opened_trace_next_targets,\n    };\n\n    let dummy_lookup_metadata = LookupMetadata {\n        contexts: \u0026[],\n        lookup_data: \u0026[],\n    };\n    let folded_constraints = air.eval_folded_circuit(\n        circuit,\n        \u0026sels,\n        \u0026alpha,\n        \u0026dummy_lookup_metadata,\n        columns_targets,\n        \u0026lookup_gadget,\n    );\n\n    // Verify: constraints / Z_H(zeta) == quotient(zeta)\n    let folded_mul = circuit.mul(folded_constraints, sels.inv_vanishing);\n    circuit.connect(folded_mul, quotient);\n\n    Ok(mmcs_op_ids)\n}\n\n/// Generate all challenges for STARK verification.\n///\n/// This includes:\n/// - Base STARK challenges (alpha, zeta, zeta_next)\n/// - PCS-specific challenges (e.g., FRI betas, query indices)\n#[allow(clippy::too_many_arguments)]\nfn get_circuit_challenges\u003c\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e + ObservableCommitment,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    const WIDTH: usize,\n    const RATE: usize,\n\u003e(\n    _air: \u0026A,\n    config: \u0026SC,\n    proof_targets: \u0026ProofTargets\u003cSC, Comm, OpeningProof\u003e,\n    public_values: \u0026[Target],\n    preprocessed_width: usize,\n    preprocessed_commit: \u0026Option\u003cComm\u003e,\n    init_trace_domain: \u0026PcsDomain\u003cSC\u003e,\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    pcs_params: \u0026PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e,\n    poseidon2_config: Poseidon2Config,\n) -\u003e Result\u003c(Vec\u003cTarget\u003e, CircuitChallenger\u003cWIDTH, RATE\u003e), CircuitBuilderError\u003e\nwhere\n    SC::Pcs: RecursivePcs\u003c\n            SC,\n            InputProof,\n            OpeningProof,\n            Comm,\n            \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain,\n        \u003e,\n    Val\u003cSC\u003e: PrimeField64,\n    SC::Challenge: ExtensionField\u003cVal\u003cSC\u003e\u003e + PrimeCharacteristicRing,\n{\n    let pcs = config.pcs();\n\n    // Compute the trace domain generator for zeta_next = zeta * generator\n    // The generator is the primitive n-th root of unity for the init_trace_domain\n    let first_point = pcs.first_point(init_trace_domain);\n    let next_point = init_trace_domain\n        .next_point(first_point)\n        .expect(\"init_trace_domain should have next_point\");\n    let trace_domain_generator = next_point * first_point.inverse();\n\n    let mut challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new(poseidon2_config);\n\n    // Set up challenge parameters matching native challenger behavior\n    let challenge_params = StarkChallengeParams {\n        degree_bits: proof_targets.degree_bits,\n        is_zk: config.is_zk(),\n        preprocessed_width,\n        preprocessed_commit,\n        trace_domain_generator,\n    };\n\n    // Allocate base STARK challenges (alpha, zeta, zeta_next) using Fiat-Shamir\n    let base_challenges = StarkChallenges::allocate::\u003cSC, Comm, OpeningProof\u003e(\n        circuit,\n        \u0026mut challenger,\n        proof_targets,\n        public_values,\n        \u0026challenge_params,\n    );\n\n    let opened_values_no_lookups = OpenedValuesTargetsWithLookups {\n        opened_values_no_lookups: proof_targets.opened_values_targets.clone(),\n        permutation_local_targets: vec![],\n        permutation_next_targets: vec![],\n    };\n\n    // Observe opened values before getting PCS challenges.\n    // For single-STARK with one instance, the standard observation order is correct.\n    opened_values_no_lookups.observe(circuit, \u0026mut challenger);\n\n    // Get PCS-specific challenges (FRI betas, query indices, etc.)\n    let pcs_challenges = SC::Pcs::get_challenges_circuit::\u003cWIDTH, RATE\u003e(\n        circuit,\n        \u0026mut challenger,\n        \u0026proof_targets.opening_proof,\n        \u0026opened_values_no_lookups,\n        pcs_params,\n    )?;\n\n    // Return flat vector: [alpha, zeta, zeta_next, ...pcs_challenges] and challenger for PCS verification\n    let mut all_challenges = base_challenges.to_vec();\n    all_challenges.extend(pcs_challenges);\n    Ok((all_challenges, challenger))\n}\n\n/// Validate the shape of the proof (dimensions, lengths).\nfn validate_proof_shape\u003cA, SC: StarkGenericConfig, Comm\u003e(\n    air: \u0026A,\n    opened_values: \u0026OpenedValuesTargets\u003cSC\u003e,\n    preprocessed_width: usize,\n    preprocessed_commit: \u0026Option\u003cComm\u003e,\n    quotient_degree: usize,\n) -\u003e Result\u003c(), VerificationError\u003e\nwhere\n    A: RecursiveAir\u003cVal\u003cSC\u003e, SC::Challenge, LogUpGadget\u003e,\n    SC::Challenge: PrimeCharacteristicRing,\n{\n    let air_width = A::width(air);\n\n    if preprocessed_commit.is_some() \u0026\u0026 preprocessed_width == 0 {\n        return Err(VerificationError::InvalidProofShape(\n            \"There is a preprocessed commit but no opening values provided.\".to_string(),\n        ));\n    }\n\n    if preprocessed_commit.is_none() \u0026\u0026 preprocessed_width \u003e 0 {\n        return Err(VerificationError::InvalidProofShape(\n            \"Preprocessed width is non-zero but no preprocessed commit provided.\".to_string(),\n        ));\n    }\n\n    let OpenedValuesTargets {\n        trace_local_targets: opened_trace_local,\n        trace_next_targets: opened_trace_next,\n        preprocessed_local_targets: opened_prep_local,\n        preprocessed_next_targets: opened_prep_next,\n        quotient_chunks_targets: opened_quotient_chunks,\n        random_targets: opened_random,\n        ..\n    } = opened_values;\n\n    if opened_trace_local.len() != air_width || opened_trace_next.len() != air_width {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Expected opened_trace_local and opened_trace_next to have length {}, got {} and {}\",\n            air_width,\n            opened_trace_local.len(),\n            opened_trace_next.len()\n        )));\n    }\n\n    let preprocessed_local_len = opened_prep_local.as_ref().map_or(0, |v| v.len());\n    let preprocessed_next_len = opened_prep_next.as_ref().map_or(0, |v| v.len());\n    if preprocessed_width != preprocessed_local_len || preprocessed_width != preprocessed_next_len {\n        // Verifier expects preprocessed trace while proof does not have it, or vice versa\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Expected preprocessed width {preprocessed_width} but local has length {preprocessed_local_len} and next has length {preprocessed_next_len}\"\n        )));\n    }\n\n    if opened_quotient_chunks.len() != quotient_degree {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Expected opened_quotient_chunks to have length {}, got {}\",\n            quotient_degree,\n            opened_quotient_chunks.len()\n        )));\n    }\n\n    if opened_quotient_chunks\n        .iter()\n        .any(|opened_chunk| opened_chunk.len() != SC::Challenge::DIMENSION)\n    {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Invalid quotient chunk length: expected {}\",\n            SC::Challenge::DIMENSION\n        )));\n    }\n\n    if let Some(r_comm) = \u0026opened_random\n        \u0026\u0026 r_comm.len() != SC::Challenge::DIMENSION\n    {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Expected opened random values to have length {}, got {}\",\n            SC::Challenge::DIMENSION,\n            r_comm.len()\n        )));\n    }\n\n    Ok(())\n}\n","traces":[{"line":59,"address":[4326492,4317648,4321652],"length":1,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[3338424],"length":1,"stats":{"Line":4}},{"line":97,"address":[3338432],"length":1,"stats":{"Line":4}},{"line":98,"address":[4136167],"length":1,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[4136182],"length":1,"stats":{"Line":4}},{"line":102,"address":[4136205],"length":1,"stats":{"Line":4}},{"line":103,"address":[4136231],"length":1,"stats":{"Line":4}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[5444030],"length":1,"stats":{"Line":4}},{"line":108,"address":[5444038],"length":1,"stats":{"Line":4}},{"line":109,"address":[5444061],"length":1,"stats":{"Line":4}},{"line":110,"address":[4136308],"length":1,"stats":{"Line":4}},{"line":111,"address":[4318059],"length":1,"stats":{"Line":4}},{"line":112,"address":[3338642],"length":1,"stats":{"Line":4}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[4136423,4145296,4145305],"length":1,"stats":{"Line":8}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[4318184],"length":1,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[5444333,5444518],"length":1,"stats":{"Line":4}},{"line":134,"address":[4318396],"length":1,"stats":{"Line":4}},{"line":135,"address":[4318428],"length":1,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":8}},{"line":138,"address":[3339297,3339163,3339103],"length":1,"stats":{"Line":8}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[5444749],"length":1,"stats":{"Line":4}},{"line":142,"address":[3339274],"length":1,"stats":{"Line":4}},{"line":144,"address":[4327096,4327056,4318869],"length":1,"stats":{"Line":12}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[5445574,5445719,5445635],"length":1,"stats":{"Line":12}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[4138261],"length":1,"stats":{"Line":4}},{"line":177,"address":[3340600],"length":1,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[4320151],"length":1,"stats":{"Line":4}},{"line":182,"address":[3341017,3340881,3342233],"length":1,"stats":{"Line":0}},{"line":184,"address":[4138546,4138649],"length":1,"stats":{"Line":0}},{"line":185,"address":[3341218,3341928,3342228,3341156],"length":1,"stats":{"Line":0}},{"line":186,"address":[5446691],"length":1,"stats":{"Line":0}},{"line":187,"address":[3341260,3341320,3342218],"length":1,"stats":{"Line":0}},{"line":190,"address":[5447741,5446294],"length":1,"stats":{"Line":8}},{"line":193,"address":[3343706,3346984,3342342,3343281,3346947,3342197,3342311],"length":1,"stats":{"Line":12}},{"line":195,"address":[4321767],"length":1,"stats":{"Line":4}},{"line":196,"address":[3342444,3342485,3342945,3346979,3342384],"length":1,"stats":{"Line":12}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[5448021,5452462,5447950,5448056,5448169,5448260],"length":1,"stats":{"Line":12}},{"line":199,"address":[5448096,5448029],"length":1,"stats":{"Line":8}},{"line":200,"address":[5448142,5448205],"length":1,"stats":{"Line":8}},{"line":205,"address":[5448754],"length":1,"stats":{"Line":4}},{"line":208,"address":[4322761,4322821],"length":1,"stats":{"Line":8}},{"line":210,"address":[4326259],"length":1,"stats":{"Line":0}},{"line":211,"address":[4322888],"length":1,"stats":{"Line":0}},{"line":214,"address":[4322865],"length":1,"stats":{"Line":4}},{"line":215,"address":[3343494],"length":1,"stats":{"Line":4}},{"line":216,"address":[3343549],"length":1,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":12}},{"line":218,"address":[3343603],"length":1,"stats":{"Line":4}},{"line":224,"address":[5449425],"length":1,"stats":{"Line":4}},{"line":225,"address":[3344924],"length":1,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[4141721],"length":1,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":229,"address":[3344064,3344683,3346802,3344127,3344168],"length":1,"stats":{"Line":6}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[4323660,4323691,4323830,4323589,4323954,4326241],"length":1,"stats":{"Line":6}},{"line":232,"address":[4141948,4141995],"length":1,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[4142134,4142087],"length":1,"stats":{"Line":4}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[5449431],"length":1,"stats":{"Line":4}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[3345056],"length":1,"stats":{"Line":4}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[4324957],"length":1,"stats":{"Line":4}},{"line":262,"address":[4325060],"length":1,"stats":{"Line":4}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[4143485],"length":1,"stats":{"Line":4}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[3346302],"length":1,"stats":{"Line":4}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[4144222],"length":1,"stats":{"Line":4}},{"line":300,"address":[4144266],"length":1,"stats":{"Line":4}},{"line":302,"address":[4144281],"length":1,"stats":{"Line":4}},{"line":311,"address":[5443594,5443668,5441808],"length":1,"stats":{"Line":4}},{"line":345,"address":[],"length":0,"stats":{"Line":4}},{"line":349,"address":[4134249],"length":1,"stats":{"Line":4}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[3336547],"length":1,"stats":{"Line":4}},{"line":353,"address":[4316098],"length":1,"stats":{"Line":4}},{"line":355,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":4}},{"line":360,"address":[],"length":0,"stats":{"Line":4}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[4134651],"length":1,"stats":{"Line":4}},{"line":377,"address":[5442454],"length":1,"stats":{"Line":4}},{"line":378,"address":[3337021],"length":1,"stats":{"Line":4}},{"line":383,"address":[],"length":0,"stats":{"Line":4}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":4}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":4}},{"line":396,"address":[3337638],"length":1,"stats":{"Line":4}},{"line":397,"address":[3337747],"length":1,"stats":{"Line":4}},{"line":401,"address":[4313312],"length":1,"stats":{"Line":4}},{"line":412,"address":[5439370],"length":1,"stats":{"Line":4}},{"line":414,"address":[4131638,4131609],"length":1,"stats":{"Line":6}},{"line":415,"address":[5439452],"length":1,"stats":{"Line":0}},{"line":416,"address":[3333934],"length":1,"stats":{"Line":0}},{"line":420,"address":[5439399,5439661],"length":1,"stats":{"Line":6}},{"line":421,"address":[4131929],"length":1,"stats":{"Line":0}},{"line":422,"address":[3334185],"length":1,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[5439537],"length":1,"stats":{"Line":4}},{"line":428,"address":[4313562],"length":1,"stats":{"Line":4}},{"line":429,"address":[],"length":0,"stats":{"Line":4}},{"line":430,"address":[4131810],"length":1,"stats":{"Line":4}},{"line":431,"address":[],"length":0,"stats":{"Line":4}},{"line":432,"address":[],"length":0,"stats":{"Line":4}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[4313657,4313815],"length":1,"stats":{"Line":8}},{"line":437,"address":[3334361],"length":1,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[5439818],"length":1,"stats":{"Line":0}},{"line":441,"address":[4132062],"length":1,"stats":{"Line":0}},{"line":445,"address":[4132439,4133968,4133977],"length":1,"stats":{"Line":8}},{"line":446,"address":[],"length":0,"stats":{"Line":8}},{"line":447,"address":[4132494],"length":1,"stats":{"Line":4}},{"line":449,"address":[3334813],"length":1,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[4314685],"length":1,"stats":{"Line":4}},{"line":455,"address":[3335270],"length":1,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[3335257],"length":1,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":8}},{"line":464,"address":[5441721,5440714,5441696],"length":1,"stats":{"Line":12}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[5441312,5441043],"length":1,"stats":{"Line":4}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[3335897],"length":1,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[3335884],"length":1,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":4}}],"covered":97,"coverable":197},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","aggregation_different_shapes.rs"],"content":"//! Integration test: 2-to-1 aggregation of proofs with different FRI shapes.\n//! Left: Uni-Stark (Fibonacci) with log_blowup=2, max_arity_log=3.\n//! Right: Batch-Stark (dummy circuit) with log_blowup=3, max_arity_log=4.\n\nmod common;\n\nuse p3_baby_bear::default_babybear_poseidon2_16;\nuse p3_batch_stark::ProverData;\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::ops::generate_poseidon2_trace;\nuse p3_circuit::test_utils::{FibonacciAir, generate_trace_rows};\nuse p3_circuit_prover::common::get_airs_and_degrees_with_prep;\nuse p3_circuit_prover::{BatchStarkProver, CircuitProverData, ConstraintProfile, TablePacking};\nuse p3_field::PrimeCharacteristicRing;\nuse p3_fri::FriParameters;\nuse p3_lookup::logup::LogUpGadget;\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\nuse p3_recursion::pcs::fri::{FriVerifierParams, InputProofTargets, MerkleCapTargets, RecValMmcs};\nuse p3_recursion::pcs::set_fri_mmcs_private_data;\nuse p3_recursion::verifier::{verify_p3_batch_proof_circuit, verify_p3_uni_proof_circuit};\nuse p3_recursion::{Poseidon2Config, StarkVerifierInputsBuilder, VerificationError};\nuse p3_uni_stark::{prove, verify};\n\nuse crate::common::baby_bear_params::{\n    Challenge, ChallengeMmcs, Challenger, DIGEST_ELEMS, Dft, F, InnerFri, MyCompress, MyConfig,\n    MyHash, MyPcs, Perm, RATE, ValMmcs, WIDTH,\n};\n\nconst TRACE_D: usize = 1;\n\nfn make_config(perm: \u0026Perm, log_blowup: usize, max_log_arity: usize) -\u003e MyConfig {\n    let log_final_poly_len = 0usize;\n    let query_pow_bits = 16usize;\n    let num_queries = (100 - query_pow_bits) / log_blowup;\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress, 0);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let fri_params = FriParameters {\n        max_log_arity,\n        log_blowup,\n        log_final_poly_len,\n        num_queries,\n        commit_proof_of_work_bits: 0,\n        query_proof_of_work_bits: query_pow_bits,\n        mmcs: challenge_mmcs,\n    };\n    let pcs = MyPcs::new(Dft::default(), val_mmcs, fri_params);\n    let challenger = Challenger::new(perm.clone());\n    MyConfig::new(pcs, challenger)\n}\n\nconst fn fri_verifier_params(log_blowup: usize) -\u003e FriVerifierParams {\n    FriVerifierParams::with_mmcs(log_blowup, 0, 0, 16, Poseidon2Config::BabyBearD4Width16)\n}\n\n#[test]\nfn test_aggregation_with_different_shapes() -\u003e Result\u003c(), VerificationError\u003e {\n    let perm = default_babybear_poseidon2_16();\n\n    // Uni-Stark (Fibonacci) with log_blowup=2, max_arity_log=3.\n    let left_config = make_config(\u0026perm, 2, 3);\n    // Batch-Stark (dummy circuit) with log_blowup=3, max_arity_log=4.\n    let right_config = make_config(\u0026perm, 3, 4);\n    let right_config_verif = make_config(\u0026perm, 3, 4); // TODO(p3): StarkConfig does not implement Clone\n\n    // Generate the Fibonacci trace.\n    let n = 1 \u003c\u003c 3;\n    let x = 21u64;\n    let pis = vec![F::ZERO, F::ONE, F::from_u64(x)];\n    let air = FibonacciAir {};\n    let trace = generate_trace_rows::\u003cF\u003e(0, 1, n);\n\n    // Prove the Fibonacci trace with the Uni-Stark.\n    let uni_proof = prove(\u0026left_config, \u0026air, trace, \u0026pis);\n    assert!(verify(\u0026left_config, \u0026air, \u0026uni_proof, \u0026pis).is_ok());\n\n    // Prove the dummy circuit with the Batch-Stark.\n    let mut builder = CircuitBuilder::new();\n    let c = builder.alloc_const(F::from_u32(42), \"dummy\");\n    let expected = builder.alloc_public_input(\"expected\");\n    builder.connect(c, expected);\n    let circuit = builder.build().unwrap();\n    let table_packing = TablePacking::new(1, 1, 1).with_fri_params(0, 3);\n    let (airs_degrees, preprocessed_columns) = get_airs_and_degrees_with_prep::\u003cMyConfig, _, 1\u003e(\n        \u0026circuit,\n        table_packing,\n        None,\n        ConstraintProfile::Standard,\n    )\n    .unwrap();\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003c_\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n    runner.set_public_inputs(\u0026[F::from_u32(42)]).unwrap();\n    let traces = runner.run().unwrap();\n    let prover_data = ProverData::from_airs_and_degrees(\u0026right_config, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n    let prover = BatchStarkProver::new(right_config).with_table_packing(table_packing);\n    let batch_stark_proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n    let common = circuit_prover_data.common_data();\n    prover\n        .verify_all_tables(\u0026batch_stark_proof, common)\n        .unwrap();\n\n    // Build the verification circuit.\n    let mut circuit_builder = CircuitBuilder::new();\n    circuit_builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cChallenge, BabyBearD4Width16\u003e,\n        perm,\n    );\n\n    // Build the verifier inputs for the Uni-Stark.\n    let left_fri_params = fri_verifier_params(2);\n    let right_fri_params = fri_verifier_params(3);\n\n    let left_verifier_inputs = StarkVerifierInputsBuilder::\u003c\n        MyConfig,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n        InnerFri,\n    \u003e::allocate(\u0026mut circuit_builder, \u0026uni_proof, None, pis.len());\n\n    // Verify the Uni-Stark proof.\n    let left_op_ids = verify_p3_uni_proof_circuit::\u003c\n        FibonacciAir,\n        MyConfig,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n        InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n        InnerFri,\n        WIDTH,\n        RATE,\n    \u003e(\n        \u0026left_config,\n        \u0026air,\n        \u0026mut circuit_builder,\n        \u0026left_verifier_inputs.proof_targets,\n        \u0026left_verifier_inputs.air_public_targets,\n        \u0026None,\n        \u0026left_fri_params,\n        Poseidon2Config::BabyBearD4Width16,\n    )?;\n\n    // Build the verifier inputs for the Batch-Stark.\n    let lookup_gadget = LogUpGadget::new();\n    let batch_proof = \u0026batch_stark_proof.proof;\n    let right_pis: Vec\u003cVec\u003cF\u003e\u003e = vec![vec![]; 5];\n\n    // Verify the Batch-Stark proof.\n    let (right_verifier_inputs, right_op_ids) = verify_p3_batch_proof_circuit::\u003c\n        MyConfig,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n        InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n        InnerFri,\n        LogUpGadget,\n        WIDTH,\n        RATE,\n        TRACE_D,\n    \u003e(\n        \u0026right_config_verif,\n        \u0026mut circuit_builder,\n        \u0026batch_stark_proof,\n        \u0026right_fri_params,\n        common,\n        \u0026lookup_gadget,\n        Poseidon2Config::BabyBearD4Width16,\n    )?;\n\n    // Build the verification circuit.\n    let verification_circuit = circuit_builder.build().unwrap();\n    let mut runner = verification_circuit.runner();\n\n    // Pack the public inputs.\n    let mut public_inputs = left_verifier_inputs.pack_values(\u0026pis, \u0026uni_proof, \u0026None);\n    public_inputs.extend(right_verifier_inputs.pack_values(\u0026right_pis, batch_proof, common));\n    runner\n        .set_public_inputs(\u0026public_inputs)\n        .map_err(VerificationError::Circuit)?;\n\n    // Set the MMCS private data for the Uni-Stark.\n    set_fri_mmcs_private_data::\u003c\n        F,\n        Challenge,\n        ChallengeMmcs,\n        ValMmcs,\n        MyHash,\n        MyCompress,\n        DIGEST_ELEMS,\n    \u003e(\u0026mut runner, \u0026left_op_ids, \u0026uni_proof.opening_proof)\n    .map_err(|e| VerificationError::InvalidProofShape(e.to_string()))?;\n\n    // Set the MMCS private data for the Batch-Stark.\n    set_fri_mmcs_private_data::\u003c\n        F,\n        Challenge,\n        ChallengeMmcs,\n        ValMmcs,\n        MyHash,\n        MyCompress,\n        DIGEST_ELEMS,\n    \u003e(\n        \u0026mut runner,\n        \u0026right_op_ids,\n        \u0026batch_stark_proof.proof.opening_proof,\n    )\n    .map_err(|e| VerificationError::InvalidProofShape(e.to_string()))?;\n\n    // Run the verification circuit.\n    let _traces = runner.run().map_err(VerificationError::Circuit)?;\n    Ok(())\n}\n","traces":[{"line":1,"address":[4225408],"length":1,"stats":{"Line":1}},{"line":31,"address":[4216288,4217445,4217487],"length":1,"stats":{"Line":1}},{"line":32,"address":[4216344],"length":1,"stats":{"Line":1}},{"line":33,"address":[4216388],"length":1,"stats":{"Line":1}},{"line":34,"address":[4216516,4216400],"length":1,"stats":{"Line":1}},{"line":35,"address":[4216444],"length":1,"stats":{"Line":1}},{"line":36,"address":[4216512,4216570],"length":1,"stats":{"Line":2}},{"line":37,"address":[4216597],"length":1,"stats":{"Line":1}},{"line":38,"address":[4216821,4216885],"length":1,"stats":{"Line":2}},{"line":39,"address":[4216907],"length":1,"stats":{"Line":1}},{"line":48,"address":[4217013,4217061],"length":1,"stats":{"Line":2}},{"line":49,"address":[4217196,4217272],"length":1,"stats":{"Line":2}},{"line":50,"address":[4217279],"length":1,"stats":{"Line":1}},{"line":51,"address":[4217215,4217387,4217459,4217505,4216529,4217020,4216828],"length":1,"stats":{"Line":1}},{"line":53,"address":[4217520],"length":1,"stats":{"Line":1}},{"line":54,"address":[4217537],"length":1,"stats":{"Line":1}},{"line":55,"address":[4217567],"length":1,"stats":{"Line":1}},{"line":58,"address":[4225115,4217584,4225344,4224649,4225362],"length":1,"stats":{"Line":3}},{"line":59,"address":[4217679],"length":1,"stats":{"Line":1}},{"line":62,"address":[4217818],"length":1,"stats":{"Line":1}},{"line":64,"address":[4217936,4217892],"length":1,"stats":{"Line":2}},{"line":65,"address":[4217970],"length":1,"stats":{"Line":1}},{"line":68,"address":[4218015],"length":1,"stats":{"Line":1}},{"line":69,"address":[4217667],"length":1,"stats":{"Line":1}},{"line":70,"address":[4218099,4218039],"length":1,"stats":{"Line":2}},{"line":72,"address":[4218334],"length":1,"stats":{"Line":1}},{"line":75,"address":[4218385,4218456,4225087],"length":1,"stats":{"Line":1}},{"line":76,"address":[4218687,4218576],"length":1,"stats":{"Line":2}},{"line":79,"address":[4218839],"length":1,"stats":{"Line":1}},{"line":80,"address":[4218921,4218846],"length":1,"stats":{"Line":2}},{"line":81,"address":[4218969],"length":1,"stats":{"Line":1}},{"line":82,"address":[4219032],"length":1,"stats":{"Line":1}},{"line":83,"address":[4219039],"length":1,"stats":{"Line":1}},{"line":84,"address":[4219217,4219146],"length":1,"stats":{"Line":2}},{"line":85,"address":[4219253,4219352],"length":1,"stats":{"Line":2}},{"line":91,"address":[4219322],"length":1,"stats":{"Line":1}},{"line":92,"address":[4219584,4219464],"length":1,"stats":{"Line":2}},{"line":93,"address":[4219768,4219655],"length":1,"stats":{"Line":2}},{"line":94,"address":[4219840,4219781],"length":1,"stats":{"Line":2}},{"line":95,"address":[4219905],"length":1,"stats":{"Line":1}},{"line":96,"address":[4220012,4220115],"length":1,"stats":{"Line":2}},{"line":97,"address":[4220193],"length":1,"stats":{"Line":1}},{"line":98,"address":[4220443,4220334],"length":1,"stats":{"Line":2}},{"line":100,"address":[4220538],"length":1,"stats":{"Line":1}},{"line":101,"address":[4220585],"length":1,"stats":{"Line":1}},{"line":102,"address":[4220623,4220683],"length":1,"stats":{"Line":2}},{"line":104,"address":[4220715],"length":1,"stats":{"Line":1}},{"line":105,"address":[4220722],"length":1,"stats":{"Line":1}},{"line":108,"address":[4220752],"length":1,"stats":{"Line":1}},{"line":109,"address":[4220855,4220759],"length":1,"stats":{"Line":2}},{"line":111,"address":[4220767],"length":1,"stats":{"Line":1}},{"line":115,"address":[4220939],"length":1,"stats":{"Line":1}},{"line":116,"address":[4220959],"length":1,"stats":{"Line":1}},{"line":118,"address":[4221025],"length":1,"stats":{"Line":1}},{"line":122,"address":[4220974],"length":1,"stats":{"Line":1}},{"line":125,"address":[4221143,4221370,4224705],"length":1,"stats":{"Line":1}},{"line":137,"address":[4221032],"length":1,"stats":{"Line":1}},{"line":138,"address":[4221056],"length":1,"stats":{"Line":1}},{"line":142,"address":[4221290],"length":1,"stats":{"Line":0}},{"line":145,"address":[4221539],"length":1,"stats":{"Line":1}},{"line":146,"address":[4221598],"length":1,"stats":{"Line":1}},{"line":147,"address":[4221606],"length":1,"stats":{"Line":1}},{"line":150,"address":[4221661,4221921,4224673,4221785],"length":1,"stats":{"Line":2}},{"line":167,"address":[4221841],"length":1,"stats":{"Line":0}},{"line":170,"address":[4222143,4222245],"length":1,"stats":{"Line":2}},{"line":171,"address":[4222311],"length":1,"stats":{"Line":1}},{"line":174,"address":[4222432,4222352],"length":1,"stats":{"Line":2}},{"line":175,"address":[4222478,4222589],"length":1,"stats":{"Line":2}},{"line":176,"address":[4222864,4222728,4224569],"length":1,"stats":{"Line":1}},{"line":177,"address":[4222627],"length":1,"stats":{"Line":1}},{"line":178,"address":[4222705,4222784],"length":1,"stats":{"Line":1}},{"line":181,"address":[4223226,4223032,4224567,4223090],"length":1,"stats":{"Line":2}},{"line":189,"address":[4222977],"length":1,"stats":{"Line":1}},{"line":190,"address":[4225176,4223067,4223146,4225152],"length":1,"stats":{"Line":1}},{"line":193,"address":[4224565,4223576,4223382,4223440],"length":1,"stats":{"Line":2}},{"line":203,"address":[4223339],"length":1,"stats":{"Line":1}},{"line":204,"address":[4223366],"length":1,"stats":{"Line":1}},{"line":206,"address":[4223417,4223496,4225272,4225248],"length":1,"stats":{"Line":1}},{"line":209,"address":[4223681,4224548],"length":1,"stats":{"Line":1}},{"line":210,"address":[4224122],"length":1,"stats":{"Line":1}},{"line":211,"address":[4225128,4218062,4218341,4221087,4225105,4217825,4220043,4222509,4224125,4220885,4220411,4222375,4219795,4220646,4217977,4222213,4224683,4224707,4219724,4221558,4225391,4218873,4218607,4219527,4219176,4220553,4224663,4221737,4217907,4224558,4224571],"length":1,"stats":{"Line":2}}],"covered":79,"coverable":81},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","air_symbolic_to_circuit.rs"],"content":"mod common;\n\nuse p3_air::{Air, BaseAir};\nuse p3_circuit::utils::{ColumnsTargets, RowSelectorsTargets};\nuse p3_circuit::{CircuitBuilder, CircuitError};\nuse p3_circuit_prover::air::{AluAir, ConstAir, PublicAir, WitnessAir};\nuse p3_commit::ExtensionMmcs;\nuse p3_field::PrimeCharacteristicRing;\nuse p3_fri::TwoAdicFriPcs;\nuse p3_lookup::logup::LogUpGadget;\nuse p3_matrix::dense::RowMajorMatrixView;\nuse p3_matrix::stack::VerticalPair;\nuse p3_poseidon2_air::RoundConstants;\nuse p3_poseidon2_circuit_air::Poseidon2CircuitAirBabyBearD4Width16;\nuse p3_recursion::traits::{LookupMetadata, RecursiveAir};\nuse p3_recursion::types::RecursiveLagrangeSelectors;\nuse p3_uni_stark::{StarkConfig, SymbolicAirBuilder, VerifierConstraintFolder};\nuse rand::rngs::SmallRng;\nuse rand::{Rng, RngExt, SeedableRng};\n\nuse crate::common::baby_bear_params::*;\n\ntype Challenge = F;\ntype ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\ntype MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\ntype MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\nfn run_recursive\u003cA\u003e(\n    air: \u0026A,\n    preprocessed_width: usize,\n    num_public_values: usize,\n    rng: \u0026mut SmallRng,\n) -\u003e Result\u003c(), CircuitError\u003e\nwhere\n    A: BaseAir\u003cF\u003e\n        + RecursiveAir\u003cF, F, LogUpGadget\u003e\n        + Air\u003cSymbolicAirBuilder\u003cF\u003e\u003e\n        + for\u003c'a\u003e Air\u003cVerifierConstraintFolder\u003c'a, MyConfig\u003e\u003e,\n{\n    let width = RecursiveAir::width(air);\n\n    let mut trace_local: Vec\u003cF\u003e = (0..width).map(|_| rng.random()).collect();\n    let mut trace_next: Vec\u003cF\u003e = (0..width).map(|_| rng.random()).collect();\n    let mut preprocessed_local: Vec\u003cF\u003e = (0..preprocessed_width).map(|_| rng.random()).collect();\n    let mut preprocessed_next: Vec\u003cF\u003e = (0..preprocessed_width).map(|_| rng.random()).collect();\n    let public_values: Vec\u003cF\u003e = (0..num_public_values)\n        .map(|_| F::from_u32(rng.next_u32()))\n        .collect();\n    let selectors: [F; 3] = [rng.random(), rng.random(), rng.random()];\n    let alpha: F = rng.random();\n\n    let main = VerticalPair::new(\n        RowMajorMatrixView::new_row(\u0026trace_local),\n        RowMajorMatrixView::new_row(\u0026trace_next),\n    );\n    let preprocessed = if preprocessed_width \u003e 0 {\n        Some(VerticalPair::new(\n            RowMajorMatrixView::new_row(\u0026preprocessed_local),\n            RowMajorMatrixView::new_row(\u0026preprocessed_next),\n        ))\n    } else {\n        None\n    };\n    let mut folder: VerifierConstraintFolder\u003c'_, MyConfig\u003e = VerifierConstraintFolder {\n        main,\n        preprocessed,\n        public_values: \u0026public_values,\n        is_first_row: selectors[0],\n        is_last_row: selectors[1],\n        is_transition: selectors[2],\n        alpha,\n        accumulator: F::ZERO,\n    };\n    air.eval(\u0026mut folder);\n    let folded_value = folder.accumulator;\n\n    let mut builder = CircuitBuilder::\u003cF\u003e::new();\n    let selector_targets = [\n        builder.public_input(),\n        builder.public_input(),\n        builder.public_input(),\n    ];\n    let public_targets: Vec\u003c_\u003e = (0..num_public_values)\n        .map(|_| builder.public_input())\n        .collect();\n\n    let pre_local_targets: Vec\u003c_\u003e = (0..preprocessed_width)\n        .map(|_| builder.public_input())\n        .collect();\n    let pre_next_targets: Vec\u003c_\u003e = (0..preprocessed_width)\n        .map(|_| builder.public_input())\n        .collect();\n    let local_targets: Vec\u003c_\u003e = (0..width).map(|_| builder.public_input()).collect();\n    let next_targets: Vec\u003c_\u003e = (0..width).map(|_| builder.public_input()).collect();\n\n    let row_selectors = RowSelectorsTargets {\n        is_first_row: selector_targets[0],\n        is_last_row: selector_targets[1],\n        is_transition: selector_targets[2],\n    };\n\n    let columns = ColumnsTargets {\n        challenges: \u0026[],\n        public_values: \u0026public_targets,\n        permutation_local_values: \u0026[],\n        permutation_next_values: \u0026[],\n        local_prep_values: \u0026pre_local_targets,\n        next_prep_values: \u0026pre_next_targets,\n        local_values: \u0026local_targets,\n        next_values: \u0026next_targets,\n    };\n\n    let alpha_t = builder.define_const(alpha);\n    let sels = RecursiveLagrangeSelectors {\n        row_selectors,\n        inv_vanishing: builder.define_const(F::ONE),\n    };\n    let lookup_gadget = LogUpGadget {};\n    let dummy_lookup_metadata = LookupMetadata {\n        contexts: \u0026[],\n        lookup_data: \u0026[],\n    };\n    let sum = air.eval_folded_circuit(\n        \u0026mut builder,\n        \u0026sels,\n        \u0026alpha_t,\n        \u0026dummy_lookup_metadata,\n        columns,\n        \u0026lookup_gadget,\n    );\n    let const_target = builder.define_const(folded_value);\n    builder.connect(const_target, sum);\n\n    let mut all_public_inputs = Vec::new();\n    all_public_inputs.extend_from_slice(\u0026selectors);\n    all_public_inputs.extend_from_slice(\u0026public_values);\n    all_public_inputs.append(\u0026mut preprocessed_local);\n    all_public_inputs.append(\u0026mut preprocessed_next);\n    all_public_inputs.append(\u0026mut trace_local);\n    all_public_inputs.append(\u0026mut trace_next);\n\n    let circuit = builder.build()?;\n    let mut runner = circuit.runner();\n    runner.set_public_inputs(\u0026all_public_inputs)?;\n    runner.run()?;\n\n    Ok(())\n}\n\n#[test]\nfn primitive_airs_symbolic_to_circuit() -\u003e Result\u003c(), CircuitError\u003e {\n    let mut rng = SmallRng::seed_from_u64(7);\n\n    // AluAir preprocessed format (per op, multiplicity added by AIR): [sel_add_vs_mul, sel_bool, sel_muladd, a_idx, b_idx, c_idx, out_idx]\n    // For an ADD operation: sel_add_vs_mul=1, sel_bool=0, sel_muladd=0\n    let alu_add_prep = vec![\n        F::ONE,  // sel_add_vs_mul\n        F::ZERO, // sel_bool\n        F::ZERO, // sel_muladd\n        F::ZERO,\n        F::ONE,\n        F::ZERO,\n        F::from_u64(2), // a_idx, b_idx, c_idx, out_idx\n    ];\n    let alu_air = AluAir::\u003cF, 1\u003e::new_with_preprocessed(1, 1, alu_add_prep);\n    run_recursive(\u0026alu_air, alu_air.preprocessed_width(), 0, \u0026mut rng)?;\n\n    let const_air = ConstAir::\u003cF, 1\u003e::new_with_preprocessed(1, vec![F::from_u64(3)]);\n    run_recursive(\n        \u0026const_air,\n        ConstAir::\u003cF, 1\u003e::preprocessed_width(),\n        0,\n        \u0026mut rng,\n    )?;\n\n    let public_air = PublicAir::\u003cF, 1\u003e::new_with_preprocessed(1, 1, vec![F::from_u64(4)]);\n    run_recursive(\u0026public_air, public_air.preprocessed_width(), 1, \u0026mut rng)?;\n\n    let witness_air = WitnessAir::\u003cF, 1\u003e::new(1, 1);\n    run_recursive(\u0026witness_air, witness_air.preprocessed_width(), 0, \u0026mut rng)?;\n\n    Ok(())\n}\n\n#[test]\nfn poseidon2_perm_air_symbolic_to_circuit() -\u003e Result\u003c(), CircuitError\u003e {\n    let mut rng = SmallRng::seed_from_u64(9);\n\n    let constants = RoundConstants::new(rng.random(), rng.random(), rng.random());\n    let preprocessed_width = Poseidon2CircuitAirBabyBearD4Width16::preprocessed_width();\n    let preprocessed_values: Vec\u003cF\u003e = (0..preprocessed_width).map(|_| rng.random()).collect();\n    let air =\n        Poseidon2CircuitAirBabyBearD4Width16::new_with_preprocessed(constants, preprocessed_values);\n\n    run_recursive(\u0026air, preprocessed_width, 0, \u0026mut rng)\n}\n","traces":[{"line":1,"address":[1873200],"length":1,"stats":{"Line":1}},{"line":28,"address":[1857827,1863168,1847184,1852499,1841856,1868483,1846929,1857840,1868241,1863155,1847171,1852512,1857585,1852257,1862913],"length":1,"stats":{"Line":5}},{"line":40,"address":[1852628,1857956,1841972,1847300,1863284],"length":1,"stats":{"Line":5}},{"line":42,"address":[1869008,1863379,1847395,1869696,1868720,1869982,1842067,1868734,1852723,1869968,1869022,1858051,1869312,1869326,1869710],"length":1,"stats":{"Line":15}},{"line":43,"address":[1847453,1852781,1868944,1847520,1869582,1858109,1852848,1863504,1869728,1863437,1858176,1869344,1869358,1869376,1842192,1868958,1869390,1869742,1842125,1869568],"length":1,"stats":{"Line":20}},{"line":44,"address":[1869454,1847555,1842227,1842291,1858275,1868638,1852883,1868624,1852947,1858211,1869216,1863539,1869440,1870000,1870014,1869230,1847619,1863603,1868926,1868912],"length":1,"stats":{"Line":20}},{"line":45,"address":[1870080,1870112,1858310,1863702,1863638,1858374,1842390,1869664,1869856,1869870,1853046,1870094,1852982,1869678,1847654,1842326,1869760,1869774,1870126,1847718],"length":1,"stats":{"Line":20}},{"line":47,"address":[1869920,1842425,1868784,1853081,1869072,1868798,1869086,1869934,1847753,1868878,1868864,1858409,1863737,1870032,1870046],"length":1,"stats":{"Line":7}},{"line":48,"address":[1842489,1853145,1858473,1847817,1863801],"length":1,"stats":{"Line":5}},{"line":49,"address":[1853223,1842504,1842567,1858551,1858488,1847832,1847895,1863816,1863879,1853160],"length":1,"stats":{"Line":10}},{"line":50,"address":[1847981,1863965,1853309,1858637,1842653],"length":1,"stats":{"Line":5}},{"line":52,"address":[1848157,1853485,1842829,1864141,1858813],"length":1,"stats":{"Line":5}},{"line":53,"address":[1842689,1853345,1864001,1858673,1848017],"length":1,"stats":{"Line":5}},{"line":54,"address":[1858735,1853407,1864063,1848079,1842751],"length":1,"stats":{"Line":5}},{"line":56,"address":[1858828,1848172,1848190,1853783,1864156,1853518,1858846,1842862,1842844,1864174,1848455,1864439,1843127,1859111,1853500],"length":1,"stats":{"Line":10}},{"line":57,"address":[1848422,1859078,1853750,1864406,1843094],"length":1,"stats":{"Line":5}},{"line":58,"address":[1858856,1864184,1848200,1848329,1842872,1853528,1858985,1843001,1853657,1864313],"length":1,"stats":{"Line":10}},{"line":59,"address":[1853672,1864328,1843016,1848344,1859000],"length":1,"stats":{"Line":5}},{"line":62,"address":[1864162,1853506,1848178,1858834,1842850],"length":1,"stats":{"Line":0}},{"line":64,"address":[1843212,1859196,1848540,1864524,1853868],"length":1,"stats":{"Line":5}},{"line":66,"address":[1848223,1853551,1858879,1864207,1842895],"length":1,"stats":{"Line":5}},{"line":67,"address":[1848279,1853607,1858935,1842951,1864263],"length":1,"stats":{"Line":5}},{"line":68,"address":[1843132,1859116,1864444,1848460,1853788],"length":1,"stats":{"Line":5}},{"line":69,"address":[1848474,1853802,1843146,1859130,1864458],"length":1,"stats":{"Line":5}},{"line":70,"address":[1843205,1853861,1859189,1848533,1864517],"length":1,"stats":{"Line":5}},{"line":74,"address":[1848699,1854027,1843371,1864683,1859355],"length":1,"stats":{"Line":5}},{"line":75,"address":[1859362,1854034,1848706,1843378,1864690],"length":1,"stats":{"Line":5}},{"line":77,"address":[1859391,1864719,1848735,1854063,1843407],"length":1,"stats":{"Line":5}},{"line":78,"address":[1843558,1854070,1843414,1854214,1848886,1859542,1864726,1848742,1859398,1864870],"length":1,"stats":{"Line":10}},{"line":79,"address":[1843430,1859414,1864742,1854086,1848758],"length":1,"stats":{"Line":5}},{"line":80,"address":[1848821,1859477,1854149,1843493,1864805],"length":1,"stats":{"Line":5}},{"line":81,"address":[1864827,1859499,1848843,1843515,1854171],"length":1,"stats":{"Line":5}},{"line":84,"address":[1869888,1869120,1848927,1870158,1859583,1854255,1843599,1870144,1864911,1869040,1868510,1869054,1869902,1868496,1869134],"length":1,"stats":{"Line":7}},{"line":85,"address":[1854278,1864934,1859606,1843622,1848950],"length":1,"stats":{"Line":5}},{"line":88,"address":[1843657,1869838,1868752,1868766,1869262,1864969,1869646,1869248,1854313,1868702,1868688,1869824,1848985,1869632,1859641],"length":1,"stats":{"Line":15}},{"line":89,"address":[1859708,1843724,1854380,1865036,1849052],"length":1,"stats":{"Line":5}},{"line":91,"address":[1869550,1849087,1868592,1869792,1868670,1843759,1869614,1869536,1854415,1869806,1868656,1865071,1868606,1869600,1859743],"length":1,"stats":{"Line":15}},{"line":92,"address":[1849151,1854479,1859807,1865135,1843823],"length":1,"stats":{"Line":5}},{"line":93,"address":[1843858,1849250,1868560,1869504,1854514,1869472,1849186,1869486,1868832,1869166,1869518,1865170,1859842,1859906,1868846,1865234,1869152,1868574,1843922,1854578],"length":1,"stats":{"Line":20}},{"line":94,"address":[1868990,1869294,1854677,1854613,1868542,1849349,1865333,1869198,1869280,1868528,1869422,1849285,1859941,1860005,1868976,1843957,1844021,1869184,1865269,1869408],"length":1,"stats":{"Line":20}},{"line":96,"address":[1854735,1844079,1860063,1865391,1849407],"length":1,"stats":{"Line":5}},{"line":97,"address":[1854684,1860012,1844028,1865340,1849356],"length":1,"stats":{"Line":5}},{"line":98,"address":[1860028,1849372,1844044,1865356,1854700],"length":1,"stats":{"Line":5}},{"line":99,"address":[1849400,1860056,1865384,1854728,1844072],"length":1,"stats":{"Line":5}},{"line":102,"address":[1860498,1855170,1844514,1849842,1865826],"length":1,"stats":{"Line":5}},{"line":104,"address":[1844108,1865420,1854764,1860092,1849436],"length":1,"stats":{"Line":5}},{"line":107,"address":[1860199,1854871,1865527,1849543,1844215],"length":1,"stats":{"Line":5}},{"line":108,"address":[1865590,1860262,1849606,1854934,1844278],"length":1,"stats":{"Line":5}},{"line":109,"address":[1854997,1844341,1849669,1860325,1865653],"length":1,"stats":{"Line":5}},{"line":110,"address":[1844404,1855060,1860388,1865716,1849732],"length":1,"stats":{"Line":5}},{"line":113,"address":[1860658,1844674,1850002,1865986,1855330],"length":1,"stats":{"Line":5}},{"line":114,"address":[1844744,1866056,1855400,1860728,1850072],"length":1,"stats":{"Line":5}},{"line":116,"address":[1866027,1844715,1855371,1860699,1850043],"length":1,"stats":{"Line":5}},{"line":119,"address":[1866093,1850109,1860765,1844781,1855437],"length":1,"stats":{"Line":5}},{"line":123,"address":[1844829,1850157,1866141,1860813,1855485],"length":1,"stats":{"Line":5}},{"line":131,"address":[1855710,1861038,1866366,1850382,1845054],"length":1,"stats":{"Line":5}},{"line":132,"address":[1855753,1850425,1845097,1861081,1866409],"length":1,"stats":{"Line":5}},{"line":134,"address":[1855760,1845104,1850432,1866416,1861088],"length":1,"stats":{"Line":5}},{"line":135,"address":[1845144,1855800,1850472,1861128,1866456],"length":1,"stats":{"Line":5}},{"line":136,"address":[1855859,1850531,1861187,1866515,1845203],"length":1,"stats":{"Line":5}},{"line":137,"address":[1850589,1845261,1866573,1861245,1855917],"length":1,"stats":{"Line":5}},{"line":138,"address":[1845284,1861268,1850612,1866596,1855940],"length":1,"stats":{"Line":5}},{"line":139,"address":[1845307,1866619,1850635,1861291,1855963],"length":1,"stats":{"Line":5}},{"line":140,"address":[1850658,1866642,1855986,1845330,1861314],"length":1,"stats":{"Line":5}},{"line":142,"address":[1857609,1846953,1868265,1861321,1850665,1866649,1852281,1855993,1862937,1845337],"length":1,"stats":{"Line":5}},{"line":143,"address":[1856463,1867035,1861707,1845807,1845723,1851051,1856379,1867119,1861791,1851135],"length":1,"stats":{"Line":10}},{"line":144,"address":[1867135,1852185,1867216,1851232,1851151,1846857,1856560,1861807,1845823,1862841,1845904,1856479,1861888,1857513,1868169],"length":1,"stats":{"Line":10}},{"line":145,"address":[1846168,1868155,1862152,1851496,1846843,1852171,1867480,1857499,1862827,1856824],"length":1,"stats":{"Line":5}},{"line":147,"address":[1867905,1857249,1846593,1862577,1851921],"length":1,"stats":{"Line":5}},{"line":148,"address":[1852212,1843964,1851168,1857515,1858116,1858317,1859428,1849193,1853174,1859948,1861824,1863444,1859648,1865276,1866463,1854787,1845840,1846955,1857599,1862580,1843664,1867908,1842333,1863645,1858502,1868171,1846859,1856422,1864976,1845151,1867152,1851924,1862939,1843444,1854521,1858218,1860115,1862829,1861750,1864756,1857540,1865078,1848772,1850479,1863546,1856496,1867078,1846943,1868267,1849459,1854100,1858416,1857501,1846884,1854620,1868255,1847846,1848992,1857611,1859750,1852788,1863744,1842432,1862868,1861135,1868157,1845766,1849292,1846845,1852187,1852283,1852989,1847460,1843766,1853088,1849094,1854320,1854422,1859849,1863830,1851094,1847760,1862927,1868196,1842518,1852271,1865177,1865443,1862843,1855807,1847661,1857252,1847562,1852173,1842132,1846596,1842234,1844131,1843865,1852890],"length":1,"stats":{"Line":5}},{"line":151,"address":[1870176,1872608,1872541,1872583,1872626],"length":1,"stats":{"Line":3}},{"line":152,"address":[1870206],"length":1,"stats":{"Line":1}},{"line":156,"address":[1870258,1870523,1870221,1870290],"length":1,"stats":{"Line":2}},{"line":163,"address":[1870239],"length":1,"stats":{"Line":1}},{"line":165,"address":[1870440],"length":1,"stats":{"Line":1}},{"line":166,"address":[1872581,1870609,1870511],"length":1,"stats":{"Line":2}},{"line":168,"address":[1870875],"length":1,"stats":{"Line":1}},{"line":169,"address":[1871192,1871348,1872564],"length":1,"stats":{"Line":1}},{"line":171,"address":[1871107],"length":1,"stats":{"Line":1}},{"line":174,"address":[1871268],"length":1,"stats":{"Line":0}},{"line":176,"address":[1871458],"length":1,"stats":{"Line":1}},{"line":177,"address":[1871701,1871787,1872547],"length":1,"stats":{"Line":2}},{"line":179,"address":[1872061],"length":1,"stats":{"Line":1}},{"line":180,"address":[1872079,1872164],"length":1,"stats":{"Line":2}},{"line":182,"address":[1872437],"length":1,"stats":{"Line":1}},{"line":183,"address":[1872566,1871721,1870544,1872099,1872448,1872557,1872655,1871127],"length":1,"stats":{"Line":2}},{"line":186,"address":[1873104,1873091,1873085,1872672,1873122],"length":1,"stats":{"Line":3}},{"line":187,"address":[1872704],"length":1,"stats":{"Line":1}},{"line":189,"address":[1872727],"length":1,"stats":{"Line":1}},{"line":190,"address":[1872815],"length":1,"stats":{"Line":1}},{"line":191,"address":[1873168,1873182,1872867],"length":1,"stats":{"Line":3}},{"line":193,"address":[1872920],"length":1,"stats":{"Line":1}},{"line":195,"address":[1873010],"length":1,"stats":{"Line":1}},{"line":196,"address":[1873017,1873058,1873151],"length":1,"stats":{"Line":2}}],"covered":92,"coverable":94},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","challenger_transcript.rs"],"content":"//! Transcript compatibility tests for CircuitChallenger vs native DuplexChallenger.\n//!\n//! These tests verify that the recursive CircuitChallenger produces identical\n//! transcript values as the native Plonky3 DuplexChallenger.\n\nmod common;\n\nuse p3_baby_bear::{BabyBear, default_babybear_poseidon2_16};\nuse p3_challenger::{CanObserve, CanSample, DuplexChallenger, FieldChallenger};\nuse p3_circuit::ops::generate_poseidon2_trace;\nuse p3_circuit::{CircuitBuilder, Traces};\nuse p3_field::extension::BinomialExtensionField;\nuse p3_field::{BasedVectorSpace, PrimeCharacteristicRing};\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\nuse p3_recursion::challenger::CircuitChallenger;\nuse p3_recursion::traits::RecursiveChallenger;\n\ntype F = BabyBear;\ntype EF = BinomialExtensionField\u003cF, 4\u003e;\nconst WIDTH: usize = 16;\nconst RATE: usize = 8;\n\nfn setup_circuit_with_poseidon2() -\u003e CircuitBuilder\u003cEF\u003e {\n    let mut circuit = CircuitBuilder::\u003cEF\u003e::new();\n    let perm = default_babybear_poseidon2_16();\n    circuit.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cEF, BabyBearD4Width16\u003e,\n        perm,\n    );\n    circuit\n}\n\n/// Test basic observe/sample transcript compatibility.\n#[test]\nfn test_transcript_single_observe_sample() {\n    let perm = default_babybear_poseidon2_16();\n\n    // Native challenger\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n\n    // Circuit challenger\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Observe a single value\n    let val = F::from_u64(42);\n    native.observe(val);\n    let val_target = circuit.define_const(EF::from(val));\n    RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, val_target);\n\n    // Fill to RATE to trigger duplexing\n    for i in 1..RATE {\n        let v = F::from_u64(i as u64);\n        native.observe(v);\n        let v_t = circuit.define_const(EF::from(v));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, v_t);\n    }\n\n    // Sample and compare\n    let native_sample: F = native.sample();\n    let circuit_sample =\n        RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n\n    // Connect circuit sample to expected native value\n    let expected = circuit.define_const(EF::from(native_sample));\n    circuit.connect(circuit_sample, expected);\n\n    // Build and run - if values match, no WitnessConflict\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let runner = compiled.runner();\n    let traces: Traces\u003cEF\u003e = runner\n        .run()\n        .expect(\"Single observe/sample should match native\");\n\n    assert!(\n        traces.witness_trace.num_rows() \u003e 0,\n        \"Should produce witness trace\"\n    );\n}\n\n/// Test observe_ext matches native observe_base_as_algebra_element.\n#[test]\nfn test_transcript_observe_ext_compatibility() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Observe a base value as algebra element (like batch-STARK does)\n    let base_val = F::from_usize(123);\n    native.observe_base_as_algebra_element::\u003cEF\u003e(base_val);\n    let val_target = circuit.define_const(EF::from(base_val));\n    RecursiveChallenger::\u003cF, EF\u003e::observe_ext(\u0026mut circuit_challenger, \u0026mut circuit, val_target);\n\n    // Observe another value\n    let base_val2 = F::from_usize(456);\n    native.observe_base_as_algebra_element::\u003cEF\u003e(base_val2);\n    let val_target2 = circuit.define_const(EF::from(base_val2));\n    RecursiveChallenger::\u003cF, EF\u003e::observe_ext(\u0026mut circuit_challenger, \u0026mut circuit, val_target2);\n\n    // Sample extension element\n    let native_ext: EF = native.sample_algebra_element();\n    let circuit_ext =\n        RecursiveChallenger::\u003cF, EF\u003e::sample_ext(\u0026mut circuit_challenger, \u0026mut circuit);\n\n    let expected = circuit.define_const(native_ext);\n    circuit.connect(circuit_ext, expected);\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"observe_ext should match native observe_base_as_algebra_element\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n/// Test multiple duplexing rounds maintain transcript compatibility.\n#[test]\nfn test_transcript_multiple_duplexing_rounds() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // First round: observe RATE elements\n    for i in 0..RATE {\n        let val = F::from_u64(i as u64 + 100);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Sample after first round\n    let native_s1: F = native.sample();\n    let circuit_s1 = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_s1 = circuit.define_const(EF::from(native_s1));\n    circuit.connect(circuit_s1, expected_s1);\n\n    // Second round: observe more elements\n    for i in 0..RATE {\n        let val = F::from_u64(i as u64 + 200);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Sample after second round\n    let native_s2: F = native.sample();\n    let circuit_s2 = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_s2 = circuit.define_const(EF::from(native_s2));\n    circuit.connect(circuit_s2, expected_s2);\n\n    // Third round with extension samples\n    for i in 0..4 {\n        let val = F::from_u64(i as u64 + 300);\n        native.observe_base_as_algebra_element::\u003cEF\u003e(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe_ext(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    let native_ext: EF = native.sample_algebra_element();\n    let circuit_ext =\n        RecursiveChallenger::\u003cF, EF\u003e::sample_ext(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_ext = circuit.define_const(native_ext);\n    circuit.connect(circuit_ext, expected_ext);\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Multiple duplexing rounds should match native\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n/// Test partial absorption (less than RATE) then sample.\n#[test]\nfn test_transcript_partial_absorption() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Observe only 3 elements (less than RATE=8)\n    for i in 0..3 {\n        let val = F::from_u64(i as u64 + 50);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Sample triggers duplexing with partial input\n    let native_sample: F = native.sample();\n    let circuit_sample =\n        RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n\n    let expected = circuit.define_const(EF::from(native_sample));\n    circuit.connect(circuit_sample, expected);\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Partial absorption should match native\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n/// Test extension field element observation (observe_algebra_element equivalent).\n#[test]\nfn test_transcript_observe_extension_element() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Create extension field elements\n    let ext_val = EF::from_basis_coefficients_slice(\u0026[\n        F::from_u64(10),\n        F::from_u64(20),\n        F::from_u64(30),\n        F::from_u64(40),\n    ])\n    .unwrap();\n\n    // Native: observe_algebra_element decomposes to D coefficients\n    native.observe_algebra_element(ext_val);\n    // Circuit: observe_ext does the same decomposition\n    let ext_target = circuit.define_const(ext_val);\n    RecursiveChallenger::\u003cF, EF\u003e::observe_ext(\u0026mut circuit_challenger, \u0026mut circuit, ext_target);\n\n    // Observe more to trigger duplexing\n    let ext_val2 = EF::from_basis_coefficients_slice(\u0026[\n        F::from_u64(11),\n        F::from_u64(21),\n        F::from_u64(31),\n        F::from_u64(41),\n    ])\n    .unwrap();\n    native.observe_algebra_element(ext_val2);\n    let ext_target2 = circuit.define_const(ext_val2);\n    RecursiveChallenger::\u003cF, EF\u003e::observe_ext(\u0026mut circuit_challenger, \u0026mut circuit, ext_target2);\n\n    // Sample and compare\n    let native_ext: EF = native.sample_algebra_element();\n    let circuit_ext =\n        RecursiveChallenger::\u003cF, EF\u003e::sample_ext(\u0026mut circuit_challenger, \u0026mut circuit);\n\n    let expected = circuit.define_const(native_ext);\n    circuit.connect(circuit_ext, expected);\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Extension element observation should match native\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n/// Test mixed observation types (base and extension).\n#[test]\nfn test_transcript_mixed_observations() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Mix of base field observations\n    for i in 0..3 {\n        let val = F::from_u64(i as u64);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Extension field observation\n    let base_as_ext = F::from_usize(999);\n    native.observe_base_as_algebra_element::\u003cEF\u003e(base_as_ext);\n    let t = circuit.define_const(EF::from(base_as_ext));\n    RecursiveChallenger::\u003cF, EF\u003e::observe_ext(\u0026mut circuit_challenger, \u0026mut circuit, t);\n\n    // More base observations\n    for i in 0..2 {\n        let val = F::from_u64(i as u64 + 100);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Sample base field element\n    let native_base: F = native.sample();\n    let circuit_base = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_base = circuit.define_const(EF::from(native_base));\n    circuit.connect(circuit_base, expected_base);\n\n    // Sample extension field element\n    let native_ext: EF = native.sample_algebra_element();\n    let circuit_ext =\n        RecursiveChallenger::\u003cF, EF\u003e::sample_ext(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_ext = circuit.define_const(native_ext);\n    circuit.connect(circuit_ext, expected_ext);\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Mixed observations should match native\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n/// Test circuit challenger clear functionality.\n/// Native DuplexChallenger doesn't have clear, so we verify circuit clear\n/// produces consistent state (fresh zero state).\n#[test]\nfn test_transcript_clear_produces_fresh_state() {\n    let perm = default_babybear_poseidon2_16();\n\n    // Create a fresh native challenger (simulating what clear does)\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // First, do some observations to dirty the state\n    for i in 0..5 {\n        let val = F::from_u64(i as u64);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Clear circuit challenger (resets to fresh zero state)\n    RecursiveChallenger::\u003cF, EF\u003e::clear(\u0026mut circuit_challenger, \u0026mut circuit);\n\n    // Now both should be in equivalent fresh states\n    // Observe same values in both\n    for i in 0..RATE {\n        let val = F::from_u64(i as u64 + 1000);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Sample should match\n    let native_sample: F = native.sample();\n    let circuit_sample =\n        RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n\n    let expected = circuit.define_const(EF::from(native_sample));\n    circuit.connect(circuit_sample, expected);\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Clear should produce fresh state matching new challenger\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n/// Test multiple consecutive samples without intermediate observations.\n#[test]\nfn test_transcript_consecutive_samples() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Initial observations\n    for i in 0..RATE {\n        let val = F::from_u64(i as u64 + 77);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Multiple consecutive samples\n    for _ in 0..5 {\n        let native_s: F = native.sample();\n        let circuit_s = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n        let expected = circuit.define_const(EF::from(native_s));\n        circuit.connect(circuit_s, expected);\n    }\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Consecutive samples should match native\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n// ============================================================================\n// Edge Case Tests\n// ============================================================================\n\n/// Edge case: Exactly RATE observations triggers duplexing, then sample.\n/// Tests the boundary condition when input buffer is exactly full.\n#[test]\nfn test_edge_case_exactly_rate_observations() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Observe exactly RATE elements (should trigger duplexing on last observe)\n    for i in 0..RATE {\n        let val = F::from_u64(i as u64 + 500);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // At this point, input buffer should be empty (duplexing occurred)\n    // and output buffer should be full\n\n    // Sample should come from output buffer without triggering new duplexing\n    let native_s1: F = native.sample();\n    let circuit_s1 = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_s1 = circuit.define_const(EF::from(native_s1));\n    circuit.connect(circuit_s1, expected_s1);\n\n    // Sample again to verify output buffer state\n    let native_s2: F = native.sample();\n    let circuit_s2 = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_s2 = circuit.define_const(EF::from(native_s2));\n    circuit.connect(circuit_s2, expected_s2);\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Exactly RATE observations should match native\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n/// Edge case: Drain entire output buffer (RATE samples) then sample again.\n/// This triggers a new duplexing when output buffer is empty.\n#[test]\nfn test_edge_case_drain_output_buffer_completely() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Observe RATE elements to trigger duplexing\n    for i in 0..RATE {\n        let val = F::from_u64(i as u64 + 600);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Drain entire output buffer (RATE samples)\n    for j in 0..RATE {\n        let native_s: F = native.sample();\n        let circuit_s = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n        let expected = circuit.define_const(EF::from(native_s));\n        circuit.connect(circuit_s, expected);\n\n        // Verify we got a valid sample at each step\n        if j == RATE - 1 {\n            // Last sample from output buffer\n        }\n    }\n\n    // Now output buffer is empty - this sample should trigger new duplexing\n    let native_extra: F = native.sample();\n    let circuit_extra = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_extra = circuit.define_const(EF::from(native_extra));\n    circuit.connect(circuit_extra, expected_extra);\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Draining output buffer then sampling should match native\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n/// Edge case: Interleaved observe/sample pattern.\n/// Tests complex state transitions with alternating operations.\n#[test]\nfn test_edge_case_interleaved_observe_sample() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Pattern: observe a few, sample, observe more, sample, etc.\n    // This tests output buffer invalidation on observe\n\n    // Observe 3\n    for i in 0..3 {\n        let val = F::from_u64(i as u64 + 700);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Sample (triggers duplexing with 3 inputs)\n    let native_s1: F = native.sample();\n    let circuit_s1 = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_s1 = circuit.define_const(EF::from(native_s1));\n    circuit.connect(circuit_s1, expected_s1);\n\n    // Observe 2 more (invalidates output buffer)\n    for i in 0..2 {\n        let val = F::from_u64(i as u64 + 800);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Sample (triggers new duplexing with 2 inputs)\n    let native_s2: F = native.sample();\n    let circuit_s2 = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_s2 = circuit.define_const(EF::from(native_s2));\n    circuit.connect(circuit_s2, expected_s2);\n\n    // Sample again (from output buffer)\n    let native_s3: F = native.sample();\n    let circuit_s3 = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_s3 = circuit.define_const(EF::from(native_s3));\n    circuit.connect(circuit_s3, expected_s3);\n\n    // Observe 1 more\n    let val = F::from_u64(900);\n    native.observe(val);\n    let t = circuit.define_const(EF::from(val));\n    RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n\n    // Final sample\n    let native_s4: F = native.sample();\n    let circuit_s4 = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_s4 = circuit.define_const(EF::from(native_s4));\n    circuit.connect(circuit_s4, expected_s4);\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Interleaved observe/sample should match native\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n/// Edge case: Sample immediately without any observations.\n/// Tests initial state sampling behavior.\n#[test]\nfn test_edge_case_sample_without_observations() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Sample immediately (duplexing with zero-initialized state)\n    let native_s1: F = native.sample();\n    let circuit_s1 = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_s1 = circuit.define_const(EF::from(native_s1));\n    circuit.connect(circuit_s1, expected_s1);\n\n    // Sample again\n    let native_s2: F = native.sample();\n    let circuit_s2 = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_s2 = circuit.define_const(EF::from(native_s2));\n    circuit.connect(circuit_s2, expected_s2);\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Sample without observations should match native\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n/// Edge case: Observe single element then sample multiple times.\n/// Tests output buffer usage after minimal input.\n#[test]\nfn test_edge_case_single_observe_multiple_samples() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Single observation\n    let val = F::from_u64(12345);\n    native.observe(val);\n    let t = circuit.define_const(EF::from(val));\n    RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n\n    // Multiple samples (first triggers duplexing, rest from buffer)\n    for _ in 0..RATE {\n        let native_s: F = native.sample();\n        let circuit_s = RecursiveChallenger::\u003cF, EF\u003e::sample(\u0026mut circuit_challenger, \u0026mut circuit);\n        let expected = circuit.define_const(EF::from(native_s));\n        circuit.connect(circuit_s, expected);\n    }\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Single observe then multiple samples should match native\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n\n/// Edge case: Extension field samples draining output buffer.\n/// Each sample_ext consumes D base elements from output.\n#[test]\nfn test_edge_case_extension_samples_drain_buffer() {\n    let perm = default_babybear_poseidon2_16();\n\n    let mut native = DuplexChallenger::\u003cF, _, WIDTH, RATE\u003e::new(perm);\n    let mut circuit = setup_circuit_with_poseidon2();\n    let mut circuit_challenger = CircuitChallenger::\u003cWIDTH, RATE\u003e::new_babybear();\n\n    // Observe RATE elements\n    for i in 0..RATE {\n        let val = F::from_u64(i as u64 + 1000);\n        native.observe(val);\n        let t = circuit.define_const(EF::from(val));\n        RecursiveChallenger::\u003cF, EF\u003e::observe(\u0026mut circuit_challenger, \u0026mut circuit, t);\n    }\n\n    // Sample extension elements (each consumes 4 base elements from RATE=8 buffer)\n    // After 2 ext samples, buffer is empty\n    let native_ext1: EF = native.sample_algebra_element();\n    let circuit_ext1 =\n        RecursiveChallenger::\u003cF, EF\u003e::sample_ext(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_ext1 = circuit.define_const(native_ext1);\n    circuit.connect(circuit_ext1, expected_ext1);\n\n    let native_ext2: EF = native.sample_algebra_element();\n    let circuit_ext2 =\n        RecursiveChallenger::\u003cF, EF\u003e::sample_ext(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_ext2 = circuit.define_const(native_ext2);\n    circuit.connect(circuit_ext2, expected_ext2);\n\n    // Third ext sample should trigger new duplexing\n    let native_ext3: EF = native.sample_algebra_element();\n    let circuit_ext3 =\n        RecursiveChallenger::\u003cF, EF\u003e::sample_ext(\u0026mut circuit_challenger, \u0026mut circuit);\n    let expected_ext3 = circuit.define_const(native_ext3);\n    circuit.connect(circuit_ext3, expected_ext3);\n\n    let compiled = circuit.build().expect(\"Circuit should build\");\n    let traces: Traces\u003cEF\u003e = compiled\n        .runner()\n        .run()\n        .expect(\"Extension samples draining buffer should match native\");\n\n    assert!(traces.witness_trace.num_rows() \u003e 0);\n}\n","traces":[{"line":1,"address":[1596768],"length":1,"stats":{"Line":1}},{"line":23,"address":[1576437,1576431,1576208],"length":1,"stats":{"Line":4}},{"line":24,"address":[1576230],"length":1,"stats":{"Line":4}},{"line":25,"address":[1576235],"length":1,"stats":{"Line":2}},{"line":26,"address":[1576291],"length":1,"stats":{"Line":2}},{"line":30,"address":[1576403],"length":1,"stats":{"Line":2}},{"line":31,"address":[1576423,1576259],"length":1,"stats":{"Line":2}},{"line":35,"address":[1581923,1580640,1581954,1581788,1581936],"length":1,"stats":{"Line":3}},{"line":36,"address":[1580647],"length":1,"stats":{"Line":1}},{"line":39,"address":[1580669],"length":1,"stats":{"Line":1}},{"line":42,"address":[1580775],"length":1,"stats":{"Line":1}},{"line":43,"address":[1580822],"length":1,"stats":{"Line":1}},{"line":46,"address":[1580940,1580888],"length":1,"stats":{"Line":2}},{"line":47,"address":[1580955],"length":1,"stats":{"Line":1}},{"line":48,"address":[1580974],"length":1,"stats":{"Line":1}},{"line":49,"address":[1581035],"length":1,"stats":{"Line":1}},{"line":52,"address":[1581042],"length":1,"stats":{"Line":1}},{"line":53,"address":[1581184,1581798],"length":1,"stats":{"Line":2}},{"line":54,"address":[1581813],"length":1,"stats":{"Line":1}},{"line":55,"address":[1581832],"length":1,"stats":{"Line":1}},{"line":56,"address":[1581893],"length":1,"stats":{"Line":1}},{"line":60,"address":[1581206],"length":1,"stats":{"Line":1}},{"line":62,"address":[1581244],"length":1,"stats":{"Line":1}},{"line":65,"address":[1581278],"length":1,"stats":{"Line":1}},{"line":66,"address":[1581335],"length":1,"stats":{"Line":1}},{"line":69,"address":[1581342],"length":1,"stats":{"Line":1}},{"line":70,"address":[1581480],"length":1,"stats":{"Line":1}},{"line":71,"address":[1581535],"length":1,"stats":{"Line":1}},{"line":72,"address":[1581550],"length":1,"stats":{"Line":1}},{"line":73,"address":[1581557],"length":1,"stats":{"Line":1}},{"line":75,"address":[1581670,1581724],"length":1,"stats":{"Line":0}},{"line":76,"address":[1581607,1581664],"length":1,"stats":{"Line":2}},{"line":79,"address":[1581752,1580907,1581707,1581627,1580790,1581913,1580845,1581973],"length":1,"stats":{"Line":3}},{"line":83,"address":[1587616,1588672,1588629,1588690,1588653],"length":1,"stats":{"Line":3}},{"line":84,"address":[1587623],"length":1,"stats":{"Line":1}},{"line":86,"address":[1587645],"length":1,"stats":{"Line":1}},{"line":87,"address":[1587736],"length":1,"stats":{"Line":1}},{"line":88,"address":[1587780],"length":1,"stats":{"Line":1}},{"line":91,"address":[1587898,1587846],"length":1,"stats":{"Line":2}},{"line":92,"address":[1587910],"length":1,"stats":{"Line":1}},{"line":93,"address":[1587929],"length":1,"stats":{"Line":1}},{"line":94,"address":[1587990],"length":1,"stats":{"Line":1}},{"line":97,"address":[1588002],"length":1,"stats":{"Line":1}},{"line":98,"address":[1588029],"length":1,"stats":{"Line":1}},{"line":99,"address":[1588048],"length":1,"stats":{"Line":1}},{"line":100,"address":[1588109],"length":1,"stats":{"Line":1}},{"line":103,"address":[1588129],"length":1,"stats":{"Line":1}},{"line":105,"address":[1588152],"length":1,"stats":{"Line":1}},{"line":107,"address":[1588174],"length":1,"stats":{"Line":1}},{"line":108,"address":[1588240],"length":1,"stats":{"Line":1}},{"line":110,"address":[1588247],"length":1,"stats":{"Line":1}},{"line":111,"address":[1588385],"length":1,"stats":{"Line":1}},{"line":112,"address":[1588400],"length":1,"stats":{"Line":1}},{"line":113,"address":[1588423],"length":1,"stats":{"Line":1}},{"line":114,"address":[1588430],"length":1,"stats":{"Line":1}},{"line":116,"address":[1588535,1588480],"length":1,"stats":{"Line":2}},{"line":117,"address":[1588579,1587803,1588643,1587748,1588709,1587865,1588499],"length":1,"stats":{"Line":2}},{"line":121,"address":[1585440,1587568,1587077,1587543,1587586],"length":1,"stats":{"Line":3}},{"line":122,"address":[1585447],"length":1,"stats":{"Line":1}},{"line":124,"address":[1585472],"length":1,"stats":{"Line":1}},{"line":125,"address":[1585581],"length":1,"stats":{"Line":1}},{"line":126,"address":[1585628],"length":1,"stats":{"Line":1}},{"line":129,"address":[1585689,1585778],"length":1,"stats":{"Line":2}},{"line":130,"address":[1585891,1587384],"length":1,"stats":{"Line":2}},{"line":131,"address":[1587435],"length":1,"stats":{"Line":1}},{"line":132,"address":[1587454],"length":1,"stats":{"Line":1}},{"line":133,"address":[1587513],"length":1,"stats":{"Line":1}},{"line":137,"address":[1585928],"length":1,"stats":{"Line":1}},{"line":138,"address":[1585972],"length":1,"stats":{"Line":1}},{"line":139,"address":[1586015],"length":1,"stats":{"Line":1}},{"line":140,"address":[1586081],"length":1,"stats":{"Line":1}},{"line":143,"address":[1586088],"length":1,"stats":{"Line":1}},{"line":144,"address":[1586235,1587233],"length":1,"stats":{"Line":2}},{"line":145,"address":[1587284],"length":1,"stats":{"Line":1}},{"line":146,"address":[1587303],"length":1,"stats":{"Line":1}},{"line":147,"address":[1587364],"length":1,"stats":{"Line":1}},{"line":151,"address":[1586271],"length":1,"stats":{"Line":1}},{"line":152,"address":[1586309],"length":1,"stats":{"Line":1}},{"line":153,"address":[1586343],"length":1,"stats":{"Line":1}},{"line":154,"address":[1586400],"length":1,"stats":{"Line":1}},{"line":157,"address":[1586414],"length":1,"stats":{"Line":1}},{"line":158,"address":[1586525,1587088],"length":1,"stats":{"Line":2}},{"line":159,"address":[1587136],"length":1,"stats":{"Line":1}},{"line":160,"address":[1587155],"length":1,"stats":{"Line":1}},{"line":161,"address":[1587216],"length":1,"stats":{"Line":1}},{"line":164,"address":[1586572],"length":1,"stats":{"Line":1}},{"line":166,"address":[1586595],"length":1,"stats":{"Line":1}},{"line":167,"address":[1586617],"length":1,"stats":{"Line":1}},{"line":168,"address":[1586683],"length":1,"stats":{"Line":1}},{"line":170,"address":[1586690],"length":1,"stats":{"Line":1}},{"line":171,"address":[1586828],"length":1,"stats":{"Line":1}},{"line":172,"address":[1586843],"length":1,"stats":{"Line":1}},{"line":173,"address":[1586866],"length":1,"stats":{"Line":1}},{"line":174,"address":[1586873],"length":1,"stats":{"Line":1}},{"line":176,"address":[1586980,1586923],"length":1,"stats":{"Line":2}},{"line":177,"address":[1585651,1585733,1587024,1586943,1587533,1587605,1585596],"length":1,"stats":{"Line":2}},{"line":181,"address":[1579112,1579281,1579314,1578160,1579296],"length":1,"stats":{"Line":3}},{"line":182,"address":[1578167],"length":1,"stats":{"Line":1}},{"line":184,"address":[1578189],"length":1,"stats":{"Line":1}},{"line":185,"address":[1578289],"length":1,"stats":{"Line":1}},{"line":186,"address":[1578336],"length":1,"stats":{"Line":1}},{"line":189,"address":[1578464,1578404],"length":1,"stats":{"Line":2}},{"line":190,"address":[1578552,1579123],"length":1,"stats":{"Line":2}},{"line":191,"address":[1579171],"length":1,"stats":{"Line":1}},{"line":192,"address":[1579190],"length":1,"stats":{"Line":1}},{"line":193,"address":[1579251],"length":1,"stats":{"Line":1}},{"line":197,"address":[1578589],"length":1,"stats":{"Line":1}},{"line":199,"address":[1578627],"length":1,"stats":{"Line":1}},{"line":201,"address":[1578661],"length":1,"stats":{"Line":1}},{"line":202,"address":[1578718],"length":1,"stats":{"Line":1}},{"line":204,"address":[1578725],"length":1,"stats":{"Line":1}},{"line":205,"address":[1578863],"length":1,"stats":{"Line":1}},{"line":206,"address":[1578878],"length":1,"stats":{"Line":1}},{"line":207,"address":[1578901],"length":1,"stats":{"Line":1}},{"line":208,"address":[1578908],"length":1,"stats":{"Line":1}},{"line":210,"address":[1578958,1579015],"length":1,"stats":{"Line":2}},{"line":211,"address":[1579333,1578304,1579059,1578359,1578978,1579271,1578427],"length":1,"stats":{"Line":2}},{"line":215,"address":[1590130,1588720,1590098,1590074,1590112],"length":1,"stats":{"Line":3}},{"line":216,"address":[1588727],"length":1,"stats":{"Line":1}},{"line":218,"address":[1588749],"length":1,"stats":{"Line":1}},{"line":219,"address":[1588846],"length":1,"stats":{"Line":1}},{"line":220,"address":[1588893],"length":1,"stats":{"Line":1}},{"line":223,"address":[1589071],"length":1,"stats":{"Line":1}},{"line":224,"address":[1588959],"length":1,"stats":{"Line":1}},{"line":225,"address":[1589012],"length":1,"stats":{"Line":1}},{"line":226,"address":[1589028],"length":1,"stats":{"Line":1}},{"line":227,"address":[1589044],"length":1,"stats":{"Line":1}},{"line":229,"address":[1589127],"length":1,"stats":{"Line":1}},{"line":232,"address":[1589157],"length":1,"stats":{"Line":1}},{"line":234,"address":[1589196],"length":1,"stats":{"Line":1}},{"line":235,"address":[1589266],"length":1,"stats":{"Line":1}},{"line":238,"address":[1589353],"length":1,"stats":{"Line":1}},{"line":239,"address":[1589278],"length":1,"stats":{"Line":1}},{"line":240,"address":[1589294],"length":1,"stats":{"Line":1}},{"line":241,"address":[1589310],"length":1,"stats":{"Line":1}},{"line":242,"address":[1589326],"length":1,"stats":{"Line":1}},{"line":244,"address":[1589409],"length":1,"stats":{"Line":1}},{"line":245,"address":[1589439],"length":1,"stats":{"Line":1}},{"line":246,"address":[1589478],"length":1,"stats":{"Line":1}},{"line":247,"address":[1589548],"length":1,"stats":{"Line":1}},{"line":250,"address":[1589571],"length":1,"stats":{"Line":1}},{"line":252,"address":[1589594],"length":1,"stats":{"Line":1}},{"line":254,"address":[1589616],"length":1,"stats":{"Line":1}},{"line":255,"address":[1589682],"length":1,"stats":{"Line":1}},{"line":257,"address":[1589689],"length":1,"stats":{"Line":1}},{"line":258,"address":[1589827],"length":1,"stats":{"Line":1}},{"line":259,"address":[1589842],"length":1,"stats":{"Line":1}},{"line":260,"address":[1589865],"length":1,"stats":{"Line":1}},{"line":261,"address":[1589872],"length":1,"stats":{"Line":1}},{"line":263,"address":[1589922,1589977],"length":1,"stats":{"Line":2}},{"line":264,"address":[1589941,1588861,1588978,1590088,1590149,1590021,1588916],"length":1,"stats":{"Line":2}},{"line":268,"address":[1578099,1578130,1577819,1576464,1578112],"length":1,"stats":{"Line":3}},{"line":269,"address":[1576471],"length":1,"stats":{"Line":1}},{"line":271,"address":[1576496],"length":1,"stats":{"Line":1}},{"line":272,"address":[1576605],"length":1,"stats":{"Line":1}},{"line":273,"address":[1576652],"length":1,"stats":{"Line":1}},{"line":276,"address":[1576720,1576780],"length":1,"stats":{"Line":2}},{"line":277,"address":[1576871,1577974],"length":1,"stats":{"Line":2}},{"line":278,"address":[1577989],"length":1,"stats":{"Line":1}},{"line":279,"address":[1578008],"length":1,"stats":{"Line":1}},{"line":280,"address":[1578069],"length":1,"stats":{"Line":1}},{"line":284,"address":[1576890],"length":1,"stats":{"Line":1}},{"line":285,"address":[1576920],"length":1,"stats":{"Line":1}},{"line":286,"address":[1576939],"length":1,"stats":{"Line":1}},{"line":287,"address":[1577000],"length":1,"stats":{"Line":1}},{"line":290,"address":[1577014],"length":1,"stats":{"Line":1}},{"line":291,"address":[1577830,1577125],"length":1,"stats":{"Line":2}},{"line":292,"address":[1577878],"length":1,"stats":{"Line":1}},{"line":293,"address":[1577897],"length":1,"stats":{"Line":1}},{"line":294,"address":[1577958],"length":1,"stats":{"Line":1}},{"line":298,"address":[1577162],"length":1,"stats":{"Line":1}},{"line":299,"address":[1577200],"length":1,"stats":{"Line":1}},{"line":300,"address":[1577234],"length":1,"stats":{"Line":1}},{"line":301,"address":[1577291],"length":1,"stats":{"Line":1}},{"line":304,"address":[1577314],"length":1,"stats":{"Line":1}},{"line":306,"address":[1577337],"length":1,"stats":{"Line":1}},{"line":307,"address":[1577359],"length":1,"stats":{"Line":1}},{"line":308,"address":[1577425],"length":1,"stats":{"Line":1}},{"line":310,"address":[1577432],"length":1,"stats":{"Line":1}},{"line":311,"address":[1577570],"length":1,"stats":{"Line":1}},{"line":312,"address":[1577585],"length":1,"stats":{"Line":1}},{"line":313,"address":[1577608],"length":1,"stats":{"Line":1}},{"line":314,"address":[1577615],"length":1,"stats":{"Line":1}},{"line":316,"address":[1577722,1577665],"length":1,"stats":{"Line":2}},{"line":317,"address":[1577766,1578149,1576743,1576620,1576675,1577685,1578089],"length":1,"stats":{"Line":2}},{"line":323,"address":[1592328,1592608,1591184,1592626,1592589],"length":1,"stats":{"Line":3}},{"line":324,"address":[1591191],"length":1,"stats":{"Line":1}},{"line":327,"address":[1591216],"length":1,"stats":{"Line":1}},{"line":329,"address":[1591325],"length":1,"stats":{"Line":1}},{"line":330,"address":[1591372],"length":1,"stats":{"Line":1}},{"line":333,"address":[1591440,1591500],"length":1,"stats":{"Line":2}},{"line":334,"address":[1591591,1592483],"length":1,"stats":{"Line":2}},{"line":335,"address":[1592498],"length":1,"stats":{"Line":1}},{"line":336,"address":[1592559],"length":1,"stats":{"Line":1}},{"line":340,"address":[1591621],"length":1,"stats":{"Line":1}},{"line":344,"address":[1591628],"length":1,"stats":{"Line":1}},{"line":345,"address":[1591769,1592339],"length":1,"stats":{"Line":2}},{"line":346,"address":[1592387],"length":1,"stats":{"Line":1}},{"line":347,"address":[1592406],"length":1,"stats":{"Line":1}},{"line":348,"address":[1592467],"length":1,"stats":{"Line":1}},{"line":352,"address":[1591805],"length":1,"stats":{"Line":1}},{"line":354,"address":[1591843],"length":1,"stats":{"Line":1}},{"line":356,"address":[1591877],"length":1,"stats":{"Line":1}},{"line":357,"address":[1591934],"length":1,"stats":{"Line":1}},{"line":359,"address":[1591941],"length":1,"stats":{"Line":1}},{"line":360,"address":[1592079],"length":1,"stats":{"Line":1}},{"line":361,"address":[1592094],"length":1,"stats":{"Line":1}},{"line":362,"address":[1592117],"length":1,"stats":{"Line":1}},{"line":363,"address":[1592124],"length":1,"stats":{"Line":1}},{"line":365,"address":[1592174,1592231],"length":1,"stats":{"Line":2}},{"line":366,"address":[1592194,1592275,1591340,1591463,1592645,1592579,1591395],"length":1,"stats":{"Line":2}},{"line":370,"address":[1579344,1580274,1580592,1580576,1580610],"length":1,"stats":{"Line":3}},{"line":371,"address":[1579351],"length":1,"stats":{"Line":1}},{"line":373,"address":[1579373],"length":1,"stats":{"Line":1}},{"line":374,"address":[1579476],"length":1,"stats":{"Line":1}},{"line":375,"address":[1579523],"length":1,"stats":{"Line":1}},{"line":378,"address":[1579584,1579661],"length":1,"stats":{"Line":2}},{"line":379,"address":[1579762,1580415],"length":1,"stats":{"Line":2}},{"line":380,"address":[1580466],"length":1,"stats":{"Line":1}},{"line":381,"address":[1580485],"length":1,"stats":{"Line":1}},{"line":382,"address":[1580546],"length":1,"stats":{"Line":1}},{"line":386,"address":[1579795],"length":1,"stats":{"Line":1}},{"line":387,"address":[1579873,1580284],"length":1,"stats":{"Line":2}},{"line":388,"address":[1580307],"length":1,"stats":{"Line":1}},{"line":389,"address":[1580341],"length":1,"stats":{"Line":1}},{"line":390,"address":[1580398],"length":1,"stats":{"Line":1}},{"line":393,"address":[1579887],"length":1,"stats":{"Line":1}},{"line":394,"address":[1580025],"length":1,"stats":{"Line":1}},{"line":395,"address":[1580040],"length":1,"stats":{"Line":1}},{"line":396,"address":[1580063],"length":1,"stats":{"Line":1}},{"line":397,"address":[1580070],"length":1,"stats":{"Line":1}},{"line":399,"address":[1580177,1580120],"length":1,"stats":{"Line":2}},{"line":400,"address":[1580629,1579491,1580221,1579546,1579622,1580140,1580566],"length":1,"stats":{"Line":2}},{"line":409,"address":[1583314,1583272,1583296,1583105,1581984],"length":1,"stats":{"Line":3}},{"line":410,"address":[1581991],"length":1,"stats":{"Line":1}},{"line":412,"address":[1582013],"length":1,"stats":{"Line":1}},{"line":413,"address":[1582116],"length":1,"stats":{"Line":1}},{"line":414,"address":[1582163],"length":1,"stats":{"Line":1}},{"line":417,"address":[1582224,1582301],"length":1,"stats":{"Line":2}},{"line":418,"address":[1582402,1583116],"length":1,"stats":{"Line":2}},{"line":419,"address":[1583164],"length":1,"stats":{"Line":1}},{"line":420,"address":[1583183],"length":1,"stats":{"Line":1}},{"line":421,"address":[1583242],"length":1,"stats":{"Line":1}},{"line":428,"address":[1582438],"length":1,"stats":{"Line":1}},{"line":429,"address":[1582476],"length":1,"stats":{"Line":1}},{"line":430,"address":[1582510],"length":1,"stats":{"Line":1}},{"line":431,"address":[1582567],"length":1,"stats":{"Line":1}},{"line":434,"address":[1582582],"length":1,"stats":{"Line":1}},{"line":435,"address":[1582620],"length":1,"stats":{"Line":1}},{"line":436,"address":[1582654],"length":1,"stats":{"Line":1}},{"line":437,"address":[1582711],"length":1,"stats":{"Line":1}},{"line":439,"address":[1582718],"length":1,"stats":{"Line":1}},{"line":440,"address":[1582856],"length":1,"stats":{"Line":1}},{"line":441,"address":[1582871],"length":1,"stats":{"Line":1}},{"line":442,"address":[1582894],"length":1,"stats":{"Line":1}},{"line":443,"address":[1582901],"length":1,"stats":{"Line":1}},{"line":445,"address":[1582951,1583008],"length":1,"stats":{"Line":2}},{"line":446,"address":[1582186,1582131,1583262,1582971,1583333,1582262,1583052],"length":1,"stats":{"Line":2}},{"line":451,"address":[1594128,1594146,1593805,1594105,1592656],"length":1,"stats":{"Line":3}},{"line":452,"address":[1592663],"length":1,"stats":{"Line":1}},{"line":454,"address":[1592688],"length":1,"stats":{"Line":1}},{"line":455,"address":[1592797],"length":1,"stats":{"Line":1}},{"line":456,"address":[1592844],"length":1,"stats":{"Line":1}},{"line":459,"address":[1592982,1592905],"length":1,"stats":{"Line":2}},{"line":460,"address":[1593083,1593946],"length":1,"stats":{"Line":2}},{"line":461,"address":[1593997],"length":1,"stats":{"Line":1}},{"line":462,"address":[1594016],"length":1,"stats":{"Line":1}},{"line":463,"address":[1594075],"length":1,"stats":{"Line":1}},{"line":467,"address":[1593111],"length":1,"stats":{"Line":1}},{"line":468,"address":[1593260,1593815],"length":1,"stats":{"Line":2}},{"line":469,"address":[1593838],"length":1,"stats":{"Line":1}},{"line":470,"address":[1593872],"length":1,"stats":{"Line":1}},{"line":471,"address":[1593929],"length":1,"stats":{"Line":1}},{"line":474,"address":[1593936],"length":1,"stats":{"Line":1}},{"line":480,"address":[1593282],"length":1,"stats":{"Line":1}},{"line":481,"address":[1593320],"length":1,"stats":{"Line":1}},{"line":482,"address":[1593354],"length":1,"stats":{"Line":1}},{"line":483,"address":[1593411],"length":1,"stats":{"Line":1}},{"line":485,"address":[1593418],"length":1,"stats":{"Line":1}},{"line":486,"address":[1593556],"length":1,"stats":{"Line":1}},{"line":487,"address":[1593571],"length":1,"stats":{"Line":1}},{"line":488,"address":[1593594],"length":1,"stats":{"Line":1}},{"line":489,"address":[1593601],"length":1,"stats":{"Line":1}},{"line":491,"address":[1593708,1593651],"length":1,"stats":{"Line":2}},{"line":492,"address":[1592812,1594095,1594165,1592867,1593671,1593752,1592943],"length":1,"stats":{"Line":2}},{"line":497,"address":[1585392,1583344,1585378,1585410,1585058],"length":1,"stats":{"Line":3}},{"line":498,"address":[1583351],"length":1,"stats":{"Line":1}},{"line":500,"address":[1583376],"length":1,"stats":{"Line":1}},{"line":501,"address":[1583485],"length":1,"stats":{"Line":1}},{"line":502,"address":[1583532],"length":1,"stats":{"Line":1}},{"line":508,"address":[1583600,1583672],"length":1,"stats":{"Line":2}},{"line":509,"address":[1583772,1585217],"length":1,"stats":{"Line":2}},{"line":510,"address":[1585268],"length":1,"stats":{"Line":1}},{"line":511,"address":[1585287],"length":1,"stats":{"Line":1}},{"line":512,"address":[1585348],"length":1,"stats":{"Line":1}},{"line":516,"address":[1583814],"length":1,"stats":{"Line":1}},{"line":517,"address":[1583858],"length":1,"stats":{"Line":1}},{"line":518,"address":[1583901],"length":1,"stats":{"Line":1}},{"line":519,"address":[1583961],"length":1,"stats":{"Line":1}},{"line":522,"address":[1583975],"length":1,"stats":{"Line":1}},{"line":523,"address":[1585069,1584086],"length":1,"stats":{"Line":2}},{"line":524,"address":[1585117],"length":1,"stats":{"Line":1}},{"line":525,"address":[1585136],"length":1,"stats":{"Line":1}},{"line":526,"address":[1585197],"length":1,"stats":{"Line":1}},{"line":530,"address":[1584125],"length":1,"stats":{"Line":1}},{"line":531,"address":[1584163],"length":1,"stats":{"Line":1}},{"line":532,"address":[1584197],"length":1,"stats":{"Line":1}},{"line":533,"address":[1584254],"length":1,"stats":{"Line":1}},{"line":536,"address":[1584269],"length":1,"stats":{"Line":1}},{"line":537,"address":[1584307],"length":1,"stats":{"Line":1}},{"line":538,"address":[1584341],"length":1,"stats":{"Line":1}},{"line":539,"address":[1584398],"length":1,"stats":{"Line":1}},{"line":542,"address":[1584410],"length":1,"stats":{"Line":1}},{"line":543,"address":[1584440],"length":1,"stats":{"Line":1}},{"line":544,"address":[1584459],"length":1,"stats":{"Line":1}},{"line":545,"address":[1584520],"length":1,"stats":{"Line":1}},{"line":548,"address":[1584535],"length":1,"stats":{"Line":1}},{"line":549,"address":[1584573],"length":1,"stats":{"Line":1}},{"line":550,"address":[1584607],"length":1,"stats":{"Line":1}},{"line":551,"address":[1584664],"length":1,"stats":{"Line":1}},{"line":553,"address":[1584671],"length":1,"stats":{"Line":1}},{"line":554,"address":[1584809],"length":1,"stats":{"Line":1}},{"line":555,"address":[1584824],"length":1,"stats":{"Line":1}},{"line":556,"address":[1584847],"length":1,"stats":{"Line":1}},{"line":557,"address":[1584854],"length":1,"stats":{"Line":1}},{"line":559,"address":[1584904,1584961],"length":1,"stats":{"Line":2}},{"line":560,"address":[1585368,1583555,1585429,1585005,1583629,1584924,1583500],"length":1,"stats":{"Line":2}},{"line":565,"address":[1590160,1591136,1591154,1591110,1591086],"length":1,"stats":{"Line":3}},{"line":566,"address":[1590167],"length":1,"stats":{"Line":1}},{"line":568,"address":[1590189],"length":1,"stats":{"Line":1}},{"line":569,"address":[1590280],"length":1,"stats":{"Line":1}},{"line":570,"address":[1590324],"length":1,"stats":{"Line":1}},{"line":573,"address":[1590442,1590390],"length":1,"stats":{"Line":2}},{"line":574,"address":[1590465],"length":1,"stats":{"Line":1}},{"line":575,"address":[1590499],"length":1,"stats":{"Line":1}},{"line":576,"address":[1590556],"length":1,"stats":{"Line":1}},{"line":579,"address":[1590568],"length":1,"stats":{"Line":1}},{"line":580,"address":[1590606],"length":1,"stats":{"Line":1}},{"line":581,"address":[1590640],"length":1,"stats":{"Line":1}},{"line":582,"address":[1590697],"length":1,"stats":{"Line":1}},{"line":584,"address":[1590704],"length":1,"stats":{"Line":1}},{"line":585,"address":[1590842],"length":1,"stats":{"Line":1}},{"line":586,"address":[1590857],"length":1,"stats":{"Line":1}},{"line":587,"address":[1590880],"length":1,"stats":{"Line":1}},{"line":588,"address":[1590887],"length":1,"stats":{"Line":1}},{"line":590,"address":[1590992,1590937],"length":1,"stats":{"Line":2}},{"line":591,"address":[1591036,1590409,1591100,1591173,1590292,1590347,1590956],"length":1,"stats":{"Line":2}},{"line":596,"address":[1596720,1596738,1595648,1596700,1596546],"length":1,"stats":{"Line":3}},{"line":597,"address":[1595655],"length":1,"stats":{"Line":1}},{"line":599,"address":[1595677],"length":1,"stats":{"Line":1}},{"line":600,"address":[1595777],"length":1,"stats":{"Line":1}},{"line":601,"address":[1595824],"length":1,"stats":{"Line":1}},{"line":604,"address":[1595890,1595942],"length":1,"stats":{"Line":2}},{"line":605,"address":[1595957],"length":1,"stats":{"Line":1}},{"line":606,"address":[1595976],"length":1,"stats":{"Line":1}},{"line":607,"address":[1596037],"length":1,"stats":{"Line":1}},{"line":610,"address":[1596044],"length":1,"stats":{"Line":1}},{"line":611,"address":[1596145,1596556],"length":1,"stats":{"Line":2}},{"line":612,"address":[1596579],"length":1,"stats":{"Line":1}},{"line":613,"address":[1596613],"length":1,"stats":{"Line":1}},{"line":614,"address":[1596670],"length":1,"stats":{"Line":1}},{"line":617,"address":[1596159],"length":1,"stats":{"Line":1}},{"line":618,"address":[1596297],"length":1,"stats":{"Line":1}},{"line":619,"address":[1596312],"length":1,"stats":{"Line":1}},{"line":620,"address":[1596335],"length":1,"stats":{"Line":1}},{"line":621,"address":[1596342],"length":1,"stats":{"Line":1}},{"line":623,"address":[1596392,1596449],"length":1,"stats":{"Line":2}},{"line":624,"address":[1595792,1595847,1596493,1596412,1596690,1595909,1596757],"length":1,"stats":{"Line":2}},{"line":629,"address":[1595411,1594176,1595600,1595578,1595618],"length":1,"stats":{"Line":3}},{"line":630,"address":[1594183],"length":1,"stats":{"Line":1}},{"line":632,"address":[1594205],"length":1,"stats":{"Line":1}},{"line":633,"address":[1594308],"length":1,"stats":{"Line":1}},{"line":634,"address":[1594355],"length":1,"stats":{"Line":1}},{"line":637,"address":[1594416,1594493],"length":1,"stats":{"Line":2}},{"line":638,"address":[1594594,1595422],"length":1,"stats":{"Line":2}},{"line":639,"address":[1595470],"length":1,"stats":{"Line":1}},{"line":640,"address":[1595489],"length":1,"stats":{"Line":1}},{"line":641,"address":[1595548],"length":1,"stats":{"Line":1}},{"line":646,"address":[1594638],"length":1,"stats":{"Line":1}},{"line":648,"address":[1594661],"length":1,"stats":{"Line":1}},{"line":649,"address":[1594683],"length":1,"stats":{"Line":1}},{"line":650,"address":[1594749],"length":1,"stats":{"Line":1}},{"line":652,"address":[1594772],"length":1,"stats":{"Line":1}},{"line":654,"address":[1594795],"length":1,"stats":{"Line":1}},{"line":655,"address":[1594817],"length":1,"stats":{"Line":1}},{"line":656,"address":[1594883],"length":1,"stats":{"Line":1}},{"line":659,"address":[1594906],"length":1,"stats":{"Line":1}},{"line":661,"address":[1594929],"length":1,"stats":{"Line":1}},{"line":662,"address":[1594951],"length":1,"stats":{"Line":1}},{"line":663,"address":[1595017],"length":1,"stats":{"Line":1}},{"line":665,"address":[1595024],"length":1,"stats":{"Line":1}},{"line":666,"address":[1595162],"length":1,"stats":{"Line":1}},{"line":667,"address":[1595177],"length":1,"stats":{"Line":1}},{"line":668,"address":[1595200],"length":1,"stats":{"Line":1}},{"line":669,"address":[1595207],"length":1,"stats":{"Line":1}},{"line":671,"address":[1595257,1595314],"length":1,"stats":{"Line":2}},{"line":672,"address":[1594378,1595637,1595568,1595277,1595358,1594454,1594323],"length":1,"stats":{"Line":2}}],"covered":396,"coverable":397},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","common","mod.rs"],"content":"#![allow(unused)]\n\nuse itertools::Itertools;\nuse p3_air::{Air, AirBuilder, BaseAir};\nuse p3_challenger::DuplexChallenger;\nuse p3_commit::ExtensionMmcs;\nuse p3_dft::Radix2DitParallel;\nuse p3_field::extension::BinomialExtensionField;\nuse p3_field::{Field, PrimeCharacteristicRing};\nuse p3_fri::TwoAdicFriPcs;\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_merkle_tree::MerkleTreeMmcs;\nuse p3_recursion::pcs::{\n    FriProofTargets, InputProofTargets, RecExtensionValMmcs, RecValMmcs, Witness,\n};\nuse p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\nuse p3_uni_stark::{StarkConfig, StarkGenericConfig, Val};\nuse rand::distr::{Distribution, StandardUniform};\nuse rand::rngs::SmallRng;\nuse rand::{Rng, RngExt, SeedableRng};\n\n// Type of the `OpeningProof` used in the circuit for a `TwoAdicFriPcs`.\npub(crate) type InnerFriGeneric\u003cMyConfig, MyHash, MyCompress, const DIGEST_ELEMS: usize\u003e =\n    FriProofTargets\u003c\n        Val\u003cMyConfig\u003e,\n        \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n        RecExtensionValMmcs\u003c\n            Val\u003cMyConfig\u003e,\n            \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n            DIGEST_ELEMS,\n            RecValMmcs\u003cVal\u003cMyConfig\u003e, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n        \u003e,\n        InputProofTargets\u003c\n            Val\u003cMyConfig\u003e,\n            \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n            RecValMmcs\u003cVal\u003cMyConfig\u003e, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n        \u003e,\n        Witness\u003cVal\u003cMyConfig\u003e\u003e,\n    \u003e;\n\n/// Common parameters for the BabyBear field.\npub(crate) mod baby_bear_params {\n    pub(crate) use p3_baby_bear::{BabyBear, Poseidon2BabyBear};\n\n    use super::*;\n\n    pub(crate) type F = BabyBear;\n    pub(crate) const D: usize = 4;\n    pub(crate) const WIDTH: usize = 16;\n    pub(crate) const RATE: usize = 8;\n    pub(crate) const DIGEST_ELEMS: usize = 8;\n    pub(crate) type Challenge = BinomialExtensionField\u003cF, D\u003e;\n    pub(crate) type Dft = Radix2DitParallel\u003cF\u003e;\n    pub(crate) type Perm = Poseidon2BabyBear\u003c16\u003e;\n    pub(crate) type MyHash = PaddingFreeSponge\u003cPerm, 16, RATE, 8\u003e;\n    pub(crate) type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\n    pub(crate) type ValMmcs =\n        MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\n    pub(crate) type ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\n    pub(crate) type Challenger = DuplexChallenger\u003cF, Perm, 16, RATE\u003e;\n    pub(crate) type MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\n    pub(crate) type MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\n    pub(crate) type InnerFri = InnerFriGeneric\u003cMyConfig, MyHash, MyCompress, DIGEST_ELEMS\u003e;\n}\n\n/// Common parameters for the KoalaBear field.\npub(crate) mod koala_bear_params {\n    pub(crate) use p3_koala_bear::{KoalaBear, Poseidon2KoalaBear};\n\n    use super::*;\n\n    pub(crate) type F = KoalaBear;\n    pub(crate) const D: usize = 4;\n    pub(crate) const WIDTH: usize = 16;\n    pub(crate) const RATE: usize = 8;\n    pub(crate) const DIGEST_ELEMS: usize = 8;\n\n    pub(crate) type Challenge = BinomialExtensionField\u003cF, D\u003e;\n    pub(crate) type Dft = Radix2DitParallel\u003cF\u003e;\n    pub(crate) type Perm = Poseidon2KoalaBear\u003c16\u003e;\n    pub(crate) type MyHash = PaddingFreeSponge\u003cPerm, 16, RATE, 8\u003e;\n    pub(crate) type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\n    pub(crate) type ValMmcs =\n        MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\n    pub(crate) type ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\n    pub(crate) type Challenger = DuplexChallenger\u003cF, Perm, 16, RATE\u003e;\n    pub(crate) type MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\n    pub(crate) type MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\n    pub(crate) type InnerFri = InnerFriGeneric\u003cMyConfig, MyHash, MyCompress, DIGEST_ELEMS\u003e;\n}\n\n/// Common parameters for the Goldilocks field.\npub(crate) mod goldilocks_params {\n    pub(crate) use p3_goldilocks::{Goldilocks, Poseidon2Goldilocks};\n\n    use super::*;\n\n    pub(crate) type F = Goldilocks;\n    pub(crate) const D: usize = 2;\n    pub(crate) const WIDTH: usize = 8;\n    pub(crate) const RATE: usize = 4;\n    pub(crate) const DIGEST_ELEMS: usize = 4;\n\n    pub(crate) type Challenge = BinomialExtensionField\u003cF, D\u003e;\n    pub(crate) type Dft = Radix2DitParallel\u003cF\u003e;\n    pub(crate) type Perm = Poseidon2Goldilocks\u003c8\u003e;\n    pub(crate) type MyHash = PaddingFreeSponge\u003cPerm, 8, RATE, 4\u003e;\n    pub(crate) type MyCompress = TruncatedPermutation\u003cPerm, 2, 4, 8\u003e;\n    pub(crate) type ValMmcs =\n        MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 4\u003e;\n    pub(crate) type ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\n    pub(crate) type Challenger = DuplexChallenger\u003cF, Perm, 8, RATE\u003e;\n    pub(crate) type MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\n    pub(crate) type MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\n    pub(crate) type InnerFri = super::InnerFriGeneric\u003cMyConfig, MyHash, MyCompress, DIGEST_ELEMS\u003e;\n}\n\n/// A test AIR that enforces multiplication constraints: `a^(degree-1) * b = c`\n///\n/// # Constraints\n/// For each of REPETITIONS triples `(a, b, c)`:\n/// 1. Multiplication: `a^(degree-1) * b = c`\n/// 2. First row: `a^2 + 1 = b`\n/// 3. Transition: `a' = a + REPETITIONS` (where `a'` is next row's `a`)\n///\n/// # Trace Layout\n/// The trace has TRACE_WIDTH = REPETITIONS * 3 columns:\n/// `[a_0, b_0, c_0, a_1, b_1, c_1, ..., a_19, b_19, c_19]`\n#[derive(Clone, Copy)]\npub(crate) struct MulAir {\n    /// Degree of the polynomial constraint `(a^(degree-1) * b = c)`\n    pub(crate) degree: u64,\n    pub(crate) rows: usize,\n}\n\nimpl Default for MulAir {\n    fn default() -\u003e Self {\n        Self {\n            degree: 3,\n            rows: 1 \u003c\u003c 3,\n        }\n    }\n}\n\n/// Number of repetitions of the multiplication constraint (must be \u003c 255 to fit in u8)\npub(crate) const REPETITIONS: usize = 20;\n\n/// Total trace width: 3 columns per repetition (a, b, c)\npub(crate) const MAIN_TRACE_WIDTH: usize = REPETITIONS; // For c values\npub(crate) const PREP_WIDTH: usize = REPETITIONS * 2; // For a and b values\n\nimpl MulAir {\n    /// Generate a random valid (or invalid) trace for testing. The trace consists of a main trace and a preprocessed trace.\n    ///\n    /// # Parameters\n    /// - `rows`: Number of rows in the trace\n    /// - `valid`: If true, generates a valid trace; if false, makes it invalid\n    pub fn random_valid_trace\u003cVal: Field\u003e(\n        \u0026self,\n        valid: bool,\n    ) -\u003e (RowMajorMatrix\u003cVal\u003e, RowMajorMatrix\u003cVal\u003e)\n    where\n        StandardUniform: Distribution\u003cVal\u003e,\n    {\n        let mut rng = SmallRng::seed_from_u64(1);\n        let mut main_trace_values = Val::zero_vec(self.rows * MAIN_TRACE_WIDTH);\n        let mut prep_trace_values = Val::zero_vec(self.rows * PREP_WIDTH);\n\n        for (i, (a, b)) in prep_trace_values.iter_mut().tuples().enumerate() {\n            let row = i / REPETITIONS;\n            *a = Val::from_usize(i);\n\n            // First row: b = a^2 + 1\n            // Other rows: random b\n            *b = if row == 0 {\n                a.square() + Val::ONE\n            } else {\n                rng.random()\n            };\n\n            // Compute c = a^(degree-1) * b\n            main_trace_values[i] = a.exp_u64(self.degree - 1) * *b;\n\n            if !valid {\n                // Make the trace invalid by corrupting c\n                main_trace_values[i] *= Val::TWO;\n            }\n        }\n\n        (\n            RowMajorMatrix::new(main_trace_values, MAIN_TRACE_WIDTH),\n            RowMajorMatrix::new(prep_trace_values, PREP_WIDTH),\n        )\n    }\n}\n\nimpl\u003cVal: Field\u003e BaseAir\u003cVal\u003e for MulAir\nwhere\n    StandardUniform: Distribution\u003cVal\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        MAIN_TRACE_WIDTH\n    }\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003e\u003e {\n        Some(self.random_valid_trace(true).1)\n    }\n}\n\nimpl\u003cAB: AirBuilder\u003e Air\u003cAB\u003e for MulAir\nwhere\n    AB::F: Field,\n    StandardUniform: Distribution\u003cAB::F\u003e,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n        let main_local = main.row_slice(0).expect(\"Matrix is empty?\");\n\n        let preprocessed = builder\n            .preprocessed()\n            .expect(\"Expected preprocessed columns\");\n        let preprocessed_local = preprocessed\n            .row_slice(0)\n            .expect(\"Preprocessed matrix is empty?\");\n        let preprocessed_next = preprocessed\n            .row_slice(1)\n            .expect(\"Preprocessed matrix only has 1 row?\");\n\n        for i in 0..REPETITIONS {\n            let prep_start = i * 2;\n            let a = preprocessed_local[prep_start].clone();\n            let b = preprocessed_local[prep_start + 1].clone();\n            let c = main_local[i].clone();\n\n            // Constraint 1: a^(degree-1) * b = c\n            builder.assert_zero(a.clone().into().exp_u64(self.degree - 1) * b.clone() - c);\n\n            // Constraint 2: On first row, b = a^2 + 1\n            builder\n                .when_first_row()\n                .assert_eq(a.clone() * a.clone() + AB::Expr::ONE, b);\n\n            // Constraint 3: On transition rows, a' = a + REPETITIONS\n            let next_a = preprocessed_next[prep_start].clone();\n            builder\n                .when_transition()\n                .assert_eq(a + AB::Expr::from_u8(REPETITIONS as u8), next_a);\n        }\n    }\n}\n","traces":[{"line":133,"address":[4101653,4101648],"length":1,"stats":{"Line":0}},{"line":141,"address":[4103152],"length":1,"stats":{"Line":0}},{"line":146,"address":[1678490],"length":1,"stats":{"Line":0}},{"line":162,"address":[2264113,2264510,2263168],"length":1,"stats":{"Line":2}},{"line":169,"address":[2858249],"length":1,"stats":{"Line":2}},{"line":170,"address":[2858377,2858291],"length":1,"stats":{"Line":2}},{"line":171,"address":[2858471,2858353,2858403],"length":1,"stats":{"Line":6}},{"line":173,"address":[2858552,2858487],"length":1,"stats":{"Line":4}},{"line":174,"address":[2858821,2859158],"length":1,"stats":{"Line":4}},{"line":175,"address":[2859181],"length":1,"stats":{"Line":2}},{"line":179,"address":[2859208,2859273],"length":1,"stats":{"Line":4}},{"line":180,"address":[2264290,2264214],"length":1,"stats":{"Line":4}},{"line":182,"address":[2264229,2264198],"length":1,"stats":{"Line":4}},{"line":186,"address":[2859282,2859348],"length":1,"stats":{"Line":4}},{"line":188,"address":[2264428],"length":1,"stats":{"Line":2}},{"line":190,"address":[2859465],"length":1,"stats":{"Line":0}},{"line":194,"address":[2263994],"length":1,"stats":{"Line":2}},{"line":195,"address":[2263802],"length":1,"stats":{"Line":2}},{"line":196,"address":[2858894],"length":1,"stats":{"Line":2}},{"line":197,"address":[2858970],"length":1,"stats":{"Line":0}},{"line":198,"address":[2263404,2263480,2264488,2264523,2264089],"length":1,"stats":{"Line":2}},{"line":205,"address":[3018128],"length":1,"stats":{"Line":2}},{"line":207,"address":[2263109],"length":1,"stats":{"Line":2}},{"line":208,"address":[2262960],"length":1,"stats":{"Line":2}},{"line":209,"address":[2262978],"length":1,"stats":{"Line":2}},{"line":210,"address":[2263087],"length":1,"stats":{"Line":2}},{"line":218,"address":[2257392,2254920,2259744,2254969,2249632,2254992,2249783,2255135,2262440,2257535,2252224,2262489],"length":1,"stats":{"Line":8}},{"line":219,"address":[2259783,2252263,2249671,2255031,2257431],"length":1,"stats":{"Line":8}},{"line":220,"address":[3008018,3007976,3010368,3010442,3013010,3015391,3015312,3012968],"length":1,"stats":{"Line":16}},{"line":223,"address":[3010532,3008076,3015481,3013068],"length":1,"stats":{"Line":8}},{"line":224,"address":[2252555,2255259,2249958,2257659,2260075],"length":1,"stats":{"Line":8}},{"line":225,"address":[2250133,2252743,2260263],"length":1,"stats":{"Line":5}},{"line":226,"address":[3015569,3010620,3013161,3008169],"length":1,"stats":{"Line":8}},{"line":227,"address":[3013192,3008200,3010683,3015645],"length":1,"stats":{"Line":8}},{"line":228,"address":[3015856,3010894],"length":1,"stats":{"Line":5}},{"line":229,"address":[3013255,3015732,3010770,3008263],"length":1,"stats":{"Line":8}},{"line":230,"address":[3015798,3008294,3010836,3013286],"length":1,"stats":{"Line":8}},{"line":232,"address":[3008336,3013328,3013398,3015872,3017873,3012789,3008412,3010989,3015145,3015939,3010910,3010201],"length":1,"stats":{"Line":24}},{"line":233,"address":[2260672,2260705,2253152,2253085,2250588,2255732,2250502,2250549,2258064,2260605,2253185,2255685,2258138,2255771,2258105],"length":1,"stats":{"Line":16}},{"line":234,"address":[3008596,3011232,3013561,3011173,3013608,3008655,3016128,3016175],"length":1,"stats":{"Line":16}},{"line":235,"address":[2253297,2253360,2258312,2250803,2255986,2258249,2255914,2260817,2260880,2250731],"length":1,"stats":{"Line":16}},{"line":236,"address":[3013886,3011580,3013954,3009077,3011660,3016455,3009003,3016523],"length":1,"stats":{"Line":16}},{"line":239,"address":[3010218,3011756,3015162,3016664,3009170,3014260,3014046,3017904,3012806,3009399,3014202,3009238,3016616,3011985,3016843,3009341,3011824,3011927,3014094],"length":1,"stats":{"Line":16}},{"line":242,"address":[3012139,3009553],"length":1,"stats":{"Line":3}},{"line":243,"address":[2259001,2254093,2256680,2251506,2261613],"length":1,"stats":{"Line":8}},{"line":244,"address":[3014529,3015157,3017891,3014464,3010213,3017076,3014471,3012154,3009568,3009649,3012235,3009591,3017154,3012177,3012801],"length":1,"stats":{"Line":8}},{"line":247,"address":[3017394,3014725,3012372,3009786],"length":1,"stats":{"Line":8}},{"line":248,"address":[3009980,3012566],"length":1,"stats":{"Line":3}},{"line":249,"address":[3014844,3009914,3017511,3012500],"length":1,"stats":{"Line":8}},{"line":250,"address":[3017878,3012728,3012624,3010038,3012794,3014892,3010206,3009995,3010140,3015084,3014944,3015150,3012581,3017627,3017559],"length":1,"stats":{"Line":8}},{"line":251,"address":[3016472,3010223,3012757,3009193,3009930,3011603,3011779,3016623,3015167,3017518,3014851,3012796,3015152,3008785,3017914,3010208,3011362,3010169,3012811,3013706,3017841,3016274,3009023,3012516,3017886,3013903,3015113,3014053],"length":1,"stats":{"Line":8}},{"line":252,"address":[3008372,3010539,3015343,3008270,3015755,3013361,3013524,3016065,3011133,3010643,3015488,3015600,3008556,3010793,3010946,3013168,3008176,3013075,3013262,3015902,3008083],"length":1,"stats":{"Line":8}}],"covered":47,"coverable":52},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","fibonacci.rs"],"content":"mod common;\n\nuse p3_baby_bear::default_babybear_poseidon2_16;\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::ops::generate_poseidon2_trace;\nuse p3_circuit::test_utils::{FibonacciAir, generate_trace_rows};\nuse p3_field::PrimeCharacteristicRing;\nuse p3_fri::create_test_fri_params;\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\nuse p3_recursion::pcs::fri::{FriVerifierParams, InputProofTargets, MerkleCapTargets, RecValMmcs};\nuse p3_recursion::pcs::set_fri_mmcs_private_data;\nuse p3_recursion::public_inputs::StarkVerifierInputsBuilder;\nuse p3_recursion::{Poseidon2Config, VerificationError, verify_p3_uni_proof_circuit};\nuse p3_uni_stark::{prove, verify};\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\nuse crate::common::baby_bear_params::*;\n\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\n#[test]\nfn test_fibonacci_verifier() -\u003e Result\u003c(), VerificationError\u003e {\n    init_logger();\n\n    let n = 1 \u003c\u003c 3;\n    let x = 21;\n\n    let perm = default_babybear_poseidon2_16();\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress, 0);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::default();\n    let trace = generate_trace_rows::\u003cF\u003e(0, 1, n);\n    let log_final_poly_len = 0;\n    let fri_params = create_test_fri_params(challenge_mmcs, log_final_poly_len);\n\n    // Enable MMCS verification\n    let fri_verifier_params = FriVerifierParams::with_mmcs(\n        fri_params.log_blowup,\n        fri_params.log_final_poly_len,\n        fri_params.commit_proof_of_work_bits,\n        fri_params.query_proof_of_work_bits,\n        Poseidon2Config::BabyBearD4Width16,\n    );\n\n    let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n    let challenger = Challenger::new(perm.clone());\n\n    let config = MyConfig::new(pcs, challenger);\n    let pis = vec![BabyBear::ZERO, BabyBear::ONE, BabyBear::from_u64(x)];\n\n    let air = FibonacciAir {};\n    let proof = prove(\u0026config, \u0026air, trace, \u0026pis);\n    assert!(verify(\u0026config, \u0026air, \u0026proof, \u0026pis).is_ok());\n\n    let mut circuit_builder = CircuitBuilder::new();\n    circuit_builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cChallenge, BabyBearD4Width16\u003e,\n        perm,\n    );\n\n    // Allocate all targets\n    let verifier_inputs = StarkVerifierInputsBuilder::\u003c\n        MyConfig,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n        InnerFri,\n    \u003e::allocate(\u0026mut circuit_builder, \u0026proof, None, pis.len());\n\n    // Add the verification circuit to the builder.\n    let mmcs_op_ids = verify_p3_uni_proof_circuit::\u003c\n        FibonacciAir,\n        MyConfig,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n        InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n        InnerFri,\n        WIDTH,\n        RATE,\n    \u003e(\n        \u0026config,\n        \u0026air,\n        \u0026mut circuit_builder,\n        \u0026verifier_inputs.proof_targets,\n        \u0026verifier_inputs.air_public_targets,\n        \u0026None,\n        \u0026fri_verifier_params,\n        Poseidon2Config::BabyBearD4Width16,\n    )?;\n\n    // Build the circuit.\n    let circuit = circuit_builder.build()?;\n\n    let mut runner = circuit.runner();\n\n    // Pack values using the same builder\n    let public_inputs = verifier_inputs.pack_values(\u0026pis, \u0026proof, \u0026None);\n\n    runner\n        .set_public_inputs(\u0026public_inputs)\n        .map_err(VerificationError::Circuit)?;\n\n    // Set MMCS private data from the FRI proof\n    set_fri_mmcs_private_data::\u003c\n        F,\n        Challenge,\n        ChallengeMmcs,\n        ValMmcs,\n        MyHash,\n        MyCompress,\n        DIGEST_ELEMS,\n    \u003e(\u0026mut runner, \u0026mmcs_op_ids, \u0026proof.opening_proof)\n    .map_err(|e| VerificationError::InvalidProofShape(e.to_string()))?;\n\n    let _traces = runner.run().map_err(VerificationError::Circuit)?;\n\n    Ok(())\n}\n","traces":[{"line":1,"address":[5495840],"length":1,"stats":{"Line":1}},{"line":23,"address":[5490052,5489472,5490046],"length":1,"stats":{"Line":1}},{"line":24,"address":[5489509,5489630],"length":1,"stats":{"Line":2}},{"line":25,"address":[5489558,5489589,5489638,5490081],"length":1,"stats":{"Line":2}},{"line":26,"address":[5489681],"length":1,"stats":{"Line":1}},{"line":28,"address":[5489817,5489958],"length":1,"stats":{"Line":2}},{"line":29,"address":[5489836],"length":1,"stats":{"Line":1}},{"line":30,"address":[5489910,5490036,5489921,5489982],"length":1,"stats":{"Line":2}},{"line":31,"address":[5490005],"length":1,"stats":{"Line":1}},{"line":32,"address":[5490065,5489776,5490012],"length":1,"stats":{"Line":1}},{"line":35,"address":[5495776,5495640,5490112,5495266,5495794],"length":1,"stats":{"Line":3}},{"line":36,"address":[5490189],"length":1,"stats":{"Line":1}},{"line":38,"address":[5490290],"length":1,"stats":{"Line":1}},{"line":39,"address":[5490165],"length":1,"stats":{"Line":1}},{"line":41,"address":[5490302],"length":1,"stats":{"Line":1}},{"line":42,"address":[5490343,5490419],"length":1,"stats":{"Line":2}},{"line":43,"address":[5490434,5490499],"length":1,"stats":{"Line":2}},{"line":44,"address":[5490526],"length":1,"stats":{"Line":1}},{"line":45,"address":[5490817,5490753],"length":1,"stats":{"Line":2}},{"line":46,"address":[5490840],"length":1,"stats":{"Line":1}},{"line":47,"address":[5490885,5490960],"length":1,"stats":{"Line":2}},{"line":48,"address":[5490177],"length":1,"stats":{"Line":1}},{"line":49,"address":[5490968,5491082],"length":1,"stats":{"Line":2}},{"line":52,"address":[5491122],"length":1,"stats":{"Line":1}},{"line":53,"address":[5491090],"length":1,"stats":{"Line":1}},{"line":54,"address":[5491098],"length":1,"stats":{"Line":1}},{"line":55,"address":[5491106],"length":1,"stats":{"Line":1}},{"line":56,"address":[5491114],"length":1,"stats":{"Line":1}},{"line":60,"address":[5491185],"length":1,"stats":{"Line":1}},{"line":61,"address":[5491373,5491457],"length":1,"stats":{"Line":2}},{"line":63,"address":[5491464],"length":1,"stats":{"Line":1}},{"line":64,"address":[5491598,5491661],"length":1,"stats":{"Line":2}},{"line":67,"address":[5491953,5495504,5491874],"length":1,"stats":{"Line":1}},{"line":68,"address":[5492184,5492073],"length":1,"stats":{"Line":2}},{"line":70,"address":[5492336],"length":1,"stats":{"Line":1}},{"line":71,"address":[5492343,5492439],"length":1,"stats":{"Line":2}},{"line":73,"address":[5492351],"length":1,"stats":{"Line":1}},{"line":77,"address":[5492569],"length":1,"stats":{"Line":1}},{"line":81,"address":[5492518],"length":1,"stats":{"Line":1}},{"line":84,"address":[5492914,5495325,5492687],"length":1,"stats":{"Line":1}},{"line":96,"address":[5492576],"length":1,"stats":{"Line":1}},{"line":97,"address":[5492600],"length":1,"stats":{"Line":1}},{"line":101,"address":[5492834],"length":1,"stats":{"Line":0}},{"line":104,"address":[5493208,5495308,5493083],"length":1,"stats":{"Line":2}},{"line":106,"address":[5493635,5493545],"length":1,"stats":{"Line":2}},{"line":109,"address":[5493651,5493728],"length":1,"stats":{"Line":2}},{"line":111,"address":[5493903,5494039,5495206],"length":1,"stats":{"Line":1}},{"line":112,"address":[5493857,5493774],"length":1,"stats":{"Line":2}},{"line":113,"address":[5493959,5493880],"length":1,"stats":{"Line":1}},{"line":116,"address":[5494389,5494253,5495204,5494195],"length":1,"stats":{"Line":2}},{"line":124,"address":[5494152],"length":1,"stats":{"Line":1}},{"line":125,"address":[5495680,5495704,5494309,5494230],"length":1,"stats":{"Line":1}},{"line":127,"address":[5494494,5495187],"length":1,"stats":{"Line":1}},{"line":129,"address":[5494935],"length":1,"stats":{"Line":1}},{"line":130,"address":[5495243,5492631,5493160,5495280,5495653,5495823,5491147,5490847,5495522,5493674,5493594,5490362,5491621,5495197,5492469,5492104,5495327,5491041,5495208,5490922,5495318,5494938,5490760,5490461,5491400,5493799],"length":1,"stats":{"Line":2}}],"covered":54,"coverable":55},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","fibonacci_batch_stark_prover.rs"],"content":"mod common;\n\nuse p3_baby_bear::default_babybear_poseidon2_16;\nuse p3_batch_stark::ProverData;\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::ops::generate_poseidon2_trace;\nuse p3_circuit_prover::common::{NonPrimitiveConfig, get_airs_and_degrees_with_prep};\nuse p3_circuit_prover::{BatchStarkProver, CircuitProverData, ConstraintProfile, TablePacking};\nuse p3_field::PrimeCharacteristicRing;\nuse p3_fri::create_test_fri_params;\nuse p3_lookup::logup::LogUpGadget;\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\nuse p3_recursion::Poseidon2Config;\nuse p3_recursion::pcs::fri::{FriVerifierParams, InputProofTargets, MerkleCapTargets, RecValMmcs};\nuse p3_recursion::pcs::set_fri_mmcs_private_data;\nuse p3_recursion::verifier::verify_p3_batch_proof_circuit;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\nuse crate::common::baby_bear_params::*;\n\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\n#[test]\nfn test_fibonacci_batch_verifier() {\n    init_logger();\n\n    let n: usize = 100;\n\n    let mut builder = CircuitBuilder::new();\n\n    // Public input: expected F(n)\n    let expected_result = builder.alloc_public_input(\"expected_result\");\n\n    // Compute F(n) iteratively\n    let mut a = builder.alloc_const(F::ZERO, \"F(0)\");\n    let mut b = builder.alloc_const(F::ONE, \"F(1)\");\n\n    for _i in 2..=n {\n        let next = builder.add(a, b);\n        a = b;\n        b = next;\n    }\n\n    // Assert computed F(n) equals expected result\n    builder.connect(b, expected_result);\n\n    builder.dump_allocation_log();\n\n    let table_packing = TablePacking::new(1, 2, 4);\n\n    // Use the default permutation for proving to match circuit's Fiat-Shamir challenger\n    let perm = default_babybear_poseidon2_16();\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress, 0);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::default();\n\n    // Create test FRI params with log_final_poly_len = 0\n    let fri_params = create_test_fri_params(challenge_mmcs, 0);\n\n    // Create config for proving\n    let pcs_proving = MyPcs::new(dft, val_mmcs, fri_params);\n    let challenger_proving = Challenger::new(perm);\n    let config_proving = MyConfig::new(pcs_proving, challenger_proving);\n\n    let circuit = builder.build().unwrap();\n    let (airs_degrees, preprocessed_columns) = get_airs_and_degrees_with_prep::\u003cMyConfig, _, 1\u003e(\n        \u0026circuit,\n        table_packing,\n        None,\n        ConstraintProfile::Standard,\n    )\n    .unwrap();\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    // Set public input\n    let expected_fib = compute_fibonacci_classical(n);\n    runner.set_public_inputs(\u0026[expected_fib]).unwrap();\n\n    let traces = runner.run().unwrap();\n\n    // Create prover data for proving and verifying.\n    let prover_data = ProverData::from_airs_and_degrees(\u0026config_proving, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    let prover = BatchStarkProver::new(config_proving).with_table_packing(table_packing);\n\n    let lookup_gadget = LogUpGadget::new();\n    let batch_stark_proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n\n    let common = circuit_prover_data.common_data();\n    prover\n        .verify_all_tables(\u0026batch_stark_proof, common)\n        .unwrap();\n\n    // Now verify the batch STARK proof recursively\n    // Use same permutation as proving to ensure Fiat-Shamir transcript compatibility\n    let dft2 = Dft::default();\n    let perm2 = default_babybear_poseidon2_16();\n    let hash2 = MyHash::new(perm2.clone());\n    let compress2 = MyCompress::new(perm2.clone());\n    let val_mmcs2 = ValMmcs::new(hash2, compress2, 0);\n    let challenge_mmcs2 = ChallengeMmcs::new(val_mmcs2.clone());\n    let fri_params2 = create_test_fri_params(challenge_mmcs2, 0);\n    let fri_verifier_params = FriVerifierParams::with_mmcs(\n        fri_params2.log_blowup,\n        fri_params2.log_final_poly_len,\n        fri_params2.commit_proof_of_work_bits,\n        fri_params2.query_proof_of_work_bits,\n        Poseidon2Config::BabyBearD4Width16,\n    );\n    let pcs_verif = MyPcs::new(dft2, val_mmcs2, fri_params2);\n    let challenger_verif = Challenger::new(perm2);\n    let config = MyConfig::new(pcs_verif, challenger_verif);\n\n    // Extract proof components\n    let batch_proof = \u0026batch_stark_proof.proof;\n\n    const TRACE_D: usize = 1; // Proof traces are in base field\n\n    // Public values (empty for all 5 circuit tables: Witness, Const, Public, Alu, Poseidon2)\n    let pis: Vec\u003cVec\u003cF\u003e\u003e = vec![vec![]; 5];\n\n    // Build the recursive verification circuit\n    let mut circuit_builder = CircuitBuilder::new();\n    let poseidon2_perm = default_babybear_poseidon2_16();\n    circuit_builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cChallenge, BabyBearD4Width16\u003e,\n        poseidon2_perm,\n    );\n\n    // Attach verifier without manually building circuit_airs\n    let (verifier_inputs, mmcs_op_ids) = verify_p3_batch_proof_circuit::\u003c\n        MyConfig,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n        InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n        InnerFri,\n        LogUpGadget,\n        WIDTH,\n        RATE,\n        TRACE_D,\n    \u003e(\n        \u0026config,\n        \u0026mut circuit_builder,\n        \u0026batch_stark_proof,\n        \u0026fri_verifier_params,\n        common,\n        \u0026lookup_gadget,\n        Poseidon2Config::BabyBearD4Width16,\n    )\n    .unwrap();\n\n    // Build the circuit\n    let verification_circuit = circuit_builder.build().unwrap();\n    let expected_public_input_len = verification_circuit.public_flat_len;\n\n    // Pack values using the builder\n    let public_inputs = verifier_inputs.pack_values(\u0026pis, batch_proof, common);\n\n    assert_eq!(public_inputs.len(), expected_public_input_len);\n    assert!(!public_inputs.is_empty());\n\n    let verification_table_packing = TablePacking::new(16, 1, 8);\n    let poseidon2_config = Poseidon2Config::BabyBearD4Width16;\n    let (verification_airs_degrees, verification_preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cMyConfig, _, 4\u003e(\n            \u0026verification_circuit,\n            verification_table_packing,\n            Some(\u0026[NonPrimitiveConfig::Poseidon2(poseidon2_config)]),\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n    let (mut verification_airs, verification_degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) =\n        verification_airs_degrees.into_iter().unzip();\n\n    // Now run the circuit to generate traces\n    let mut runner = verification_circuit.runner();\n    runner.set_public_inputs(\u0026public_inputs).unwrap();\n\n    // Set MMCS private data for the verification circuit\n    set_fri_mmcs_private_data::\u003c\n        F,\n        Challenge,\n        ChallengeMmcs,\n        ValMmcs,\n        MyHash,\n        MyCompress,\n        DIGEST_ELEMS,\n    \u003e(\n        \u0026mut runner,\n        \u0026mmcs_op_ids,\n        \u0026batch_stark_proof.proof.opening_proof,\n    )\n    .unwrap();\n\n    // Run the circuit to generate traces\n    let verification_traces = runner.run().unwrap();\n\n    // Create a new config and prover for the verification circuit\n    let dft3 = Dft::default();\n    let perm3 = default_babybear_poseidon2_16();\n    let hash3 = MyHash::new(perm3.clone());\n    let compress3 = MyCompress::new(perm3.clone());\n    let val_mmcs3 = ValMmcs::new(hash3, compress3, 0);\n    let challenge_mmcs3 = ChallengeMmcs::new(val_mmcs3.clone());\n    let fri_params3 = create_test_fri_params(challenge_mmcs3, 0);\n    let pcs3 = MyPcs::new(dft3, val_mmcs3, fri_params3);\n    let challenger3 = Challenger::new(perm3);\n    let config3 = MyConfig::new(pcs3, challenger3);\n\n    let verification_prover_data =\n        ProverData::from_airs_and_degrees(\u0026config3, \u0026mut verification_airs, \u0026verification_degrees);\n    let verification_circuit_prover_data =\n        CircuitProverData::new(verification_prover_data, verification_preprocessed_columns);\n\n    let mut verification_prover =\n        BatchStarkProver::new(config3).with_table_packing(verification_table_packing);\n    verification_prover.register_poseidon2_table(poseidon2_config);\n\n    // Prove the verification circuit\n    let verification_proof = verification_prover\n        .prove_all_tables(\u0026verification_traces, \u0026verification_circuit_prover_data)\n        .expect(\"Failed to prove verification circuit\");\n\n    // Verify the proof of the verification circuit\n    verification_prover\n        .verify_all_tables(\n            \u0026verification_proof,\n            verification_circuit_prover_data.common_data(),\n        )\n        .expect(\"Failed to verify proof of verification circuit\");\n}\n\nfn compute_fibonacci_classical(n: usize) -\u003e F {\n    if n == 0 {\n        return F::ZERO;\n    }\n    if n == 1 {\n        return F::ONE;\n    }\n\n    let mut a = F::ZERO;\n    let mut b = F::ONE;\n\n    for _i in 2..=n {\n        let next = a + b;\n        a = b;\n        b = next;\n    }\n\n    b\n}\n","traces":[{"line":1,"address":[7703104],"length":1,"stats":{"Line":1}},{"line":25,"address":[7692734,7692160,7692740],"length":1,"stats":{"Line":1}},{"line":26,"address":[7692197,7692318],"length":1,"stats":{"Line":2}},{"line":27,"address":[7692277,7692769,7692326,7692246],"length":1,"stats":{"Line":2}},{"line":28,"address":[7692369],"length":1,"stats":{"Line":1}},{"line":30,"address":[7692505,7692646],"length":1,"stats":{"Line":2}},{"line":31,"address":[7692524],"length":1,"stats":{"Line":1}},{"line":32,"address":[7692609,7692598,7692670,7692724],"length":1,"stats":{"Line":2}},{"line":33,"address":[7692693],"length":1,"stats":{"Line":1}},{"line":34,"address":[7692700,7692753,7692464],"length":1,"stats":{"Line":1}},{"line":37,"address":[7702437,7703023,7703074,7693040,7703056],"length":1,"stats":{"Line":3}},{"line":38,"address":[7693137],"length":1,"stats":{"Line":1}},{"line":40,"address":[7693374],"length":1,"stats":{"Line":1}},{"line":42,"address":[7693386],"length":1,"stats":{"Line":1}},{"line":45,"address":[7693497,7693423],"length":1,"stats":{"Line":2}},{"line":48,"address":[7693504],"length":1,"stats":{"Line":1}},{"line":49,"address":[7693554],"length":1,"stats":{"Line":1}},{"line":51,"address":[7693607,7703018],"length":1,"stats":{"Line":2}},{"line":52,"address":[7693808,7702990],"length":1,"stats":{"Line":2}},{"line":53,"address":[7702997],"length":1,"stats":{"Line":1}},{"line":54,"address":[7703011],"length":1,"stats":{"Line":1}},{"line":58,"address":[7693854],"length":1,"stats":{"Line":1}},{"line":60,"address":[7693884],"length":1,"stats":{"Line":1}},{"line":62,"address":[7693891],"length":1,"stats":{"Line":1}},{"line":65,"address":[7693925],"length":1,"stats":{"Line":1}},{"line":66,"address":[7693944,7694036],"length":1,"stats":{"Line":2}},{"line":67,"address":[7694051,7694116],"length":1,"stats":{"Line":2}},{"line":68,"address":[7694143],"length":1,"stats":{"Line":1}},{"line":69,"address":[7694370,7694434],"length":1,"stats":{"Line":2}},{"line":70,"address":[7694457],"length":1,"stats":{"Line":1}},{"line":73,"address":[7694502],"length":1,"stats":{"Line":1}},{"line":76,"address":[7694624],"length":1,"stats":{"Line":1}},{"line":77,"address":[7694804],"length":1,"stats":{"Line":1}},{"line":78,"address":[7694956],"length":1,"stats":{"Line":1}},{"line":80,"address":[7695198,7695088],"length":1,"stats":{"Line":2}},{"line":81,"address":[7695376,7695236],"length":1,"stats":{"Line":2}},{"line":87,"address":[7695346],"length":1,"stats":{"Line":1}},{"line":88,"address":[7695488,7695608],"length":1,"stats":{"Line":2}},{"line":89,"address":[7695679,7695792],"length":1,"stats":{"Line":2}},{"line":92,"address":[7695805,7695864],"length":1,"stats":{"Line":2}},{"line":93,"address":[7695871],"length":1,"stats":{"Line":1}},{"line":95,"address":[7695936],"length":1,"stats":{"Line":1}},{"line":98,"address":[7696043,7696146],"length":1,"stats":{"Line":2}},{"line":99,"address":[7696224],"length":1,"stats":{"Line":1}},{"line":101,"address":[7696365,7696474],"length":1,"stats":{"Line":2}},{"line":103,"address":[7696537],"length":1,"stats":{"Line":1}},{"line":105,"address":[7696620],"length":1,"stats":{"Line":1}},{"line":106,"address":[7696627],"length":1,"stats":{"Line":1}},{"line":108,"address":[7696728,7696665],"length":1,"stats":{"Line":2}},{"line":110,"address":[7696760],"length":1,"stats":{"Line":1}},{"line":111,"address":[7696767],"length":1,"stats":{"Line":1}},{"line":115,"address":[7696797],"length":1,"stats":{"Line":1}},{"line":116,"address":[7696804],"length":1,"stats":{"Line":1}},{"line":117,"address":[7696961,7696872],"length":1,"stats":{"Line":2}},{"line":118,"address":[7696976,7697041],"length":1,"stats":{"Line":2}},{"line":119,"address":[7697068],"length":1,"stats":{"Line":1}},{"line":120,"address":[7697359,7697295],"length":1,"stats":{"Line":2}},{"line":121,"address":[7697402],"length":1,"stats":{"Line":1}},{"line":122,"address":[7697471],"length":1,"stats":{"Line":1}},{"line":123,"address":[7697439],"length":1,"stats":{"Line":1}},{"line":124,"address":[7697447],"length":1,"stats":{"Line":1}},{"line":125,"address":[7697455],"length":1,"stats":{"Line":1}},{"line":126,"address":[7697463],"length":1,"stats":{"Line":1}},{"line":129,"address":[7697537],"length":1,"stats":{"Line":1}},{"line":130,"address":[7697725],"length":1,"stats":{"Line":1}},{"line":131,"address":[7697877],"length":1,"stats":{"Line":1}},{"line":134,"address":[7698009],"length":1,"stats":{"Line":1}},{"line":139,"address":[7698097,7698017],"length":1,"stats":{"Line":2}},{"line":142,"address":[7698112],"length":1,"stats":{"Line":1}},{"line":143,"address":[7698156],"length":1,"stats":{"Line":1}},{"line":144,"address":[7698221],"length":1,"stats":{"Line":1}},{"line":150,"address":[7698339,7698473],"length":1,"stats":{"Line":2}},{"line":168,"address":[7698407],"length":1,"stats":{"Line":1}},{"line":171,"address":[7698515,7698617],"length":1,"stats":{"Line":2}},{"line":172,"address":[7698655],"length":1,"stats":{"Line":1}},{"line":175,"address":[7698791,7698679],"length":1,"stats":{"Line":2}},{"line":177,"address":[7698869,7698806],"length":1,"stats":{"Line":2}},{"line":178,"address":[7698981,7699044],"length":1,"stats":{"Line":1}},{"line":180,"address":[7699010],"length":1,"stats":{"Line":1}},{"line":181,"address":[7699074],"length":1,"stats":{"Line":1}},{"line":182,"address":[7699200],"length":1,"stats":{"Line":1}},{"line":183,"address":[7699090],"length":1,"stats":{"Line":1}},{"line":186,"address":[7699082],"length":1,"stats":{"Line":1}},{"line":189,"address":[7699170],"length":1,"stats":{"Line":1}},{"line":190,"address":[7699439],"length":1,"stats":{"Line":1}},{"line":191,"address":[7699432,7699312],"length":1,"stats":{"Line":2}},{"line":194,"address":[7699503,7699616],"length":1,"stats":{"Line":2}},{"line":195,"address":[7699725,7699632],"length":1,"stats":{"Line":2}},{"line":198,"address":[7699817],"length":1,"stats":{"Line":1}},{"line":208,"address":[7699762],"length":1,"stats":{"Line":1}},{"line":209,"address":[7699801],"length":1,"stats":{"Line":1}},{"line":211,"address":[7699856],"length":1,"stats":{"Line":1}},{"line":214,"address":[7699870],"length":1,"stats":{"Line":1}},{"line":217,"address":[7699977],"length":1,"stats":{"Line":1}},{"line":218,"address":[7700024],"length":1,"stats":{"Line":1}},{"line":219,"address":[7700178,7700089],"length":1,"stats":{"Line":2}},{"line":220,"address":[7700193,7700258],"length":1,"stats":{"Line":2}},{"line":221,"address":[7700285],"length":1,"stats":{"Line":1}},{"line":222,"address":[7700576,7700512],"length":1,"stats":{"Line":2}},{"line":223,"address":[7700619],"length":1,"stats":{"Line":1}},{"line":224,"address":[7700648],"length":1,"stats":{"Line":1}},{"line":225,"address":[7700822],"length":1,"stats":{"Line":1}},{"line":226,"address":[7700974],"length":1,"stats":{"Line":1}},{"line":229,"address":[7701182,7701096],"length":1,"stats":{"Line":2}},{"line":231,"address":[7701242],"length":1,"stats":{"Line":1}},{"line":234,"address":[7701377,7701480],"length":1,"stats":{"Line":2}},{"line":235,"address":[7701556],"length":1,"stats":{"Line":1}},{"line":239,"address":[7701635],"length":1,"stats":{"Line":1}},{"line":240,"address":[7701642],"length":1,"stats":{"Line":1}},{"line":244,"address":[7701773],"length":1,"stats":{"Line":1}},{"line":246,"address":[7701692],"length":1,"stats":{"Line":1}},{"line":248,"address":[7701780],"length":1,"stats":{"Line":1}},{"line":249,"address":[7701712,7700051,7698127,7698702,7696907,7695551,7701113,7701571,7696831,7694078,7701448,7700220,7701822,7696556,7695305,7696074,7699375,7699572,7698044,7699655,7700124,7700519,7700933,7703044,7702451,7697302,7693449,7697496,7694583,7695157,7697836,7698829,7695819,7703093,7699992,7694377,7698183,7693979,7695748,7696442,7694464,7696688,7698585,7697003,7694915],"length":1,"stats":{"Line":2}},{"line":251,"address":[7692800],"length":1,"stats":{"Line":1}},{"line":252,"address":[7692816],"length":1,"stats":{"Line":1}},{"line":253,"address":[7692834],"length":1,"stats":{"Line":0}},{"line":255,"address":[7692826],"length":1,"stats":{"Line":1}},{"line":256,"address":[7692931],"length":1,"stats":{"Line":0}},{"line":259,"address":[7692851],"length":1,"stats":{"Line":1}},{"line":260,"address":[7692859],"length":1,"stats":{"Line":1}},{"line":262,"address":[7692867,7692941,7693015],"length":1,"stats":{"Line":3}},{"line":263,"address":[7692983],"length":1,"stats":{"Line":1}},{"line":264,"address":[7693003],"length":1,"stats":{"Line":1}},{"line":265,"address":[7693011],"length":1,"stats":{"Line":1}},{"line":268,"address":[7693017],"length":1,"stats":{"Line":1}},{"line":269,"address":[7693025],"length":1,"stats":{"Line":1}}],"covered":124,"coverable":126},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","fri.rs"],"content":"mod common;\n\nuse p3_baby_bear::default_babybear_poseidon2_16;\nuse p3_challenger::{CanObserve, CanSampleBits, FieldChallenger, GrindingChallenger};\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::ops::generate_poseidon2_trace;\nuse p3_commit::Pcs;\nuse p3_dft::Radix2DitParallel as Dft;\nuse p3_field::coset::TwoAdicMultiplicativeCoset;\nuse p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing};\nuse p3_fri::create_test_fri_params;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\n// Recursive target graph pieces\nuse p3_recursion::pcs::fri::{\n    FriProofTargets, InputProofTargets, MerkleCapTargets, RecExtensionValMmcs, RecValMmcs,\n    Witness as RecWitness,\n};\nuse p3_recursion::public_inputs::{CommitmentOpening, FriVerifierInputs};\nuse p3_recursion::{Poseidon2Config, Recursive};\nuse rand::SeedableRng;\nuse rand::rngs::SmallRng;\n\nuse crate::common::baby_bear_params::*;\n\ntype RecVal = RecValMmcs\u003cF, 8, MyHash, MyCompress\u003e;\ntype RecExt = RecExtensionValMmcs\u003cF, Challenge, 8, RecVal\u003e;\n\n// Bring the circuit we're testing.\nuse p3_recursion::pcs::fri::verify_fri_circuit;\n\n/// Alias for FriProofTargets used for lens/value extraction and allocation\ntype FriTargets =\n    FriProofTargets\u003cF, Challenge, RecExt, InputProofTargets\u003cF, Challenge, RecVal\u003e, RecWitness\u003cF\u003e\u003e;\n\n/// Type alias for commitments with opening points structure\ntype CommitmentsWithPoints = Vec\u003c(\n    Challenge,\n    Vec\u003c(\n        TwoAdicMultiplicativeCoset\u003cF\u003e,\n        Vec\u003c(Challenge, Vec\u003cChallenge\u003e)\u003e,\n    )\u003e,\n)\u003e;\n\n/// Helper: build one group's evaluation matrices for a given seed and sizes.\nfn make_evals(\n    polynomial_log_sizes: \u0026[u8],\n    seed: u64,\n) -\u003e Vec\u003c(TwoAdicMultiplicativeCoset\u003cF\u003e, RowMajorMatrix\u003cF\u003e)\u003e {\n    let mut rng = SmallRng::seed_from_u64(seed);\n    polynomial_log_sizes\n        .iter()\n        .map(|\u0026deg_bits| {\n            let rows = 1usize \u003c\u003c deg_bits;\n            let domain = TwoAdicMultiplicativeCoset::new(F::GENERATOR, deg_bits as usize)\n                .expect(\"valid two-adic size\");\n\n            // Ensure width \u003e= 1 to avoid zero-width matrices for small degrees.\n            let width = core::cmp::max(1, (deg_bits as usize).saturating_sub(4));\n\n            (\n                domain,\n                RowMajorMatrix::\u003cF\u003e::rand_nonzero(\u0026mut rng, rows, width),\n            )\n        })\n        .collect()\n}\n\n/// Holds all the public inputs and challenges required for a recursive FRI verification circuit.\nstruct ProduceInputsResult {\n    /// FRI values, ordered to match the structure required by `FriProofTargets`.\n    fri_values: Vec\u003cChallenge\u003e,\n    /// The `alpha` challenge used for batching polynomial commitments.\n    alpha: Challenge,\n    /// The `beta` challenges, one for each FRI folding phase.\n    betas: Vec\u003cChallenge\u003e,\n    /// The query indices, represented as little-endian bits, for each query.\n    index_bits_per_query: Vec\u003cVec\u003cChallenge\u003e\u003e,\n    /// Commitments with opening points structure (per batch)\n    commitments_with_points: CommitmentsWithPoints,\n    /// The total number of FRI folding phases (rounds).\n    num_phases: usize,\n    /// The log base 2 of the size of the largest domain.\n    log_max_height: usize,\n    /// The FRI proof\n    fri_proof: \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::Proof,\n}\n\n/// Produce all public inputs for a recursive FRI verification circuit over **multiple input batches**.\n///\n/// `group_sizes` is a list of groups, each group is a list of log2 degrees.\nfn produce_inputs_multi(\n    pcs: \u0026MyPcs,\n    perm: \u0026Perm,\n    log_blowup: usize,\n    log_final_poly_len: usize,\n    // commit phase pow bits and query pow bits\n    pow_bits: (usize, usize),\n    group_sizes: \u0026[Vec\u003cu8\u003e],\n    seed_base: u64,\n) -\u003e ProduceInputsResult {\n    // Build per-group evals and commit\n    let mut groups_evals = Vec::new();\n    for (i, sizes) in group_sizes.iter().enumerate() {\n        groups_evals.push(make_evals(sizes, seed_base + i as u64));\n    }\n\n    // Flatten domain sizes (base log sizes) for public inputs\n    let mut domains_log_sizes = Vec::new();\n    for sizes in group_sizes {\n        domains_log_sizes.extend(sizes.iter().map(|\u0026b| b as usize));\n    }\n    let val_sizes: Vec\u003cF\u003e = domains_log_sizes\n        .iter()\n        .map(|\u0026b| F::from_u8(b as u8))\n        .collect();\n\n    // --- Prover path ---\n    let mut p_challenger = Challenger::new(perm.clone());\n    p_challenger.observe_slice(\u0026val_sizes);\n\n    // Commit each group and observe all commitments before sampling zeta\n    let mut commitments_and_data = Vec::new();\n    for evals in \u0026groups_evals {\n        let (commitment, prover_data) =\n            \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::commit(pcs, evals.clone());\n        p_challenger.observe(commitment.clone());\n        commitments_and_data.push((commitment, prover_data));\n    }\n\n    // Single zeta for all matrices across all groups\n    let zeta: Challenge = p_challenger.sample_algebra_element();\n\n    // Build open request: one (\u0026ProverData, points_per_matrix) per group\n    let mut open_data = Vec::new();\n    for (i, _evals) in groups_evals.iter().enumerate() {\n        let mat_count = groups_evals[i].len();\n        open_data.push((\u0026commitments_and_data[i].1, vec![vec![zeta]; mat_count]));\n    }\n\n    // Open and produce FRI proof\n    let (opened_values, fri_proof) =\n        \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::open(pcs, open_data, \u0026mut p_challenger);\n\n    // --- Verifier transcript replay (to derive the public inputs) ---\n    let mut v_challenger = Challenger::new(perm.clone());\n    v_challenger.observe_slice(\u0026val_sizes);\n    for (commitment, _) in \u0026commitments_and_data {\n        v_challenger.observe(commitment.clone());\n    }\n    let _zeta_v: Challenge = v_challenger.sample_algebra_element();\n\n    // Flatten opened values in the same order we passed to `open`\n    // Shape: OpenedValues -\u003e groups -\u003e matrices -\u003e columns\n    let point_values_flat: Vec\u003cVec\u003cChallenge\u003e\u003e =\n        opened_values.into_iter().flatten().flatten().collect();\n\n    // Extract proof pieces\n    let p3_fri::FriProof {\n        commit_phase_commits,\n        ref query_proofs,\n        final_poly,\n        query_pow_witness,\n        commit_pow_witnesses,\n    } = fri_proof.clone();\n\n    // Observe all opened evaluation values (same order)\n    for values in \u0026point_values_flat {\n        for \u0026opening in values {\n            v_challenger.observe_algebra_element(opening);\n        }\n    }\n\n    // α (batch combiner)\n    let alpha: Challenge = v_challenger.sample_algebra_element();\n\n    let (commit_pow_bits, query_pow_bits) = pow_bits;\n\n    // β_i per phase: observe commitment, then sample β\n    let mut betas: Vec\u003cChallenge\u003e = Vec::with_capacity(commit_phase_commits.len());\n    for (c, w) in commit_phase_commits.iter().zip(commit_pow_witnesses.iter()) {\n        v_challenger.observe(c.clone());\n        assert!(v_challenger.check_witness(commit_pow_bits, *w));\n        betas.push(v_challenger.sample_algebra_element());\n    }\n\n    // Final poly coeffs (constant here)\n    for \u0026c in \u0026final_poly {\n        v_challenger.observe_algebra_element(c);\n    }\n\n    // Bind the variable-arity schedule into the transcript before query grinding,\n    // matching the native FRI verifier in Plonky3.\n    if let Some(first_qp) = query_proofs.first() {\n        for step in \u0026first_qp.commit_phase_openings {\n            v_challenger.observe(F::from_usize(step.log_arity as usize));\n        }\n    }\n\n    // PoW check\n    assert!(v_challenger.check_witness(query_pow_bits, query_pow_witness));\n\n    // Query indices\n    let num_phases = commit_phase_commits.len();\n    let log_max_height = num_phases + log_blowup + log_final_poly_len;\n    let num_queries = query_proofs.len();\n    let mut indices: Vec\u003cusize\u003e = Vec::with_capacity(num_queries);\n    for _ in 0..num_queries {\n        indices.push(v_challenger.sample_bits(log_max_height));\n    }\n\n    // Index bits per query (LE)\n    let mut index_bits_per_query: Vec\u003cVec\u003cChallenge\u003e\u003e = Vec::with_capacity(num_queries);\n    for \u0026index in \u0026indices {\n        let mut bits_one = Vec::with_capacity(log_max_height);\n        for k in 0..log_max_height {\n            bits_one.push(if (index \u003e\u003e k) \u0026 1 == 1 {\n                Challenge::ONE\n            } else {\n                Challenge::ZERO\n            });\n        }\n        index_bits_per_query.push(bits_one);\n    }\n\n    // Build commitments_with_points structure\n    // For each batch: (commitment_placeholder, Vec\u003c(domain, Vec\u003c(z, [f(z)])\u003e)\u003e)\n    let mut commitments_with_points = Vec::new();\n    let mut pv_idx = 0;\n    for sizes in group_sizes.iter() {\n        let mut mats_data = Vec::new();\n        for \u0026log_size in sizes {\n            let domain = TwoAdicMultiplicativeCoset::new(F::GENERATOR, log_size as usize)\n                .expect(\"valid domain\");\n            let points_and_values = vec![(zeta, point_values_flat[pv_idx].clone())];\n            mats_data.push((domain, points_and_values));\n            pv_idx += 1;\n        }\n        // Use a placeholder value for the commitment (not used in arithmetic verification)\n        let commit_placeholder = Challenge::ZERO;\n        commitments_with_points.push((commit_placeholder, mats_data));\n    }\n\n    // —— FriProofTargets values ——\n\n    let fri_values: Vec\u003cChallenge\u003e = FriTargets::get_values(\u0026p3_fri::FriProof {\n        commit_phase_commits,\n        query_proofs: query_proofs.clone(),\n        final_poly,\n        query_pow_witness,\n        commit_pow_witnesses,\n    });\n\n    ProduceInputsResult {\n        fri_values,\n        alpha,\n        betas,\n        index_bits_per_query,\n        commitments_with_points,\n        num_phases,\n        log_max_height,\n        fri_proof,\n    }\n}\n\n/// Linearize public inputs in the exact order allocated by the circuit builder.\nfn pack_inputs(\n    fri_vals: Vec\u003cChallenge\u003e,\n    alpha: Challenge,\n    betas: Vec\u003cChallenge\u003e,\n    index_bits_all_queries: Vec\u003cVec\u003cChallenge\u003e\u003e,\n    commitments_with_points: CommitmentsWithPoints,\n) -\u003e Vec\u003cChallenge\u003e {\n    let commitment_openings = commitments_with_points\n        .into_iter()\n        .map(|(commitment, mats)| {\n            let mut opened_points = Vec::new();\n            for (_domain, points_and_values) in mats {\n                for (z, fz) in points_and_values {\n                    opened_points.push((z, fz));\n                }\n            }\n            CommitmentOpening {\n                commitment,\n                opened_points,\n            }\n        })\n        .collect();\n\n    FriVerifierInputs {\n        fri_proof_values: fri_vals,\n        alpha,\n        betas,\n        query_index_bits: index_bits_all_queries,\n        commitment_openings,\n    }\n    .build()\n}\n\n/// Holds all the FRI parameters and group sizes to generate test inputs.\nstruct FriSetup {\n    pcs: MyPcs,\n    perm: Perm,\n    log_blowup: usize,\n    log_final_poly_len: usize,\n    query_pow_bits: usize,\n    commit_pow_bits: usize,\n    group_sizes: Vec\u003cVec\u003cu8\u003e\u003e,\n}\n\nimpl FriSetup {\n    const fn new(\n        pcs: MyPcs,\n        perm: Perm,\n        log_blowup: usize,\n        log_final_poly_len: usize,\n        query_pow_bits: usize,\n        commit_pow_bits: usize,\n        group_sizes: Vec\u003cVec\u003cu8\u003e\u003e,\n    ) -\u003e Self {\n        Self {\n            pcs,\n            perm,\n            log_blowup,\n            log_final_poly_len,\n            query_pow_bits,\n            commit_pow_bits,\n            group_sizes,\n        }\n    }\n}\n\nfn generate_setup(log_final_poly_len: usize, group_sizes: Vec\u003cVec\u003cu8\u003e\u003e) -\u003e FriSetup {\n    // Common setup\n    let perm = default_babybear_poseidon2_16();\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress, 0);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::\u003cF\u003e::default();\n\n    let fri_params = create_test_fri_params(challenge_mmcs, log_final_poly_len);\n    let log_blowup = fri_params.log_blowup;\n    let log_final_poly_len = fri_params.log_final_poly_len;\n    let query_pow_bits = fri_params.query_proof_of_work_bits;\n    let commit_pow_bits = fri_params.commit_proof_of_work_bits;\n    let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n\n    FriSetup::new(\n        pcs,\n        perm,\n        log_blowup,\n        log_final_poly_len,\n        query_pow_bits,\n        commit_pow_bits,\n        group_sizes,\n    )\n}\n\nfn run_fri_test(setup: FriSetup, build_only: bool) {\n    let FriSetup {\n        pcs,\n        perm,\n        log_blowup,\n        log_final_poly_len,\n        query_pow_bits,\n        commit_pow_bits,\n        group_sizes,\n    } = setup;\n\n    // Produce two proofs with different inputs (same shape), to reuse one circuit\n    let result_1 = produce_inputs_multi(\n        \u0026pcs,\n        \u0026perm,\n        log_blowup,\n        log_final_poly_len,\n        (commit_pow_bits, query_pow_bits),\n        \u0026group_sizes,\n        /*seed_base=*/ 0,\n    );\n\n    let result_2 = produce_inputs_multi(\n        \u0026pcs,\n        \u0026perm,\n        log_blowup,\n        log_final_poly_len,\n        (commit_pow_bits, query_pow_bits),\n        \u0026group_sizes,\n        /*seed_base=*/ 1,\n    );\n\n    // Shape checks (must match so we can reuse one circuit)\n    assert_eq!(result_1.num_phases, result_2.num_phases);\n    assert_eq!(result_1.log_max_height, result_2.log_max_height);\n\n    let num_phases = result_1.num_phases;\n    let log_max_height = result_1.log_max_height;\n    let expected_final_poly_len = 1 \u003c\u003c log_final_poly_len;\n\n    // ——— Build circuit once (using first proof's shape) ———\n    let mut builder = CircuitBuilder::\u003cChallenge\u003e::new();\n\n    // 1) Allocate FriProofTargets using instance 1\n    let fri_targets = FriTargets::new(\u0026mut builder, \u0026result_1.fri_proof);\n\n    // Verify the final polynomial has the expected length\n    assert_eq!(\n        fri_targets.final_poly.len(),\n        expected_final_poly_len,\n        \"Circuit final polynomial should have {expected_final_poly_len} coefficients\"\n    );\n\n    // 2) Public inputs for α, βs, index bits\n    let alpha_t = builder.public_input();\n    let betas_t: Vec\u003c_\u003e = (0..num_phases).map(|_| builder.public_input()).collect();\n\n    let num_queries = result_1.index_bits_per_query.len();\n    let index_bits_t_per_query: Vec\u003cVec\u003c_\u003e\u003e = (0..num_queries)\n        .map(|_| {\n            (0..log_max_height)\n                .map(|_| builder.public_input())\n                .collect()\n        })\n        .collect();\n\n    builder.push_scope(\"commitments_with_opening_points\");\n\n    // 3) Build commitments_with_opening_points targets structure\n    // For each batch: allocate commitment target + (domain, Vec\u003c(z_target, [fz_targets])\u003e)\n    let mut commitments_with_opening_points_targets = Vec::new();\n    for (_commit_val, mats_data) in \u0026result_1.commitments_with_points {\n        // Allocate commitment target (placeholder, not used in arithmetic verification)\n        let commit_t = builder.public_input();\n\n        let mut mats_targets = Vec::new();\n        for (domain, points_and_values) in mats_data {\n            let mut pv_targets = Vec::new();\n            for (_z, fz) in points_and_values {\n                let z_t = builder.public_input();\n                let fz_t: Vec\u003c_\u003e = (0..fz.len()).map(|_| builder.public_input()).collect();\n                pv_targets.push((z_t, fz_t));\n            }\n            mats_targets.push((*domain, pv_targets));\n        }\n        commitments_with_opening_points_targets.push((commit_t, mats_targets));\n    }\n    builder.pop_scope();\n\n    // 4) Wire the arithmetic-only FRI verifier (MMCS verification disabled for this test)\n    let _mmcs_op_ids =\n        verify_fri_circuit::\u003cF, Challenge, RecExt, RecVal, RecWitness\u003cF\u003e, p3_recursion::Target\u003e(\n            \u0026mut builder,\n            \u0026fri_targets,\n            alpha_t,\n            \u0026betas_t,\n            \u0026index_bits_t_per_query,\n            \u0026commitments_with_opening_points_targets,\n            log_blowup,\n            None, // MMCS verification disabled\n        )\n        .unwrap();\n\n    builder.dump_allocation_log();\n    let circuit = builder.build().unwrap();\n\n    if build_only {\n        return;\n    }\n\n    // ---- Run instance 1 ----\n    let pub_inputs1 = pack_inputs(\n        result_1.fri_values,\n        result_1.alpha,\n        result_1.betas,\n        result_1.index_bits_per_query.clone(),\n        result_1.commitments_with_points,\n    );\n    let mut runner1 = circuit.clone().runner();\n    runner1.set_public_inputs(\u0026pub_inputs1).unwrap();\n    runner1.run().unwrap();\n\n    // ---- Run instance 2 ----\n    let pub_inputs2 = pack_inputs(\n        result_2.fri_values,\n        result_2.alpha,\n        result_2.betas,\n        result_2.index_bits_per_query.clone(),\n        result_2.commitments_with_points,\n    );\n    let mut runner2 = circuit.runner();\n    runner2.set_public_inputs(\u0026pub_inputs2).unwrap();\n    runner2.run().unwrap();\n}\n\n#[test]\nfn test_circuit_fri_verifier_degree_0_final_poly() {\n    // Three \"rounds\"/batches of inputs, different shapes. Include a degree-0 (height=1)\n    // matrix so the `log_height == log_blowup` reduced-opening constraint is exercised.\n    //   [0, 5, 8, 8, 10], [8, 11], [4, 5, 8]\n    let groups = vec![vec![0u8, 5, 8, 8, 10], vec![8u8, 11], vec![4u8, 5, 8]];\n\n    let setup = generate_setup(0, groups);\n\n    run_fri_test(setup, false);\n}\n\n#[test]\nfn test_circuit_fri_verifier_degree_1_final_poly() {\n    // Use smaller matrices to ensure we actually get a higher-degree final polynomial\n    // For a final polynomial of degree 1, we need `log_max_height` small enough\n    let groups = vec![vec![3u8, 4], vec![5u8]];\n\n    let setup = generate_setup(1, groups);\n\n    run_fri_test(setup, false);\n}\n\n#[test]\nfn test_circuit_fri_verifier_degree_3_final_poly() {\n    // Small matrices to get higher-degree final polynomial\n    let groups = vec![vec![4u8], vec![5u8]];\n\n    let setup = generate_setup(2, groups);\n\n    run_fri_test(setup, false);\n}\n\n#[test]\nfn test_circuit_fri_verifier_scoped_builder() {\n    let groups = vec![vec![0u8, 5, 8, 8, 10], vec![8u8, 11], vec![4u8, 5, 8]];\n    let setup = generate_setup(0, groups);\n    run_fri_test(setup, true);\n}\n\n// ============================================================================\n// E2E test with full MMCS verification\n// ============================================================================\n\n/// Run FRI test with full MMCS verification.\nfn run_fri_test_with_mmcs(setup: FriSetup) {\n    let FriSetup {\n        pcs,\n        perm,\n        log_blowup,\n        log_final_poly_len,\n        query_pow_bits,\n        commit_pow_bits,\n        group_sizes,\n    } = setup;\n\n    // Produce a proof\n    let result = produce_inputs_multi(\n        \u0026pcs,\n        \u0026perm,\n        log_blowup,\n        log_final_poly_len,\n        (commit_pow_bits, query_pow_bits),\n        \u0026group_sizes,\n        /*seed_base=*/ 42,\n    );\n\n    let num_phases = result.num_phases;\n    let log_max_height = result.log_max_height;\n    let num_queries = result.index_bits_per_query.len();\n\n    // ——— Build circuit with MMCS verification enabled ———\n    let mut builder = CircuitBuilder::\u003cChallenge\u003e::new();\n\n    // Enable Poseidon2 permutation for MMCS verification\n    let perm_for_circuit = default_babybear_poseidon2_16();\n    builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cChallenge, BabyBearD4Width16\u003e,\n        perm_for_circuit,\n    );\n\n    // 1) Allocate FriProofTargets\n    let fri_targets = FriTargets::new(\u0026mut builder, \u0026result.fri_proof);\n\n    // 2) Public inputs for α, βs, index bits\n    let alpha_t = builder.public_input();\n    let betas_t: Vec\u003c_\u003e = (0..num_phases).map(|_| builder.public_input()).collect();\n\n    let index_bits_t_per_query: Vec\u003cVec\u003c_\u003e\u003e = (0..num_queries)\n        .map(|_| {\n            (0..log_max_height)\n                .map(|_| builder.public_input())\n                .collect()\n        })\n        .collect();\n\n    // 3) Build commitments_with_opening_points targets structure with MerkleCapTargets\n    // Extract actual commitments from the prover transcript\n    let mut v_challenger = Challenger::new(perm);\n    let val_sizes: Vec\u003cF\u003e = group_sizes\n        .iter()\n        .flat_map(|sizes| sizes.iter().map(|\u0026b| F::from_u8(b)))\n        .collect();\n    v_challenger.observe_slice(\u0026val_sizes);\n\n    // Rebuild commitments for targets and values\n    let mut actual_commitments = Vec::new();\n\n    // We need to extract the commitments from the PCS - for this test, we'll\n    // recreate the evaluation matrices and re-commit to get the actual values\n    let mut groups_evals = Vec::new();\n    for (i, sizes) in group_sizes.iter().enumerate() {\n        groups_evals.push(make_evals(sizes, 42 + i as u64));\n    }\n\n    for evals in \u0026groups_evals {\n        let (commitment, _prover_data) =\n            \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::commit(\u0026pcs, evals.clone());\n        v_challenger.observe(commitment.clone());\n        actual_commitments.push(commitment);\n    }\n\n    let mut commitments_with_opening_points_targets = Vec::new();\n\n    for (group_idx, (_commit_placeholder, mats_data)) in\n        result.commitments_with_points.iter().enumerate()\n    {\n        // Allocate MerkleCapTargets for the commitment using Recursive::new\n        let commit_hash_targets = \u003cMerkleCapTargets\u003cF, DIGEST_ELEMS\u003e as Recursive\u003cChallenge\u003e\u003e::new(\n            \u0026mut builder,\n            \u0026actual_commitments[group_idx],\n        );\n\n        let mut mats_targets = Vec::new();\n        for (domain, points_and_values) in mats_data {\n            let mut pv_targets = Vec::new();\n            for (_z, fz) in points_and_values {\n                let z_t = builder.public_input();\n                let fz_t: Vec\u003c_\u003e = (0..fz.len()).map(|_| builder.public_input()).collect();\n                pv_targets.push((z_t, fz_t));\n            }\n            mats_targets.push((*domain, pv_targets));\n        }\n\n        commitments_with_opening_points_targets.push((commit_hash_targets, mats_targets));\n    }\n\n    // 4) Wire the FRI verifier with MMCS verification enabled\n    let mmcs_op_ids = verify_fri_circuit::\u003c\n        F,\n        Challenge,\n        RecExt,\n        RecVal,\n        RecWitness\u003cF\u003e,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n    \u003e(\n        \u0026mut builder,\n        \u0026fri_targets,\n        alpha_t,\n        \u0026betas_t,\n        \u0026index_bits_t_per_query,\n        \u0026commitments_with_opening_points_targets,\n        log_blowup,\n        Some(Poseidon2Config::BabyBearD4Width16),\n    )\n    .unwrap();\n\n    println!(\n        \"FRI circuit with MMCS: {} MMCS operations requiring private data\",\n        mmcs_op_ids.len()\n    );\n\n    // Build the circuit\n    let circuit = builder.build().unwrap();\n\n    // ---- Pack public inputs in allocation order ----\n    let mut packed_inputs: Vec\u003cChallenge\u003e = Vec::new();\n\n    // 1. FRI proof values (allocated by FriTargets::new - lifted for batch openings)\n    packed_inputs.extend(\u0026result.fri_values);\n\n    // 2. Alpha\n    packed_inputs.push(result.alpha);\n\n    // 3. Betas\n    packed_inputs.extend(\u0026result.betas);\n\n    // 4. Index bits per query\n    for bits in \u0026result.index_bits_per_query {\n        packed_inputs.extend(bits);\n    }\n\n    // 5. Commitments with opening points\n    // MerkleCapTargets uses lifted representation (one target per base field value)\n    for (group_idx, (_commit_placeholder, mats_data)) in\n        result.commitments_with_points.iter().enumerate()\n    {\n        // Commitment cap entries as lifted extension field values\n        for entry in actual_commitments[group_idx].roots() {\n            for \u0026c in entry {\n                packed_inputs.push(Challenge::from(c));\n            }\n        }\n\n        // Then (z, fz) pairs for each matrix\n        for (_domain, points_and_values) in mats_data {\n            for (z, fz) in points_and_values {\n                packed_inputs.push(*z);\n                packed_inputs.extend(fz);\n            }\n        }\n    }\n\n    let mut runner = circuit.runner();\n    runner.set_public_inputs(\u0026packed_inputs).unwrap();\n\n    println!(\n        \"FRI circuit with MMCS: {} MMCS operations (input batch + commit-phase)\",\n        mmcs_op_ids.len()\n    );\n\n    // Set MMCS private data from the FRI proof\n    // This sets siblings for both input batch MMCS and commit-phase MMCS\n    let log_max_height = result.log_max_height;\n\n    let mut op_idx = 0;\n    for query_proof in \u0026result.fri_proof.query_proofs {\n        // Input batch MMCS proofs\n        for batch_opening in \u0026query_proof.input_proof {\n            let siblings: Vec\u003c[Challenge; 2]\u003e = batch_opening\n                .opening_proof\n                .iter()\n                .map(|digest| {\n                    let ext_elements: Vec\u003cChallenge\u003e = digest\n                        .chunks(4)\n                        .map(|chunk| {\n                            Challenge::from_basis_coefficients_slice(chunk)\n                                .expect(\"chunk size should match extension degree\")\n                        })\n                        .collect();\n                    [ext_elements[0], ext_elements[1]]\n                })\n                .collect();\n            for sibling in siblings {\n                runner\n                    .set_private_data(\n                        mmcs_op_ids[op_idx],\n                        p3_circuit::NonPrimitiveOpPrivateData::Poseidon2Perm(\n                            p3_circuit::ops::Poseidon2PermPrivateData { sibling },\n                        ),\n                    )\n                    .expect(\"Failed to set input batch MMCS private data\");\n                op_idx += 1;\n            }\n        }\n\n        // Commit-phase MMCS proofs\n        for (phase_idx, phase_opening) in query_proof.commit_phase_openings.iter().enumerate() {\n            let log_folded_height = log_max_height.saturating_sub(phase_idx + 1);\n\n            // Only set data if there's a tree to verify (height \u003e 0)\n            if log_folded_height \u003e 0 {\n                let siblings: Vec\u003c[Challenge; 2]\u003e = phase_opening\n                    .opening_proof\n                    .iter()\n                    .take(log_folded_height)\n                    .map(|digest| {\n                        let ext_elements: Vec\u003cChallenge\u003e = digest\n                            .chunks(4)\n                            .map(|chunk| {\n                                Challenge::from_basis_coefficients_slice(chunk)\n                                    .expect(\"chunk size should match extension degree\")\n                            })\n                            .collect();\n                        [ext_elements[0], ext_elements[1]]\n                    })\n                    .collect();\n                for sibling in siblings {\n                    runner\n                        .set_private_data(\n                            mmcs_op_ids[op_idx],\n                            p3_circuit::NonPrimitiveOpPrivateData::Poseidon2Perm(\n                                p3_circuit::ops::Poseidon2PermPrivateData { sibling },\n                            ),\n                        )\n                        .expect(\"Failed to set commit-phase MMCS private data\");\n                    op_idx += 1;\n                }\n            }\n        }\n    }\n    assert_eq!(\n        op_idx,\n        mmcs_op_ids.len(),\n        \"Should have set private data for all MMCS ops\"\n    );\n\n    // Run the circuit\n    runner.run().expect(\"FRI+MMCS circuit execution failed\");\n}\n\n#[test]\nfn test_circuit_fri_verifier_with_mmcs() {\n    // Test that the FRI circuit with MMCS verification builds and runs correctly.\n    let groups = vec![vec![4u8, 5]];\n    let setup = generate_setup(1, groups);\n    run_fri_test_with_mmcs(setup);\n}\n","traces":[{"line":1,"address":[2172080],"length":1,"stats":{"Line":1}},{"line":46,"address":[2139152],"length":1,"stats":{"Line":2}},{"line":50,"address":[2139202],"length":1,"stats":{"Line":2}},{"line":52,"address":[2139222],"length":1,"stats":{"Line":2}},{"line":53,"address":[2139280,2139231,2139312],"length":1,"stats":{"Line":6}},{"line":54,"address":[2139325,2139559],"length":1,"stats":{"Line":2}},{"line":55,"address":[2139368],"length":1,"stats":{"Line":2}},{"line":56,"address":[2139388],"length":1,"stats":{"Line":2}},{"line":59,"address":[2139426],"length":1,"stats":{"Line":2}},{"line":61,"address":[2139498],"length":1,"stats":{"Line":2}},{"line":63,"address":[2139475],"length":1,"stats":{"Line":2}},{"line":65,"address":[2139551],"length":1,"stats":{"Line":2}},{"line":66,"address":[2139251],"length":1,"stats":{"Line":2}},{"line":67,"address":[2139266],"length":1,"stats":{"Line":2}},{"line":92,"address":[2158125,2155162,2148768],"length":1,"stats":{"Line":2}},{"line":103,"address":[2149007],"length":1,"stats":{"Line":2}},{"line":104,"address":[2149211,2149124],"length":1,"stats":{"Line":4}},{"line":105,"address":[2149423,2158026],"length":1,"stats":{"Line":4}},{"line":109,"address":[2149453],"length":1,"stats":{"Line":1}},{"line":110,"address":[2149571,2149488],"length":1,"stats":{"Line":4}},{"line":111,"address":[2158192,2149673,2158202,2157932],"length":1,"stats":{"Line":8}},{"line":113,"address":[2149711],"length":1,"stats":{"Line":1}},{"line":114,"address":[2149750],"length":1,"stats":{"Line":3}},{"line":115,"address":[2149793,2158144,2158157],"length":1,"stats":{"Line":5}},{"line":116,"address":[2149840],"length":1,"stats":{"Line":3}},{"line":119,"address":[2149934,2149855],"length":1,"stats":{"Line":4}},{"line":120,"address":[2149949,2150033],"length":1,"stats":{"Line":4}},{"line":123,"address":[2150048],"length":1,"stats":{"Line":1}},{"line":124,"address":[2150142,2150063,2157863],"length":1,"stats":{"Line":6}},{"line":125,"address":[2157465],"length":1,"stats":{"Line":1}},{"line":126,"address":[2157458,2150252],"length":1,"stats":{"Line":4}},{"line":127,"address":[2157577,2157641],"length":1,"stats":{"Line":2}},{"line":128,"address":[2157648],"length":1,"stats":{"Line":2}},{"line":129,"address":[2157847,2157584,2157868],"length":1,"stats":{"Line":2}},{"line":132,"address":[2150278],"length":1,"stats":{"Line":2}},{"line":135,"address":[2150293],"length":1,"stats":{"Line":2}},{"line":136,"address":[2150300,2150396],"length":1,"stats":{"Line":4}},{"line":137,"address":[2150655,2157110],"length":1,"stats":{"Line":4}},{"line":138,"address":[2157143],"length":1,"stats":{"Line":2}},{"line":142,"address":[2150775],"length":1,"stats":{"Line":2}},{"line":143,"address":[2150696],"length":1,"stats":{"Line":2}},{"line":146,"address":[2150935,2151011],"length":1,"stats":{"Line":4}},{"line":147,"address":[2151026,2151110],"length":1,"stats":{"Line":4}},{"line":148,"address":[2151125],"length":1,"stats":{"Line":2}},{"line":149,"address":[2157042,2151274],"length":1,"stats":{"Line":4}},{"line":151,"address":[2151300],"length":1,"stats":{"Line":2}},{"line":156,"address":[2151307],"length":1,"stats":{"Line":1}},{"line":160,"address":[2151502],"length":1,"stats":{"Line":1}},{"line":161,"address":[2151542],"length":1,"stats":{"Line":1}},{"line":162,"address":[2151566],"length":1,"stats":{"Line":1}},{"line":163,"address":[2151606],"length":1,"stats":{"Line":1}},{"line":164,"address":[2151627],"length":1,"stats":{"Line":1}},{"line":165,"address":[2151455],"length":1,"stats":{"Line":1}},{"line":168,"address":[2151755,2151675],"length":1,"stats":{"Line":2}},{"line":169,"address":[2156791,2151857],"length":1,"stats":{"Line":2}},{"line":170,"address":[2156894],"length":1,"stats":{"Line":1}},{"line":175,"address":[2151899],"length":1,"stats":{"Line":1}},{"line":177,"address":[2151922],"length":1,"stats":{"Line":2}},{"line":180,"address":[2151946],"length":1,"stats":{"Line":2}},{"line":181,"address":[2152000,2152080],"length":1,"stats":{"Line":4}},{"line":182,"address":[2152443,2156619],"length":1,"stats":{"Line":4}},{"line":183,"address":[2156642],"length":1,"stats":{"Line":2}},{"line":184,"address":[2156722],"length":1,"stats":{"Line":2}},{"line":188,"address":[2152461],"length":1,"stats":{"Line":2}},{"line":189,"address":[2156598,2152605],"length":1,"stats":{"Line":4}},{"line":194,"address":[2152655],"length":1,"stats":{"Line":2}},{"line":195,"address":[2152772,2152855],"length":1,"stats":{"Line":2}},{"line":196,"address":[2152961],"length":1,"stats":{"Line":1}},{"line":201,"address":[2152822,2153015],"length":1,"stats":{"Line":2}},{"line":204,"address":[2153059],"length":1,"stats":{"Line":1}},{"line":205,"address":[2153100,2153213],"length":1,"stats":{"Line":1}},{"line":206,"address":[2153198,2153242],"length":1,"stats":{"Line":2}},{"line":207,"address":[2153258],"length":1,"stats":{"Line":1}},{"line":208,"address":[2153273,2153364],"length":1,"stats":{"Line":2}},{"line":209,"address":[2153439,2156574],"length":1,"stats":{"Line":2}},{"line":213,"address":[2153473],"length":1,"stats":{"Line":1}},{"line":214,"address":[2153567,2153488,2156400],"length":1,"stats":{"Line":5}},{"line":215,"address":[2153700,2156131],"length":1,"stats":{"Line":4}},{"line":216,"address":[2156139,2156215],"length":1,"stats":{"Line":4}},{"line":217,"address":[2156321,2156418,2156536,2156488],"length":1,"stats":{"Line":8}},{"line":218,"address":[2156490],"length":1,"stats":{"Line":2}},{"line":220,"address":[2156458],"length":1,"stats":{"Line":1}},{"line":223,"address":[2156329],"length":1,"stats":{"Line":2}},{"line":224,"address":[2156392,2156164,2156556],"length":1,"stats":{"Line":2}},{"line":228,"address":[2153718],"length":1,"stats":{"Line":2}},{"line":229,"address":[2153741],"length":1,"stats":{"Line":2}},{"line":230,"address":[2153832,2153753,2155529],"length":1,"stats":{"Line":5}},{"line":231,"address":[2153989],"length":1,"stats":{"Line":1}},{"line":232,"address":[2155264,2155176,2156074],"length":1,"stats":{"Line":4}},{"line":233,"address":[2155389],"length":1,"stats":{"Line":1}},{"line":234,"address":[2155534],"length":1,"stats":{"Line":1}},{"line":235,"address":[2155586,2156100],"length":1,"stats":{"Line":1}},{"line":236,"address":[2155959],"length":1,"stats":{"Line":1}},{"line":237,"address":[2156030,2156079],"length":1,"stats":{"Line":2}},{"line":240,"address":[2148996],"length":1,"stats":{"Line":2}},{"line":241,"address":[2155399],"length":1,"stats":{"Line":2}},{"line":242,"address":[2155207,2156113,2155521],"length":1,"stats":{"Line":2}},{"line":246,"address":[2154189],"length":1,"stats":{"Line":2}},{"line":247,"address":[2154007],"length":1,"stats":{"Line":1}},{"line":248,"address":[2154055],"length":1,"stats":{"Line":1}},{"line":249,"address":[2154109],"length":1,"stats":{"Line":2}},{"line":251,"address":[2154149],"length":1,"stats":{"Line":2}},{"line":252,"address":[2154070,2154355],"length":1,"stats":{"Line":0}},{"line":254,"address":[2154722],"length":1,"stats":{"Line":1}},{"line":255,"address":[2154466],"length":1,"stats":{"Line":1}},{"line":257,"address":[2154498],"length":1,"stats":{"Line":1}},{"line":258,"address":[2154538],"length":1,"stats":{"Line":1}},{"line":259,"address":[2154570],"length":1,"stats":{"Line":1}},{"line":262,"address":[2154602],"length":1,"stats":{"Line":1}},{"line":264,"address":[2149155,2150339,2157424,2153784,2151057,2149874,2154945,2150954,2153519,2152023,2156765,2149511,2153304,2156935,2151698,2151470,2150094,2154410,2149980,2157054],"length":1,"stats":{"Line":1}},{"line":267,"address":[2140091,2139584,2140121],"length":1,"stats":{"Line":1}},{"line":274,"address":[2139621],"length":1,"stats":{"Line":1}},{"line":275,"address":[2139706],"length":1,"stats":{"Line":1}},{"line":276,"address":[2140184,2141051,2140160,2139764],"length":1,"stats":{"Line":3}},{"line":277,"address":[2140231],"length":1,"stats":{"Line":1}},{"line":278,"address":[2140361,2140279,2140473],"length":1,"stats":{"Line":3}},{"line":279,"address":[2140875,2140558,2140748],"length":1,"stats":{"Line":3}},{"line":280,"address":[2140960,2141046],"length":1,"stats":{"Line":2}},{"line":281,"address":[2141036,2140843],"length":1,"stats":{"Line":1}},{"line":282,"address":[2140624,2140444],"length":1,"stats":{"Line":1}},{"line":283,"address":[2140679],"length":1,"stats":{"Line":1}},{"line":285,"address":[2140640],"length":1,"stats":{"Line":1}},{"line":287,"address":[2141075,2140238,2140332,2140732],"length":1,"stats":{"Line":1}},{"line":288,"address":[2139781],"length":1,"stats":{"Line":1}},{"line":290,"address":[2139906],"length":1,"stats":{"Line":1}},{"line":291,"address":[2139813],"length":1,"stats":{"Line":1}},{"line":293,"address":[2139844],"length":1,"stats":{"Line":1}},{"line":294,"address":[2139875],"length":1,"stats":{"Line":1}},{"line":297,"address":[2140047],"length":1,"stats":{"Line":1}},{"line":298,"address":[2139713,2140097,2140059,2140139],"length":1,"stats":{"Line":1}},{"line":312,"address":[2172112],"length":1,"stats":{"Line":2}},{"line":321,"address":[2172183],"length":1,"stats":{"Line":2}},{"line":330,"address":[2172314],"length":1,"stats":{"Line":2}},{"line":333,"address":[2148732,2147296,2148650],"length":1,"stats":{"Line":2}},{"line":335,"address":[2147331],"length":1,"stats":{"Line":2}},{"line":336,"address":[2147447,2147536],"length":1,"stats":{"Line":4}},{"line":337,"address":[2147616,2147551],"length":1,"stats":{"Line":4}},{"line":338,"address":[2147643],"length":1,"stats":{"Line":2}},{"line":339,"address":[2147870,2147934],"length":1,"stats":{"Line":4}},{"line":340,"address":[2147957],"length":1,"stats":{"Line":2}},{"line":342,"address":[2148002],"length":1,"stats":{"Line":2}},{"line":343,"address":[2148119],"length":1,"stats":{"Line":2}},{"line":344,"address":[2148140],"length":1,"stats":{"Line":2}},{"line":345,"address":[2148161],"length":1,"stats":{"Line":2}},{"line":346,"address":[2148182],"length":1,"stats":{"Line":2}},{"line":347,"address":[2148203],"length":1,"stats":{"Line":2}},{"line":349,"address":[2148514],"length":1,"stats":{"Line":2}},{"line":351,"address":[2148362],"length":1,"stats":{"Line":2}},{"line":356,"address":[2148450],"length":1,"stats":{"Line":2}},{"line":358,"address":[2147406,2147964,2148584,2147482,2147578,2147877,2148664,2148750,2148078],"length":1,"stats":{"Line":2}},{"line":360,"address":[2145555,2141088,2147096],"length":1,"stats":{"Line":2}},{"line":362,"address":[2141299],"length":1,"stats":{"Line":2}},{"line":363,"address":[2141309],"length":1,"stats":{"Line":2}},{"line":364,"address":[2141384],"length":1,"stats":{"Line":2}},{"line":365,"address":[2141407],"length":1,"stats":{"Line":2}},{"line":366,"address":[2141430],"length":1,"stats":{"Line":2}},{"line":367,"address":[2141453],"length":1,"stats":{"Line":2}},{"line":368,"address":[2141476],"length":1,"stats":{"Line":2}},{"line":369,"address":[2141151],"length":1,"stats":{"Line":2}},{"line":372,"address":[2141625],"length":1,"stats":{"Line":2}},{"line":378,"address":[2141514],"length":1,"stats":{"Line":2}},{"line":380,"address":[2141678],"length":1,"stats":{"Line":1}},{"line":382,"address":[2141822],"length":1,"stats":{"Line":1}},{"line":388,"address":[2141710],"length":1,"stats":{"Line":1}},{"line":390,"address":[2141875],"length":1,"stats":{"Line":1}},{"line":393,"address":[2141899],"length":1,"stats":{"Line":1}},{"line":394,"address":[2142024,2142164],"length":1,"stats":{"Line":1}},{"line":396,"address":[2142202],"length":1,"stats":{"Line":2}},{"line":397,"address":[2142226],"length":1,"stats":{"Line":2}},{"line":398,"address":[2142242,2142289],"length":1,"stats":{"Line":2}},{"line":401,"address":[2142282],"length":1,"stats":{"Line":2}},{"line":404,"address":[2142310],"length":1,"stats":{"Line":2}},{"line":407,"address":[2142581,2142466],"length":1,"stats":{"Line":1}},{"line":408,"address":[2142458,2142390],"length":1,"stats":{"Line":2}},{"line":414,"address":[2142705,2142567],"length":1,"stats":{"Line":2}},{"line":415,"address":[2142732,2147166,2147152],"length":1,"stats":{"Line":3}},{"line":417,"address":[2142762,2142837],"length":1,"stats":{"Line":2}},{"line":419,"address":[2142873,2147184],"length":1,"stats":{"Line":2}},{"line":420,"address":[2147207],"length":1,"stats":{"Line":1}},{"line":421,"address":[2147264,2147278,2147213],"length":1,"stats":{"Line":3}},{"line":422,"address":[2147235],"length":1,"stats":{"Line":1}},{"line":423,"address":[2147250],"length":1,"stats":{"Line":2}},{"line":424,"address":[2142896],"length":1,"stats":{"Line":1}},{"line":426,"address":[2142903],"length":1,"stats":{"Line":2}},{"line":430,"address":[2142978],"length":1,"stats":{"Line":2}},{"line":431,"address":[2143069,2146319,2142985],"length":1,"stats":{"Line":5}},{"line":433,"address":[2145943,2143207],"length":1,"stats":{"Line":2}},{"line":435,"address":[2145958],"length":1,"stats":{"Line":1}},{"line":436,"address":[2146061,2146683,2145973],"length":1,"stats":{"Line":3}},{"line":437,"address":[2146195],"length":1,"stats":{"Line":1}},{"line":438,"address":[2146329,2146405],"length":1,"stats":{"Line":2}},{"line":439,"address":[2146534,2146697],"length":1,"stats":{"Line":2}},{"line":440,"address":[2147120,2146704,2147134],"length":1,"stats":{"Line":3}},{"line":441,"address":[2146775],"length":1,"stats":{"Line":1}},{"line":443,"address":[2146553],"length":1,"stats":{"Line":1}},{"line":444,"address":[2146354,2146675,2146850],"length":1,"stats":{"Line":1}},{"line":445,"address":[2146209],"length":1,"stats":{"Line":1}},{"line":446,"address":[2146004,2146868,2146311],"length":1,"stats":{"Line":1}},{"line":447,"address":[2143232],"length":1,"stats":{"Line":1}},{"line":451,"address":[2143459],"length":1,"stats":{"Line":2}},{"line":455,"address":[2143247],"length":1,"stats":{"Line":2}},{"line":456,"address":[2143310],"length":1,"stats":{"Line":2}},{"line":457,"address":[2143373],"length":1,"stats":{"Line":2}},{"line":461,"address":[2143519],"length":1,"stats":{"Line":2}},{"line":463,"address":[2143557],"length":1,"stats":{"Line":2}},{"line":464,"address":[2143604],"length":1,"stats":{"Line":2}},{"line":466,"address":[2143718],"length":1,"stats":{"Line":1}},{"line":471,"address":[2143960],"length":1,"stats":{"Line":1}},{"line":472,"address":[2143726],"length":1,"stats":{"Line":1}},{"line":473,"address":[2143774],"length":1,"stats":{"Line":1}},{"line":474,"address":[2143790],"length":1,"stats":{"Line":1}},{"line":475,"address":[2143838],"length":1,"stats":{"Line":1}},{"line":476,"address":[2143920],"length":1,"stats":{"Line":1}},{"line":477,"address":[2144031,2143879,2145645],"length":1,"stats":{"Line":1}},{"line":478,"address":[2144063,2144126],"length":1,"stats":{"Line":2}},{"line":479,"address":[2144149,2144242],"length":1,"stats":{"Line":2}},{"line":480,"address":[2144271],"length":1,"stats":{"Line":2}},{"line":483,"address":[2144601],"length":1,"stats":{"Line":2}},{"line":484,"address":[2144385],"length":1,"stats":{"Line":2}},{"line":485,"address":[2144433],"length":1,"stats":{"Line":2}},{"line":486,"address":[2144449],"length":1,"stats":{"Line":2}},{"line":487,"address":[2144497],"length":1,"stats":{"Line":2}},{"line":488,"address":[2144561],"length":1,"stats":{"Line":2}},{"line":489,"address":[2144672,2145579,2144520],"length":1,"stats":{"Line":1}},{"line":490,"address":[2144688,2144797],"length":1,"stats":{"Line":2}},{"line":491,"address":[2144813,2144906],"length":1,"stats":{"Line":2}},{"line":492,"address":[2144935],"length":1,"stats":{"Line":1}},{"line":493,"address":[2142938,2145701,2146886,2144172,2144836,2142785,2142421,2143024,2144765,2144078,2145569,2145635,2141545,2142349,2143869,2145049,2141733,2143572,2142105],"length":1,"stats":{"Line":2}},{"line":496,"address":[2170032,2170818,2170769,2170800,2170775],"length":1,"stats":{"Line":3}},{"line":500,"address":[2170049,2170756],"length":1,"stats":{"Line":1}},{"line":502,"address":[2170643],"length":1,"stats":{"Line":1}},{"line":504,"address":[2170707],"length":1,"stats":{"Line":1}},{"line":505,"address":[2170748,2170837],"length":1,"stats":{"Line":2}},{"line":508,"address":[2171424,2170848,2171394,2171400,2171442],"length":1,"stats":{"Line":3}},{"line":511,"address":[2171381,2170865],"length":1,"stats":{"Line":1}},{"line":513,"address":[2171273],"length":1,"stats":{"Line":1}},{"line":515,"address":[2171335],"length":1,"stats":{"Line":1}},{"line":516,"address":[2171373,2171461],"length":1,"stats":{"Line":2}},{"line":519,"address":[2172018,2172012,2171472,2172050,2172032],"length":1,"stats":{"Line":3}},{"line":521,"address":[2171489,2171999],"length":1,"stats":{"Line":1}},{"line":523,"address":[2171891],"length":1,"stats":{"Line":1}},{"line":525,"address":[2171953],"length":1,"stats":{"Line":1}},{"line":526,"address":[2172069,2171991],"length":1,"stats":{"Line":2}},{"line":529,"address":[2169962,2169956,2169216,2169984,2170002],"length":1,"stats":{"Line":3}},{"line":530,"address":[2169233,2169943],"length":1,"stats":{"Line":1}},{"line":531,"address":[2169827],"length":1,"stats":{"Line":1}},{"line":532,"address":[2169891],"length":1,"stats":{"Line":1}},{"line":533,"address":[2169935,2170021],"length":1,"stats":{"Line":2}},{"line":540,"address":[2164473,2167515,2158224],"length":1,"stats":{"Line":1}},{"line":542,"address":[2158356],"length":1,"stats":{"Line":1}},{"line":543,"address":[2158366],"length":1,"stats":{"Line":1}},{"line":544,"address":[2158449],"length":1,"stats":{"Line":1}},{"line":545,"address":[2158472],"length":1,"stats":{"Line":1}},{"line":546,"address":[2158495],"length":1,"stats":{"Line":1}},{"line":547,"address":[2158518],"length":1,"stats":{"Line":1}},{"line":548,"address":[2158541],"length":1,"stats":{"Line":1}},{"line":549,"address":[2158272],"length":1,"stats":{"Line":1}},{"line":552,"address":[2158690],"length":1,"stats":{"Line":1}},{"line":558,"address":[2158579],"length":1,"stats":{"Line":1}},{"line":562,"address":[2158743],"length":1,"stats":{"Line":1}},{"line":563,"address":[2158767],"length":1,"stats":{"Line":1}},{"line":564,"address":[2158783,2158854],"length":1,"stats":{"Line":2}},{"line":567,"address":[2158870],"length":1,"stats":{"Line":1}},{"line":570,"address":[2158877],"length":1,"stats":{"Line":1}},{"line":571,"address":[2158942],"length":1,"stats":{"Line":1}},{"line":577,"address":[2159052],"length":1,"stats":{"Line":1}},{"line":580,"address":[2159091,2159160],"length":1,"stats":{"Line":2}},{"line":581,"address":[2167968,2159187,2167982],"length":1,"stats":{"Line":3}},{"line":584,"address":[2159253,2168000],"length":1,"stats":{"Line":2}},{"line":585,"address":[2168023],"length":1,"stats":{"Line":1}},{"line":586,"address":[2168608,2168622,2168029],"length":1,"stats":{"Line":3}},{"line":587,"address":[2168051],"length":1,"stats":{"Line":1}},{"line":588,"address":[2168066],"length":1,"stats":{"Line":1}},{"line":589,"address":[2159320],"length":1,"stats":{"Line":1}},{"line":593,"address":[2159327],"length":1,"stats":{"Line":1}},{"line":594,"address":[2159486],"length":1,"stats":{"Line":1}},{"line":595,"address":[2159562],"length":1,"stats":{"Line":1}},{"line":596,"address":[2159609,2167536,2167561,2168477,2168464],"length":1,"stats":{"Line":5}},{"line":597,"address":[2159632],"length":1,"stats":{"Line":1}},{"line":598,"address":[2159647,2159738],"length":1,"stats":{"Line":2}},{"line":601,"address":[2159753],"length":1,"stats":{"Line":1}},{"line":605,"address":[2159768],"length":1,"stats":{"Line":1}},{"line":606,"address":[2159820,2159896],"length":1,"stats":{"Line":2}},{"line":607,"address":[2160155,2167363],"length":1,"stats":{"Line":2}},{"line":610,"address":[2160193,2167332],"length":1,"stats":{"Line":2}},{"line":611,"address":[2167038],"length":1,"stats":{"Line":1}},{"line":612,"address":[2167031,2160342],"length":1,"stats":{"Line":2}},{"line":613,"address":[2167142,2167202],"length":1,"stats":{"Line":2}},{"line":614,"address":[2167209],"length":1,"stats":{"Line":1}},{"line":615,"address":[2167280,2167345,2167157],"length":1,"stats":{"Line":1}},{"line":617,"address":[2160360],"length":1,"stats":{"Line":1}},{"line":619,"address":[2160673,2166430],"length":1,"stats":{"Line":2}},{"line":620,"address":[2160367,2160454],"length":1,"stats":{"Line":2}},{"line":623,"address":[2165939],"length":1,"stats":{"Line":1}},{"line":625,"address":[2160733],"length":1,"stats":{"Line":1}},{"line":626,"address":[2165946],"length":1,"stats":{"Line":1}},{"line":628,"address":[2165962],"length":1,"stats":{"Line":1}},{"line":629,"address":[2166103,2166794,2166018],"length":1,"stats":{"Line":3}},{"line":630,"address":[2166237],"length":1,"stats":{"Line":1}},{"line":631,"address":[2166516,2166440],"length":1,"stats":{"Line":2}},{"line":632,"address":[2166645,2166808],"length":1,"stats":{"Line":2}},{"line":633,"address":[2166815,2168432,2168446],"length":1,"stats":{"Line":3}},{"line":634,"address":[2166886],"length":1,"stats":{"Line":1}},{"line":636,"address":[2166664],"length":1,"stats":{"Line":1}},{"line":637,"address":[2166961,2166465,2166786],"length":1,"stats":{"Line":1}},{"line":639,"address":[2166247],"length":1,"stats":{"Line":1}},{"line":640,"address":[2166979,2165969,2166049,2166414],"length":1,"stats":{"Line":1}},{"line":643,"address":[2160986],"length":1,"stats":{"Line":1}},{"line":654,"address":[2160774],"length":1,"stats":{"Line":1}},{"line":655,"address":[2160837],"length":1,"stats":{"Line":1}},{"line":656,"address":[2160900],"length":1,"stats":{"Line":1}},{"line":660,"address":[2161046],"length":1,"stats":{"Line":1}},{"line":662,"address":[2161163],"length":1,"stats":{"Line":1}},{"line":664,"address":[2161147,2161084],"length":1,"stats":{"Line":2}},{"line":668,"address":[2161271],"length":1,"stats":{"Line":1}},{"line":671,"address":[2161386],"length":1,"stats":{"Line":1}},{"line":674,"address":[2161450],"length":1,"stats":{"Line":1}},{"line":677,"address":[2161494],"length":1,"stats":{"Line":1}},{"line":680,"address":[2161533],"length":1,"stats":{"Line":1}},{"line":683,"address":[2161556],"length":1,"stats":{"Line":1}},{"line":684,"address":[2161713,2165892],"length":1,"stats":{"Line":2}},{"line":689,"address":[2161989],"length":1,"stats":{"Line":1}},{"line":690,"address":[2161723],"length":1,"stats":{"Line":1}},{"line":693,"address":[2165108,2162049],"length":1,"stats":{"Line":2}},{"line":694,"address":[2165288,2165738],"length":1,"stats":{"Line":2}},{"line":695,"address":[2165857],"length":1,"stats":{"Line":1}},{"line":700,"address":[2165322],"length":1,"stats":{"Line":1}},{"line":701,"address":[2165487],"length":1,"stats":{"Line":1}},{"line":702,"address":[2165660],"length":1,"stats":{"Line":1}},{"line":703,"address":[2165710],"length":1,"stats":{"Line":1}},{"line":708,"address":[2162082],"length":1,"stats":{"Line":1}},{"line":709,"address":[2162263,2162167],"length":1,"stats":{"Line":2}},{"line":711,"address":[2162339],"length":1,"stats":{"Line":1}},{"line":713,"address":[2162300],"length":1,"stats":{"Line":1}},{"line":718,"address":[2162447],"length":1,"stats":{"Line":1}},{"line":720,"address":[2162471],"length":1,"stats":{"Line":1}},{"line":721,"address":[2162483],"length":1,"stats":{"Line":1}},{"line":723,"address":[2163276,2162640],"length":1,"stats":{"Line":2}},{"line":724,"address":[2163378],"length":1,"stats":{"Line":1}},{"line":726,"address":[2164495],"length":1,"stats":{"Line":1}},{"line":727,"address":[2164534,2167616,2167953,2167947],"length":1,"stats":{"Line":2}},{"line":729,"address":[2167662],"length":1,"stats":{"Line":1}},{"line":730,"address":[2168640,2167709],"length":1,"stats":{"Line":2}},{"line":731,"address":[2168695],"length":1,"stats":{"Line":1}},{"line":732,"address":[2168710],"length":1,"stats":{"Line":1}},{"line":733,"address":[2168744],"length":1,"stats":{"Line":1}},{"line":734,"address":[2167729],"length":1,"stats":{"Line":1}},{"line":735,"address":[2167804,2167739],"length":1,"stats":{"Line":2}},{"line":736,"address":[2167924,2167767],"length":1,"stats":{"Line":1}},{"line":737,"address":[2164581],"length":1,"stats":{"Line":1}},{"line":738,"address":[2165056,2164588,2164770],"length":1,"stats":{"Line":3}},{"line":740,"address":[2164971],"length":1,"stats":{"Line":1}},{"line":741,"address":[2164817,2164881],"length":1,"stats":{"Line":2}},{"line":742,"address":[2164915],"length":1,"stats":{"Line":1}},{"line":743,"address":[2164883],"length":1,"stats":{"Line":1}},{"line":746,"address":[2164978],"length":1,"stats":{"Line":1}},{"line":747,"address":[2165012,2165061],"length":1,"stats":{"Line":1}},{"line":748,"address":[2164738,2164863],"length":1,"stats":{"Line":1}},{"line":752,"address":[2163416],"length":1,"stats":{"Line":1}},{"line":753,"address":[2163722],"length":1,"stats":{"Line":1}},{"line":756,"address":[2163810],"length":1,"stats":{"Line":1}},{"line":757,"address":[2163828],"length":1,"stats":{"Line":1}},{"line":759,"address":[2163871],"length":1,"stats":{"Line":1}},{"line":760,"address":[2163926],"length":1,"stats":{"Line":1}},{"line":761,"address":[2163949,2168411,2168080,2168417],"length":1,"stats":{"Line":2}},{"line":763,"address":[2168126],"length":1,"stats":{"Line":1}},{"line":764,"address":[2168173,2168496],"length":1,"stats":{"Line":2}},{"line":765,"address":[2168551],"length":1,"stats":{"Line":1}},{"line":766,"address":[2168566],"length":1,"stats":{"Line":1}},{"line":767,"address":[2168600],"length":1,"stats":{"Line":1}},{"line":768,"address":[2168193],"length":1,"stats":{"Line":1}},{"line":769,"address":[2168203,2168268],"length":1,"stats":{"Line":2}},{"line":770,"address":[2168388,2168231],"length":1,"stats":{"Line":1}},{"line":771,"address":[2163972],"length":1,"stats":{"Line":1}},{"line":772,"address":[2163979,2164161,2164447],"length":1,"stats":{"Line":3}},{"line":774,"address":[2164362],"length":1,"stats":{"Line":1}},{"line":775,"address":[2164272,2164208],"length":1,"stats":{"Line":2}},{"line":776,"address":[2164306],"length":1,"stats":{"Line":1}},{"line":777,"address":[2164274],"length":1,"stats":{"Line":1}},{"line":780,"address":[2164369],"length":1,"stats":{"Line":1}},{"line":781,"address":[2164403,2164452],"length":1,"stats":{"Line":1}},{"line":782,"address":[2164129,2164254],"length":1,"stats":{"Line":1}},{"line":786,"address":[2162883,2162705],"length":1,"stats":{"Line":1}},{"line":788,"address":[2162674],"length":1,"stats":{"Line":1}},{"line":793,"address":[2162921,2162798],"length":1,"stats":{"Line":2}},{"line":794,"address":[2160406,2161465,2159260,2158814,2159517,2159670,2159446,2161393,2161107,2162978,2165090,2165905,2167471,2159851,2159783,2162190,2158610,2158904,2159113],"length":1,"stats":{"Line":1}},{"line":797,"address":[2168752,2169168,2169186,2169144,2169150],"length":1,"stats":{"Line":3}},{"line":799,"address":[2168769,2169131],"length":1,"stats":{"Line":1}},{"line":800,"address":[2169025],"length":1,"stats":{"Line":1}},{"line":801,"address":[2169087],"length":1,"stats":{"Line":1}},{"line":802,"address":[2169123,2169205],"length":1,"stats":{"Line":2}}],"covered":390,"coverable":391},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","mul_air.rs"],"content":"//! Test for recursive STARK verification with a multiplication AIR.\n\nmod common;\n\nuse p3_baby_bear::default_babybear_poseidon2_16;\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::ops::generate_poseidon2_trace;\nuse p3_fri::create_test_fri_params;\nuse p3_matrix::Matrix;\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\nuse p3_recursion::pcs::fri::{FriVerifierParams, MerkleCapTargets};\nuse p3_recursion::public_inputs::StarkVerifierInputsBuilder;\nuse p3_recursion::{Poseidon2Config, VerificationError, verify_p3_uni_proof_circuit};\nuse p3_uni_stark::{prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed};\nuse p3_util::log2_ceil_usize;\n\nuse crate::common::MulAir;\nuse crate::common::baby_bear_params::{\n    Challenge, ChallengeMmcs, Challenger, DIGEST_ELEMS, Dft, F, InnerFri, MyCompress, MyConfig,\n    MyHash, MyPcs, RATE, ValMmcs, WIDTH,\n};\n\n#[test]\nfn test_mul_verifier_circuit() -\u003e Result\u003c(), VerificationError\u003e {\n    let n = 1 \u003c\u003c 3;\n\n    let perm = default_babybear_poseidon2_16();\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress, 0);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::default();\n\n    let log_final_poly_len = 0;\n    let fri_params = create_test_fri_params(challenge_mmcs, log_final_poly_len);\n    let fri_verifier_params = FriVerifierParams::from(\u0026fri_params);\n    let _log_height_max = fri_params.log_final_poly_len + fri_params.log_blowup;\n    let _pow_bits = fri_params.query_proof_of_work_bits;\n    let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n    let challenger = Challenger::new(perm.clone());\n\n    let config = MyConfig::new(pcs, challenger);\n    let pis = vec![];\n\n    // Create AIR and generate valid trace\n    let air: MulAir = MulAir { degree: 2, rows: n };\n    let (trace, _) = air.random_valid_trace(true);\n\n    // Setup preprocessed data\n    let (preprocessed_prover_data, preprocessed_vk) =\n        setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(trace.height())).unzip();\n    // Generate and verify proof\n    let proof = prove_with_preprocessed(\n        \u0026config,\n        \u0026air,\n        trace,\n        \u0026pis,\n        preprocessed_prover_data.as_ref(),\n    );\n    assert!(\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, preprocessed_vk.as_ref()).is_ok()\n    );\n\n    let mut circuit_builder = CircuitBuilder::new();\n    circuit_builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cChallenge, BabyBearD4Width16\u003e,\n        perm,\n    );\n\n    // Allocate all targets\n    let verifier_inputs = StarkVerifierInputsBuilder::\u003c\n        MyConfig,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n        InnerFri,\n    \u003e::allocate(\n        \u0026mut circuit_builder,\n        \u0026proof,\n        preprocessed_vk.as_ref().map(|vk| \u0026vk.commitment),\n        pis.len(),\n    );\n\n    // Add the verification circuit to the builder\n    verify_p3_uni_proof_circuit::\u003c_, _, _, _, _, WIDTH, RATE\u003e(\n        \u0026config,\n        \u0026air,\n        \u0026mut circuit_builder,\n        \u0026verifier_inputs.proof_targets,\n        \u0026verifier_inputs.air_public_targets,\n        \u0026verifier_inputs.preprocessed_commit,\n        \u0026fri_verifier_params,\n        Poseidon2Config::BabyBearD4Width16,\n    )?;\n\n    // Build the circuit\n    let circuit = circuit_builder.build()?;\n\n    let mut runner = circuit.runner();\n\n    // Pack values using the same builder\n    let public_inputs =\n        verifier_inputs.pack_values(\u0026pis, \u0026proof, \u0026preprocessed_vk.map(|vk| vk.commitment));\n\n    runner\n        .set_public_inputs(\u0026public_inputs)\n        .map_err(VerificationError::Circuit)?;\n\n    let _traces = runner.run().map_err(VerificationError::Circuit)?;\n\n    Ok(())\n}\n","traces":[{"line":1,"address":[3398704],"length":1,"stats":{"Line":1}},{"line":24,"address":[3398079,3398559,3392784,3398626,3398608],"length":1,"stats":{"Line":3}},{"line":25,"address":[3392849],"length":1,"stats":{"Line":1}},{"line":27,"address":[3392965],"length":1,"stats":{"Line":1}},{"line":28,"address":[3393006,3393082],"length":1,"stats":{"Line":2}},{"line":29,"address":[3393097,3393162],"length":1,"stats":{"Line":2}},{"line":30,"address":[3393189],"length":1,"stats":{"Line":1}},{"line":31,"address":[3393480,3393416],"length":1,"stats":{"Line":2}},{"line":32,"address":[3393503],"length":1,"stats":{"Line":1}},{"line":34,"address":[3392837,3393548],"length":1,"stats":{"Line":2}},{"line":35,"address":[3393556,3393670],"length":1,"stats":{"Line":2}},{"line":36,"address":[3393694],"length":1,"stats":{"Line":1}},{"line":37,"address":[3393739,3393987],"length":1,"stats":{"Line":1}},{"line":38,"address":[3393791],"length":1,"stats":{"Line":1}},{"line":39,"address":[3393807,3394007],"length":1,"stats":{"Line":2}},{"line":40,"address":[3394015,3394099],"length":1,"stats":{"Line":2}},{"line":42,"address":[3394106],"length":1,"stats":{"Line":1}},{"line":43,"address":[3394230],"length":1,"stats":{"Line":1}},{"line":46,"address":[3394289],"length":1,"stats":{"Line":1}},{"line":47,"address":[3394334,3394382],"length":1,"stats":{"Line":2}},{"line":50,"address":[3394587],"length":1,"stats":{"Line":1}},{"line":51,"address":[3394483],"length":1,"stats":{"Line":1}},{"line":53,"address":[3394938],"length":1,"stats":{"Line":1}},{"line":56,"address":[3394739],"length":1,"stats":{"Line":1}},{"line":57,"address":[3394795],"length":1,"stats":{"Line":1}},{"line":58,"address":[3394899],"length":1,"stats":{"Line":1}},{"line":59,"address":[3394991,3394818,3398405],"length":1,"stats":{"Line":1}},{"line":60,"address":[3395277,3395224],"length":1,"stats":{"Line":0}},{"line":61,"address":[3395007,3395110,3395263],"length":1,"stats":{"Line":3}},{"line":64,"address":[3395340],"length":1,"stats":{"Line":1}},{"line":65,"address":[3395347,3395443],"length":1,"stats":{"Line":2}},{"line":67,"address":[3395355],"length":1,"stats":{"Line":1}},{"line":71,"address":[3395623],"length":1,"stats":{"Line":1}},{"line":78,"address":[3398592,3395522,3398600],"length":1,"stats":{"Line":3}},{"line":79,"address":[3395568],"length":1,"stats":{"Line":1}},{"line":83,"address":[3395749,3398138,3395969],"length":1,"stats":{"Line":1}},{"line":87,"address":[3395630],"length":1,"stats":{"Line":1}},{"line":88,"address":[3395654],"length":1,"stats":{"Line":1}},{"line":89,"address":[3395741],"length":1,"stats":{"Line":1}},{"line":92,"address":[3396146,3395889],"length":1,"stats":{"Line":1}},{"line":95,"address":[3398121,3396153],"length":1,"stats":{"Line":1}},{"line":97,"address":[3396665,3396575],"length":1,"stats":{"Line":2}},{"line":101,"address":[3396756,3396681,3398675,3398672],"length":1,"stats":{"Line":4}},{"line":103,"address":[3397076,3397212,3398032],"length":1,"stats":{"Line":1}},{"line":104,"address":[3396987],"length":1,"stats":{"Line":1}},{"line":105,"address":[3397053,3397132],"length":1,"stats":{"Line":1}},{"line":107,"address":[3397317,3398015],"length":1,"stats":{"Line":1}},{"line":109,"address":[3397758],"length":1,"stats":{"Line":1}},{"line":110,"address":[3398025,3398069,3398655,3393423,3396698,3393025,3393510,3394257,3398093,3398572,3396624,3394042,3395473,3398423,3394341,3394437,3396947,3398034,3398131,3395038,3397761,3398140,3393701,3395685,3393124,3393629,3397837],"length":1,"stats":{"Line":2}}],"covered":48,"coverable":49},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","poseidon_perm.rs"],"content":"mod common;\n\nuse p3_baby_bear::BabyBear as F;\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::ops::{BabyBearD1Width16, Poseidon2CircuitRow, generate_poseidon2_trace};\nuse p3_field::PrimeCharacteristicRing;\nuse p3_fri::create_test_fri_params;\nuse p3_poseidon2::ExternalLayerConstants;\nuse p3_poseidon2_air::RoundConstants;\nuse p3_poseidon2_circuit_air::{\n    Poseidon2CircuitAirBabyBearD4Width16, extract_preprocessed_from_operations,\n};\nuse p3_recursion::pcs::fri::{\n    FriProofTargets, FriVerifierParams, InputProofTargets, MerkleCapTargets, RecExtensionValMmcs,\n    RecValMmcs, Witness,\n};\nuse p3_recursion::public_inputs::StarkVerifierInputsBuilder;\nuse p3_recursion::{Poseidon2Config, VerificationError, verify_p3_uni_proof_circuit};\nuse p3_uni_stark::{\n    StarkGenericConfig, prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed,\n};\nuse rand::rngs::SmallRng;\nuse rand::{RngExt, SeedableRng};\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n/// Initializes a global logger with default parameters.\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\nuse crate::common::baby_bear_params::*;\n\n// Use base field challenges for this test to keep proof size manageable.\n// The common module uses extension field challenges (D=4), which would\n// create 4x more observations and circuit operations.\ntype Challenge = F;\ntype ChallengeMmcs = p3_commit::ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\ntype MyPcs = p3_fri::TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\ntype MyConfig = p3_uni_stark::StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\n#[test]\nfn test_poseidon2_perm_verifier() -\u003e Result\u003c(), VerificationError\u003e {\n    init_logger();\n\n    let mut rng = SmallRng::seed_from_u64(1);\n    let beginning_full_constants = rng.random();\n    let partial_constants = rng.random();\n    let ending_full_constants = rng.random();\n    let constants = RoundConstants::new(\n        beginning_full_constants,\n        partial_constants,\n        ending_full_constants,\n    );\n    let perm = Poseidon2BabyBear::\u003c16\u003e::new(\n        ExternalLayerConstants::new(\n            beginning_full_constants.to_vec(),\n            ending_full_constants.to_vec(),\n        ),\n        partial_constants.to_vec(),\n    );\n\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress, 0);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::default();\n    // Keep a small final poly length; with enough rows we still get FRI fold phases.\n    let log_final_poly_len = 0;\n    let fri_params = create_test_fri_params(challenge_mmcs, log_final_poly_len);\n    let fri_verifier_params = FriVerifierParams::from(\u0026fri_params);\n    let _log_height_max = fri_params.log_final_poly_len + fri_params.log_blowup;\n    let _pow_bits = fri_params.query_proof_of_work_bits;\n    let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n    let challenger = Challenger::new(perm.clone());\n    let config = MyConfig::new(pcs, challenger);\n\n    // Build a trace with enough rows to satisfy FRI height constraints.\n    let n_rows: usize = 32;\n    let ops: Vec\u003c_\u003e = (0..n_rows)\n        .map(|row| {\n            let input_values: Vec\u003cF\u003e = (0..16_u32)\n                .map(|i| F::from_u32(i + 5 + row as u32))\n                .collect();\n            Poseidon2CircuitRow {\n                new_start: true,\n                merkle_path: false,\n                mmcs_bit: false,\n                mmcs_index_sum: F::ZERO,\n                input_values,\n                in_ctl: [false; 4],\n                input_indices: [0; 4],\n                out_ctl: [false; 2],\n                output_indices: [0; 2],\n                mmcs_index_sum_idx: 0,\n                mmcs_ctl_enabled: false,\n            }\n        })\n        .collect();\n\n    let preprocessed = extract_preprocessed_from_operations(\u0026ops);\n    let air = Poseidon2CircuitAirBabyBearD4Width16::new_with_preprocessed(\n        constants.clone(),\n        preprocessed,\n    );\n\n    let (prover_data, verifier_data) = setup_preprocessed(\u0026config, \u0026air, 5).unwrap();\n\n    let trace = air.generate_trace_rows(\u0026ops, \u0026constants, 0);\n\n    let public_inputs: Vec\u003cF\u003e = vec![];\n    let proof = prove_with_preprocessed(\u0026config, \u0026air, trace, \u0026public_inputs, Some(\u0026prover_data));\n    assert!(\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026public_inputs, Some(\u0026verifier_data))\n            .is_ok()\n    );\n\n    type InnerFri = FriProofTargets\u003c\n        p3_uni_stark::Val\u003cMyConfig\u003e,\n        \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n        RecExtensionValMmcs\u003c\n            p3_uni_stark::Val\u003cMyConfig\u003e,\n            \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n            DIGEST_ELEMS,\n            RecValMmcs\u003cp3_uni_stark::Val\u003cMyConfig\u003e, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n        \u003e,\n        InputProofTargets\u003c\n            p3_uni_stark::Val\u003cMyConfig\u003e,\n            \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n            RecValMmcs\u003cp3_uni_stark::Val\u003cMyConfig\u003e, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n        \u003e,\n        Witness\u003cp3_uni_stark::Val\u003cMyConfig\u003e\u003e,\n    \u003e;\n\n    let mut circuit_builder = CircuitBuilder::new();\n    // Use the same permutation as the prover to ensure Fiat-Shamir challengers match.\n    // D=1 (base field challenges) uses the base variant which operates on 16 elements directly.\n    circuit_builder.enable_poseidon2_perm_base::\u003cBabyBearD1Width16, _\u003e(\n        generate_poseidon2_trace::\u003cChallenge, BabyBearD1Width16\u003e,\n        perm,\n    );\n    let verifier_inputs = StarkVerifierInputsBuilder::\u003c\n        MyConfig,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n        InnerFri,\n    \u003e::allocate(\n        \u0026mut circuit_builder,\n        \u0026proof,\n        Some(\u0026verifier_data.commitment),\n        public_inputs.len(),\n    );\n\n    verify_p3_uni_proof_circuit::\u003c\n        Poseidon2CircuitAirBabyBearD4Width16,\n        MyConfig,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n        InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n        InnerFri,\n        WIDTH,\n        RATE,\n    \u003e(\n        \u0026config,\n        \u0026air,\n        \u0026mut circuit_builder,\n        \u0026verifier_inputs.proof_targets,\n        \u0026verifier_inputs.air_public_targets,\n        \u0026verifier_inputs.preprocessed_commit,\n        \u0026fri_verifier_params,\n        Poseidon2Config::BabyBearD1Width16,\n    )?;\n\n    let circuit = circuit_builder.build()?;\n    let mut runner = circuit.runner();\n\n    let packed_publics =\n        verifier_inputs.pack_values(\u0026public_inputs, \u0026proof, \u0026Some(verifier_data.commitment));\n\n    runner\n        .set_public_inputs(\u0026packed_publics)\n        .map_err(VerificationError::Circuit)?;\n    let _ = runner.run().map_err(VerificationError::Circuit)?;\n\n    Ok(())\n}\n","traces":[{"line":1,"address":[4704544],"length":1,"stats":{"Line":1}},{"line":31,"address":[4696768,4697342,4697348],"length":1,"stats":{"Line":1}},{"line":32,"address":[4696926,4696805],"length":1,"stats":{"Line":2}},{"line":33,"address":[4696934,4696854,4697377,4696885],"length":1,"stats":{"Line":2}},{"line":34,"address":[4696977],"length":1,"stats":{"Line":1}},{"line":36,"address":[4697254,4697113],"length":1,"stats":{"Line":2}},{"line":37,"address":[4697132],"length":1,"stats":{"Line":1}},{"line":38,"address":[4697278,4697206,4697217,4697332],"length":1,"stats":{"Line":2}},{"line":39,"address":[4697301],"length":1,"stats":{"Line":1}},{"line":40,"address":[4697308,4697361,4697072],"length":1,"stats":{"Line":1}},{"line":53,"address":[4697408,4703493,4704037,4704368,4704386],"length":1,"stats":{"Line":3}},{"line":54,"address":[4697500],"length":1,"stats":{"Line":1}},{"line":56,"address":[4697654],"length":1,"stats":{"Line":1}},{"line":57,"address":[4697683],"length":1,"stats":{"Line":1}},{"line":58,"address":[4697704],"length":1,"stats":{"Line":1}},{"line":59,"address":[4697733],"length":1,"stats":{"Line":1}},{"line":60,"address":[4697790],"length":1,"stats":{"Line":1}},{"line":65,"address":[4698200],"length":1,"stats":{"Line":1}},{"line":66,"address":[4698068],"length":1,"stats":{"Line":1}},{"line":67,"address":[4697945],"length":1,"stats":{"Line":1}},{"line":68,"address":[4698023],"length":1,"stats":{"Line":1}},{"line":69,"address":[4704088,4698111,4698027],"length":1,"stats":{"Line":1}},{"line":70,"address":[4698127],"length":1,"stats":{"Line":1}},{"line":71,"address":[4698159,4698243,4704069],"length":1,"stats":{"Line":1}},{"line":73,"address":[4698343,4698259],"length":1,"stats":{"Line":2}},{"line":74,"address":[4698358,4698423],"length":1,"stats":{"Line":2}},{"line":75,"address":[4698450],"length":1,"stats":{"Line":1}},{"line":76,"address":[4698677,4698741],"length":1,"stats":{"Line":2}},{"line":77,"address":[4698764],"length":1,"stats":{"Line":1}},{"line":79,"address":[4697476,4698809],"length":1,"stats":{"Line":2}},{"line":80,"address":[4698817,4698931],"length":1,"stats":{"Line":2}},{"line":81,"address":[4698955],"length":1,"stats":{"Line":1}},{"line":82,"address":[4699248,4699000],"length":1,"stats":{"Line":1}},{"line":83,"address":[4699052],"length":1,"stats":{"Line":1}},{"line":84,"address":[4699068,4699268],"length":1,"stats":{"Line":2}},{"line":85,"address":[4699360,4699276],"length":1,"stats":{"Line":2}},{"line":86,"address":[4699367],"length":1,"stats":{"Line":1}},{"line":89,"address":[4697488],"length":1,"stats":{"Line":1}},{"line":91,"address":[4699500,4704112],"length":1,"stats":{"Line":2}},{"line":93,"address":[4704432,4704452,4704135],"length":1,"stats":{"Line":3}},{"line":94,"address":[4704157],"length":1,"stats":{"Line":1}},{"line":95,"address":[4704249],"length":1,"stats":{"Line":1}},{"line":101,"address":[4704172],"length":1,"stats":{"Line":1}},{"line":102,"address":[4704189],"length":1,"stats":{"Line":1}},{"line":103,"address":[4704206],"length":1,"stats":{"Line":1}},{"line":104,"address":[4704223],"length":1,"stats":{"Line":1}},{"line":108,"address":[4704348],"length":1,"stats":{"Line":1}},{"line":109,"address":[4699587],"length":1,"stats":{"Line":1}},{"line":111,"address":[4699686,4699602],"length":1,"stats":{"Line":2}},{"line":112,"address":[4699830],"length":1,"stats":{"Line":1}},{"line":113,"address":[4699701],"length":1,"stats":{"Line":1}},{"line":114,"address":[4699766],"length":1,"stats":{"Line":1}},{"line":117,"address":[4699917,4699866],"length":1,"stats":{"Line":2}},{"line":119,"address":[4700216,4700107],"length":1,"stats":{"Line":2}},{"line":121,"address":[4700231],"length":1,"stats":{"Line":1}},{"line":122,"address":[4700370,4703861,4700291],"length":1,"stats":{"Line":1}},{"line":123,"address":[4700666,4700719],"length":1,"stats":{"Line":0}},{"line":124,"address":[4700583,4700504,4700705],"length":1,"stats":{"Line":3}},{"line":125,"address":[4700644],"length":1,"stats":{"Line":1}},{"line":145,"address":[4700782],"length":1,"stats":{"Line":1}},{"line":148,"address":[4700789,4700885],"length":1,"stats":{"Line":2}},{"line":150,"address":[4700797],"length":1,"stats":{"Line":1}},{"line":152,"address":[4701019],"length":1,"stats":{"Line":1}},{"line":160,"address":[4700964],"length":1,"stats":{"Line":1}},{"line":163,"address":[4703552,4701365,4701145],"length":1,"stats":{"Line":1}},{"line":175,"address":[4701026],"length":1,"stats":{"Line":1}},{"line":176,"address":[4701050],"length":1,"stats":{"Line":1}},{"line":177,"address":[4701137],"length":1,"stats":{"Line":1}},{"line":180,"address":[4701542,4701285],"length":1,"stats":{"Line":1}},{"line":182,"address":[4701549,4703535],"length":1,"stats":{"Line":1}},{"line":183,"address":[4702049,4701959],"length":1,"stats":{"Line":2}},{"line":186,"address":[4702130,4702065],"length":1,"stats":{"Line":2}},{"line":188,"address":[4702437,4702573,4703446],"length":1,"stats":{"Line":1}},{"line":189,"address":[4702348],"length":1,"stats":{"Line":1}},{"line":190,"address":[4702493,4702414],"length":1,"stats":{"Line":1}},{"line":191,"address":[4702678,4703425],"length":1,"stats":{"Line":1}},{"line":193,"address":[4703126],"length":1,"stats":{"Line":1}},{"line":194,"address":[4698962,4699633,4704050,4698684,4703129,4703448,4700535,4703483,4698890,4703507,4698286,4698385,4703427,4704415,4702296,4699303,4700915,4698771,4699873,4702008,4699728,4702082,4703545,4703554,4703879,4701081,4699531,4700130,4700250],"length":1,"stats":{"Line":2}}],"covered":77,"coverable":78},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","preprocessing.rs"],"content":"mod common;\n\nuse p3_air::{Air, AirBuilder, BaseAir};\nuse p3_baby_bear::default_babybear_poseidon2_16;\nuse p3_batch_stark::{ProverData, StarkInstance, prove_batch, verify_batch};\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::ops::generate_poseidon2_trace;\nuse p3_field::Field;\nuse p3_fri::create_test_fri_params;\nuse p3_lookup::logup::LogUpGadget;\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\nuse p3_recursion::pcs::MerkleCapTargets;\nuse p3_recursion::{\n    BatchStarkVerifierInputsBuilder, FriVerifierParams, Poseidon2Config, VerificationError,\n    verify_batch_circuit,\n};\nuse rand::distr::{Distribution, StandardUniform};\n\nuse crate::common::MulAir;\nuse crate::common::baby_bear_params::{\n    Challenge, ChallengeMmcs, Challenger, DIGEST_ELEMS, Dft, F, InnerFri, MyCompress, MyConfig,\n    MyHash, MyPcs, RATE, ValMmcs, WIDTH,\n};\n\n/// Enum to hold different AIR types for batch verification\n#[derive(Clone, Copy)]\nenum MixedAir {\n    Mul(MulAir),               // has preprocessed columns\n    Add(AddAirNoPreprocessed), // doesn't have any preprocessed columns\n    Sub(SubAirPartialPreprocessed),\n}\n\nimpl\u003cVal: Field\u003e BaseAir\u003cVal\u003e for MixedAir\nwhere\n    StandardUniform: Distribution\u003cVal\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        match self {\n            Self::Mul(air) =\u003e BaseAir::\u003cVal\u003e::width(air),\n            Self::Add(air) =\u003e BaseAir::\u003cVal\u003e::width(air),\n            Self::Sub(air) =\u003e BaseAir::\u003cVal\u003e::width(air),\n        }\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003e\u003e {\n        match self {\n            Self::Mul(air) =\u003e BaseAir::\u003cVal\u003e::preprocessed_trace(air),\n            Self::Add(air) =\u003e BaseAir::\u003cVal\u003e::preprocessed_trace(air),\n            Self::Sub(air) =\u003e BaseAir::\u003cVal\u003e::preprocessed_trace(air),\n        }\n    }\n}\n\nimpl\u003cAB: AirBuilder\u003e Air\u003cAB\u003e for MixedAir\nwhere\n    AB::F: Field,\n    StandardUniform: Distribution\u003cAB::F\u003e,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        match self {\n            Self::Mul(air) =\u003e Air::\u003cAB\u003e::eval(air, builder),\n            Self::Add(air) =\u003e Air::\u003cAB\u003e::eval(air, builder),\n            Self::Sub(air) =\u003e Air::\u003cAB\u003e::eval(air, builder),\n        }\n    }\n}\n\n/// AIR that doesn't have preprocessed columns - simple addition of two values\n#[derive(Clone, Copy)]\npub struct AddAirNoPreprocessed {\n    rows: usize,\n}\n\nimpl Default for AddAirNoPreprocessed {\n    fn default() -\u003e Self {\n        Self { rows: 1 \u003c\u003c 3 }\n    }\n}\n\nimpl AddAirNoPreprocessed {\n    pub fn random_valid_trace\u003cVal: Field\u003e(\u0026self, valid: bool) -\u003e RowMajorMatrix\u003cVal\u003e\n    where\n        StandardUniform: Distribution\u003cVal\u003e,\n    {\n        let width = 3; // [a, b, c] columns\n        let mut main_trace_values = Val::zero_vec(self.rows * width);\n\n        for row in 0..self.rows {\n            let base_idx = row * width;\n            let a = Val::from_usize(row);\n            let b = Val::from_usize(row + 1);\n            main_trace_values[base_idx] = a;\n            main_trace_values[base_idx + 1] = b;\n\n            // c = a + b\n            main_trace_values[base_idx + 2] = if valid {\n                a + b\n            } else {\n                a + b + Val::ONE // Make invalid\n            };\n        }\n\n        RowMajorMatrix::new(main_trace_values, width)\n    }\n}\n\nimpl\u003cVal: Field\u003e BaseAir\u003cVal\u003e for AddAirNoPreprocessed\nwhere\n    StandardUniform: Distribution\u003cVal\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        3 // [a, b, c]\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003e\u003e {\n        None // No preprocessed columns\n    }\n}\n\nimpl\u003cAB: AirBuilder\u003e Air\u003cAB\u003e for AddAirNoPreprocessed\nwhere\n    AB::F: Field,\n    StandardUniform: Distribution\u003cAB::F\u003e,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n        let main_local = main.row_slice(0).expect(\"Matrix is empty?\");\n\n        let a = main_local[0].clone();\n        let b = main_local[1].clone();\n        let c = main_local[2].clone();\n\n        // Constraint: a + b = c\n        builder.assert_zero(a + b - c);\n    }\n}\n\n/// AIR that has some preprocessed columns - subtraction with one preprocessed constant\n#[derive(Clone, Copy)]\npub struct SubAirPartialPreprocessed {\n    rows: usize,\n}\n\nimpl Default for SubAirPartialPreprocessed {\n    fn default() -\u003e Self {\n        Self { rows: 1 \u003c\u003c 3 }\n    }\n}\n\nimpl SubAirPartialPreprocessed {\n    pub fn random_valid_trace\u003cVal: Field\u003e(\n        \u0026self,\n        valid: bool,\n    ) -\u003e (RowMajorMatrix\u003cVal\u003e, RowMajorMatrix\u003cVal\u003e)\n    where\n        StandardUniform: Distribution\u003cVal\u003e,\n    {\n        let main_width = 2; // [a, result] columns\n        let prep_width = 1; // [constant] column\n\n        let mut main_trace_values = Val::zero_vec(self.rows * main_width);\n        let mut prep_trace_values = Val::zero_vec(self.rows * prep_width);\n\n        for row in 0..self.rows {\n            let main_base_idx = row * main_width;\n            let prep_base_idx = row * prep_width;\n\n            let a = Val::from_usize(row + 10);\n            let constant = Val::from_usize(5); // Preprocessed constant\n\n            main_trace_values[main_base_idx] = a;\n            prep_trace_values[prep_base_idx] = constant;\n\n            // result = a - constant\n            main_trace_values[main_base_idx + 1] = if valid {\n                a - constant\n            } else {\n                a - constant + Val::ONE // Make invalid\n            };\n        }\n\n        (\n            RowMajorMatrix::new(main_trace_values, main_width),\n            RowMajorMatrix::new(prep_trace_values, prep_width),\n        )\n    }\n}\n\nimpl\u003cVal: Field\u003e BaseAir\u003cVal\u003e for SubAirPartialPreprocessed\nwhere\n    StandardUniform: Distribution\u003cVal\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        2 // [a, result]\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003e\u003e {\n        Some(self.random_valid_trace(true).1)\n    }\n}\n\nimpl\u003cAB: AirBuilder\u003e Air\u003cAB\u003e for SubAirPartialPreprocessed\nwhere\n    AB::F: Field,\n    StandardUniform: Distribution\u003cAB::F\u003e,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n        let main_local = main.row_slice(0).expect(\"Matrix is empty?\");\n\n        let preprocessed = builder\n            .preprocessed()\n            .expect(\"Expected preprocessed columns\");\n        let preprocessed_local = preprocessed\n            .row_slice(0)\n            .expect(\"Preprocessed matrix is empty?\");\n\n        let a = main_local[0].clone();\n        let result = main_local[1].clone();\n        let constant = preprocessed_local[0].clone();\n\n        // Constraint: a - constant = result\n        builder.assert_zero(a - constant - result);\n    }\n}\n\n#[test]\nfn test_batch_verifier_with_mixed_preprocessed() -\u003e Result\u003c(), VerificationError\u003e {\n    let n = 1 \u003c\u003c 3;\n\n    let perm = default_babybear_poseidon2_16();\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress, 0);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::default();\n\n    let log_final_poly_len = 0;\n    let fri_params = create_test_fri_params(challenge_mmcs, log_final_poly_len);\n    let fri_verifier_params = FriVerifierParams::from(\u0026fri_params);\n    let _log_height_max = fri_params.log_final_poly_len + fri_params.log_blowup;\n    let _pow_bits = fri_params.query_proof_of_work_bits;\n    let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n    let challenger = Challenger::new(perm.clone());\n\n    let config = MyConfig::new(pcs, challenger);\n\n    // Create three different AIRs with different preprocessed column configurations\n    let air1 = MulAir { degree: 2, rows: n }; // Has preprocessed columns\n    let air2 = AddAirNoPreprocessed { rows: n }; // No preprocessed columns  \n    let air3 = SubAirPartialPreprocessed { rows: n }; // Some preprocessed columns\n\n    // Generate valid traces for each AIR\n    let trace1 = air1.random_valid_trace(true).0;\n    let trace2 = air2.random_valid_trace(true);\n    let trace3 = air3.random_valid_trace(true).0;\n\n    // Each AIR has empty public inputs for this test\n    let pvs = [vec![], vec![], vec![]];\n\n    // Create MixedAir instances for batch proving\n    let mixed_air1: MixedAir = MixedAir::Mul(air1);\n    let mixed_air2 = MixedAir::Add(air2);\n    let mixed_air3 = MixedAir::Sub(air3);\n\n    // Create StarkInstances for batch proving\n    let instances = vec![\n        StarkInstance {\n            air: \u0026mixed_air1,\n            trace: trace1,\n            public_values: pvs[0].clone(),\n            lookups: Vec::new(),\n        },\n        StarkInstance {\n            air: \u0026mixed_air2,\n            trace: trace2,\n            public_values: pvs[1].clone(),\n            lookups: Vec::new(),\n        },\n        StarkInstance {\n            air: \u0026mixed_air3,\n            trace: trace3,\n            public_values: pvs[2].clone(),\n            lookups: Vec::new(),\n        },\n    ];\n\n    // Generate prover data and batch proof\n    let prover_data = ProverData::from_instances(\u0026config, \u0026instances);\n    let lookup_gadget = LogUpGadget::new();\n    let batch_proof = prove_batch(\u0026config, \u0026instances, \u0026prover_data);\n    let airs = [mixed_air1, mixed_air2, mixed_air3];\n    let common_data = \u0026prover_data.common;\n\n    verify_batch(\u0026config, \u0026airs, \u0026batch_proof, \u0026pvs, common_data).unwrap();\n\n    // Create AIRs vector for verification circuit\n    let airs = vec![mixed_air1, mixed_air2, mixed_air3];\n\n    // The first and last AIRs have preprocessed columns, the second does not\n    assert!(BaseAir::\u003cF\u003e::preprocessed_trace(\u0026airs[0]).is_some());\n    assert!(BaseAir::\u003cF\u003e::preprocessed_trace(\u0026airs[1]).is_none());\n    assert!(BaseAir::\u003cF\u003e::preprocessed_trace(\u0026airs[2]).is_some());\n\n    let mut circuit_builder = CircuitBuilder::new();\n    circuit_builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cChallenge, BabyBearD4Width16\u003e,\n        perm,\n    );\n\n    // Allocate batch verifier inputs\n    let air_public_counts = vec![0usize; batch_proof.opened_values.instances.len()];\n    let verifier_inputs = BatchStarkVerifierInputsBuilder::\u003c\n        MyConfig,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n        InnerFri,\n    \u003e::allocate(\n        \u0026mut circuit_builder,\n        \u0026batch_proof,\n        common_data,\n        \u0026air_public_counts,\n    );\n\n    // Create PCS verifier params from FRI verifier params\n    let pcs_verifier_params = fri_verifier_params;\n\n    // Add the batch verification circuit to the builder for the following AIRs:\n    // 1. MulAir (has preprocessed columns)\n    // 2. AddAirNoPreprocessed (no preprocessed columns)\n    // 3. SubAirPartialPreprocessed (some preprocessed columns)\n    verify_batch_circuit::\u003c_, _, _, _, _, _, WIDTH, RATE\u003e(\n        \u0026config,\n        \u0026airs,\n        \u0026mut circuit_builder,\n        \u0026verifier_inputs.proof_targets,\n        \u0026verifier_inputs.air_public_targets,\n        \u0026pcs_verifier_params,\n        \u0026verifier_inputs.common_data,\n        \u0026lookup_gadget,\n        Poseidon2Config::BabyBearD4Width16,\n    )?;\n\n    // Build the circuit\n    let circuit = circuit_builder.build()?;\n    let mut runner = circuit.runner();\n\n    // Pack values using the batch builder\n    let public_inputs = verifier_inputs.pack_values(\n        \u0026pvs, // public inputs for each AIR\n        \u0026batch_proof,\n        common_data,\n    );\n\n    runner\n        .set_public_inputs(\u0026public_inputs)\n        .map_err(VerificationError::Circuit)?;\n\n    let _traces = runner.run().map_err(VerificationError::Circuit)?;\n\n    Ok(())\n}\n","traces":[{"line":1,"address":[3079200],"length":1,"stats":{"Line":1}},{"line":28,"address":[3112144,3112152],"length":1,"stats":{"Line":2}},{"line":39,"address":[3121680],"length":1,"stats":{"Line":1}},{"line":40,"address":[3121693],"length":1,"stats":{"Line":1}},{"line":41,"address":[3121729],"length":1,"stats":{"Line":1}},{"line":42,"address":[3121754],"length":1,"stats":{"Line":1}},{"line":43,"address":[3121779],"length":1,"stats":{"Line":1}},{"line":45,"address":[3121798],"length":1,"stats":{"Line":1}},{"line":47,"address":[3121536],"length":1,"stats":{"Line":1}},{"line":48,"address":[3121560],"length":1,"stats":{"Line":1}},{"line":49,"address":[3121602],"length":1,"stats":{"Line":1}},{"line":50,"address":[3121628],"length":1,"stats":{"Line":1}},{"line":51,"address":[3121654],"length":1,"stats":{"Line":1}},{"line":53,"address":[3121673],"length":1,"stats":{"Line":1}},{"line":61,"address":[3118624,3118768,3118912,3119056],"length":1,"stats":{"Line":3}},{"line":62,"address":[3118792,3118648,3118936,3119080],"length":1,"stats":{"Line":3}},{"line":63,"address":[3118834,3119122,3118978,3118690],"length":1,"stats":{"Line":3}},{"line":64,"address":[3118860,3119148,3119004,3118716],"length":1,"stats":{"Line":3}},{"line":65,"address":[3118886,3118742,3119174,3119030],"length":1,"stats":{"Line":3}},{"line":67,"address":[3119188,3118900,3119044,3118756],"length":1,"stats":{"Line":3}},{"line":71,"address":[3121520,3121525],"length":1,"stats":{"Line":0}},{"line":79,"address":[3121824],"length":1,"stats":{"Line":0}},{"line":83,"address":[3069379,3069347,3068448],"length":1,"stats":{"Line":1}},{"line":87,"address":[3068505],"length":1,"stats":{"Line":1}},{"line":88,"address":[3068525,3068617],"length":1,"stats":{"Line":1}},{"line":90,"address":[3069342,3068586,3068684],"length":1,"stats":{"Line":3}},{"line":91,"address":[3068912,3068931,3068790],"length":1,"stats":{"Line":2}},{"line":92,"address":[3068920,3068960],"length":1,"stats":{"Line":2}},{"line":93,"address":[3068967],"length":1,"stats":{"Line":1}},{"line":94,"address":[3069034],"length":1,"stats":{"Line":1}},{"line":95,"address":[3069077],"length":1,"stats":{"Line":1}},{"line":98,"address":[3069280,3069243,3069165],"length":1,"stats":{"Line":3}},{"line":99,"address":[3069196,3069266],"length":1,"stats":{"Line":2}},{"line":101,"address":[3069216,3069177],"length":1,"stats":{"Line":0}},{"line":105,"address":[3068818],"length":1,"stats":{"Line":1}},{"line":106,"address":[3068886,3068630,3069360],"length":1,"stats":{"Line":1}},{"line":113,"address":[3132768],"length":1,"stats":{"Line":1}},{"line":115,"address":[3132773],"length":1,"stats":{"Line":1}},{"line":117,"address":[3132736],"length":1,"stats":{"Line":1}},{"line":118,"address":[3132744],"length":1,"stats":{"Line":1}},{"line":119,"address":[3132757],"length":1,"stats":{"Line":1}},{"line":127,"address":[3125477,3123843,3123744,3124560,3125595,3126379,3125471,3126288,3125504],"length":1,"stats":{"Line":3}},{"line":128,"address":[3125532,3123772,3124588,3126316],"length":1,"stats":{"Line":3}},{"line":129,"address":[3123891,3126372,3124636,3125630,3126414,3123823,3125588,3124700],"length":1,"stats":{"Line":6}},{"line":131,"address":[3123961,3125680,3124770,3124010,3124819,3125726,3126504,3126458],"length":1,"stats":{"Line":6}},{"line":132,"address":[3125872,3124093,3124954,3124156,3126636,3126573,3125809,3124891],"length":1,"stats":{"Line":6}},{"line":133,"address":[3124248,3125098,3125035,3126775,3124311,3125964,3126714,3126027],"length":1,"stats":{"Line":6}},{"line":136,"address":[3126847,3124475,3125323,3126191,3126967,3125171,3124403,3126119],"length":1,"stats":{"Line":6}},{"line":137,"address":[3124110,3127042,3125414,3124658,3126226,3125981,3124430,3124787,3123978,3124265,3126146,3126475,3125826,3126590,3125697,3126730,3126926,3125282,3124908,3125052,3124510],"length":1,"stats":{"Line":3}},{"line":141,"address":[3121840,3121845],"length":1,"stats":{"Line":0}},{"line":149,"address":[3127616],"length":1,"stats":{"Line":0}},{"line":153,"address":[3070203,3069392,3070696],"length":1,"stats":{"Line":1}},{"line":160,"address":[3069449],"length":1,"stats":{"Line":1}},{"line":161,"address":[3069477],"length":1,"stats":{"Line":1}},{"line":163,"address":[3069573,3069489],"length":1,"stats":{"Line":1}},{"line":164,"address":[3069550,3069599,3069675],"length":1,"stats":{"Line":3}},{"line":166,"address":[3069683,3069759,3070669],"length":1,"stats":{"Line":3}},{"line":167,"address":[3070247,3069865,3070219],"length":1,"stats":{"Line":2}},{"line":168,"address":[3070278,3070305,3070227],"length":1,"stats":{"Line":2}},{"line":170,"address":[3070286,3070331],"length":1,"stats":{"Line":2}},{"line":171,"address":[3070379],"length":1,"stats":{"Line":1}},{"line":173,"address":[3070406],"length":1,"stats":{"Line":1}},{"line":174,"address":[3070449],"length":1,"stats":{"Line":1}},{"line":177,"address":[3070609,3070494,3070572],"length":1,"stats":{"Line":3}},{"line":178,"address":[3070525,3070595],"length":1,"stats":{"Line":2}},{"line":180,"address":[3070545,3070506],"length":1,"stats":{"Line":0}},{"line":184,"address":[3070084],"length":1,"stats":{"Line":1}},{"line":185,"address":[3069892],"length":1,"stats":{"Line":1}},{"line":186,"address":[3069960],"length":1,"stats":{"Line":1}},{"line":187,"address":[3070036],"length":1,"stats":{"Line":0}},{"line":188,"address":[3069711,3069624,3070179,3070674,3070709],"length":1,"stats":{"Line":1}},{"line":195,"address":[3137040],"length":1,"stats":{"Line":1}},{"line":197,"address":[3137045],"length":1,"stats":{"Line":1}},{"line":199,"address":[3136896],"length":1,"stats":{"Line":1}},{"line":200,"address":[3136914],"length":1,"stats":{"Line":1}},{"line":201,"address":[3137023],"length":1,"stats":{"Line":1}},{"line":209,"address":[3135680,3134851,3134768,3133971,3132784,3135783,3133868,3133888,3133874],"length":1,"stats":{"Line":3}},{"line":210,"address":[3132812,3134796,3135711,3133916],"length":1,"stats":{"Line":3}},{"line":211,"address":[3132928,3134006,3133964,3134844,3135760,3134886,3132855,3135834],"length":1,"stats":{"Line":6}},{"line":214,"address":[3134061,3134938,3135918,3133003],"length":1,"stats":{"Line":3}},{"line":215,"address":[3134092,3133037,3134969,3135952],"length":1,"stats":{"Line":3}},{"line":216,"address":[3133201,3136103],"length":1,"stats":{"Line":2}},{"line":217,"address":[3134154,3136006,3135031,3133091],"length":1,"stats":{"Line":3}},{"line":218,"address":[3134185,3133155,3136057,3135062],"length":1,"stats":{"Line":3}},{"line":220,"address":[3134235,3133225,3133274,3134281,3136127,3136173,3135109,3135155],"length":1,"stats":{"Line":6}},{"line":221,"address":[3134427,3136319,3136256,3135287,3133409,3134364,3135224,3133346],"length":1,"stats":{"Line":6}},{"line":222,"address":[3133553,3135429,3135368,3136474,3134519,3133490,3136411,3134582],"length":1,"stats":{"Line":6}},{"line":225,"address":[3135485,3134654,3133610,3136546],"length":1,"stats":{"Line":3}},{"line":226,"address":[3133116,3133507,3133010,3134252,3136611,3134068,3134716,3135241,3135631,3132883,3133804,3135038,3135384,3135925,3136023,3133242,3133363,3135126,3136144,3134536,3136273,3136428,3134381,3134161,3134945],"length":1,"stats":{"Line":3}},{"line":230,"address":[3070736,3079136,3079154,3078574,3079092],"length":1,"stats":{"Line":3}},{"line":231,"address":[3070816],"length":1,"stats":{"Line":1}},{"line":233,"address":[3070932],"length":1,"stats":{"Line":1}},{"line":234,"address":[3070973,3071049],"length":1,"stats":{"Line":2}},{"line":235,"address":[3071129,3071064],"length":1,"stats":{"Line":2}},{"line":236,"address":[3071156],"length":1,"stats":{"Line":1}},{"line":237,"address":[3071383,3071447],"length":1,"stats":{"Line":2}},{"line":238,"address":[3071470],"length":1,"stats":{"Line":1}},{"line":240,"address":[3070804,3071515],"length":1,"stats":{"Line":2}},{"line":241,"address":[3071523,3071637],"length":1,"stats":{"Line":2}},{"line":242,"address":[3071661],"length":1,"stats":{"Line":1}},{"line":243,"address":[3071706,3071954],"length":1,"stats":{"Line":1}},{"line":244,"address":[3071758],"length":1,"stats":{"Line":1}},{"line":245,"address":[3071974,3071774],"length":1,"stats":{"Line":2}},{"line":246,"address":[3071982,3072066],"length":1,"stats":{"Line":2}},{"line":248,"address":[3072073],"length":1,"stats":{"Line":1}},{"line":251,"address":[3072197],"length":1,"stats":{"Line":1}},{"line":252,"address":[3072221],"length":1,"stats":{"Line":1}},{"line":253,"address":[3072233],"length":1,"stats":{"Line":1}},{"line":256,"address":[3072313,3072266],"length":1,"stats":{"Line":2}},{"line":257,"address":[3072427],"length":1,"stats":{"Line":1}},{"line":258,"address":[3072463,3072508],"length":1,"stats":{"Line":2}},{"line":261,"address":[3072601],"length":1,"stats":{"Line":1}},{"line":264,"address":[3072836],"length":1,"stats":{"Line":1}},{"line":265,"address":[3072880],"length":1,"stats":{"Line":1}},{"line":266,"address":[3072908],"length":1,"stats":{"Line":1}},{"line":269,"address":[3078888,3074130,3072946,3073009],"length":1,"stats":{"Line":3}},{"line":270,"address":[3073212],"length":1,"stats":{"Line":1}},{"line":272,"address":[3073017],"length":1,"stats":{"Line":1}},{"line":273,"address":[3073089],"length":1,"stats":{"Line":1}},{"line":274,"address":[3073164],"length":1,"stats":{"Line":1}},{"line":275,"address":[3073171,3073124],"length":1,"stats":{"Line":0}},{"line":276,"address":[3073583],"length":1,"stats":{"Line":1}},{"line":278,"address":[3073388],"length":1,"stats":{"Line":1}},{"line":279,"address":[3073460],"length":1,"stats":{"Line":1}},{"line":280,"address":[3073535],"length":1,"stats":{"Line":1}},{"line":281,"address":[3073542,3073495],"length":1,"stats":{"Line":0}},{"line":282,"address":[3073954],"length":1,"stats":{"Line":1}},{"line":284,"address":[3073759],"length":1,"stats":{"Line":1}},{"line":285,"address":[3073831],"length":1,"stats":{"Line":1}},{"line":286,"address":[3073906],"length":1,"stats":{"Line":1}},{"line":287,"address":[3073866,3073913],"length":1,"stats":{"Line":0}},{"line":291,"address":[3074509,3074604],"length":1,"stats":{"Line":2}},{"line":292,"address":[3074611],"length":1,"stats":{"Line":1}},{"line":293,"address":[3074667],"length":1,"stats":{"Line":1}},{"line":294,"address":[3074737],"length":1,"stats":{"Line":1}},{"line":295,"address":[3074841],"length":1,"stats":{"Line":1}},{"line":297,"address":[3074955,3074849],"length":1,"stats":{"Line":2}},{"line":300,"address":[3074987],"length":1,"stats":{"Line":1}},{"line":303,"address":[3075183,3075273],"length":1,"stats":{"Line":2}},{"line":304,"address":[3075415],"length":1,"stats":{"Line":1}},{"line":305,"address":[3075611],"length":1,"stats":{"Line":1}},{"line":307,"address":[3075815],"length":1,"stats":{"Line":1}},{"line":308,"address":[3075918,3075822],"length":1,"stats":{"Line":2}},{"line":310,"address":[3075830],"length":1,"stats":{"Line":1}},{"line":314,"address":[3075989],"length":1,"stats":{"Line":1}},{"line":315,"address":[3076162],"length":1,"stats":{"Line":1}},{"line":323,"address":[3076047],"length":1,"stats":{"Line":1}},{"line":327,"address":[3076169],"length":1,"stats":{"Line":1}},{"line":333,"address":[3076643,3078633,3076415],"length":1,"stats":{"Line":1}},{"line":335,"address":[3076225],"length":1,"stats":{"Line":1}},{"line":337,"address":[3076320],"length":1,"stats":{"Line":1}},{"line":338,"address":[3076344],"length":1,"stats":{"Line":1}},{"line":340,"address":[3076407],"length":1,"stats":{"Line":1}},{"line":343,"address":[3076563,3076820],"length":1,"stats":{"Line":1}},{"line":346,"address":[3076827,3078616],"length":1,"stats":{"Line":1}},{"line":347,"address":[3077327,3077237],"length":1,"stats":{"Line":2}},{"line":350,"address":[3077380],"length":1,"stats":{"Line":1}},{"line":356,"address":[3078527,3077559,3077695],"length":1,"stats":{"Line":1}},{"line":357,"address":[3077433,3077513],"length":1,"stats":{"Line":2}},{"line":358,"address":[3077615,3077536],"length":1,"stats":{"Line":1}},{"line":360,"address":[3078510,3077800],"length":1,"stats":{"Line":1}},{"line":362,"address":[3078241],"length":1,"stats":{"Line":1}},{"line":363,"address":[3072009,3075225,3074540,3071668,3077458,3074923,3078588,3078626,3071596,3071477,3078564,3072368,3074630,3076070,3078244,3070992,3071390,3076256,3077387,3072470,3079183,3078938,3078635,3079105,3072281,3077286,3072969,3078529,3075948,3071091,3078520,3072563],"length":1,"stats":{"Line":2}}],"covered":153,"coverable":163},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","test_lookups.rs"],"content":"mod common;\n\nuse p3_baby_bear::default_babybear_poseidon2_16;\nuse p3_batch_stark::{CommonData, ProverData};\nuse p3_circuit::op::PrimitiveOpType;\nuse p3_circuit::ops::{Poseidon2PermCall, generate_poseidon2_trace};\nuse p3_circuit::{CircuitBuilder, Poseidon2PermOps};\nuse p3_circuit_prover::air::{AluAir, ConstAir, PublicAir, WitnessAir};\nuse p3_circuit_prover::batch_stark_prover::PrimitiveTable;\nuse p3_circuit_prover::common::{NonPrimitiveConfig, get_airs_and_degrees_with_prep};\nuse p3_circuit_prover::{\n    BatchStarkProof, BatchStarkProver, CircuitProverData, ConstraintProfile, Poseidon2Config,\n    TablePacking,\n};\nuse p3_field::PrimeCharacteristicRing;\nuse p3_fri::create_test_fri_params;\nuse p3_lookup::logup::LogUpGadget;\nuse p3_lookup::lookup_traits::LookupData;\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\nuse p3_recursion::generation::generate_batch_challenges;\nuse p3_recursion::pcs::fri::{FriVerifierParams, InputProofTargets, MerkleCapTargets, RecValMmcs};\nuse p3_recursion::verifier::{CircuitTablesAir, verify_p3_batch_proof_circuit};\nuse p3_recursion::{BatchStarkVerifierInputsBuilder, GenerationError, VerificationError};\nconst TRACE_D: usize = 1; // Proof traces are in base field\n\nuse crate::common::baby_bear_params::*;\n\nfn setup_circuit_builder() -\u003e CircuitBuilder\u003cChallenge\u003e {\n    let mut circuit_builder = CircuitBuilder::new();\n    let poseidon2_perm = default_babybear_poseidon2_16();\n    circuit_builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cChallenge, BabyBearD4Width16\u003e,\n        poseidon2_perm,\n    );\n    circuit_builder\n}\n\n// In this file, the circuits compute the following function.\nfn repeated_arith(a: usize, b: usize, x: usize, n: usize) -\u003e usize {\n    let mut y = a * x + b;\n    for _i in 0..n {\n        y = a * y + b;\n    }\n    y\n}\n\n#[test]\nfn test_arith_lookups() {\n    let TestCircuitProofData {\n        mut batch_stark_proof,\n        circuit_prover_data,\n        lookup_gadget,\n        config,\n        params,\n        pis,\n        prover,\n    } = get_test_circuit_proof();\n    let common = circuit_prover_data.common_data();\n\n    prover\n        .verify_all_tables(\u0026batch_stark_proof, common)\n        .unwrap();\n\n    // Build the recursive verification circuit\n    let mut circuit_builder = setup_circuit_builder();\n\n    let (verifier_inputs, _all_challenges) = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        None,\n        \u0026lookup_gadget,\n    );\n\n    // Build the circuit\n    let verification_circuit = circuit_builder.build().unwrap();\n    let expected_public_input_len = verification_circuit.public_flat_len;\n\n    // Pack values using the builder\n    let batch_proof = \u0026batch_stark_proof.proof;\n    let public_inputs = verifier_inputs\n        .unwrap()\n        .pack_values(\u0026pis, batch_proof, common);\n\n    assert_eq!(public_inputs.len(), expected_public_input_len);\n    assert!(!public_inputs.is_empty());\n\n    // Actually run the circuit to ensure constraints are satisfiable\n    let mut runner = verification_circuit.runner();\n    runner.set_public_inputs(\u0026public_inputs).unwrap();\n    let _traces = runner.run().unwrap();\n}\n\n#[test]\n#[should_panic]\nfn test_wrong_multiplicities() {\n    let n = 10;\n\n    // Get a circuit that computes arithmetic operations.\n    let builder = get_circuit(n);\n\n    let table_packing = TablePacking::new(1, 4, 4);\n\n    let config_proving = get_proving_config();\n\n    let circuit = builder.build().unwrap();\n    let (airs_degrees, mut preprocessed_columns) =\n        get_airs_and_degrees_with_prep::\u003cMyConfig, _, 1\u003e(\n            \u0026circuit,\n            table_packing,\n            None,\n            ConstraintProfile::Standard,\n        )\n        .unwrap();\n\n    // Introduce an error in the witness multiplicities.\n    preprocessed_columns.primitive[PrimitiveOpType::Witness as usize]\n        [PrimitiveTable::Alu as usize] += F::ONE;\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    let init_a = 3;\n    let init_b = 5;\n    let init_x = 7;\n    let expected_result = F::from_usize(repeated_arith(init_a, init_b, init_x, n));\n\n    runner\n        .set_public_inputs(\u0026[\n            F::from_usize(init_x),\n            F::from_usize(init_a),\n            F::from_usize(init_b),\n            expected_result,\n        ])\n        .unwrap();\n\n    let traces = runner.run().unwrap();\n\n    // Create prover data for proving and verifying.\n    let prover_data = ProverData::from_airs_and_degrees(\u0026config_proving, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    let prover = BatchStarkProver::new(config_proving).with_table_packing(table_packing);\n\n    // Prove the circuit.\n    let lookup_gadget = LogUpGadget::new();\n    let mut batch_stark_proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n    let common = circuit_prover_data.common_data();\n\n    // Now verify the batch STARK proof recursively\n    let (config, fri_verifier_params, pow_bits, log_height_max) = get_recursive_config_and_params();\n\n    // Build the recursive verification circuit\n    let mut circuit_builder = setup_circuit_builder();\n\n    // Public values (empty for all 4 circuit tables, using base field)\n    let pis: Vec\u003cVec\u003cF\u003e\u003e = vec![vec![]; 4];\n\n    // Attach verifier without manually building circuit_airs\n    let params = Parameters {\n        fri_verifier_params,\n        pow_bits,\n        log_height_max,\n    };\n    let (verifier_inputs, _all_challenges) = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        None,\n        \u0026lookup_gadget,\n    );\n\n    // Build the circuit\n    let verification_circuit = circuit_builder.build().unwrap();\n    let expected_public_input_len = verification_circuit.public_flat_len;\n\n    // Pack values using the builder\n    let batch_proof = \u0026batch_stark_proof.proof;\n    let public_inputs = verifier_inputs\n        .unwrap()\n        .pack_values(\u0026pis, batch_proof, common);\n\n    assert_eq!(public_inputs.len(), expected_public_input_len);\n    assert!(!public_inputs.is_empty());\n\n    // Actually run the circuit to ensure constraints are satisfiable\n    let mut runner = verification_circuit.runner();\n    runner.set_public_inputs(\u0026public_inputs).unwrap();\n\n    // This line fails because the proof was generated with wrong multiplicities.\n    // Thus, we have an OOD evaluation mismatch, resulting in a `WitnessConflict` in the circuit.\n    let _traces = runner.run().unwrap();\n}\n\n#[test]\n#[should_panic(expected = \"WitnessConflict\")]\nfn test_wrong_expected_cumulated() {\n    let TestCircuitProofData {\n        mut batch_stark_proof,\n        circuit_prover_data,\n        lookup_gadget,\n        config,\n        params,\n        pis,\n        ..\n    } = get_test_circuit_proof();\n    let common = circuit_prover_data.common_data();\n\n    // Introduce an error in the global expected cumulated values for the first lookup.\n    // This leads to the sum of all expected cumulated values being off by 1,\n    // which causes a WitnessConflict during recursive verification.\n    batch_stark_proof.proof.global_lookup_data[0][0].expected_cumulated += F::ONE;\n    // Introduce an error in the expected cumulated values for the first lookup.\n    assert!(batch_stark_proof.proof.global_lookup_data.len() == 4);\n\n    // Build the recursive verification circuit\n    let mut circuit_builder = setup_circuit_builder();\n\n    let (verifier_inputs, _all_challenges) = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        None,\n        \u0026lookup_gadget,\n    );\n\n    // Build the circuit\n    let verification_circuit = circuit_builder.build().unwrap();\n    let expected_public_input_len = verification_circuit.public_flat_len;\n\n    // Pack values using the builder\n    let public_inputs =\n        verifier_inputs\n            .unwrap()\n            .pack_values(\u0026pis, \u0026batch_stark_proof.proof, common);\n\n    assert_eq!(public_inputs.len(), expected_public_input_len);\n    assert!(!public_inputs.is_empty());\n\n    // Actually run the circuit to ensure constraints are satisfiable\n    let mut runner = verification_circuit.runner();\n    runner.set_public_inputs(\u0026public_inputs).unwrap();\n\n    // This line fails because the verifier gets wrong global lookup data.\n    // This leads to the sum of all expected cumulated values being off by 1,\n    // which causes a WitnessConflict during recursive verification.\n    let _traces = runner.run().unwrap();\n}\n\n#[test]\n#[should_panic(expected = \"WitnessConflict\")]\nfn test_inconsistent_lookup_name() {\n    let TestCircuitProofData {\n        mut batch_stark_proof,\n        circuit_prover_data,\n        lookup_gadget,\n        config,\n        params,\n        pis,\n        ..\n    } = get_test_circuit_proof();\n    let common = circuit_prover_data.common_data();\n\n    let real_lookup_data = batch_stark_proof.proof.global_lookup_data.clone();\n    // First, modify the first global lookup data's name.\n    assert!(real_lookup_data.len() == 4);\n    let mut fake_global_lookup_data = real_lookup_data.clone();\n    fake_global_lookup_data[0][0].name = \"ModifiedLookup\".to_string();\n\n    // Build the recursive verification circuit\n    let mut circuit_builder = setup_circuit_builder();\n\n    // Attach verifier without manually building circuit_airs. Generation fails because of the fake lookup data.\n    // First, only challenges use the fake lookup data.\n    let (_verifier_inputs, all_challenges) = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        Some(\u0026fake_global_lookup_data),\n        \u0026lookup_gadget,\n    );\n\n    match all_challenges {\n        Err(GenerationError::InvalidProofShape(msg)) =\u003e {\n            assert_eq!(msg, \"Global lookups are inconsistent with lookups\");\n        }\n        Err(_) =\u003e panic!(\"Expected InvalidProofShape\"),\n        Ok(_) =\u003e panic!(\"Expected error due to inconsistent lookup shape\"),\n    }\n\n    // Second, only the verifier uses the fake lookup data with a modified name.\n    // Since global permutation challenges are generated based on the `name`,\n    // this leads to a `WitnessConflict` during recursive verification due to failed constraints.\n    batch_stark_proof.proof.global_lookup_data = fake_global_lookup_data;\n\n    let mut circuit_builder = setup_circuit_builder();\n    let (verifier_inputs, _all_challenges) = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        Some(real_lookup_data.as_slice()),\n        \u0026lookup_gadget,\n    );\n\n    // Build the circuit\n    let verification_circuit = circuit_builder.build().unwrap();\n    let expected_public_input_len = verification_circuit.public_flat_len;\n\n    // Pack values using the builder\n    let public_inputs =\n        verifier_inputs\n            .unwrap()\n            .pack_values(\u0026pis, \u0026batch_stark_proof.proof, common);\n\n    assert_eq!(public_inputs.len(), expected_public_input_len);\n    assert!(!public_inputs.is_empty());\n\n    // Actually run the circuit to ensure constraints are satisfiable\n    let mut runner = verification_circuit.runner();\n    runner.set_public_inputs(\u0026public_inputs).unwrap();\n\n    // This line fails because the verifier gets wrong global lookup data.\n    // This leads to the sum of all expected cumulated values being off by 1,\n    // which causes a WitnessConflict during recursive verification.\n    let _traces = runner.run().unwrap();\n}\n\n#[test]\nfn test_inconsistent_lookup_commitment_shape() {\n    let TestCircuitProofData {\n        mut batch_stark_proof,\n        circuit_prover_data,\n        lookup_gadget,\n        config,\n        params,\n        pis,\n        ..\n    } = get_test_circuit_proof();\n    let common = circuit_prover_data.common_data();\n\n    let real_lookup_data = batch_stark_proof.proof.global_lookup_data.clone();\n    batch_stark_proof.proof.global_lookup_data = real_lookup_data;\n    batch_stark_proof.proof.commitments.permutation = None;\n\n    // Build the recursive verification circuit\n    let mut circuit_builder = setup_circuit_builder();\n\n    let (verifier_inputs, _all_challenges) = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        None,\n        \u0026lookup_gadget,\n    );\n\n    match verifier_inputs {\n        Err(VerificationError::InvalidProofShape(msg)) =\u003e {\n            assert_eq!(msg, \"Mismatch between lookup commitment and lookup data\");\n        }\n        Err(_) =\u003e panic!(\"Expected InvalidProofShape\"),\n        Ok(_) =\u003e panic!(\"Expected error due to inconsistent lookup shape\"),\n    }\n}\n\n#[test]\n#[should_panic(expected = \"Expected cumulated values not sorted by auxiliary index\")]\nfn test_inconsistent_lookup_order_shape() {\n    let TestCircuitProofData {\n        mut batch_stark_proof,\n        circuit_prover_data,\n        lookup_gadget,\n        config,\n        params,\n        pis,\n        ..\n    } = get_test_circuit_proof();\n    let common = circuit_prover_data.common_data();\n\n    let real_lookup_data = batch_stark_proof.proof.global_lookup_data.clone();\n    let mut fake_global_lookup_data = real_lookup_data.clone();\n    assert!(fake_global_lookup_data[3].len() \u003e 1);\n    fake_global_lookup_data[3].swap(0, 1);\n\n    // Build the recursive verification circuit\n    let mut circuit_builder = setup_circuit_builder();\n\n    // First, only challenges use the fake lookup data.\n    let (_verifier_inputs, all_challenges) = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        Some(\u0026fake_global_lookup_data),\n        \u0026lookup_gadget,\n    );\n\n    match all_challenges {\n        Err(GenerationError::InvalidProofShape(msg)) =\u003e {\n            assert_eq!(msg, \"Global lookups are inconsistent with lookups\");\n        }\n        Err(_) =\u003e panic!(\"Expected InvalidProofShape\"),\n        Ok(_) =\u003e panic!(\"Expected error due to inconsistent lookup shape\"),\n    }\n\n    // Second, only the verifier uses the fake lookup data.\n    batch_stark_proof.proof.global_lookup_data = fake_global_lookup_data;\n\n    let mut circuit_builder = setup_circuit_builder();\n    let _ = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        Some(real_lookup_data.as_slice()),\n        \u0026lookup_gadget,\n    );\n}\n\n#[test]\n#[should_panic(expected = \"Too many expected cumulated values provided\")]\nfn test_extra_global_lookup() {\n    let TestCircuitProofData {\n        mut batch_stark_proof,\n        circuit_prover_data,\n        lookup_gadget,\n        config,\n        params,\n        pis,\n        ..\n    } = get_test_circuit_proof();\n    let common = circuit_prover_data.common_data();\n\n    let real_lookup_data = batch_stark_proof.proof.global_lookup_data.clone();\n    let fake_lookup = LookupData {\n        name: \"FakeLookup\".to_string(),\n        aux_idx: 0,\n        expected_cumulated: Challenge::ZERO,\n    };\n    let mut fake_global_lookup_data = real_lookup_data.clone();\n    fake_global_lookup_data[0].push(fake_lookup);\n\n    // Build the recursive verification circuit\n    let mut circuit_builder = setup_circuit_builder();\n\n    // First, only challenges use the fake lookup data with an extra global lookup.\n    let (_verifier_inputs, all_challenges) = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        Some(\u0026fake_global_lookup_data),\n        \u0026lookup_gadget,\n    );\n\n    match all_challenges {\n        Err(GenerationError::InvalidProofShape(msg)) =\u003e {\n            assert_eq!(msg, \"Global lookups are inconsistent with lookups\");\n        }\n        Err(_) =\u003e panic!(\"Expected InvalidProofShape\"),\n        Ok(_) =\u003e panic!(\"Expected error due to inconsistent lookup shape\"),\n    }\n\n    // Second, only the verifier uses the fake lookup data.\n    batch_stark_proof.proof.global_lookup_data = fake_global_lookup_data;\n\n    let mut circuit_builder = setup_circuit_builder();\n    let _ = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        Some(real_lookup_data.as_slice()),\n        \u0026lookup_gadget,\n    );\n}\n\n#[test]\n#[should_panic(expected = \"Expected cumulated value missing\")]\nfn test_missing_global_lookup() {\n    let TestCircuitProofData {\n        mut batch_stark_proof,\n        circuit_prover_data,\n        lookup_gadget,\n        config,\n        params,\n        pis,\n        ..\n    } = get_test_circuit_proof();\n    let common = circuit_prover_data.common_data();\n\n    let real_lookup_data = batch_stark_proof.proof.global_lookup_data.clone();\n    let mut fake_global_lookup_data = real_lookup_data.clone();\n    assert!(!fake_global_lookup_data[0].is_empty());\n    fake_global_lookup_data[0].pop();\n\n    // Build the recursive verification circuit\n    let mut circuit_builder = setup_circuit_builder();\n\n    // First, only challenges use the fake lookup data with a missing global lookup.\n    let (_verifier_inputs, all_challenges) = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        Some(\u0026fake_global_lookup_data),\n        \u0026lookup_gadget,\n    );\n\n    match all_challenges {\n        Err(GenerationError::InvalidProofShape(msg)) =\u003e {\n            assert_eq!(msg, \"Global lookups are inconsistent with lookups\");\n        }\n        Err(_) =\u003e panic!(\"Expected InvalidProofShape\"),\n        Ok(_) =\u003e panic!(\"Expected error due to inconsistent lookup shape\"),\n    }\n\n    // Second, only the verifier uses the fake lookup data.\n    batch_stark_proof.proof.global_lookup_data = fake_global_lookup_data;\n\n    let mut circuit_builder = setup_circuit_builder();\n    let (verifier_inputs, _all_challenges) = get_verifier_inputs_and_challenges(\n        \u0026mut circuit_builder,\n        \u0026config,\n        \u0026params,\n        \u0026mut batch_stark_proof,\n        common,\n        \u0026pis,\n        Some(real_lookup_data.as_slice()),\n        \u0026lookup_gadget,\n    );\n\n    match verifier_inputs {\n        Err(VerificationError::InvalidProofShape(msg)) =\u003e {\n            assert_eq!(msg, \"Expected cumulated value missing\");\n        }\n        Err(_) =\u003e panic!(\"Expected InvalidProofShape\"),\n        Ok(_) =\u003e panic!(\"Expected error due to inconsistent lookup shape\"),\n    }\n}\n\nstruct TestCircuitProofData {\n    batch_stark_proof: BatchStarkProof\u003cMyConfig\u003e,\n    circuit_prover_data: CircuitProverData\u003cMyConfig\u003e,\n    lookup_gadget: LogUpGadget,\n    config: MyConfig,\n    params: Parameters,\n    pis: Vec\u003cVec\u003cF\u003e\u003e,\n    prover: BatchStarkProver\u003cMyConfig\u003e,\n}\n\nfn get_test_circuit_proof() -\u003e TestCircuitProofData {\n    let n = 10;\n\n    // Get a circuit that computes arithmetic operations.\n    let builder = get_circuit(n);\n\n    let table_packing = TablePacking::new(1, 4, 4);\n\n    let config_proving = get_proving_config();\n\n    let circuit = builder.build().unwrap();\n    let (airs_degrees, preprocessed_columns) = get_airs_and_degrees_with_prep::\u003cMyConfig, _, 1\u003e(\n        \u0026circuit,\n        table_packing,\n        None,\n        ConstraintProfile::Standard,\n    )\n    .unwrap();\n\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    let init_a = 3;\n    let init_b = 5;\n    let init_x = 7;\n    let expected_result = F::from_usize(repeated_arith(init_a, init_b, init_x, n));\n\n    runner\n        .set_public_inputs(\u0026[\n            F::from_usize(init_x),\n            F::from_usize(init_a),\n            F::from_usize(init_b),\n            expected_result,\n        ])\n        .unwrap();\n\n    let traces = runner.run().unwrap();\n\n    // Create prover data for proving and verifying.\n    let prover_data = ProverData::from_airs_and_degrees(\u0026config_proving, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    let lookup_gadget = LogUpGadget::new();\n    let prover = BatchStarkProver::new(config_proving).with_table_packing(table_packing);\n    let batch_stark_proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n\n    let (config, fri_verifier_params, pow_bits, log_height_max) = get_recursive_config_and_params();\n    let params = Parameters {\n        fri_verifier_params,\n        pow_bits,\n        log_height_max,\n    };\n    let pis = vec![vec![]; 4];\n\n    TestCircuitProofData {\n        batch_stark_proof,\n        circuit_prover_data,\n        lookup_gadget,\n        config,\n        params,\n        pis,\n        prover,\n    }\n}\n\n// Returns the proving configuration for the initial circuit.\n// Uses the default permutation to match the circuit's Fiat-Shamir challenger.\nfn get_proving_config() -\u003e MyConfig {\n    let perm = default_babybear_poseidon2_16();\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress, 0);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::default();\n\n    let fri_params = create_test_fri_params(challenge_mmcs, 0);\n\n    let pcs_proving = MyPcs::new(dft, val_mmcs, fri_params);\n    let challenger_proving = Challenger::new(perm);\n    MyConfig::new(pcs_proving, challenger_proving)\n}\n\n// Returns the configuration and FRI verifier params for recursive verification.\n// Uses the default permutation to match the circuit's Fiat-Shamir challenger.\nfn get_recursive_config_and_params() -\u003e (MyConfig, FriVerifierParams, usize, usize) {\n    let dft2 = Dft::default();\n    let perm2 = default_babybear_poseidon2_16();\n    let hash2 = MyHash::new(perm2.clone());\n    let compress2 = MyCompress::new(perm2.clone());\n    let val_mmcs2 = ValMmcs::new(hash2, compress2, 0);\n    let challenge_mmcs2 = ChallengeMmcs::new(val_mmcs2.clone());\n    let fri_params2 = create_test_fri_params(challenge_mmcs2, 0);\n    let fri_verifier_params = FriVerifierParams::from(\u0026fri_params2);\n    let pow_bits = fri_params2.query_proof_of_work_bits;\n    let log_height_max = fri_params2.log_final_poly_len + fri_params2.log_blowup;\n    let pcs_verif = MyPcs::new(dft2, val_mmcs2, fri_params2);\n    let challenger_verif = Challenger::new(perm2);\n    (\n        MyConfig::new(pcs_verif, challenger_verif),\n        fri_verifier_params,\n        pow_bits,\n        log_height_max,\n    )\n}\n\ntype ResultVerifierInputsAndChallenges = (\n    Result\u003c\n        BatchStarkVerifierInputsBuilder\u003cMyConfig, MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e, InnerFri\u003e,\n        VerificationError,\n    \u003e,\n    Result\u003cVec\u003cChallenge\u003e, GenerationError\u003e,\n);\n\nstruct Parameters {\n    fri_verifier_params: FriVerifierParams,\n    pow_bits: usize,\n    log_height_max: usize,\n}\n\n// Gets the verifier inputs and generates all necessary challenges for the recursive verification circuit.\n#[allow(clippy::too_many_arguments)]\nfn get_verifier_inputs_and_challenges(\n    circuit_builder: \u0026mut CircuitBuilder\u003cChallenge\u003e,\n    config: \u0026MyConfig,\n    params: \u0026Parameters,\n    batch_stark_proof: \u0026mut BatchStarkProof\u003cMyConfig\u003e,\n    common: \u0026CommonData\u003cMyConfig\u003e,\n    pis: \u0026[Vec\u003cF\u003e],\n    optional_global_lookups: Option\u003c\u0026[Vec\u003cLookupData\u003cChallenge\u003e\u003e]\u003e,\n    lookup_gadget: \u0026LogUpGadget,\n) -\u003e ResultVerifierInputsAndChallenges {\n    // Extract proof components\n    let rows = batch_stark_proof.rows;\n    let packing = batch_stark_proof.table_packing;\n\n    // Base field AIRs for native challenge generation\n    let native_airs = vec![\n        CircuitTablesAir::Witness(WitnessAir::\u003cF, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Witness],\n            packing.witness_lanes(),\n        )),\n        CircuitTablesAir::Const(ConstAir::\u003cF, TRACE_D\u003e::new(rows[PrimitiveTable::Const])),\n        CircuitTablesAir::Public(PublicAir::\u003cF, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Public],\n            packing.public_lanes(),\n        )),\n        CircuitTablesAir::Alu(AluAir::\u003cF, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Alu],\n            packing.alu_lanes(),\n        )),\n    ];\n\n    // Attach verifier without manually building circuit_airs\n    let verifier_inputs = verify_p3_batch_proof_circuit::\u003c\n        MyConfig,\n        MerkleCapTargets\u003cF, DIGEST_ELEMS\u003e,\n        InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n        InnerFri,\n        LogUpGadget,\n        WIDTH,\n        RATE,\n        TRACE_D,\n    \u003e(\n        config,\n        circuit_builder,\n        batch_stark_proof,\n        \u0026params.fri_verifier_params,\n        common,\n        lookup_gadget,\n        Poseidon2Config::BabyBearD4Width16,\n    )\n    .map(|(inputs, _mmcs_op_ids)| inputs);\n\n    // If provided, override the global lookups in the proof used for challenge generation\n    if let Some(global_lookups) = optional_global_lookups {\n        batch_stark_proof.proof.global_lookup_data = global_lookups.to_vec();\n    }\n\n    let batch_proof = \u0026batch_stark_proof.proof;\n\n    // Generate all the challenge values for batch proof (uses base field AIRs)\n    let all_challenges = generate_batch_challenges(\n        \u0026native_airs,\n        config,\n        batch_proof,\n        pis,\n        Some(\u0026[params.pow_bits, params.log_height_max]),\n        common,\n        lookup_gadget,\n    );\n\n    (verifier_inputs, all_challenges)\n}\n\n// Creates a circuit builder and builds a circuit that computes the following function:\n// - y = a * x + b\n// - repeated n times:\n//   for i in 0..n {\n//     y = a * y + b\n//   }\nfn get_circuit(n: usize) -\u003e CircuitBuilder\u003cF\u003e {\n    let mut builder = CircuitBuilder::\u003cF\u003e::new();\n\n    let x = builder.public_input();\n    let a = builder.public_input();\n    let b = builder.public_input();\n    let expected_result = builder.public_input();\n\n    // y = a * x + b\n    let mut y = builder.mul(a, x);\n    y = builder.add(b, y);\n    for _i in 0..n {\n        y = builder.mul(a, y);\n        y = builder.add(b, y);\n    }\n\n    builder.connect(y, expected_result);\n\n    builder\n}\n\n/// Test Poseidon2 with input/output CTL lookups enabled.\n/// This is a minimal test to verify that CTL lookups work correctly\n/// with Poseidon2 operations, similar to how MMCS uses them.\n#[test]\nfn test_poseidon2_ctl_lookups() {\n    let mut builder: CircuitBuilder\u003cChallenge\u003e = CircuitBuilder::new();\n    let poseidon2_perm = default_babybear_poseidon2_16();\n    let poseidon2_config = Poseidon2Config::BabyBearD4Width16;\n    builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cChallenge, BabyBearD4Width16\u003e,\n        poseidon2_perm,\n    );\n\n    // Create public inputs that will also serve as witnesses for the Poseidon2 inputs\n    let input0 = builder.public_input();\n    let input1 = builder.public_input();\n\n    // Create a Poseidon2 operation with input CTL enabled for limbs 0 and 1\n    let (_op_id, outputs) = builder\n        .add_poseidon2_perm(Poseidon2PermCall {\n            config: poseidon2_config,\n            new_start: true,\n            merkle_path: false,\n            mmcs_bit: None,\n            inputs: [Some(input0), Some(input1), None, None],\n            out_ctl: [true, true], // Enable output CTL\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })\n        .unwrap();\n\n    // The outputs should be witnesses that can be used\n    let output0 = outputs[0].unwrap();\n    let output1 = outputs[1].unwrap();\n\n    // Create another Poseidon2 operation that uses these outputs as inputs\n    let (_op_id2, _) = builder\n        .add_poseidon2_perm(Poseidon2PermCall {\n            config: poseidon2_config,\n            new_start: true,\n            merkle_path: false,\n            mmcs_bit: None,\n            inputs: [Some(output0), Some(output1), None, None],\n            out_ctl: [false, false],\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })\n        .unwrap();\n\n    let table_packing = TablePacking::new(1, 1, 4);\n    let config_proving = get_proving_config();\n\n    let circuit = builder.build().unwrap();\n\n    let (airs_degrees, preprocessed_columns) = get_airs_and_degrees_with_prep::\u003cMyConfig, _, 4\u003e(\n        \u0026circuit,\n        table_packing,\n        Some(\u0026[NonPrimitiveConfig::Poseidon2(poseidon2_config)]),\n        ConstraintProfile::Standard,\n    )\n    .unwrap();\n\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    // Set the public inputs\n    let input_val0 = Challenge::from_u32(12345);\n    let input_val1 = Challenge::from_u32(67890);\n    runner.set_public_inputs(\u0026[input_val0, input_val1]).unwrap();\n\n    let traces = runner.run().unwrap();\n\n    let prover_data = ProverData::from_airs_and_degrees(\u0026config_proving, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    let common = circuit_prover_data.common_data();\n\n    let mut prover = BatchStarkProver::new(config_proving).with_table_packing(table_packing);\n    prover.register_poseidon2_table(poseidon2_config);\n\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n\n    prover\n        .verify_all_tables(\u0026proof, common)\n        .expect(\"Poseidon2 CTL lookup verification should succeed\");\n}\n\n/// Test Poseidon2 with chained operations and CTL lookups.\n/// This tests a chain of Poseidon2 operations where:\n/// - First operation: CTL inputs from witness\n/// - Middle operation: chained from previous (no explicit inputs)\n/// - Last operation: CTL outputs to witness\n#[test]\nfn test_poseidon2_chained_ctl_lookups() {\n    use p3_circuit::Poseidon2PermOps;\n    use p3_circuit::ops::Poseidon2PermCall;\n    use p3_poseidon2_circuit_air::BabyBearD4Width16;\n\n    let mut builder: CircuitBuilder\u003cChallenge\u003e = CircuitBuilder::new();\n    let poseidon2_perm = default_babybear_poseidon2_16();\n    let poseidon2_config = Poseidon2Config::BabyBearD4Width16;\n    builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cChallenge, BabyBearD4Width16\u003e,\n        poseidon2_perm,\n    );\n\n    // Create public inputs for the first operation's inputs\n    let input0 = builder.public_input();\n    let input1 = builder.public_input();\n\n    // First Poseidon2 operation: new_start=true, inputs from witness\n    let (_op_id, _outputs) = builder\n        .add_poseidon2_perm(Poseidon2PermCall {\n            config: poseidon2_config,\n            new_start: true,\n            merkle_path: false, // Sponge mode\n            mmcs_bit: None,\n            inputs: [Some(input0), Some(input1), None, None],\n            out_ctl: [false, false], // Not exposing outputs yet\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })\n        .unwrap();\n\n    // Second Poseidon2 operation: new_start=false, chained from first\n    let (_op_id2, _outputs2) = builder\n        .add_poseidon2_perm(Poseidon2PermCall {\n            config: poseidon2_config,\n            new_start: false, // Chained\n            merkle_path: false,\n            mmcs_bit: None,\n            inputs: [None, None, None, None], // Chained from previous output\n            out_ctl: [false, false],\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })\n        .unwrap();\n\n    // Third Poseidon2 operation: new_start=false, chained, with output CTL\n    let (_op_id3, outputs3) = builder\n        .add_poseidon2_perm(Poseidon2PermCall {\n            config: poseidon2_config,\n            new_start: false,\n            merkle_path: false,\n            mmcs_bit: None,\n            inputs: [None, None, None, None],\n            out_ctl: [true, true], // Expose outputs via CTL\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })\n        .unwrap();\n\n    // Fourth operation: new_start=true to signal end of previous chain\n    // This operation uses the exposed outputs from op3 as inputs\n    let (_op_id4, _) = builder\n        .add_poseidon2_perm(Poseidon2PermCall {\n            config: poseidon2_config,\n            new_start: true,\n            merkle_path: false,\n            mmcs_bit: None,\n            inputs: [outputs3[0], outputs3[1], None, None],\n            out_ctl: [false, false],\n            return_all_outputs: false,\n            mmcs_index_sum: None,\n        })\n        .unwrap();\n\n    let table_packing = TablePacking::new(1, 1, 4);\n    let config_proving = get_proving_config();\n\n    let circuit = builder.build().unwrap();\n\n    let (airs_degrees, preprocessed_columns) = get_airs_and_degrees_with_prep::\u003cMyConfig, _, 4\u003e(\n        \u0026circuit,\n        table_packing,\n        Some(\u0026[NonPrimitiveConfig::Poseidon2(poseidon2_config)]),\n        ConstraintProfile::Standard,\n    )\n    .unwrap();\n\n    let (mut airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    // Set the public inputs\n    let input_val0 = Challenge::from_u32(111);\n    let input_val1 = Challenge::from_u32(222);\n    runner.set_public_inputs(\u0026[input_val0, input_val1]).unwrap();\n\n    let traces = runner.run().unwrap();\n\n    let prover_data = ProverData::from_airs_and_degrees(\u0026config_proving, \u0026mut airs, \u0026degrees);\n    let circuit_prover_data = CircuitProverData::new(prover_data, preprocessed_columns);\n\n    let common = circuit_prover_data.common_data();\n\n    let mut prover = BatchStarkProver::new(config_proving).with_table_packing(table_packing);\n    prover.register_poseidon2_table(poseidon2_config);\n\n    let proof = prover\n        .prove_all_tables(\u0026traces, \u0026circuit_prover_data)\n        .unwrap();\n\n    prover\n        .verify_all_tables(\u0026proof, common)\n        .expect(\"Chained Poseidon2 CTL lookup verification should succeed\");\n}\n","traces":[{"line":1,"address":[6496128],"length":1,"stats":{"Line":1}},{"line":28,"address":[6462821,6462815,6462592],"length":1,"stats":{"Line":1}},{"line":29,"address":[6462614],"length":1,"stats":{"Line":1}},{"line":30,"address":[6462619],"length":1,"stats":{"Line":1}},{"line":31,"address":[6462675],"length":1,"stats":{"Line":2}},{"line":35,"address":[6462787],"length":1,"stats":{"Line":1}},{"line":36,"address":[6462643,6462807],"length":1,"stats":{"Line":2}},{"line":39,"address":[6458800],"length":1,"stats":{"Line":2}},{"line":40,"address":[6458845,6458936],"length":1,"stats":{"Line":2}},{"line":41,"address":[6458914,6459078,6458949],"length":1,"stats":{"Line":6}},{"line":42,"address":[6458999,6459039,6459083],"length":1,"stats":{"Line":4}},{"line":44,"address":[6459016],"length":1,"stats":{"Line":2}},{"line":45,"address":[6459021],"length":1,"stats":{"Line":2}},{"line":48,"address":[6462544,6460448,6462530,6462562,6462470],"length":1,"stats":{"Line":3}},{"line":50,"address":[6460574],"length":1,"stats":{"Line":1}},{"line":51,"address":[6460584],"length":1,"stats":{"Line":1}},{"line":53,"address":[6460623],"length":1,"stats":{"Line":1}},{"line":54,"address":[6460654],"length":1,"stats":{"Line":1}},{"line":55,"address":[6460718],"length":1,"stats":{"Line":1}},{"line":56,"address":[6460750],"length":1,"stats":{"Line":1}},{"line":57,"address":[6460485],"length":1,"stats":{"Line":1}},{"line":58,"address":[6460844,6460781],"length":1,"stats":{"Line":2}},{"line":61,"address":[6460876],"length":1,"stats":{"Line":1}},{"line":62,"address":[6460883],"length":1,"stats":{"Line":1}},{"line":65,"address":[6460913],"length":1,"stats":{"Line":1}},{"line":67,"address":[6461024,6460920],"length":1,"stats":{"Line":2}},{"line":73,"address":[6460936],"length":1,"stats":{"Line":1}},{"line":79,"address":[6461283,6461181],"length":1,"stats":{"Line":2}},{"line":80,"address":[6461321],"length":1,"stats":{"Line":1}},{"line":83,"address":[6461345],"length":1,"stats":{"Line":1}},{"line":84,"address":[6461353],"length":1,"stats":{"Line":1}},{"line":85,"address":[6461401],"length":1,"stats":{"Line":1}},{"line":86,"address":[6461472],"length":1,"stats":{"Line":1}},{"line":88,"address":[6461638],"length":1,"stats":{"Line":1}},{"line":89,"address":[6461767,6461853],"length":1,"stats":{"Line":1}},{"line":92,"address":[6461790,6461883],"length":1,"stats":{"Line":2}},{"line":93,"address":[6461983,6461899],"length":1,"stats":{"Line":2}},{"line":94,"address":[6462012],"length":1,"stats":{"Line":1}},{"line":95,"address":[6461423,6461251,6462581,6460959,6462166,6462113,6461916,6462484,6461598,6460804],"length":1,"stats":{"Line":2}},{"line":99,"address":[6472386,6468016,6472331,6472169,6472368],"length":1,"stats":{"Line":4}},{"line":100,"address":[6468068],"length":1,"stats":{"Line":1}},{"line":103,"address":[6468160],"length":1,"stats":{"Line":1}},{"line":105,"address":[6468186],"length":1,"stats":{"Line":1}},{"line":107,"address":[6468267],"length":1,"stats":{"Line":1}},{"line":109,"address":[6468392,6468274],"length":1,"stats":{"Line":2}},{"line":110,"address":[6468570],"length":1,"stats":{"Line":1}},{"line":111,"address":[6468430],"length":1,"stats":{"Line":1}},{"line":117,"address":[6468540],"length":1,"stats":{"Line":1}},{"line":120,"address":[6468664,6468873],"length":1,"stats":{"Line":2}},{"line":121,"address":[6468782],"length":1,"stats":{"Line":1}},{"line":122,"address":[6468880],"length":1,"stats":{"Line":1}},{"line":123,"address":[6469143,6469030],"length":1,"stats":{"Line":2}},{"line":125,"address":[6469151],"length":1,"stats":{"Line":1}},{"line":126,"address":[6469163],"length":1,"stats":{"Line":1}},{"line":127,"address":[6469175],"length":1,"stats":{"Line":1}},{"line":128,"address":[6469207,6469271],"length":1,"stats":{"Line":2}},{"line":131,"address":[6469384],"length":1,"stats":{"Line":1}},{"line":132,"address":[6469304],"length":1,"stats":{"Line":1}},{"line":133,"address":[6469323],"length":1,"stats":{"Line":1}},{"line":134,"address":[6469342],"length":1,"stats":{"Line":1}},{"line":137,"address":[6469448],"length":1,"stats":{"Line":1}},{"line":139,"address":[6469470],"length":1,"stats":{"Line":1}},{"line":142,"address":[6469577,6469680],"length":1,"stats":{"Line":2}},{"line":143,"address":[6469758],"length":1,"stats":{"Line":1}},{"line":145,"address":[6470008,6469899],"length":1,"stats":{"Line":2}},{"line":148,"address":[6470071],"length":1,"stats":{"Line":1}},{"line":150,"address":[6470154],"length":1,"stats":{"Line":1}},{"line":151,"address":[6470161],"length":1,"stats":{"Line":0}},{"line":152,"address":[6470262,6470199],"length":1,"stats":{"Line":0}},{"line":155,"address":[6470278],"length":1,"stats":{"Line":0}},{"line":158,"address":[6470419],"length":1,"stats":{"Line":0}},{"line":161,"address":[6470552,6470466],"length":1,"stats":{"Line":0}},{"line":164,"address":[6470575],"length":1,"stats":{"Line":0}},{"line":169,"address":[6470734],"length":1,"stats":{"Line":0}},{"line":175,"address":[6470647],"length":1,"stats":{"Line":0}},{"line":181,"address":[6470891,6470987],"length":1,"stats":{"Line":0}},{"line":182,"address":[6471025],"length":1,"stats":{"Line":0}},{"line":185,"address":[6471049],"length":1,"stats":{"Line":0}},{"line":186,"address":[6471057],"length":1,"stats":{"Line":0}},{"line":187,"address":[6471105],"length":1,"stats":{"Line":0}},{"line":188,"address":[6471176],"length":1,"stats":{"Line":0}},{"line":190,"address":[6471342],"length":1,"stats":{"Line":0}},{"line":191,"address":[6471474,6471558],"length":1,"stats":{"Line":0}},{"line":194,"address":[6471591,6471495],"length":1,"stats":{"Line":0}},{"line":195,"address":[6471607,6471691],"length":1,"stats":{"Line":0}},{"line":199,"address":[6471720],"length":1,"stats":{"Line":0}},{"line":200,"address":[6468739,6471302,6470493,6471821,6472183,6472352,6472405,6469099,6471874,6470678,6468218,6471624,6470955,6470434,6471127,6470090,6468351,6469222,6468499,6470222,6469976,6469608],"length":1,"stats":{"Line":9}},{"line":204,"address":[6482256,6484298,6484358,6484384,6484402],"length":1,"stats":{"Line":4}},{"line":206,"address":[6482382],"length":1,"stats":{"Line":1}},{"line":207,"address":[6482392],"length":1,"stats":{"Line":1}},{"line":209,"address":[6482423],"length":1,"stats":{"Line":1}},{"line":210,"address":[6482446],"length":1,"stats":{"Line":1}},{"line":211,"address":[6482510],"length":1,"stats":{"Line":1}},{"line":213,"address":[6482293,6482542],"length":1,"stats":{"Line":2}},{"line":214,"address":[6482605],"length":1,"stats":{"Line":1}},{"line":219,"address":[6482636],"length":1,"stats":{"Line":1}},{"line":221,"address":[6482728],"length":1,"stats":{"Line":1}},{"line":224,"address":[6482803],"length":1,"stats":{"Line":1}},{"line":226,"address":[6482812,6482916],"length":1,"stats":{"Line":2}},{"line":232,"address":[6482828],"length":1,"stats":{"Line":1}},{"line":238,"address":[6483073,6483175],"length":1,"stats":{"Line":2}},{"line":239,"address":[6483213],"length":1,"stats":{"Line":1}},{"line":243,"address":[6483229],"length":1,"stats":{"Line":1}},{"line":244,"address":[6483277],"length":1,"stats":{"Line":1}},{"line":245,"address":[6483348],"length":1,"stats":{"Line":1}},{"line":247,"address":[6483514],"length":1,"stats":{"Line":1}},{"line":248,"address":[6483730,6483646],"length":1,"stats":{"Line":1}},{"line":251,"address":[6483763,6483667],"length":1,"stats":{"Line":2}},{"line":252,"address":[6483863,6483779],"length":1,"stats":{"Line":2}},{"line":257,"address":[6483892],"length":1,"stats":{"Line":1}},{"line":258,"address":[6484046,6484312,6482851,6483143,6483299,6483796,6483474,6482565,6483993,6484421],"length":1,"stats":{"Line":7}},{"line":262,"address":[6482208,6482226,6482046,6478640,6482183],"length":1,"stats":{"Line":4}},{"line":264,"address":[6478782],"length":1,"stats":{"Line":1}},{"line":265,"address":[6478792],"length":1,"stats":{"Line":1}},{"line":267,"address":[6478823],"length":1,"stats":{"Line":1}},{"line":268,"address":[6478846],"length":1,"stats":{"Line":1}},{"line":269,"address":[6478910],"length":1,"stats":{"Line":1}},{"line":271,"address":[6478677,6478942],"length":1,"stats":{"Line":2}},{"line":272,"address":[6479005],"length":1,"stats":{"Line":1}},{"line":274,"address":[6479036],"length":1,"stats":{"Line":1}},{"line":276,"address":[6479067,6479130],"length":1,"stats":{"Line":2}},{"line":277,"address":[6479182],"length":1,"stats":{"Line":1}},{"line":278,"address":[6479267,6479309,6482143,6479199,6479408],"length":1,"stats":{"Line":2}},{"line":281,"address":[6479533],"length":1,"stats":{"Line":1}},{"line":285,"address":[6479714],"length":1,"stats":{"Line":1}},{"line":291,"address":[6479548],"length":1,"stats":{"Line":1}},{"line":292,"address":[6479651],"length":1,"stats":{"Line":1}},{"line":296,"address":[6479881],"length":1,"stats":{"Line":1}},{"line":297,"address":[6480023],"length":1,"stats":{"Line":1}},{"line":298,"address":[6480063,6480149],"length":1,"stats":{"Line":2}},{"line":300,"address":[6480104,6482122],"length":1,"stats":{"Line":0}},{"line":301,"address":[6479911,6480002],"length":1,"stats":{"Line":0}},{"line":307,"address":[6480254,6480199],"length":1,"stats":{"Line":1}},{"line":309,"address":[6480369],"length":1,"stats":{"Line":1}},{"line":310,"address":[6480376,6480559],"length":1,"stats":{"Line":2}},{"line":316,"address":[6480392],"length":1,"stats":{"Line":1}},{"line":317,"address":[6480496],"length":1,"stats":{"Line":1}},{"line":322,"address":[6480812,6480716],"length":1,"stats":{"Line":2}},{"line":323,"address":[6480850],"length":1,"stats":{"Line":1}},{"line":327,"address":[6480866],"length":1,"stats":{"Line":1}},{"line":328,"address":[6480914],"length":1,"stats":{"Line":1}},{"line":329,"address":[6480985],"length":1,"stats":{"Line":1}},{"line":331,"address":[6481151],"length":1,"stats":{"Line":1}},{"line":332,"address":[6481283,6481367],"length":1,"stats":{"Line":1}},{"line":335,"address":[6481304,6481400],"length":1,"stats":{"Line":2}},{"line":336,"address":[6481416,6481500],"length":1,"stats":{"Line":2}},{"line":341,"address":[6481529],"length":1,"stats":{"Line":1}},{"line":342,"address":[6480936,6481433,6479579,6482173,6482245,6478965,6481630,6481111,6479954,6480780,6481683,6480415,6479090,6482060,6479226],"length":1,"stats":{"Line":11}},{"line":345,"address":[6496080,6496055,6494144,6496098,6495874],"length":1,"stats":{"Line":3}},{"line":347,"address":[6494227],"length":1,"stats":{"Line":1}},{"line":348,"address":[6494234],"length":1,"stats":{"Line":1}},{"line":350,"address":[6494262],"length":1,"stats":{"Line":1}},{"line":351,"address":[6494285],"length":1,"stats":{"Line":1}},{"line":352,"address":[6494349],"length":1,"stats":{"Line":1}},{"line":354,"address":[6494166,6494381],"length":1,"stats":{"Line":2}},{"line":355,"address":[6494444],"length":1,"stats":{"Line":1}},{"line":357,"address":[6494469],"length":1,"stats":{"Line":1}},{"line":358,"address":[6494507,6494492],"length":1,"stats":{"Line":1}},{"line":359,"address":[6494624,6494647],"length":1,"stats":{"Line":1}},{"line":362,"address":[6494762],"length":1,"stats":{"Line":1}},{"line":364,"address":[6494849],"length":1,"stats":{"Line":1}},{"line":370,"address":[6494777],"length":1,"stats":{"Line":1}},{"line":375,"address":[6495029],"length":1,"stats":{"Line":1}},{"line":376,"address":[6495222],"length":1,"stats":{"Line":1}},{"line":377,"address":[6495270,6495384],"length":1,"stats":{"Line":2}},{"line":378,"address":[6495434,6495336],"length":1,"stats":{"Line":1}},{"line":379,"address":[6495890,6495304],"length":1,"stats":{"Line":0}},{"line":380,"address":[6495123,6495202],"length":1,"stats":{"Line":0}},{"line":382,"address":[6494404,6495160,6496117,6494802,6495911,6495468,6495461],"length":1,"stats":{"Line":2}},{"line":386,"address":[6494013,6494114,6491968,6494096,6494068],"length":1,"stats":{"Line":4}},{"line":388,"address":[6492055],"length":1,"stats":{"Line":1}},{"line":389,"address":[6492065],"length":1,"stats":{"Line":1}},{"line":391,"address":[6492096],"length":1,"stats":{"Line":1}},{"line":392,"address":[6492119],"length":1,"stats":{"Line":1}},{"line":393,"address":[6492183],"length":1,"stats":{"Line":1}},{"line":395,"address":[6491990,6492215],"length":1,"stats":{"Line":2}},{"line":396,"address":[6492278],"length":1,"stats":{"Line":1}},{"line":398,"address":[6492309],"length":1,"stats":{"Line":1}},{"line":399,"address":[6492395,6492348],"length":1,"stats":{"Line":2}},{"line":400,"address":[6492403,6492484],"length":1,"stats":{"Line":2}},{"line":401,"address":[6492543],"length":1,"stats":{"Line":1}},{"line":404,"address":[6492658],"length":1,"stats":{"Line":1}},{"line":407,"address":[6492839],"length":1,"stats":{"Line":1}},{"line":413,"address":[6492673],"length":1,"stats":{"Line":1}},{"line":414,"address":[6492776],"length":1,"stats":{"Line":1}},{"line":418,"address":[6493006],"length":1,"stats":{"Line":0}},{"line":419,"address":[6493142],"length":1,"stats":{"Line":0}},{"line":420,"address":[6493256,6493182],"length":1,"stats":{"Line":0}},{"line":422,"address":[6493220,6494029],"length":1,"stats":{"Line":0}},{"line":423,"address":[6493121,6493036],"length":1,"stats":{"Line":0}},{"line":427,"address":[6493361,6493306],"length":1,"stats":{"Line":0}},{"line":429,"address":[6493476],"length":1,"stats":{"Line":0}},{"line":430,"address":[6493621],"length":1,"stats":{"Line":0}},{"line":436,"address":[6493491],"length":1,"stats":{"Line":0}},{"line":437,"address":[6493576],"length":1,"stats":{"Line":0}},{"line":439,"address":[6493706],"length":1,"stats":{"Line":0}},{"line":440,"address":[6492704,6494133,6492363,6492238,6493721,6492438,6493076,6494058,6493516],"length":1,"stats":{"Line":5}},{"line":444,"address":[6465776,6467986,6467968,6467871,6467944],"length":1,"stats":{"Line":4}},{"line":446,"address":[6465871],"length":1,"stats":{"Line":1}},{"line":447,"address":[6465881],"length":1,"stats":{"Line":1}},{"line":449,"address":[6465912],"length":1,"stats":{"Line":1}},{"line":450,"address":[6465935],"length":1,"stats":{"Line":1}},{"line":451,"address":[6465999],"length":1,"stats":{"Line":1}},{"line":453,"address":[6465798,6466031],"length":1,"stats":{"Line":2}},{"line":454,"address":[6466094],"length":1,"stats":{"Line":1}},{"line":456,"address":[6466125],"length":1,"stats":{"Line":1}},{"line":457,"address":[6466215],"length":1,"stats":{"Line":1}},{"line":458,"address":[6466148],"length":1,"stats":{"Line":1}},{"line":462,"address":[6466294,6466342],"length":1,"stats":{"Line":2}},{"line":463,"address":[6466350,6466430],"length":1,"stats":{"Line":2}},{"line":466,"address":[6466509],"length":1,"stats":{"Line":1}},{"line":469,"address":[6466690],"length":1,"stats":{"Line":1}},{"line":475,"address":[6466524],"length":1,"stats":{"Line":1}},{"line":476,"address":[6466627],"length":1,"stats":{"Line":1}},{"line":480,"address":[6466857],"length":1,"stats":{"Line":1}},{"line":481,"address":[6466992],"length":1,"stats":{"Line":1}},{"line":482,"address":[6467032,6467106],"length":1,"stats":{"Line":2}},{"line":484,"address":[6467887,6467070],"length":1,"stats":{"Line":0}},{"line":485,"address":[6466887,6466972],"length":1,"stats":{"Line":0}},{"line":489,"address":[6467156,6467211],"length":1,"stats":{"Line":1}},{"line":491,"address":[6467326],"length":1,"stats":{"Line":1}},{"line":492,"address":[6467471],"length":1,"stats":{"Line":1}},{"line":498,"address":[6467341],"length":1,"stats":{"Line":1}},{"line":499,"address":[6467426],"length":1,"stats":{"Line":1}},{"line":501,"address":[6467556],"length":1,"stats":{"Line":0}},{"line":502,"address":[6466555,6467366,6466927,6468005,6466301,6467571,6466183,6466384,6466054,6467916],"length":1,"stats":{"Line":7}},{"line":506,"address":[6475490,6475446,6475472,6475210,6472416],"length":1,"stats":{"Line":4}},{"line":508,"address":[6472519],"length":1,"stats":{"Line":1}},{"line":509,"address":[6472529],"length":1,"stats":{"Line":1}},{"line":511,"address":[6472560],"length":1,"stats":{"Line":1}},{"line":512,"address":[6472583],"length":1,"stats":{"Line":1}},{"line":513,"address":[6472647],"length":1,"stats":{"Line":1}},{"line":515,"address":[6472438,6472679],"length":1,"stats":{"Line":2}},{"line":516,"address":[6472742],"length":1,"stats":{"Line":1}},{"line":518,"address":[6472773],"length":1,"stats":{"Line":1}},{"line":519,"address":[6472859,6472812],"length":1,"stats":{"Line":2}},{"line":520,"address":[6472867,6472947,6473008],"length":1,"stats":{"Line":2}},{"line":521,"address":[6472974,6473057],"length":1,"stats":{"Line":2}},{"line":524,"address":[6473087],"length":1,"stats":{"Line":1}},{"line":527,"address":[6473268],"length":1,"stats":{"Line":1}},{"line":533,"address":[6473102],"length":1,"stats":{"Line":1}},{"line":534,"address":[6473205],"length":1,"stats":{"Line":1}},{"line":538,"address":[6473435],"length":1,"stats":{"Line":1}},{"line":539,"address":[6473576],"length":1,"stats":{"Line":1}},{"line":540,"address":[6473616,6473702],"length":1,"stats":{"Line":2}},{"line":542,"address":[6475407,6473657],"length":1,"stats":{"Line":0}},{"line":543,"address":[6473556,6473465],"length":1,"stats":{"Line":0}},{"line":547,"address":[6473807,6473752],"length":1,"stats":{"Line":1}},{"line":549,"address":[6473922],"length":1,"stats":{"Line":1}},{"line":550,"address":[6474067],"length":1,"stats":{"Line":1}},{"line":556,"address":[6473937],"length":1,"stats":{"Line":1}},{"line":557,"address":[6474022],"length":1,"stats":{"Line":1}},{"line":561,"address":[6474250],"length":1,"stats":{"Line":0}},{"line":562,"address":[6474444],"length":1,"stats":{"Line":0}},{"line":563,"address":[6474492,6474606],"length":1,"stats":{"Line":0}},{"line":564,"address":[6474656,6474558],"length":1,"stats":{"Line":0}},{"line":565,"address":[6474526,6475226],"length":1,"stats":{"Line":0}},{"line":566,"address":[6474344,6474423],"length":1,"stats":{"Line":0}},{"line":568,"address":[6475509,6475436,6472901,6473133,6474690,6473962,6473508,6474381,6472827,6472702,6474683,6475247],"length":1,"stats":{"Line":6}},{"line":580,"address":[6462848,6465635,6465743],"length":1,"stats":{"Line":4}},{"line":581,"address":[6462901],"length":1,"stats":{"Line":4}},{"line":584,"address":[6462961],"length":1,"stats":{"Line":4}},{"line":586,"address":[6462987],"length":1,"stats":{"Line":2}},{"line":588,"address":[6463068],"length":1,"stats":{"Line":3}},{"line":590,"address":[6463075,6463193],"length":1,"stats":{"Line":4}},{"line":591,"address":[6463231,6463371],"length":1,"stats":{"Line":5}},{"line":597,"address":[6463341],"length":1,"stats":{"Line":2}},{"line":599,"address":[6463603,6463483],"length":1,"stats":{"Line":4}},{"line":600,"address":[6463787,6463674],"length":1,"stats":{"Line":4}},{"line":602,"address":[6463795],"length":1,"stats":{"Line":2}},{"line":603,"address":[6463807],"length":1,"stats":{"Line":2}},{"line":604,"address":[6463819],"length":1,"stats":{"Line":2}},{"line":605,"address":[6463851,6463915],"length":1,"stats":{"Line":4}},{"line":608,"address":[6464028],"length":1,"stats":{"Line":2}},{"line":609,"address":[6463948],"length":1,"stats":{"Line":2}},{"line":610,"address":[6463967],"length":1,"stats":{"Line":2}},{"line":611,"address":[6463986],"length":1,"stats":{"Line":2}},{"line":614,"address":[6464092],"length":1,"stats":{"Line":2}},{"line":616,"address":[6464114],"length":1,"stats":{"Line":2}},{"line":619,"address":[6464221,6464318],"length":1,"stats":{"Line":4}},{"line":620,"address":[6464378],"length":1,"stats":{"Line":2}},{"line":622,"address":[6464513],"length":1,"stats":{"Line":2}},{"line":623,"address":[6464564],"length":1,"stats":{"Line":2}},{"line":625,"address":[6464722],"length":1,"stats":{"Line":2}},{"line":626,"address":[6464769],"length":1,"stats":{"Line":2}},{"line":628,"address":[6464807,6464879],"length":1,"stats":{"Line":3}},{"line":629,"address":[6464961],"length":1,"stats":{"Line":3}},{"line":634,"address":[6465025,6465105],"length":1,"stats":{"Line":4}},{"line":636,"address":[6465294],"length":1,"stats":{"Line":1}},{"line":637,"address":[6465155],"length":1,"stats":{"Line":1}},{"line":638,"address":[6465193],"length":1,"stats":{"Line":3}},{"line":640,"address":[6465231],"length":1,"stats":{"Line":1}},{"line":643,"address":[6465269],"length":1,"stats":{"Line":3}},{"line":645,"address":[6463152,6463019,6463866,6464532,6463743,6465052,6465490,6463300,6465649,6465764,6464737,6464252,6464822,6463546],"length":1,"stats":{"Line":3}},{"line":649,"address":[6460419,6459104,6460341],"length":1,"stats":{"Line":1}},{"line":650,"address":[6459121],"length":1,"stats":{"Line":3}},{"line":651,"address":[6459201,6459277],"length":1,"stats":{"Line":4}},{"line":652,"address":[6459354,6459292],"length":1,"stats":{"Line":3}},{"line":653,"address":[6459381],"length":1,"stats":{"Line":1}},{"line":654,"address":[6459608,6459672],"length":1,"stats":{"Line":4}},{"line":655,"address":[6459695],"length":1,"stats":{"Line":3}},{"line":657,"address":[6459740],"length":1,"stats":{"Line":1}},{"line":659,"address":[6459856],"length":1,"stats":{"Line":3}},{"line":660,"address":[6460018],"length":1,"stats":{"Line":1}},{"line":661,"address":[6460161],"length":1,"stats":{"Line":3}},{"line":662,"address":[6459316,6459815,6460355,6459702,6460120,6459220,6460267,6460432,6459615],"length":1,"stats":{"Line":1}},{"line":666,"address":[6484432,6485935,6485856],"length":1,"stats":{"Line":2}},{"line":667,"address":[6484449],"length":1,"stats":{"Line":2}},{"line":668,"address":[6484515],"length":1,"stats":{"Line":2}},{"line":669,"address":[6484572,6484658],"length":1,"stats":{"Line":4}},{"line":670,"address":[6484735,6484673],"length":1,"stats":{"Line":4}},{"line":671,"address":[6484762],"length":1,"stats":{"Line":2}},{"line":672,"address":[6484989,6485053],"length":1,"stats":{"Line":4}},{"line":673,"address":[6485093],"length":1,"stats":{"Line":2}},{"line":674,"address":[6485143],"length":1,"stats":{"Line":1}},{"line":675,"address":[6485191],"length":1,"stats":{"Line":1}},{"line":676,"address":[6485212,6485414],"length":1,"stats":{"Line":3}},{"line":677,"address":[6485258,6485434],"length":1,"stats":{"Line":4}},{"line":678,"address":[6485442],"length":1,"stats":{"Line":1}},{"line":679,"address":[6485700],"length":1,"stats":{"Line":1}},{"line":680,"address":[6485591],"length":1,"stats":{"Line":3}},{"line":685,"address":[6484697,6484531,6484996,6485150,6484604,6485782,6485870,6485550,6485953],"length":1,"stats":{"Line":3}},{"line":703,"address":[6488248,6488242,6485968],"length":1,"stats":{"Line":2}},{"line":714,"address":[6486201],"length":1,"stats":{"Line":1}},{"line":715,"address":[6486233],"length":1,"stats":{"Line":2}},{"line":718,"address":[6486593,6487162,6486332,6487559,6486275,6487010,6488261,6486758],"length":1,"stats":{"Line":2}},{"line":719,"address":[6486460],"length":1,"stats":{"Line":1}},{"line":720,"address":[6486288,6486372],"length":1,"stats":{"Line":3}},{"line":721,"address":[6486380],"length":1,"stats":{"Line":2}},{"line":723,"address":[6486630,6486549],"length":1,"stats":{"Line":3}},{"line":724,"address":[6486877],"length":1,"stats":{"Line":1}},{"line":725,"address":[6486714,6486795],"length":1,"stats":{"Line":3}},{"line":726,"address":[6486803],"length":1,"stats":{"Line":2}},{"line":728,"address":[6487129],"length":1,"stats":{"Line":1}},{"line":729,"address":[6487047,6486966],"length":1,"stats":{"Line":3}},{"line":730,"address":[6487055],"length":1,"stats":{"Line":1}},{"line":735,"address":[6487531],"length":1,"stats":{"Line":1}},{"line":748,"address":[6487527],"length":1,"stats":{"Line":1}},{"line":753,"address":[6488289,6487628,6488272],"length":1,"stats":{"Line":5}},{"line":756,"address":[6487635,6487949],"length":1,"stats":{"Line":2}},{"line":757,"address":[6487706,6487805,6487827],"length":1,"stats":{"Line":3}},{"line":760,"address":[6487721],"length":1,"stats":{"Line":1}},{"line":763,"address":[6488043],"length":1,"stats":{"Line":1}},{"line":764,"address":[6487737],"length":1,"stats":{"Line":1}},{"line":768,"address":[6488020],"length":1,"stats":{"Line":1}},{"line":773,"address":[6488092],"length":1,"stats":{"Line":1}},{"line":774,"address":[6488212,6487580,6487765],"length":1,"stats":{"Line":3}},{"line":782,"address":[6458781,6458240,6458787],"length":1,"stats":{"Line":4}},{"line":783,"address":[6458280],"length":1,"stats":{"Line":4}},{"line":785,"address":[6458342,6458290],"length":1,"stats":{"Line":8}},{"line":786,"address":[6458354],"length":1,"stats":{"Line":4}},{"line":787,"address":[6458381],"length":1,"stats":{"Line":4}},{"line":788,"address":[6458408],"length":1,"stats":{"Line":4}},{"line":791,"address":[6458443],"length":1,"stats":{"Line":4}},{"line":792,"address":[6458469],"length":1,"stats":{"Line":4}},{"line":793,"address":[6458508,6458776],"length":1,"stats":{"Line":4}},{"line":794,"address":[6458648,6458735],"length":1,"stats":{"Line":4}},{"line":795,"address":[6458742],"length":1,"stats":{"Line":2}},{"line":798,"address":[6458675],"length":1,"stats":{"Line":2}},{"line":800,"address":[6458699],"length":1,"stats":{"Line":2}},{"line":801,"address":[6458306,6458719],"length":1,"stats":{"Line":2}},{"line":807,"address":[6478452,6478610,6478560,6478592,6475520],"length":1,"stats":{"Line":3}},{"line":808,"address":[6475557],"length":1,"stats":{"Line":1}},{"line":809,"address":[6475623],"length":1,"stats":{"Line":1}},{"line":810,"address":[6475683],"length":1,"stats":{"Line":1}},{"line":811,"address":[6475691],"length":1,"stats":{"Line":1}},{"line":817,"address":[6475803],"length":1,"stats":{"Line":1}},{"line":818,"address":[6475830],"length":1,"stats":{"Line":1}},{"line":821,"address":[6476090],"length":1,"stats":{"Line":1}},{"line":822,"address":[6475930],"length":1,"stats":{"Line":1}},{"line":827,"address":[6475856],"length":1,"stats":{"Line":1}},{"line":828,"address":[6475914],"length":1,"stats":{"Line":1}},{"line":832,"address":[6476060],"length":1,"stats":{"Line":1}},{"line":835,"address":[6476168],"length":1,"stats":{"Line":1}},{"line":836,"address":[6476211],"length":1,"stats":{"Line":1}},{"line":839,"address":[6476492],"length":1,"stats":{"Line":1}},{"line":840,"address":[6476332],"length":1,"stats":{"Line":1}},{"line":845,"address":[6476258],"length":1,"stats":{"Line":1}},{"line":846,"address":[6476316],"length":1,"stats":{"Line":1}},{"line":850,"address":[6476462],"length":1,"stats":{"Line":1}},{"line":852,"address":[6476506],"length":1,"stats":{"Line":1}},{"line":853,"address":[6476546],"length":1,"stats":{"Line":1}},{"line":855,"address":[6476553,6476662],"length":1,"stats":{"Line":2}},{"line":857,"address":[6476859,6476708],"length":1,"stats":{"Line":2}},{"line":860,"address":[6476700],"length":1,"stats":{"Line":1}},{"line":863,"address":[6476829],"length":1,"stats":{"Line":1}},{"line":865,"address":[6476971,6477091],"length":1,"stats":{"Line":2}},{"line":866,"address":[6477162,6477269],"length":1,"stats":{"Line":2}},{"line":869,"address":[6477290],"length":1,"stats":{"Line":1}},{"line":870,"address":[6477348],"length":1,"stats":{"Line":1}},{"line":871,"address":[6477355],"length":1,"stats":{"Line":1}},{"line":873,"address":[6477445],"length":1,"stats":{"Line":1}},{"line":875,"address":[6477631,6477546],"length":1,"stats":{"Line":2}},{"line":876,"address":[6477691],"length":1,"stats":{"Line":1}},{"line":878,"address":[6477834,6477891],"length":1,"stats":{"Line":2}},{"line":880,"address":[6477899],"length":1,"stats":{"Line":1}},{"line":881,"address":[6478036],"length":1,"stats":{"Line":1}},{"line":884,"address":[6478115],"length":1,"stats":{"Line":1}},{"line":885,"address":[6478122],"length":1,"stats":{"Line":1}},{"line":888,"address":[6478181],"length":1,"stats":{"Line":1}},{"line":889,"address":[6478228],"length":1,"stats":{"Line":1}},{"line":890,"address":[6478629,6477297,6475642,6478051,6476788,6478466,6478578,6477571,6476621,6477225,6477854,6478196,6478270,6477034],"length":1,"stats":{"Line":2}},{"line":898,"address":[6491888,6488368,6491780,6491938,6491920],"length":1,"stats":{"Line":3}},{"line":903,"address":[6488405],"length":1,"stats":{"Line":1}},{"line":904,"address":[6488471],"length":1,"stats":{"Line":1}},{"line":905,"address":[6488531],"length":1,"stats":{"Line":1}},{"line":906,"address":[6488539],"length":1,"stats":{"Line":1}},{"line":912,"address":[6488651],"length":1,"stats":{"Line":1}},{"line":913,"address":[6488678],"length":1,"stats":{"Line":1}},{"line":916,"address":[6488938],"length":1,"stats":{"Line":1}},{"line":917,"address":[6488778],"length":1,"stats":{"Line":1}},{"line":922,"address":[6488704],"length":1,"stats":{"Line":1}},{"line":923,"address":[6488762],"length":1,"stats":{"Line":1}},{"line":927,"address":[6488908],"length":1,"stats":{"Line":1}},{"line":930,"address":[6489204],"length":1,"stats":{"Line":1}},{"line":931,"address":[6489044],"length":1,"stats":{"Line":1}},{"line":936,"address":[6488984],"length":1,"stats":{"Line":1}},{"line":937,"address":[6489028],"length":1,"stats":{"Line":1}},{"line":941,"address":[6489174],"length":1,"stats":{"Line":1}},{"line":944,"address":[6489470],"length":1,"stats":{"Line":1}},{"line":945,"address":[6489310],"length":1,"stats":{"Line":1}},{"line":950,"address":[6489250],"length":1,"stats":{"Line":1}},{"line":951,"address":[6489294],"length":1,"stats":{"Line":1}},{"line":955,"address":[6489440],"length":1,"stats":{"Line":1}},{"line":959,"address":[6489818],"length":1,"stats":{"Line":1}},{"line":960,"address":[6489658],"length":1,"stats":{"Line":1}},{"line":965,"address":[6489548],"length":1,"stats":{"Line":1}},{"line":966,"address":[6489642],"length":1,"stats":{"Line":1}},{"line":970,"address":[6489788],"length":1,"stats":{"Line":1}},{"line":972,"address":[6489832],"length":1,"stats":{"Line":1}},{"line":973,"address":[6489872],"length":1,"stats":{"Line":1}},{"line":975,"address":[6489988,6489879],"length":1,"stats":{"Line":2}},{"line":977,"address":[6490185,6490034],"length":1,"stats":{"Line":2}},{"line":980,"address":[6490026],"length":1,"stats":{"Line":1}},{"line":983,"address":[6490155],"length":1,"stats":{"Line":1}},{"line":985,"address":[6490417,6490297],"length":1,"stats":{"Line":2}},{"line":986,"address":[6490595,6490488],"length":1,"stats":{"Line":2}},{"line":989,"address":[6490616],"length":1,"stats":{"Line":1}},{"line":990,"address":[6490674],"length":1,"stats":{"Line":1}},{"line":991,"address":[6490681],"length":1,"stats":{"Line":1}},{"line":993,"address":[6490771],"length":1,"stats":{"Line":1}},{"line":995,"address":[6490957,6490872],"length":1,"stats":{"Line":2}},{"line":996,"address":[6491017],"length":1,"stats":{"Line":1}},{"line":998,"address":[6491160,6491217],"length":1,"stats":{"Line":2}},{"line":1000,"address":[6491225],"length":1,"stats":{"Line":1}},{"line":1001,"address":[6491364],"length":1,"stats":{"Line":1}},{"line":1004,"address":[6491443],"length":1,"stats":{"Line":1}},{"line":1005,"address":[6491450],"length":1,"stats":{"Line":1}},{"line":1008,"address":[6491509],"length":1,"stats":{"Line":1}},{"line":1009,"address":[6491556],"length":1,"stats":{"Line":1}},{"line":1010,"address":[6488490,6491906,6490623,6490360,6491180,6490551,6489947,6491524,6491794,6491379,6491598,6491957,6490897,6490114],"length":1,"stats":{"Line":2}}],"covered":406,"coverable":451},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","symmetric-air","src","lib.rs"],"content":"#![no_std]\n\npub mod sponge_air;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","symmetric-air","src","sponge_air","air.rs"],"content":"//! An AIR for a sponge construction using an arbitrary permutation on field elements.\n//!\n//! We instantiate a duplex challenger in overwrite mode: at each row, the challenger applies\n//! one permutation.\n//! Depending on the situation, the rate part of the state comes either from the input\n//! (during absorbing) or is the output of the previous row (during squeezing).\n//! When we want to clear the state, we set the `reset` flag to 1 to clear the capacity.\n//!\n//! We assume that the input is correctly padded, and that its length is a multiple of `RATE`.\n\nuse core::array;\nuse core::borrow::Borrow;\nuse core::marker::PhantomData;\n\nuse p3_air::{Air, AirBuilder, BaseAir};\nuse p3_field::{PrimeCharacteristicRing, PrimeField};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\n\nuse crate::sponge_air::columns::{SpongeCols, num_cols};\n\n#[derive(Debug)]\npub struct SpongeAir\u003cF: PrimeCharacteristicRing, const RATE: usize, const CAPACITY: usize\u003e {\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF, const RATE: usize, const CAPACITY: usize\u003e Default for SpongeAir\u003cF, RATE, CAPACITY\u003e\nwhere\n    F: PrimeCharacteristicRing,\n{\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cF: PrimeCharacteristicRing, const RATE: usize, const CAPACITY: usize\u003e\n    SpongeAir\u003cF, RATE, CAPACITY\u003e\n{\n    #[must_use]\n    pub const fn new() -\u003e Self {\n        Self {\n            _phantom: PhantomData,\n        }\n    }\n\n    pub fn generate_trace_rows(\u0026self) -\u003e RowMajorMatrix\u003cF\u003e\n    where\n        F: PrimeField,\n    {\n        todo!()\n    }\n}\n\nimpl\u003cF: PrimeCharacteristicRing + Sync, const RATE: usize, const CAPACITY: usize\u003e BaseAir\u003cF\u003e\n    for SpongeAir\u003cF, RATE, CAPACITY\u003e\n{\n    fn width(\u0026self) -\u003e usize {\n        num_cols::\u003cRATE, CAPACITY\u003e()\n    }\n}\n\nimpl\u003cAB: AirBuilder, const RATE: usize, const CAPACITY: usize\u003e Air\u003cAB\u003e\n    for SpongeAir\u003cAB::F, RATE, CAPACITY\u003e\n{\n    /// Correctness of state transitions is enforced outside the AIR with lookups.\n    #[inline]\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n        let (local, next) = (\n            main.row_slice(0).expect(\"Matrix is empty?\"),\n            main.row_slice(1).expect(\"Matrix only has 1 row?\"),\n        );\n        let local: \u0026SpongeCols\u003cAB::Var, RATE, CAPACITY\u003e = (*local).borrow();\n        let _next: \u0026SpongeCols\u003cAB::Var, RATE, CAPACITY\u003e = (*next).borrow();\n\n        let _output_mode = AB::Expr::ONE - local.absorb.clone();\n\n        // When resetting the state, we just have to clear the capacity. The rate will be overwritten by the input.\n        builder\n            .when(local.reset.clone())\n            .assert_zeros::\u003cCAPACITY, _\u003e(array::from_fn(|i| local.capacity[i].clone()));\n\n        // TODO: Add all lookups:\n        // - If local.absorb = 1:\n        //      * local.rate comes from input lookups.\n        // - If local.absorb = 0:\n        //      * local.rate is sent to output lookups.\n        // - If next.absorb = 0:\n        //      * next.rate = perm(local.state).rate.\n        // - If next.reset = 0:\n        //      * next.capacity = perm(local.state).capacity.\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","symmetric-air","src","sponge_air","columns.rs"],"content":"use core::borrow::{Borrow, BorrowMut};\nuse core::mem::size_of;\n\n/// Columns for the sponge AIR which hashes an arbitrary-length input.\n#[repr(C)]\npub struct SpongeCols\u003cT, const RATE: usize, const CAPACITY: usize\u003e {\n    // Flag to clear the capacity, which will clear the state.\n    // Preprocessed.\n    pub reset: T,\n    // When set to 1, the rate is overwritten by external input.\n    // When set to 0, the rate is copied from the previous row.\n    // Preprocessed.\n    pub absorb: T,\n\n    pub input_addresses: [T; RATE],\n\n    pub rate: [T; RATE],\n\n    pub capacity: [T; CAPACITY],\n}\n\npub const fn num_cols\u003cconst RATE: usize, const CAPACITY: usize\u003e() -\u003e usize {\n    size_of::\u003cSpongeCols\u003cu8, RATE, CAPACITY\u003e\u003e()\n}\n\nimpl\u003cT, const RATE: usize, const CAPACITY: usize\u003e Borrow\u003cSpongeCols\u003cT, RATE, CAPACITY\u003e\u003e for [T] {\n    fn borrow(\u0026self) -\u003e \u0026SpongeCols\u003cT, RATE, CAPACITY\u003e {\n        let (prefix, shorts, suffix) = unsafe { self.align_to::\u003cSpongeCols\u003cT, RATE, CAPACITY\u003e\u003e() };\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\n        debug_assert_eq!(shorts.len(), 1);\n        \u0026shorts[0]\n    }\n}\n\nimpl\u003cT, const RATE: usize, const CAPACITY: usize\u003e BorrowMut\u003cSpongeCols\u003cT, RATE, CAPACITY\u003e\u003e\n    for [T]\n{\n    fn borrow_mut(\u0026mut self) -\u003e \u0026mut SpongeCols\u003cT, RATE, CAPACITY\u003e {\n        let (prefix, shorts, suffix) =\n            unsafe { self.align_to_mut::\u003cSpongeCols\u003cT, RATE, CAPACITY\u003e\u003e() };\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\n        debug_assert_eq!(shorts.len(), 1);\n        \u0026mut shorts[0]\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","symmetric-air","src","sponge_air","mod.rs"],"content":"pub mod air;\npub mod columns;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","test-utils","src","lib.rs"],"content":"//! Test utilities for Plonky3 recursion crates.\n\n/// Maximum allowed constraint degree for AIR constraints.\n/// Keeping this at 3 ensures efficient FRI proving.\npub const MAX_CONSTRAINT_DEGREE: usize = 3;\n\npub use {p3_air, p3_batch_stark, p3_field, p3_lookup, p3_matrix, p3_uni_stark};\n\n/// Macro to generate a constraint degree test for an AIR.\n///\n/// Usage: `assert_air_constraint_degree!(air, \"AirName\");`\n#[macro_export]\nmacro_rules! assert_air_constraint_degree {\n    ($air:expr, $air_name:expr) =\u003e {{\n        use p3_lookup::lookup_traits::lookup_data_to_expr;\n        use $crate::p3_air::BaseAir;\n        use $crate::p3_batch_stark::symbolic::get_symbolic_constraints;\n        use $crate::p3_field::PrimeCharacteristicRing;\n        use $crate::p3_lookup::logup::LogUpGadget;\n        use $crate::p3_lookup::lookup_traits::{Kind, LookupData};\n        use $crate::p3_matrix::Matrix;\n        use $crate::p3_uni_stark::SymbolicAirBuilder;\n\n        type F = p3_baby_bear::BabyBear;\n        let mut air = $air;\n\n        let preprocessed_width = air.preprocessed_trace().map(|m| m.width()).unwrap_or(0);\n\n        let lookups = \u003c_ as Air\u003cSymbolicAirBuilder\u003cF, F\u003e\u003e\u003e::get_lookups(\u0026mut air);\n        let lookup_data = lookups\n            .iter()\n            .filter_map(|lookup| match \u0026lookup.kind {\n                Kind::Global(name) =\u003e Some(LookupData {\n                    name: name.clone(),\n                    aux_idx: lookup.columns[0],\n                    expected_cumulated: F::ZERO,\n                }),\n                _ =\u003e None,\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let lookup_data = lookup_data_to_expr(\u0026lookup_data);\n\n        let lookup_gadget = LogUpGadget::new();\n        let (base_constraints, extension_constraints) = get_symbolic_constraints(\n            \u0026air,\n            preprocessed_width,\n            0,\n            \u0026lookups,\n            \u0026lookup_data,\n            \u0026lookup_gadget,\n        );\n\n        for (i, constraint) in base_constraints.iter().enumerate() {\n            let degree = constraint.degree_multiple();\n            assert!(\n                degree \u003c= $crate::MAX_CONSTRAINT_DEGREE,\n                \"{} base constraint {} has degree {} which exceeds maximum of {}\",\n                $air_name,\n                i,\n                degree,\n                $crate::MAX_CONSTRAINT_DEGREE\n            );\n        }\n\n        for (i, constraint) in extension_constraints.iter().enumerate() {\n            let degree = constraint.degree_multiple();\n            assert!(\n                degree \u003c= $crate::MAX_CONSTRAINT_DEGREE,\n                \"{} extension constraint {} has degree {} which exceeds maximum of {}\",\n                $air_name,\n                i,\n                degree,\n                $crate::MAX_CONSTRAINT_DEGREE\n            );\n        }\n    }};\n}\n","traces":[{"line":27,"address":[2315456,2315464],"length":1,"stats":{"Line":10}},{"line":32,"address":[5539152,5539398,5539404,5539120],"length":1,"stats":{"Line":10}},{"line":33,"address":[5539202,5539327],"length":1,"stats":{"Line":10}},{"line":34,"address":[5539210],"length":1,"stats":{"Line":5}},{"line":35,"address":[5539229,5539324],"length":1,"stats":{"Line":10}},{"line":38,"address":[5539261],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":6}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, '🌙'),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      const nbHit = covered? trace.stats.Line: 0;
      return e(
        'div',
        { className: 'code-text-container' },
        e(
          'code',
          {
            className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          },
          line
        ),
        e(
          'div',
          { className: 'cover-indicator' + (covered? ' check-cover': '') + (uncovered? ' no-cover': '')},
          e(
            'div',
            { className: (covered? 'stat-line-hit': '')},
            covered? nbHit: ""
          )
        )
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '🌙';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '☀️';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '🌙';
    }
  });
})();
</script>
</body>
</html>